index,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,localization_target
7632,CWE-190,"jpc_streamlist_t * jpc_ppmstabtostreams ( jpc_ppxstab_t * tab ) { jpc_streamlist_t * streams ; uchar * dataptr ; uint_fast32_t datacnt ; uint_fast32_t tpcnt ; jpc_ppxstabent_t * ent ; int entno ; jas_stream_t * stream ; int n ; if ( ! ( streams = jpc_streamlist_create ( ) ) ) { goto error ; } if ( ! tab -> numents ) { return streams ; } entno = 0 ; ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; for ( ; ; ) { if ( datacnt < 4 ) { goto error ; } if ( ! ( stream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jpc_streamlist_insert ( streams , jpc_streamlist_numstreams ( streams ) , stream ) ) { goto error ; } tpcnt = ( dataptr [ 0 ] << 24 ) | ( dataptr [ 1 ] << 16 ) | ( dataptr [ 2 ] << 8 ) | dataptr [ 3 ] ; datacnt -= 4 ; dataptr += 4 ; while ( tpcnt ) { if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { goto error ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } n = jas_min ( tpcnt , datacnt ) ; if ( jas_stream_write ( stream , dataptr , n ) != n ) { goto error ; } tpcnt -= n ; dataptr += n ; datacnt -= n ; } jas_stream_rewind ( stream ) ; if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { break ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } } return streams ; error : if ( streams ) { jpc_streamlist_destroy ( streams ) ; } return 0 ; }","<S2SV_ModStart> * streams ; jas_uchar <S2SV_ModEnd> * dataptr ;
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar * dataptr ; <S2SV_EndBug>
568,CWE-59,"static int mountpoint_last ( struct nameidata * nd , struct path * path ) { int error = 0 ; struct dentry * dentry ; struct dentry * dir = nd -> path . dentry ; if ( nd -> flags & lookup_rcu ) { if ( unlazy_walk ( nd , null ) ) { error = - echild ; goto out ; } } nd -> flags &= ~ lookup_parent ; if ( unlikely ( nd -> last_type != last_norm ) ) { error = handle_dots ( nd , nd -> last_type ) ; if ( error ) goto out ; dentry = dget ( nd -> path . dentry ) ; goto done ; } mutex_lock ( & dir -> d_inode -> i_mutex ) ; dentry = d_lookup ( dir , & nd -> last ) ; if ( ! dentry ) { dentry = d_alloc ( dir , & nd -> last ) ; if ( ! dentry ) { error = - enomem ; mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; error = ptr_err ( dentry ) ; if ( is_err ( dentry ) ) { mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } } mutex_unlock ( & dir -> d_inode -> i_mutex ) ; done : if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { error = - enoent ; dput ( dentry ) ; goto out ; } path -> dentry = dentry ; path -> mnt = mntget ( nd -> path . mnt ) ; if ( should_follow_link ( dentry , nd -> flags & lookup_follow ) ) return 1 ; follow_mount ( path ) ; error = 0 ; out : terminate_walk ( nd ) ; return error ; }","<S2SV_ModStart> -> mnt = <S2SV_ModEnd> nd -> path <S2SV_ModStart> path . mnt <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 1 ; mntget ( path -> mnt ) ;
",torvalds@linux/295dc39d941dc2ae53d5c170365af4c9d5c16212,CVE-2014-5045,https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212,2014-08-01T11:13Z,<S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug>
8359,CWE-362,"static struct rtable * icmp_route_lookup ( struct net * net , struct sk_buff * skb_in , const struct iphdr * iph , __be32 saddr , u8 tos , int type , int code , struct icmp_bxm * param ) { struct flowi4 fl4 = { . daddr = ( param -> replyopts . srr ? param -> replyopts . faddr : iph -> saddr ) , . saddr = saddr , . flowi4_tos = rt_tos ( tos ) , . flowi4_proto = ipproto_icmp , . fl4_icmp_type = type , . fl4_icmp_code = code , } ; struct rtable * rt , * rt2 ; int err ; security_skb_classify_flow ( skb_in , flowi4_to_flowi ( & fl4 ) ) ; rt = __ip_route_output_key ( net , & fl4 ) ; if ( is_err ( rt ) ) return rt ; rt2 = rt ; if ( ! fl4 . saddr ) fl4 . saddr = rt -> rt_src ; rt = ( struct rtable * ) xfrm_lookup ( net , & rt -> dst , flowi4_to_flowi ( & fl4 ) , null , 0 ) ; if ( ! is_err ( rt ) ) { if ( rt != rt2 ) return rt ; } else if ( ptr_err ( rt ) == - eperm ) { rt = null ; } else return rt ; err = xfrm_decode_session_reverse ( skb_in , flowi4_to_flowi ( & fl4 ) , af_inet ) ; if ( err ) goto relookup_failed ; if ( inet_addr_type ( net , fl4 . saddr ) == rtn_local ) { rt2 = __ip_route_output_key ( net , & fl4 ) ; if ( is_err ( rt2 ) ) err = ptr_err ( rt2 ) ; } else { struct flowi4 fl4_2 = { } ; unsigned long orefdst ; fl4_2 . daddr = fl4 . saddr ; rt2 = ip_route_output_key ( net , & fl4_2 ) ; if ( is_err ( rt2 ) ) { err = ptr_err ( rt2 ) ; goto relookup_failed ; } orefdst = skb_in -> _skb_refdst ; err = ip_route_input ( skb_in , fl4 . daddr , fl4 . saddr , rt_tos ( tos ) , rt2 -> dst . dev ) ; dst_release ( & rt2 -> dst ) ; rt2 = skb_rtable ( skb_in ) ; skb_in -> _skb_refdst = orefdst ; } if ( err ) goto relookup_failed ; rt2 = ( struct rtable * ) xfrm_lookup ( net , & rt2 -> dst , flowi4_to_flowi ( & fl4 ) , null , xfrm_lookup_icmp ) ; if ( ! is_err ( rt2 ) ) { dst_release ( & rt -> dst ) ; rt = rt2 ; } else if ( ptr_err ( rt2 ) == - eperm ) { if ( rt ) dst_release ( & rt -> dst ) ; return rt2 ; } else { err = ptr_err ( rt2 ) ; goto relookup_failed ; } return rt ; relookup_failed : if ( rt ) return rt ; return err_ptr ( err ) ; }","<S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> param -> replyopts . opt . opt
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> . daddr = ( param -> replyopts . srr ? <S2SV_EndBug> <S2SV_StartBug> param -> replyopts . faddr : iph -> saddr ) , <S2SV_EndBug>"
6344,CWE-772,"generic_ret * init_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) { static generic_ret ret ; gss_buffer_desc client_name , service_name ; kadm5_server_handle_t handle ; om_uint32 minor_stat ; const char * errmsg = null ; size_t clen , slen ; char * cdots , * sdots ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( * arg , rqstp , & handle ) ) ) goto exit_func ; if ( ! ( ret . code = check_handle ( ( void * ) handle ) ) ) { ret . api_version = handle -> api_version ; } free_server_handle ( handle ) ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } if ( ret . code != 0 ) errmsg = krb5_get_error_message ( null , ret . code ) ; clen = client_name . length ; trunc_name ( & clen , & cdots ) ; slen = service_name . length ; trunc_name ( & slen , & sdots ) ; krb5_klog_syslog ( log_notice , _ ( ""request:<s2sv_blank>kadm5_init,<s2sv_blank>%.*s%s,<s2sv_blank>%s,<s2sv_blank>"" ""client=%.*s%s,<s2sv_blank>service=%.*s%s,<s2sv_blank>addr=%s,<s2sv_blank>"" ""vers=%d,<s2sv_blank>flavor=%d"" ) , ( int ) clen , ( char * ) client_name . value , cdots , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) , ret . api_version & ~ ( kadm5_api_version_mask ) , rqstp -> rq_cred . oa_flavor ) ; if ( errmsg != null ) krb5_free_error_message ( null , errmsg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : return ( & ret ) ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; kadm5_server_handle_t handle <S2SV_ModStart> errmsg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> return ( &
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
438,CWE-416,"int ppp_register_net_channel ( struct net * net , struct ppp_channel * chan ) { struct channel * pch ; struct ppp_net * pn ; pch = kzalloc ( sizeof ( struct channel ) , gfp_kernel ) ; if ( ! pch ) return - enomem ; pn = ppp_pernet ( net ) ; pch -> ppp = null ; pch -> chan = chan ; pch -> chan_net = net ; chan -> ppp = pch ; init_ppp_file ( & pch -> file , channel ) ; pch -> file . hdrlen = chan -> hdrlen ; # ifdef config_ppp_multilink pch -> lastseq = - 1 ; # endif init_rwsem ( & pch -> chan_sem ) ; spin_lock_init ( & pch -> downl ) ; rwlock_init ( & pch -> upl ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; pch -> file . index = ++ pn -> last_channel_index ; list_add ( & pch -> list , & pn -> new_channels ) ; atomic_inc ( & channel_count ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; return 0 ; }","<S2SV_ModStart> -> chan_net = get_net ( net ) <S2SV_ModEnd> ; chan ->
",torvalds@linux/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,CVE-2016-4805,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,2016-05-23T10:59Z,<S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug>
137,CWE-000,"int snd_usbmidi_create ( struct snd_card * card , struct usb_interface * iface , struct list_head * midi_list , const struct snd_usb_audio_quirk * quirk ) { struct snd_usb_midi * umidi ; struct snd_usb_midi_endpoint_info endpoints [ midi_max_endpoints ] ; int out_ports , in_ports ; int i , err ; umidi = kzalloc ( sizeof ( * umidi ) , gfp_kernel ) ; if ( ! umidi ) return - enomem ; umidi -> dev = interface_to_usbdev ( iface ) ; umidi -> card = card ; umidi -> iface = iface ; umidi -> quirk = quirk ; umidi -> usb_protocol_ops = & snd_usbmidi_standard_ops ; spin_lock_init ( & umidi -> disc_lock ) ; init_rwsem ( & umidi -> disc_rwsem ) ; mutex_init ( & umidi -> mutex ) ; umidi -> usb_id = usb_id ( le16_to_cpu ( umidi -> dev -> descriptor . idvendor ) , le16_to_cpu ( umidi -> dev -> descriptor . idproduct ) ) ; setup_timer ( & umidi -> error_timer , snd_usbmidi_error_timer , ( unsigned long ) umidi ) ; memset ( endpoints , 0 , sizeof ( endpoints ) ) ; switch ( quirk ? quirk -> type : quirk_midi_standard_interface ) { case quirk_midi_standard_interface : err = snd_usbmidi_get_ms_info ( umidi , endpoints ) ; if ( umidi -> usb_id == usb_id ( 0x0763 , 0x0150 ) ) umidi -> usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops ; break ; case quirk_midi_us122l : umidi -> usb_protocol_ops = & snd_usbmidi_122l_ops ; case quirk_midi_fixed_endpoint : memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case quirk_midi_yamaha : err = snd_usbmidi_detect_yamaha ( umidi , & endpoints [ 0 ] ) ; break ; case quirk_midi_roland : err = snd_usbmidi_detect_roland ( umidi , & endpoints [ 0 ] ) ; break ; case quirk_midi_midiman : umidi -> usb_protocol_ops = & snd_usbmidi_midiman_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = 0 ; break ; case quirk_midi_novation : umidi -> usb_protocol_ops = & snd_usbmidi_novation_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case quirk_midi_raw_bytes : umidi -> usb_protocol_ops = & snd_usbmidi_raw_ops ; if ( umidi -> usb_id == usb_id ( 0x07fd , 0x0001 ) ) usb_set_interface ( umidi -> dev , 0 , 0 ) ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case quirk_midi_emagic : umidi -> usb_protocol_ops = & snd_usbmidi_emagic_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case quirk_midi_cme : umidi -> usb_protocol_ops = & snd_usbmidi_cme_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case quirk_midi_akai : umidi -> usb_protocol_ops = & snd_usbmidi_akai_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; endpoints [ 1 ] . out_cables = 0 ; break ; case quirk_midi_ftdi : umidi -> usb_protocol_ops = & snd_usbmidi_ftdi_ops ; err = usb_control_msg ( umidi -> dev , usb_sndctrlpipe ( umidi -> dev , 0 ) , 3 , 0x40 , 0x60 , 0 , null , 0 , 1000 ) ; if ( err < 0 ) break ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case quirk_midi_ch345 : umidi -> usb_protocol_ops = & snd_usbmidi_ch345_broken_sysex_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; default : dev_err ( & umidi -> dev -> dev , ""invalid<s2sv_blank>quirk<s2sv_blank>type<s2sv_blank>%d\\n"" , quirk -> type ) ; err = - enxio ; break ; } if ( err < 0 ) { kfree ( umidi ) ; return err ; } out_ports = 0 ; in_ports = 0 ; for ( i = 0 ; i < midi_max_endpoints ; ++ i ) { out_ports += hweight16 ( endpoints [ i ] . out_cables ) ; in_ports += hweight16 ( endpoints [ i ] . in_cables ) ; } err = snd_usbmidi_create_rawmidi ( umidi , out_ports , in_ports ) ; if ( err < 0 ) { kfree ( umidi ) ; return err ; } if ( quirk && quirk -> type == quirk_midi_midiman ) err = snd_usbmidi_create_endpoints_midiman ( umidi , & endpoints [ 0 ] ) ; else err = snd_usbmidi_create_endpoints ( umidi , endpoints ) ; if ( err < 0 ) { snd_usbmidi_free ( umidi ) ; return err ; } usb_autopm_get_interface_no_resume ( umidi -> iface ) ; list_add_tail ( & umidi -> list , midi_list ) ; return 0 ; }","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> return err ;
",torvalds@linux/07d86ca93db7e5cdf4743564d98292042ec21af7,CVE-2016-2384,https://github.com/torvalds/linux/commit/07d86ca93db7e5cdf4743564d98292042ec21af7,2016-04-27T17:59Z,<S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug>
4646,CWE-190,"int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { char * cbuf = buf ; while ( len ) { int sent = recv ( conn -> sock , cbuf , len , 0 ) ; if ( sent == 0 || sent == - 1 ) { __mongo_set_error ( conn , mongo_io_error , strerror ( errno ) , errno ) ; return mongo_error ; } cbuf += sent ; len -= sent ; } return mongo_ok ; }","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = recv
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug>"
236,CWE-125,"int ts_obj_print_bio ( bio * bio , const asn1_object * obj ) { char obj_txt [ 128 ] ; int len = obj_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; bio_write ( bio , obj_txt , len ) ; bio_write ( bio , ""\\n"" , 1 ) ; return 1 ; }","<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , ""%s\\n"" , obj_txt <S2SV_ModEnd> ) ; return
",openssl@openssl/0ed26acce328ec16a3aa635f1ca37365e8c7403a,CVE-2016-2180,https://github.com/openssl/openssl/commit/0ed26acce328ec16a3aa635f1ca37365e8c7403a,2016-08-01T02:59Z,"<S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug>"
5,CWE-362,"struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { struct request * rq = tags -> rqs [ tag ] ; struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }","<S2SV_ModStart> tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,"<S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug>"
7183,CWE-552,"static ssize_t _hostsock_recvmsg ( oe_fd_t * sock_ , struct oe_msghdr * msg , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; void * buf = null ; size_t buf_size = 0 ; if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) oe_raise_errno ( oe_einval ) ; if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) oe_raise_errno ( oe_enomem ) ; { if ( oe_syscall_recvmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , & msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , & msg -> msg_controllen , flags ) != oe_ok ) { oe_raise_errno ( oe_einval ) ; } if ( ret == - 1 ) oe_raise_errno ( oe_errno ) ; } if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) oe_raise_errno ( oe_einval ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size = 0 ; oe_socklen_t namelen_out = 0 ; size_t controllen_out <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_ModStart> msg_namelen , & namelen_out <S2SV_ModEnd> , buf , <S2SV_ModStart> msg_controllen , & controllen_out <S2SV_ModEnd> , flags ) <S2SV_ModStart> } if ( ! msg -> msg_name ) msg -> msg_namelen = 0 ; else { if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ; } if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ; else { if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ; else msg -> msg_flags |= OE_MSG_CTRUNC ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> & msg -> msg_namelen , <S2SV_EndBug> <S2SV_StartBug> & msg -> msg_controllen , <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) <S2SV_EndBug>"
510,CWE-125,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = err_ptr ( - einval ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | netif_f_gso_robust ) ) { skb_shinfo ( skb ) -> gso_segs = div_round_up ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = null ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( skb_gso_udp_tunnel | skb_gso_udp_tunnel_csum ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = csum_mangled_0 ; skb -> ip_summed = checksum_none ; if ( ! skb -> encap_hdr_csum ) features |= netif_f_hw_csum ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = nexthdr_fragment ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + skb_gso_cb ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; skb_gso_cb ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,<S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug>
1180,CWE-125,"void __skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps , struct sock * sk , int tstype ) { struct sk_buff * skb ; bool tsonly ; if ( ! sk ) return ; tsonly = sk -> sk_tsflags & sof_timestamping_opt_tsonly ; if ( ! skb_may_tx_timestamp ( sk , tsonly ) ) return ; if ( tsonly ) { # ifdef config_inet if ( ( sk -> sk_tsflags & sof_timestamping_opt_stats ) && sk -> sk_protocol == ipproto_tcp && sk -> sk_type == sock_stream ) skb = tcp_get_timestamping_opt_stats ( sk ) ; else # endif skb = alloc_skb ( 0 , gfp_atomic ) ; } else { skb = skb_clone ( orig_skb , gfp_atomic ) ; } if ( ! skb ) return ; if ( tsonly ) { skb_shinfo ( skb ) -> tx_flags = skb_shinfo ( orig_skb ) -> tx_flags ; skb_shinfo ( skb ) -> tskey = skb_shinfo ( orig_skb ) -> tskey ; } if ( hwtstamps ) * skb_hwtstamps ( skb ) = * hwtstamps ; else skb -> tstamp = ktime_get_real ( ) ; __skb_complete_tx_timestamp ( skb , sk , tstype ) ; }","<S2SV_ModStart> ; bool tsonly , opt_stats = false <S2SV_ModStart> == SOCK_STREAM ) { <S2SV_ModStart> sk ) ; opt_stats = true ; } <S2SV_ModStart> sk , tstype , opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,"<S2SV_StartBug> bool tsonly ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug>"
1188,CWE-264,"static struct cifssesinfo * cifs_find_smb_ses ( struct tcp_server_info * server , char * username ) { struct list_head * tmp ; struct cifssesinfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ; list_for_each ( tmp , & server -> smb_ses_list ) { ses = list_entry ( tmp , struct cifssesinfo , smb_ses_list ) ; if ( strncmp ( ses -> username , username , max_username_size ) ) continue ; ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return null ; }","<S2SV_ModStart> * server , struct smb_vol * vol ) { <S2SV_ModEnd> struct cifsSesInfo * <S2SV_ModStart> cifs_tcp_ses_lock ) ; list_for_each_entry ( ses <S2SV_ModEnd> , & server <S2SV_ModStart> server -> smb_ses_list , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> if ( strncmp <S2SV_ModStart> -> userName , vol -> <S2SV_ModStart> ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; }
",torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2,CVE-2011-1585,https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2,2013-06-08T13:05Z,"<S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug>"
3871,CWE-362,"int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & attr_uid && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & attr_gid && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , ext4_ht_quota , ( ext4_maxquotas_init_blocks ( inode -> i_sb ) + ext4_maxquotas_del_blocks ( inode -> i_sb ) ) + 3 ) ; if ( is_err ( handle ) ) { error = ptr_err ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & attr_uid ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & attr_gid ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & attr_size ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , ext4_inode_extents ) ) ) { struct ext4_sb_info * sbi = ext4_sb ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - efbig ; } if ( ! s_isreg ( inode -> i_mode ) ) return - einval ; if ( is_i_version ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , ext4_ht_inode , 3 ) ; if ( is_err ( handle ) ) { error = ptr_err ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & ext4_i ( inode ) -> i_data_sem ) ; ext4_i ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & ext4_i ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( null , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; } truncate_pagecache ( inode , inode -> i_size ) ; if ( shrink ) ext4_truncate ( inode ) ; } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( null , inode ) ; if ( ! rc && ( ia_valid & attr_mode ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }","<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
",torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z,"<S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug>"
5684,CWE-125,"void cisco_autorp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) { int type ; int numrps ; int hold ; nd_tcheck ( bp [ 0 ] ) ; nd_print ( ( ndo , ""<s2sv_blank>auto-rp<s2sv_blank>"" ) ) ; type = bp [ 0 ] ; switch ( type ) { case 0x11 : nd_print ( ( ndo , ""candidate-advert"" ) ) ; break ; case 0x12 : nd_print ( ( ndo , ""mapping"" ) ) ; break ; default : nd_print ( ( ndo , ""type-0x%02x"" , type ) ) ; break ; } nd_tcheck ( bp [ 1 ] ) ; numrps = bp [ 1 ] ; nd_tcheck2 ( bp [ 2 ] , 2 ) ; nd_print ( ( ndo , ""<s2sv_blank>hold<s2sv_blank>"" ) ) ; hold = extract_16bits ( & bp [ 2 ] ) ; if ( hold ) unsigned_relts_print ( ndo , extract_16bits ( & bp [ 2 ] ) ) ; else nd_print ( ( ndo , ""forever"" ) ) ; bp += 8 ; len -= 8 ; while ( numrps -- ) { int nentries ; char s ; nd_tcheck2 ( bp [ 0 ] , 4 ) ; nd_print ( ( ndo , ""<s2sv_blank>rp<s2sv_blank>%s"" , ipaddr_string ( ndo , bp ) ) ) ; nd_tcheck ( bp [ 4 ] ) ; switch ( bp [ 4 ] & 0x3 ) { case 0 : nd_print ( ( ndo , ""<s2sv_blank>pimv?"" ) ) ; break ; case 1 : nd_print ( ( ndo , ""<s2sv_blank>pimv1"" ) ) ; break ; case 2 : nd_print ( ( ndo , ""<s2sv_blank>pimv2"" ) ) ; break ; case 3 : nd_print ( ( ndo , ""<s2sv_blank>pimv1+2"" ) ) ; break ; } if ( bp [ 4 ] & 0xfc ) nd_print ( ( ndo , ""<s2sv_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ; nd_tcheck ( bp [ 5 ] ) ; nentries = bp [ 5 ] ; bp += 6 ; len -= 6 ; s = '<s2sv_blank>' ; for ( ; nentries ; nentries -- ) { nd_tcheck2 ( bp [ 0 ] , 6 ) ; nd_print ( ( ndo , ""%c%s%s/%d"" , s , bp [ 0 ] & 1 ? ""!"" : """" , ipaddr_string ( ndo , & bp [ 2 ] ) , bp [ 1 ] ) ) ; if ( bp [ 0 ] & 0x02 ) { nd_print ( ( ndo , ""<s2sv_blank>bidir"" ) ) ; } if ( bp [ 0 ] & 0xfc ) { nd_print ( ( ndo , ""[rsvd=0x%02x]"" , bp [ 0 ] & 0xfc ) ) ; } s = ',' ; bp += 6 ; len -= 6 ; } } return ; trunc : nd_print ( ( ndo , ""[|autorp]"" ) ) ; return ; }","<S2SV_ModStart> int hold ; if ( len < 8 ) goto trunc ; <S2SV_ModStart> char s ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> ) ) ; bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] & 0x3 <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] & 0xfc <S2SV_ModStart> , bp [ 0 <S2SV_ModEnd> ] & 0xfc <S2SV_ModStart> ) ) ; bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> = bp [ 0 <S2SV_ModEnd> ] ; bp <S2SV_ModStart> ; bp += 1 ; len -= 1 <S2SV_ModEnd> ; s = <S2SV_ModStart> -- ) { if ( len < 6 ) goto trunc ;
",the-tcpdump-group@tcpdump/5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc,CVE-2017-13030,https://github.com/the-tcpdump-group/tcpdump/commit/5dc1860d8267b1e0cb78c9ffa2a40bea2fdb3ddc,2017-09-14T06:29Z,"<S2SV_StartBug> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( bp [ 4 ] & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp [ 4 ] & 0xfc ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> nentries = bp [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> bp += 6 ; len -= 6 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 6 ) ; <S2SV_EndBug>"
3018,CWE-399,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | msr_pmm ) ; mtpmr ( pmrn_pmgc0 , pmgc0_pmie | pmgc0_fcece ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug>"
5855,CWE-20,"void beforesleep ( struct aeeventloop * eventloop ) { redis_notused ( eventloop ) ; listnode * ln ; redisclient * c ; if ( server . vm_enabled && listlength ( server . io_ready_clients ) ) { listiter li ; listrewind ( server . io_ready_clients , & li ) ; while ( ( ln = listnext ( & li ) ) ) { c = ln -> value ; struct rediscommand * cmd ; listdelnode ( server . io_ready_clients , ln ) ; c -> flags &= ( ~ redis_io_wait ) ; server . vm_blocked_clients -- ; aecreatefileevent ( server . el , c -> fd , ae_readable , readqueryfromclient , c ) ; cmd = lookupcommand ( c -> argv [ 0 ] -> ptr ) ; redisassert ( cmd != null ) ; call ( c , cmd ) ; resetclient ( c ) ; if ( c -> querybuf && sdslen ( c -> querybuf ) > 0 ) processinputbuffer ( c ) ; } } while ( listlength ( server . unblocked_clients ) ) { ln = listfirst ( server . unblocked_clients ) ; redisassert ( ln != null ) ; c = ln -> value ; listdelnode ( server . unblocked_clients , ln ) ; if ( c -> querybuf && sdslen ( c -> querybuf ) > 0 ) processinputbuffer ( c ) ; } flushappendonlyfile ( ) ; }","<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && listLength ( <S2SV_ModStart> ; server . cache_blocked_clients <S2SV_ModEnd> -- ; aeCreateFileEvent
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,<S2SV_StartBug> if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) { <S2SV_EndBug> <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug>
520,CWE-200,"int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case fbiogtype : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - efault ; return 0 ; } case fbioputcmap_sparc : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; int index , count , i ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - efault ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = null ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - efault ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case fbiogetcmap_sparc : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; int index , count , i ; u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - efault ; if ( index + count > cmap -> len ) return - einval ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - efault ; } return 0 ; } default : return - einval ; } }","<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
",torvalds@linux/250c6c49e3b68756b14983c076183568636e2bde,CVE-2018-6412,https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde,2018-01-31T07:29Z,"<S2SV_StartBug> int index , count , i ; <S2SV_EndBug> <S2SV_StartBug> int index , count , i ; <S2SV_EndBug>"
6366,CWE-401,"static int htc_config_pipe_credits ( struct htc_target * target ) { struct sk_buff * skb ; struct htc_config_pipe_msg * cp_msg ; int ret ; unsigned long time_left ; skb = alloc_skb ( 50 + sizeof ( struct htc_frame_hdr ) , gfp_atomic ) ; if ( ! skb ) { dev_err ( target -> dev , ""failed<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>send<s2sv_blank>buffer\\n"" ) ; return - enomem ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; cp_msg = skb_put ( skb , sizeof ( struct htc_config_pipe_msg ) ) ; cp_msg -> message_id = cpu_to_be16 ( htc_msg_config_pipe_id ) ; cp_msg -> pipe_id = usb_wlan_tx_pipe ; cp_msg -> credits = target -> credits ; target -> htc_flags |= htc_op_config_pipe_credits ; ret = htc_issue_send ( target , skb , skb -> len , 0 , endpoint0 ) ; if ( ret ) goto err ; time_left = wait_for_completion_timeout ( & target -> cmd_wait , hz ) ; if ( ! time_left ) { dev_err ( target -> dev , ""htc<s2sv_blank>credit<s2sv_blank>config<s2sv_blank>timeout\\n"" ) ; return - etimedout ; } return 0 ; err : kfree_skb ( skb ) ; return - einval ; }","<S2SV_ModStart> ""HTC<S2SV_blank>credit<S2SV_blank>config<S2SV_blank>timeout\\n"" ) ; kfree_skb ( skb ) ;
",torvalds@linux/853acf7caf10b828102d92d05b5c101666a6142b,CVE-2019-19073,https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b,2019-11-18T06:15Z,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug>
7875,CWE-20,"void enc624j600updatemacconfig ( netinterface * interface ) { uint16_t duplexmode ; duplexmode = enc624j600readreg ( interface , enc624j600_reg_estat ) & estat_phydpx ; if ( duplexmode ) { enc624j600writereg ( interface , enc624j600_reg_macon2 , macon2_defer | macon2_padcfg2 | macon2_padcfg0 | macon2_txcrcen | macon2_r1 | macon2_fuldpx ) ; enc624j600writereg ( interface , enc624j600_reg_mabbipg , 0x15 ) ; } else { enc624j600writereg ( interface , enc624j600_reg_macon2 , macon2_defer | macon2_padcfg2 | macon2_padcfg0 | macon2_txcrcen | macon2_r1 ) ; enc624j600writereg ( interface , enc624j600_reg_mabbipg , 0x12 ) ; } }","<S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug>"
6944,CWE-400,"static enum hrtimer_restart perf_swevent_hrtimer ( struct hrtimer * hrtimer ) { enum hrtimer_restart ret = hrtimer_restart ; struct perf_sample_data data ; struct pt_regs * regs ; struct perf_event * event ; u64 period ; event = container_of ( hrtimer , struct perf_event , hw . hrtimer ) ; if ( event -> state != perf_event_state_active ) return hrtimer_norestart ; event -> pmu -> read ( event ) ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; regs = get_irq_regs ( ) ; if ( regs && ! perf_exclude_event ( event , regs ) ) { if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) ) if ( perf_event_overflow ( event , 0 , & data , regs ) ) ret = hrtimer_norestart ; } period = max_t ( u64 , 10000 , event -> hw . sample_period ) ; hrtimer_forward_now ( hrtimer , ns_to_ktime ( period ) ) ; return ret ; }","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <S2SV_EndBug>"
5404,CWE-358,"void defragregistertests ( void ) { # ifdef unittests utregistertest ( ""defraginordersimpletest"" , defraginordersimpletest ) ; utregistertest ( ""defragreversesimpletest"" , defragreversesimpletest ) ; utregistertest ( ""defragsturgesnovakbsdtest"" , defragsturgesnovakbsdtest ) ; utregistertest ( ""defragsturgesnovaklinuxtest"" , defragsturgesnovaklinuxtest ) ; utregistertest ( ""defragsturgesnovakwindowstest"" , defragsturgesnovakwindowstest ) ; utregistertest ( ""defragsturgesnovaksolaristest"" , defragsturgesnovaksolaristest ) ; utregistertest ( ""defragsturgesnovakfirsttest"" , defragsturgesnovakfirsttest ) ; utregistertest ( ""defragsturgesnovaklasttest"" , defragsturgesnovaklasttest ) ; utregistertest ( ""defragipv4nodatatest"" , defragipv4nodatatest ) ; utregistertest ( ""defragipv4toolargetest"" , defragipv4toolargetest ) ; utregistertest ( ""ipv6defraginordersimpletest"" , ipv6defraginordersimpletest ) ; utregistertest ( ""ipv6defragreversesimpletest"" , ipv6defragreversesimpletest ) ; utregistertest ( ""ipv6defragsturgesnovakbsdtest"" , ipv6defragsturgesnovakbsdtest ) ; utregistertest ( ""ipv6defragsturgesnovaklinuxtest"" , ipv6defragsturgesnovaklinuxtest ) ; utregistertest ( ""ipv6defragsturgesnovakwindowstest"" , ipv6defragsturgesnovakwindowstest ) ; utregistertest ( ""ipv6defragsturgesnovaksolaristest"" , ipv6defragsturgesnovaksolaristest ) ; utregistertest ( ""ipv6defragsturgesnovakfirsttest"" , ipv6defragsturgesnovakfirsttest ) ; utregistertest ( ""ipv6defragsturgesnovaklasttest"" , ipv6defragsturgesnovaklasttest ) ; utregistertest ( ""defragvlantest"" , defragvlantest ) ; utregistertest ( ""defragvlanqinqtest"" , defragvlanqinqtest ) ; utregistertest ( ""defragtrackerreusetest"" , defragtrackerreusetest ) ; utregistertest ( ""defragtimeouttest"" , defragtimeouttest ) ; utregistertest ( ""defragmfipv4test"" , defragmfipv4test ) ; utregistertest ( ""defragmfipv6test"" , defragmfipv6test ) ; # endif }","<S2SV_ModStart> DefragMfIpv6Test ) ; UtRegisterTest ( ""DefragTestBadProto"" , DefragTestBadProto ) ;
",inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z,<S2SV_StartBug> # endif <S2SV_EndBug>
703,CWE-000,"static void sas_eh_handle_sas_errors ( struct scsi_host * shost , struct list_head * work_q ) { struct scsi_cmnd * cmd , * n ; enum task_disposition res = task_is_done ; int tmf_resp , need_reset ; struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; unsigned long flags ; struct sas_ha_struct * ha = shost_to_sas_ha ( shost ) ; list_head ( done ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct sas_task * task ; spin_lock_irqsave ( & dev -> done_lock , flags ) ; task = to_sas_task ( cmd ) ; spin_unlock_irqrestore ( & dev -> done_lock , flags ) ; if ( ! task ) list_move_tail ( & cmd -> eh_entry , & done ) ; } again : list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct sas_task * task = to_sas_task ( cmd ) ; list_del_init ( & cmd -> eh_entry ) ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; need_reset = task -> task_state_flags & sas_task_need_dev_reset ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; if ( need_reset ) { sas_dprintk ( ""%s:<s2sv_blank>task<s2sv_blank>0x%p<s2sv_blank>requests<s2sv_blank>reset\\n"" , __func__ , task ) ; goto reset ; } sas_dprintk ( ""trying<s2sv_blank>to<s2sv_blank>find<s2sv_blank>task<s2sv_blank>0x%p\\n"" , task ) ; res = sas_scsi_find_task ( task ) ; switch ( res ) { case task_is_done : sas_dprintk ( ""%s:<s2sv_blank>task<s2sv_blank>0x%p<s2sv_blank>is<s2sv_blank>done\\n"" , __func__ , task ) ; sas_eh_defer_cmd ( cmd ) ; continue ; case task_is_aborted : sas_dprintk ( ""%s:<s2sv_blank>task<s2sv_blank>0x%p<s2sv_blank>is<s2sv_blank>aborted\\n"" , __func__ , task ) ; sas_eh_defer_cmd ( cmd ) ; continue ; case task_is_at_lu : sas_dprintk ( ""task<s2sv_blank>0x%p<s2sv_blank>is<s2sv_blank>at<s2sv_blank>lu:<s2sv_blank>lu<s2sv_blank>recover\\n"" , task ) ; reset : tmf_resp = sas_recover_lu ( task -> dev , cmd ) ; if ( tmf_resp == tmf_resp_func_complete ) { sas_dprintk ( ""dev<s2sv_blank>%016llx<s2sv_blank>lu<s2sv_blank>%llx<s2sv_blank>is<s2sv_blank>"" ""recovered\\n"" , sas_addr ( task -> dev ) , cmd -> device -> lun ) ; sas_eh_defer_cmd ( cmd ) ; sas_scsi_clear_queue_lu ( work_q , cmd ) ; goto again ; } case task_is_not_at_lu : case task_abort_failed : sas_dprintk ( ""task<s2sv_blank>0x%p<s2sv_blank>is<s2sv_blank>not<s2sv_blank>at<s2sv_blank>lu:<s2sv_blank>i_t<s2sv_blank>recover\\n"" , task ) ; tmf_resp = sas_recover_i_t ( task -> dev ) ; if ( tmf_resp == tmf_resp_func_complete || tmf_resp == - enodev ) { struct domain_device * dev = task -> dev ; sas_dprintk ( ""i_t<s2sv_blank>%016llx<s2sv_blank>recovered\\n"" , sas_addr ( task -> dev -> sas_addr ) ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_i_t ( work_q , dev ) ; goto again ; } try_to_reset_cmd_device ( cmd ) ; if ( i -> dft -> lldd_clear_nexus_port ) { struct asd_sas_port * port = task -> dev -> port ; sas_dprintk ( ""clearing<s2sv_blank>nexus<s2sv_blank>for<s2sv_blank>port:%d\\n"" , port -> id ) ; res = i -> dft -> lldd_clear_nexus_port ( port ) ; if ( res == tmf_resp_func_complete ) { sas_dprintk ( ""clear<s2sv_blank>nexus<s2sv_blank>port:%d<s2sv_blank>"" ""succeeded\\n"" , port -> id ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_port ( work_q , port ) ; goto again ; } } if ( i -> dft -> lldd_clear_nexus_ha ) { sas_dprintk ( ""clear<s2sv_blank>nexus<s2sv_blank>ha\\n"" ) ; res = i -> dft -> lldd_clear_nexus_ha ( ha ) ; if ( res == tmf_resp_func_complete ) { sas_dprintk ( ""clear<s2sv_blank>nexus<s2sv_blank>ha<s2sv_blank>"" ""succeeded\\n"" ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } sas_dprintk ( ""error<s2sv_blank>from<s2sv_blank><s2sv_blank>device<s2sv_blank>%llx,<s2sv_blank>lun<s2sv_blank>%llx<s2sv_blank>"" ""couldn\'t<s2sv_blank>be<s2sv_blank>recovered<s2sv_blank>in<s2sv_blank>any<s2sv_blank>way\\n"" , sas_addr ( task -> dev -> sas_addr ) , cmd -> device -> lun ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } out : list_splice_tail ( & done , work_q ) ; list_splice_tail_init ( & ha -> eh_ata_q , work_q ) ; return ; clear_q : sas_dprintk ( ""---<s2sv_blank>exit<s2sv_blank>%s<s2sv_blank>--<s2sv_blank>clear_q\\n"" , __func__ ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) sas_eh_finish_cmd ( cmd ) ; goto out ; }","<S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
",torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug>
1189,CWE-264,"static struct cifssesinfo * cifs_get_smb_ses ( struct tcp_server_info * server , struct smb_vol * volume_info ) { int rc = - enomem , xid ; struct cifssesinfo * ses ; xid = getxid ( ) ; ses = cifs_find_smb_ses ( server , volume_info -> username ) ; if ( ses ) { cfyi ( 1 , ""existing<s2sv_blank>smb<s2sv_blank>sess<s2sv_blank>found<s2sv_blank>(status=%d)"" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; freexid ( xid ) ; return err_ptr ( rc ) ; } if ( ses -> need_reconnect ) { cfyi ( 1 , ""session<s2sv_blank>needs<s2sv_blank>reconnect"" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; freexid ( xid ) ; return err_ptr ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; freexid ( xid ) ; return ses ; } cfyi ( 1 , ""existing<s2sv_blank>smb<s2sv_blank>sess<s2sv_blank>not<s2sv_blank>found"" ) ; ses = sesinfoalloc ( ) ; if ( ses == null ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockaddr6 . sin6_family == af_inet6 ) sprintf ( ses -> servername , ""%pi6"" , & server -> addr . sockaddr6 . sin6_addr ) ; else sprintf ( ses -> servername , ""%pi4"" , & server -> addr . sockaddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> username , volume_info -> username , max_username_size ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , gfp_kernel ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainname = kmalloc ( len + 1 , gfp_kernel ) ; if ( ses -> domainname ) strcpy ( ses -> domainname , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overridesecflg = volume_info -> secflg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; freexid ( xid ) ; return ses ; get_ses_fail : sesinfofree ( ses ) ; freexid ( xid ) ; return err_ptr ( rc ) ; }","<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if
",torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2,CVE-2011-1585,https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2,2013-06-08T13:05Z,"<S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug>"
4649,CWE-190,"static char * mongo_data_append ( char * start , const void * data , int len ) { memcpy ( start , data , len ) ; return start + len ; }","<S2SV_ModStart> * data , size_t <S2SV_ModEnd> len ) {
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> static char * mongo_data_append ( char * start , const void * data , int len ) { <S2SV_EndBug>"
3455,CWE-399,static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( hf_nmi_mask | hf_iret_mask ) ) == hf_nmi_mask ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( x86_eflags_tf | x86_eflags_rf ) ; update_db_bp_intercept ( vcpu ) ; },"<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d,CVE-2015-8104,https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d,2015-11-16T11:59Z,<S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug>
2489,CWE-000,"static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; declare_sockaddr ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = null ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - eopnotsupp ; if ( msg -> msg_flags & msg_oob ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = null ; err = - enotconn ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( sock_passcred , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - emsgsize ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > skb_max_alloc ) { data_len = min_t ( size_t , len - skb_max_alloc , max_skb_frags * page_size ) ; data_len = page_align ( data_len ) ; build_bug_on ( skb_max_alloc < page_size ) ; } skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & msg_dontwait , & err , page_alloc_costly_order ) ; if ( skb == null ) goto out ; err = unix_scm_to_skb ( & scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & msg_dontwait ) ; restart : if ( ! other ) { err = - econnreset ; if ( sunaddr == null ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == null ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } unix_state_lock ( other ) ; err = - eperm ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; if ( sock_flag ( other , sock_dead ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = 0 ; unix_state_lock ( sk ) ; if ( unix_peer ( sk ) == other ) { unix_peer ( sk ) = null ; unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - econnrefused ; } else { unix_state_unlock ( sk ) ; } other = null ; if ( err ) goto out_free ; goto restart ; } err = - epipe ; if ( other -> sk_shutdown & rcv_shutdown ) goto out_unlock ; if ( sk -> sk_type != sock_seqpacket ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { if ( ! timeo ) { err = - eagain ; goto out_unlock ; } timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , sock_rcvtstamp ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other ) ; sock_put ( other ) ; scm_destroy ( & scm ) ; return len ; out_unlock : unix_state_unlock ( other ) ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( & scm ) ; return err ; }","<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,"<S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug>"
103,CWE-200,"int ext4_map_blocks ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , int flags ) { struct extent_status es ; int retval ; int ret = 0 ; # ifdef es_aggressive_test struct ext4_map_blocks orig_map ; memcpy ( & orig_map , map , sizeof ( * map ) ) ; # endif map -> m_flags = 0 ; ext_debug ( ""ext4_map_blocks():<s2sv_blank>inode<s2sv_blank>%lu,<s2sv_blank>flag<s2sv_blank>%d,<s2sv_blank>max_blocks<s2sv_blank>%u,"" ""logical<s2sv_blank>block<s2sv_blank>%lu\\n"" , inode -> i_ino , flags , map -> m_len , ( unsigned long ) map -> m_lblk ) ; if ( unlikely ( map -> m_len > int_max ) ) map -> m_len = int_max ; if ( unlikely ( map -> m_lblk >= ext_max_blocks ) ) return - efscorrupted ; if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { map -> m_pblk = ext4_es_pblock ( & es ) + map -> m_lblk - es . es_lblk ; map -> m_flags |= ext4_es_is_written ( & es ) ? ext4_map_mapped : ext4_map_unwritten ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { map -> m_pblk = 0 ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; retval = 0 ; } else { bug_on ( 1 ) ; } # ifdef es_aggressive_test ext4_map_blocks_es_recheck ( handle , inode , map , & orig_map , flags ) ; # endif goto found ; } down_read ( & ext4_i ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , ext4_inode_extents ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags & ext4_get_blocks_keep_size ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags & ext4_get_blocks_keep_size ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""es<s2sv_blank>len<s2sv_blank>assertion<s2sv_blank>failed<s2sv_blank>for<s2sv_blank>inode<s2sv_blank>"" ""%lu:<s2sv_blank>retval<s2sv_blank>%d<s2sv_blank>!=<s2sv_blank>map->m_len<s2sv_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; warn_on ( 1 ) ; } status = map -> m_flags & ext4_map_unwritten ? extent_status_unwritten : extent_status_written ; if ( ! ( flags & ext4_get_blocks_delalloc_reserve ) && ! ( status & extent_status_written ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= extent_status_delayed ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) retval = ret ; } up_read ( ( & ext4_i ( inode ) -> i_data_sem ) ) ; found : if ( retval > 0 && map -> m_flags & ext4_map_mapped ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } if ( ( flags & ext4_get_blocks_create ) == 0 ) return retval ; if ( retval > 0 && map -> m_flags & ext4_map_mapped ) if ( ! ( flags & ext4_get_blocks_convert_unwritten ) ) return retval ; map -> m_flags &= ~ ext4_map_flags ; down_write ( & ext4_i ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , ext4_inode_extents ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; if ( retval > 0 && map -> m_flags & ext4_map_new ) { ext4_clear_inode_state ( inode , ext4_state_ext_migrate ) ; } if ( ( retval > 0 ) && ( flags & ext4_get_blocks_delalloc_reserve ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""es<s2sv_blank>len<s2sv_blank>assertion<s2sv_blank>failed<s2sv_blank>for<s2sv_blank>inode<s2sv_blank>"" ""%lu:<s2sv_blank>retval<s2sv_blank>%d<s2sv_blank>!=<s2sv_blank>map->m_len<s2sv_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; warn_on ( 1 ) ; } if ( flags & ext4_get_blocks_zero && map -> m_flags & ext4_map_mapped && map -> m_flags & ext4_map_new ) { ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ; if ( ret ) { retval = ret ; goto out_sem ; } } if ( ( flags & ext4_get_blocks_pre_io ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) ) goto out_sem ; } status = map -> m_flags & ext4_map_unwritten ? extent_status_unwritten : extent_status_written ; if ( ! ( flags & ext4_get_blocks_delalloc_reserve ) && ! ( status & extent_status_written ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= extent_status_delayed ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) { retval = ret ; goto out_sem ; } } out_sem : up_write ( ( & ext4_i ( inode ) -> i_data_sem ) ) ; if ( retval > 0 && map -> m_flags & ext4_map_mapped ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } return retval ; }","<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
",torvalds@linux/06bd3c36a733ac27962fea7d6f47168841376824,CVE-2017-7495,https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824,2017-05-15T18:29Z,<S2SV_StartBug> } <S2SV_EndBug>
6255,CWE-863,"static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg , struct bpf_reg_state * dst_reg , struct bpf_insn_aux_data * tmp_aux , const bool commit_window ) { struct bpf_insn_aux_data * aux = commit_window ? cur_aux ( env ) : tmp_aux ; struct bpf_verifier_state * vstate = env -> cur_state ; bool off_is_neg = off_reg -> smin_value < 0 ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = bpf_op ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; int err ; if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ; if ( vstate -> speculative ) goto do_sim ; err = retrieve_ptr_limit ( ptr_reg , off_reg , & alu_limit , opcode ) ; if ( err < 0 ) return err ; if ( commit_window ) { alu_state = tmp_aux -> alu_state ; alu_limit = abs ( tmp_aux -> alu_limit - alu_limit ) ; } else { alu_state = off_is_neg ? bpf_alu_neg_value : 0 ; alu_state |= ptr_is_dst_reg ? bpf_alu_sanitize_src : bpf_alu_sanitize_dst ; } err = update_alu_sanitation_state ( aux , alu_state , alu_limit ) ; if ( err < 0 ) return err ; do_sim : if ( commit_window ) return 0 ; if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg && ret ) * dst_reg = tmp ; return ! ret ? reason_stack : 0 ; }","<S2SV_ModStart> cur_state ; bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE
",torvalds@linux/801c6058d14a82179a7ee17a4b532cac6fad067f,CVE-2021-31829,https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f,2021-05-06T16:15Z,<S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug>
2109,CWE-200,"static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = af_tipc ; addr -> addrtype = tipc_addr_id ; addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }","<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z,<S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug>
5987,CWE-119,"static inline void header_put_byte ( sf_private * psf , char x ) { if ( psf -> headindex < signed_sizeof ( psf -> header ) - 1 ) psf -> header [ psf -> headindex ++ ] = x ; }","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] =
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 ) <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug>
111,CWE-189,"static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - enomem ; if ( ! access_ok ( buffer , count ) ) return - efault ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define write_cond ( ! hidg -> write_pending ) try_again : while ( ! write_cond ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & o_nonblock ) return - eagain ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , write_cond ) ) return - erestartsys ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { error ( hidg -> func . config -> cdev , ""copy_from_user<s2sv_blank>error\\n"" ) ; status = - einval ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; status = usb_ep_queue ( hidg -> in_ep , req , gfp_atomic ) ; if ( status < 0 ) { error ( hidg -> func . config -> cdev , ""usb_ep_queue<s2sv_blank>error<s2sv_blank>on<s2sv_blank>int<s2sv_blank>endpoint<s2sv_blank>%zd\\n"" , status ) ; goto release_write_pending_unlocked ; } else { status = count ; } spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; release_write_pending_unlocked : hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }","<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending
",torvalds@linux/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036,CVE-2019-14763,https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036,2019-08-07T22:15Z,"<S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug>"
6699,CWE-476,"static void ov518_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , ""couldn\'t<s2sv_blank>get<s2sv_blank>altsetting\\n"" ) ; sd -> gspca_dev . usb_err = - eio ; return ; } packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wmaxpacketsize ) ; ov518_reg_w32 ( sd , r51x_fifo_psize , packet_size & ~ 7 , 2 ) ; reg_w ( sd , 0x2b , 0 ) ; reg_w ( sd , 0x2c , 0 ) ; reg_w ( sd , 0x2d , 0 ) ; reg_w ( sd , 0x2e , 0 ) ; reg_w ( sd , 0x3b , 0 ) ; reg_w ( sd , 0x3c , 0 ) ; reg_w ( sd , 0x3d , 0 ) ; reg_w ( sd , 0x3e , 0 ) ; if ( sd -> bridge == bridge_ov518 ) { reg_w_mask ( sd , 0x20 , 0x08 , 0x08 ) ; reg_w_mask ( sd , 0x28 , 0x80 , 0xf0 ) ; reg_w_mask ( sd , 0x38 , 0x80 , 0xf0 ) ; } else { reg_w ( sd , 0x28 , 0x80 ) ; reg_w ( sd , 0x38 , 0x80 ) ; } hsegs = sd -> gspca_dev . pixfmt . width / 16 ; vsegs = sd -> gspca_dev . pixfmt . height / 4 ; reg_w ( sd , 0x29 , hsegs ) ; reg_w ( sd , 0x2a , vsegs ) ; reg_w ( sd , 0x39 , hsegs ) ; reg_w ( sd , 0x3a , vsegs ) ; reg_w ( sd , 0x2f , 0x80 ) ; if ( sd -> bridge == bridge_ov518plus && sd -> revision == 0 && sd -> sensor == sen_ov7620ae ) sd -> clockdiv = 0 ; else sd -> clockdiv = 1 ; reg_w ( sd , 0x51 , 0x04 ) ; reg_w ( sd , 0x22 , 0x18 ) ; reg_w ( sd , 0x23 , 0xff ) ; if ( sd -> bridge == bridge_ov518plus ) { switch ( sd -> sensor ) { case sen_ov7620ae : if ( sd -> revision > 0 && sd -> gspca_dev . pixfmt . width == 640 ) { reg_w ( sd , 0x20 , 0x60 ) ; reg_w ( sd , 0x21 , 0x1f ) ; } else { reg_w ( sd , 0x20 , 0x00 ) ; reg_w ( sd , 0x21 , 0x19 ) ; } break ; case sen_ov7620 : reg_w ( sd , 0x20 , 0x00 ) ; reg_w ( sd , 0x21 , 0x19 ) ; break ; default : reg_w ( sd , 0x21 , 0x19 ) ; } } else reg_w ( sd , 0x71 , 0x17 ) ; i2c_w ( sd , 0x54 , 0x23 ) ; reg_w ( sd , 0x2f , 0x80 ) ; if ( sd -> bridge == bridge_ov518plus ) { reg_w ( sd , 0x24 , 0x94 ) ; reg_w ( sd , 0x25 , 0x90 ) ; ov518_reg_w32 ( sd , 0xc4 , 400 , 2 ) ; ov518_reg_w32 ( sd , 0xc6 , 540 , 2 ) ; ov518_reg_w32 ( sd , 0xc7 , 540 , 2 ) ; ov518_reg_w32 ( sd , 0xc8 , 108 , 2 ) ; ov518_reg_w32 ( sd , 0xca , 131098 , 3 ) ; ov518_reg_w32 ( sd , 0xcb , 532 , 2 ) ; ov518_reg_w32 ( sd , 0xcc , 2400 , 2 ) ; ov518_reg_w32 ( sd , 0xcd , 32 , 2 ) ; ov518_reg_w32 ( sd , 0xce , 608 , 2 ) ; } else { reg_w ( sd , 0x24 , 0x9f ) ; reg_w ( sd , 0x25 , 0x90 ) ; ov518_reg_w32 ( sd , 0xc4 , 400 , 2 ) ; ov518_reg_w32 ( sd , 0xc6 , 381 , 2 ) ; ov518_reg_w32 ( sd , 0xc7 , 381 , 2 ) ; ov518_reg_w32 ( sd , 0xc8 , 128 , 2 ) ; ov518_reg_w32 ( sd , 0xca , 183331 , 3 ) ; ov518_reg_w32 ( sd , 0xcb , 746 , 2 ) ; ov518_reg_w32 ( sd , 0xcc , 1750 , 2 ) ; ov518_reg_w32 ( sd , 0xcd , 45 , 2 ) ; ov518_reg_w32 ( sd , 0xce , 851 , 2 ) ; } reg_w ( sd , 0x2f , 0x80 ) ; }","<S2SV_ModStart> return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; }
",torvalds@linux/998912346c0da53a6dbb71fab3a138586b596b30,CVE-2020-11608,https://github.com/torvalds/linux/commit/998912346c0da53a6dbb71fab3a138586b596b30,2020-04-07T14:15Z,<S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug>
6768,CWE-295,"static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ sha256len ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ sha256strlen ] , * subject , * issuer ; char * line ; int i ; x509_name * subj ; char common_name [ field_size + 1 ] ; ssl_set_verify ( tunnel -> ssl_handle , ssl_verify_peer , null ) ; x509 * cert = ssl_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == null ) { log_error ( ""unable<s2sv_blank>to<s2sv_blank>get<s2sv_blank>gateway<s2sv_blank>certificate.\\n"" ) ; return 1 ; } subj = x509_get_subject_name ( cert ) ; # ifdef have_x509_check_host if ( x509_check_host ( cert , common_name , field_size , 0 , null ) == 1 ) cert_valid = 1 ; # else if ( subj && x509_name_get_text_by_nid ( subj , nid_commonname , common_name , field_size ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , field_size ) == 0 ) cert_valid = 1 ; # endif if ( cert_valid && ssl_get_verify_result ( tunnel -> ssl_handle ) == x509_v_ok ) { log_debug ( ""gateway<s2sv_blank>certificate<s2sv_blank>validation<s2sv_blank>succeeded.\\n"" ) ; ret = 0 ; goto free_cert ; } log_debug ( ""gateway<s2sv_blank>certificate<s2sv_blank>validation<s2sv_blank>failed.\\n"" ) ; if ( x509_digest ( cert , evp_sha256 ( ) , digest , & len ) <= 0 || len != sha256len ) { log_error ( ""could<s2sv_blank>not<s2sv_blank>compute<s2sv_blank>certificate<s2sv_blank>sha256<s2sv_blank>digest.\\n"" ) ; goto free_cert ; } for ( i = 0 ; i < sha256len ; i ++ ) sprintf ( & digest_str [ 2 * i ] , ""%02x"" , digest [ i ] ) ; digest_str [ sha256strlen - 1 ] = '\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != null ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , sha256strlen - 1 ) == 0 ) break ; if ( elem != null ) { log_debug ( ""gateway<s2sv_blank>certificate<s2sv_blank>digest<s2sv_blank>found<s2sv_blank>in<s2sv_blank>white<s2sv_blank>list.\\n"" ) ; ret = 0 ; goto free_cert ; } subject = x509_name_oneline ( subj , null , 0 ) ; issuer = x509_name_oneline ( x509_get_issuer_name ( cert ) , null , 0 ) ; log_error ( ""gateway<s2sv_blank>certificate<s2sv_blank>validation<s2sv_blank>failed,<s2sv_blank>and<s2sv_blank>the<s2sv_blank>certificate<s2sv_blank>digest<s2sv_blank>in<s2sv_blank>not<s2sv_blank>in<s2sv_blank>the<s2sv_blank>local<s2sv_blank>whitelist.<s2sv_blank>if<s2sv_blank>you<s2sv_blank>trust<s2sv_blank>it,<s2sv_blank>rerun<s2sv_blank>with:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>--trusted-cert<s2sv_blank>%s\\n"" , digest_str ) ; log_error ( ""or<s2sv_blank>add<s2sv_blank>this<s2sv_blank>line<s2sv_blank>to<s2sv_blank>your<s2sv_blank>config<s2sv_blank>file:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>trusted-cert<s2sv_blank>=<s2sv_blank>%s\\n"" , digest_str ) ; log_error ( ""gateway<s2sv_blank>certificate:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>subject:\\n"" ) ; for ( line = strtok ( subject , ""/"" ) ; line != null ; line = strtok ( null , ""/"" ) ) log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" , line ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>issuer:\\n"" ) ; for ( line = strtok ( issuer , ""/"" ) ; line != null ; line = strtok ( null , ""/"" ) ) log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" , line ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>sha256<s2sv_blank>digest:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" , digest_str ) ; free_cert : x509_free ( cert ) ; return ret ; }","<S2SV_ModStart> * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_ModStart> 1 ] ; <S2SV_ModEnd> if ( subj
",adrienverge@openfortivpn/9eee997d599a89492281fc7ffdd79d88cd61afc3,CVE-2020-7042,https://github.com/adrienverge/openfortivpn/commit/9eee997d599a89492281fc7ffdd79d88cd61afc3,2020-02-27T18:15Z,"<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; <S2SV_EndBug>"
480,CWE-20,"static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = null ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = checksum_none ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = ll_reserved_space ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == ipproto_udp || sk -> sk_protocol == ipproto_raw ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + ipv6_maxplen ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , emsgsize , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - emsgsize ; } if ( transhdrlen && sk -> sk_protocol == ipproto_udp && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & msg_more ) && rt -> dst . dev -> features & ( netif_f_ipv6_csum | netif_f_hw_csum ) ) csummode = checksum_partial ; if ( sk -> sk_type == sock_dgram || sk -> sk_type == sock_raw ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & skbtx_any_sw_tstamp && sk -> sk_tsflags & sof_timestamping_opt_id ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == ipproto_udp ) && ( rt -> dst . dev -> features & netif_f_ufo ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == sock_dgram ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & ipcork_allfrag ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & ipcork_allfrag ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & msg_more ) && ! ( rt -> dst . dev -> features & netif_f_sg ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & msg_dontwait ) , & err ) ; } else { skb = null ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - enobufs ; } if ( ! skb ) goto error ; skb -> protocol = htons ( eth_p_ipv6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - einval ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - efault ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & msg_confirm ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & netif_f_sg ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - efault ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - enomem ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - emsgsize ; if ( i == max_skb_frags ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - efault ; error : cork -> length -= length ; ip6_inc_stats ( sock_net ( sk ) , rt -> rt6i_idev , ipstats_mib_outdiscards ) ; return err ; }","<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
",torvalds@linux/232cd35d0804cc241eb887bb8d4d9b3b9881c64a,CVE-2017-9242,https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a,2017-05-27T01:29Z,<S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug>
2689,CWE-20,"static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ bdevname_size ] ; bdev = blkdev_get_by_dev ( dev , fmode_read | fmode_write | fmode_excl , sb ) ; if ( is_err ( bdev ) ) goto fail ; return bdev ; fail : ext3_msg ( sb , ""error:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>open<s2sv_blank>journal<s2sv_blank>device<s2sv_blank>%s:<s2sv_blank>%ld"" , __bdevname ( dev , b ) , ptr_err ( bdev ) ) ; return null ; }","<S2SV_ModStart> ( sb , KERN_ERR ,
",torvalds@linux/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,CVE-2013-1848,https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,2013-03-22T11:59Z,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug>"
625,CWE-476,"static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _u_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdadc ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdadc = tvb_get_letohs ( tvb , offset ) ; ver_major = usb_audio_bcd44_to_dec ( bcdadc >> 8 ) ; ver = ver_major + usb_audio_bcd44_to_dec ( bcdadc & 0xff ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , ""%2.2f"" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; } audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , enc_little_endian ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bincollection , tvb , offset , 1 , enc_little_endian ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , enc_little_endian ) ; offset ++ ; } } return offset - offset_start ; }","<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
",wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z,<S2SV_StartBug> } <S2SV_EndBug>
3437,CWE-476,"void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { negotiate_message * sec_blob = ( negotiate_message * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( negotiate_message ) ) ; memcpy ( sec_blob -> signature , ntlmssp_signature , 8 ) ; sec_blob -> messagetype = ntlmnegotiate ; flags = ntlmssp_negotiate_56 | ntlmssp_request_target | ntlmssp_negotiate_128 | ntlmssp_negotiate_unicode | ntlmssp_negotiate_ntlm | ntlmssp_negotiate_extended_sec ; if ( ses -> server -> sign ) { flags |= ntlmssp_negotiate_sign ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= ntlmssp_negotiate_key_xch ; } sec_blob -> negotiateflags = cpu_to_le32 ( flags ) ; sec_blob -> workstationname . bufferoffset = 0 ; sec_blob -> workstationname . length = 0 ; sec_blob -> workstationname . maximumlength = 0 ; sec_blob -> domainname . bufferoffset = 0 ; sec_blob -> domainname . length = 0 ; sec_blob -> domainname . maximumlength = 0 ; }","<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags
",torvalds@linux/cabfb3680f78981d26c078a26e5c748531257ebb,CVE-2018-1066,https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb,2018-03-02T08:29Z,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
85,CWE-190,"static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == vfio_device_get_info ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - efault ; if ( info . argsz < minsz ) return - einval ; info . flags = vfio_device_flags_pci ; if ( vdev -> reset_works ) info . flags |= vfio_device_flags_reset ; info . num_regions = vfio_pci_num_regions + vdev -> num_regions ; info . num_irqs = vfio_pci_num_irqs ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - efault : 0 ; } else if ( cmd == vfio_device_get_region_info ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = null , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - efault ; if ( info . argsz < minsz ) return - einval ; switch ( info . index ) { case vfio_pci_config_region_index : info . offset = vfio_pci_index_to_offset ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = vfio_region_info_flag_read | vfio_region_info_flag_write ; break ; case vfio_pci_bar0_region_index ... vfio_pci_bar5_region_index : info . offset = vfio_pci_index_to_offset ( info . index ) ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { info . flags = 0 ; break ; } info . flags = vfio_region_info_flag_read | vfio_region_info_flag_write ; if ( vdev -> bar_mmap_supported [ info . index ] ) { info . flags |= vfio_region_info_flag_mmap ; if ( info . index == vdev -> msix_bar ) { ret = msix_sparse_mmap_cap ( vdev , & caps ) ; if ( ret ) return ret ; } } break ; case vfio_pci_rom_region_index : { void __iomem * io ; size_t size ; info . offset = vfio_pci_index_to_offset ( info . index ) ; info . flags = 0 ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { if ( pdev -> resource [ pci_rom_resource ] . flags & ioresource_rom_shadow ) info . size = 0x20000 ; else break ; } io = pci_map_rom ( pdev , & size ) ; if ( ! io || ! size ) { info . size = 0 ; break ; } pci_unmap_rom ( pdev , io ) ; info . flags = vfio_region_info_flag_read ; break ; } case vfio_pci_vga_region_index : if ( ! vdev -> has_vga ) return - einval ; info . offset = vfio_pci_index_to_offset ( info . index ) ; info . size = 0xc0000 ; info . flags = vfio_region_info_flag_read | vfio_region_info_flag_write ; break ; default : if ( info . index >= vfio_pci_num_regions + vdev -> num_regions ) return - einval ; i = info . index - vfio_pci_num_regions ; info . offset = vfio_pci_index_to_offset ( info . index ) ; info . size = vdev -> region [ i ] . size ; info . flags = vdev -> region [ i ] . flags ; ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ; if ( ret ) return ret ; } if ( caps . size ) { info . flags |= vfio_region_info_flag_caps ; if ( info . argsz < sizeof ( info ) + caps . size ) { info . argsz = sizeof ( info ) + caps . size ; info . cap_offset = 0 ; } else { vfio_info_cap_shift ( & caps , sizeof ( info ) ) ; if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) { kfree ( caps . buf ) ; return - efault ; } info . cap_offset = sizeof ( info ) ; } kfree ( caps . buf ) ; } return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - efault : 0 ; } else if ( cmd == vfio_device_get_irq_info ) { struct vfio_irq_info info ; minsz = offsetofend ( struct vfio_irq_info , count ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - efault ; if ( info . argsz < minsz || info . index >= vfio_pci_num_irqs ) return - einval ; switch ( info . index ) { case vfio_pci_intx_irq_index ... vfio_pci_msix_irq_index : case vfio_pci_req_irq_index : break ; case vfio_pci_err_irq_index : if ( pci_is_pcie ( vdev -> pdev ) ) break ; default : return - einval ; } info . flags = vfio_irq_info_eventfd ; info . count = vfio_pci_get_irq_count ( vdev , info . index ) ; if ( info . index == vfio_pci_intx_irq_index ) info . flags |= ( vfio_irq_info_maskable | vfio_irq_info_automasked ) ; else info . flags |= vfio_irq_info_noresize ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - efault : 0 ; } else if ( cmd == vfio_device_set_irqs ) { struct vfio_irq_set hdr ; u8 * data = null ; int ret = 0 ; minsz = offsetofend ( struct vfio_irq_set , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - efault ; if ( hdr . argsz < minsz || hdr . index >= vfio_pci_num_irqs || hdr . flags & ~ ( vfio_irq_set_data_type_mask | vfio_irq_set_action_type_mask ) ) return - einval ; if ( ! ( hdr . flags & vfio_irq_set_data_none ) ) { size_t size ; int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ; if ( hdr . flags & vfio_irq_set_data_bool ) size = sizeof ( uint8_t ) ; else if ( hdr . flags & vfio_irq_set_data_eventfd ) size = sizeof ( int32_t ) ; else return - einval ; if ( hdr . argsz - minsz < hdr . count * size || hdr . start >= max || hdr . start + hdr . count > max ) return - einval ; data = memdup_user ( ( void __user * ) ( arg + minsz ) , hdr . count * size ) ; if ( is_err ( data ) ) return ptr_err ( data ) ; } mutex_lock ( & vdev -> igate ) ; ret = vfio_pci_set_irqs_ioctl ( vdev , hdr . flags , hdr . index , hdr . start , hdr . count , data ) ; mutex_unlock ( & vdev -> igate ) ; kfree ( data ) ; return ret ; } else if ( cmd == vfio_device_reset ) { return vdev -> reset_works ? pci_try_reset_function ( vdev -> pdev ) : - einval ; } else if ( cmd == vfio_device_get_pci_hot_reset_info ) { struct vfio_pci_hot_reset_info hdr ; struct vfio_pci_fill_info fill = { 0 } ; struct vfio_pci_dependent_device * devices = null ; bool slot = false ; int ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset_info , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - efault ; if ( hdr . argsz < minsz ) return - einval ; hdr . flags = 0 ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - enodev ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & fill . max , slot ) ; if ( ret ) return ret ; warn_on ( ! fill . max ) ; if ( hdr . argsz < sizeof ( hdr ) + ( fill . max * sizeof ( * devices ) ) ) { ret = - enospc ; hdr . count = fill . max ; goto reset_info_exit ; } devices = kcalloc ( fill . max , sizeof ( * devices ) , gfp_kernel ) ; if ( ! devices ) return - enomem ; fill . devices = devices ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_fill_devs , & fill , slot ) ; if ( ! ret ) hdr . count = fill . cur ; reset_info_exit : if ( copy_to_user ( ( void __user * ) arg , & hdr , minsz ) ) ret = - efault ; if ( ! ret ) { if ( copy_to_user ( ( void __user * ) ( arg + minsz ) , devices , hdr . count * sizeof ( * devices ) ) ) ret = - efault ; } kfree ( devices ) ; return ret ; } else if ( cmd == vfio_device_pci_hot_reset ) { struct vfio_pci_hot_reset hdr ; int32_t * group_fds ; struct vfio_pci_group_entry * groups ; struct vfio_pci_group_info info ; bool slot = false ; int i , count = 0 , ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - efault ; if ( hdr . argsz < minsz || hdr . flags ) return - einval ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - enodev ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & count , slot ) ; if ( ret ) return ret ; if ( ! hdr . count || hdr . count > count ) return - einval ; group_fds = kcalloc ( hdr . count , sizeof ( * group_fds ) , gfp_kernel ) ; groups = kcalloc ( hdr . count , sizeof ( * groups ) , gfp_kernel ) ; if ( ! group_fds || ! groups ) { kfree ( group_fds ) ; kfree ( groups ) ; return - enomem ; } if ( copy_from_user ( group_fds , ( void __user * ) ( arg + minsz ) , hdr . count * sizeof ( * group_fds ) ) ) { kfree ( group_fds ) ; kfree ( groups ) ; return - efault ; } for ( i = 0 ; i < hdr . count ; i ++ ) { struct vfio_group * group ; struct fd f = fdget ( group_fds [ i ] ) ; if ( ! f . file ) { ret = - ebadf ; break ; } group = vfio_group_get_external_user ( f . file ) ; fdput ( f ) ; if ( is_err ( group ) ) { ret = ptr_err ( group ) ; break ; } groups [ i ] . group = group ; groups [ i ] . id = vfio_external_user_iommu_id ( group ) ; } kfree ( group_fds ) ; if ( ret ) goto hot_reset_release ; info . count = hdr . count ; info . groups = groups ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_validate_devs , & info , slot ) ; if ( ! ret ) ret = slot ? pci_try_reset_slot ( vdev -> pdev -> slot ) : pci_try_reset_bus ( vdev -> pdev -> bus ) ; hot_reset_release : for ( i -- ; i >= 0 ; i -- ) vfio_group_put_external_user ( groups [ i ] . group ) ; kfree ( groups ) ; return ret ; } return - enotty ; }","<S2SV_ModStart> vfio_irq_set hdr ; size_t size ; <S2SV_ModStart> NULL ; int max , <S2SV_ModStart> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdr . start <S2SV_ModStart> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
",torvalds@linux/05692d7005a364add85c6e25a6c4447ce08f913a,CVE-2016-9084,https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a,2016-11-28T03:59Z,<S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug>
6055,CWE-000,"static void dump_completed_io ( struct inode * inode ) { # ifdef ext4_debug struct list_head * cur , * before , * after ; ext4_io_end_t * io , * io0 , * io1 ; if ( list_empty ( & ext4_i ( inode ) -> i_completed_io_list ) ) { ext4_debug ( ""inode<s2sv_blank>%lu<s2sv_blank>completed_io<s2sv_blank>list<s2sv_blank>is<s2sv_blank>empty\\n"" , inode -> i_ino ) ; return ; } ext4_debug ( ""dump<s2sv_blank>inode<s2sv_blank>%lu<s2sv_blank>completed_io<s2sv_blank>list<s2sv_blank>\\n"" , inode -> i_ino ) ; list_for_each_entry ( io , & ext4_i ( inode ) -> i_completed_io_list , list ) { cur = & io -> list ; before = cur -> prev ; io0 = container_of ( before , ext4_io_end_t , list ) ; after = cur -> next ; io1 = container_of ( after , ext4_io_end_t , list ) ; ext4_debug ( ""io<s2sv_blank>0x%p<s2sv_blank>from<s2sv_blank>inode<s2sv_blank>%lu,prev<s2sv_blank>0x%p,next<s2sv_blank>0x%p\\n"" , io , inode -> i_ino , io0 , io1 ) ; } # endif }","<S2SV_ModStart> * io1 ; unsigned long flags ; <S2SV_ModStart> inode -> i_ino ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,"<S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\n"" , inode -> i_ino ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug>"
4793,CWE-327,"int wc_signaturegenerate ( enum wc_hashtype hash_type , enum wc_signaturetype sig_type , const byte * data , word32 data_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , wc_rng * rng ) { int ret ; word32 hash_len , hash_enc_len ; # ifdef wolfssl_small_stack byte * hash_data ; # else byte hash_data [ max_der_digest_sz ] ; # endif if ( data == null || data_len <= 0 || sig == null || sig_len == null || * sig_len <= 0 || key == null || key_len <= 0 ) { return bad_func_arg ; } if ( ( int ) * sig_len < wc_signaturegetsize ( sig_type , key , key_len ) ) { wolfssl_msg ( ""wc_signaturegenerate:<s2sv_blank>invalid<s2sv_blank>sig<s2sv_blank>type/len"" ) ; return bad_func_arg ; } ret = wc_hashgetdigestsize ( hash_type ) ; if ( ret < 0 ) { wolfssl_msg ( ""wc_signaturegenerate:<s2sv_blank>invalid<s2sv_blank>hash<s2sv_blank>type/len"" ) ; return ret ; } hash_enc_len = hash_len = ret ; # if ! defined ( no_rsa ) && ! defined ( wolfssl_rsa_public_only ) if ( sig_type == wc_signature_type_rsa_w_enc ) { hash_enc_len += max_der_digest_asn_sz ; } # endif # ifdef wolfssl_small_stack hash_data = ( byte * ) xmalloc ( hash_enc_len , null , dynamic_type_tmp_buffer ) ; if ( hash_data == null ) { return memory_e ; } # endif ret = wc_hash ( hash_type , data , data_len , hash_data , hash_len ) ; if ( ret == 0 ) { if ( sig_type == wc_signature_type_rsa_w_enc ) { # if defined ( no_rsa ) || defined ( no_asn ) || defined ( wolfssl_rsa_public_only ) ret = sig_type_e ; # else ret = wc_signaturederencode ( hash_type , hash_data , hash_len , & hash_enc_len ) ; # endif } if ( ret == 0 ) { ret = wc_signaturegeneratehash ( hash_type , sig_type , hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; } } # ifdef wolfssl_small_stack xfree ( hash_data , null , dynamic_type_tmp_buffer ) ; # endif return ret ; }","<S2SV_ModStart> rng ) { return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> , data , <S2SV_ModStart> , data_len , sig , <S2SV_ModEnd> sig_len , key <S2SV_ModStart> key_len , rng , 1 <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",wolfSSL@wolfssl/23878512c65834d12811b1107d19a001478eca5d,CVE-2019-19962,https://github.com/wolfSSL/wolfssl/commit/23878512c65834d12811b1107d19a001478eca5d,2019-12-25T00:15Z,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
8189,CWE-17,"static void parsefirstline ( webs * wp ) { char * op , * protover , * url , * host , * query , * path , * port , * ext , * buf ; int listenport ; assert ( wp ) ; assert ( websvalid ( wp ) ) ; op = gettoken ( wp , 0 ) ; if ( op == null || * op == '\\0' ) { webserror ( wp , http_code_not_found | webs_close , ""bad<s2sv_blank>http<s2sv_blank>request"" ) ; return ; } wp -> method = supper ( sclone ( op ) ) ; url = gettoken ( wp , 0 ) ; if ( url == null || * url == '\\0' ) { webserror ( wp , http_code_bad_request | webs_close , ""bad<s2sv_blank>http<s2sv_blank>request"" ) ; return ; } if ( strlen ( url ) > me_goahead_limit_uri ) { webserror ( wp , http_code_request_url_too_large | webs_close , ""uri<s2sv_blank>too<s2sv_blank>big"" ) ; return ; } protover = gettoken ( wp , ""\\r\\n"" ) ; if ( websgetloglevel ( ) == 2 ) { trace ( 2 , ""%s<s2sv_blank>%s<s2sv_blank>%s"" , wp -> method , url , protover ) ; } host = path = port = query = ext = null ; if ( websurlparse ( url , & buf , null , & host , & port , & path , & ext , null , & query ) < 0 ) { error ( ""cannot<s2sv_blank>parse<s2sv_blank>url:<s2sv_blank>%s"" , url ) ; webserror ( wp , http_code_bad_request | webs_close | webs_nolog , ""bad<s2sv_blank>url"" ) ; return ; } if ( ( wp -> path = websnormalizeuripath ( path ) ) == 0 ) { error ( ""cannot<s2sv_blank>normalize<s2sv_blank>url:<s2sv_blank>%s"" , url ) ; webserror ( wp , http_code_bad_request | webs_close | webs_nolog , ""bad<s2sv_blank>url"" ) ; wfree ( buf ) ; return ; } wp -> url = sclone ( url ) ; if ( ext ) { wp -> ext = sclone ( slower ( ext ) ) ; } wp -> filename = sfmt ( ""%s%s"" , websgetdocuments ( ) , wp -> path ) ; wp -> query = sclone ( query ) ; wp -> host = sclone ( host ) ; wp -> protocol = wp -> flags & webs_secure ? ""https"" : ""http"" ; if ( smatch ( protover , ""http/1.1"" ) ) { wp -> flags |= webs_keep_alive | webs_http11 ; } else if ( smatch ( protover , ""http/1.0"" ) ) { wp -> flags &= ~ ( webs_http11 ) ; } else { protover = sclone ( ""http/1.1"" ) ; webserror ( wp , webs_close | http_code_not_acceptable , ""unsupported<s2sv_blank>http<s2sv_blank>protocol"" ) ; } wp -> protoversion = sclone ( protover ) ; if ( ( listenport = socketgetport ( wp -> listensid ) ) >= 0 ) { wp -> port = listenport ; } else { wp -> port = atoi ( port ) ; } wfree ( buf ) ; }","<S2SV_ModStart> -> path = websValidateUriPath <S2SV_ModEnd> ( path )
",embedthis@goahead/eed4a7d177bf94a54c7b06ccce88507fbd76fb77,CVE-2014-9707,https://github.com/embedthis/goahead/commit/eed4a7d177bf94a54c7b06ccce88507fbd76fb77,2015-03-31T14:59Z,<S2SV_StartBug> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <S2SV_EndBug>
3362,CWE-119,"static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case trackpad_report_id : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case mouse_report_id : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; npoints = ( size - 6 ) / 8 ; msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case double_report_id : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == usb_device_id_apple_magicmouse ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , rel_x , x ) ; input_report_rel ( input , rel_y , y ) ; } else { input_report_key ( input , btn_mouse , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }","<S2SV_ModStart> / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; }
",torvalds@linux/c54def7bd64d7c0b6993336abcffb8444795bf38,CVE-2014-3181,https://github.com/torvalds/linux/commit/c54def7bd64d7c0b6993336abcffb8444795bf38,2014-09-28T10:55Z,<S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug>
2296,CWE-000,"unsigned int get_random_int ( void ) { struct keydata * keyptr ; __u32 * hash = get_cpu_var ( get_random_int_hash ) ; int ret ; keyptr = get_keyptr ( ) ; hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ; ret = half_md4_transform ( hash , keyptr -> secret ) ; put_cpu_var ( get_random_int_hash ) ; return ret ; }","<S2SV_ModStart> void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var (
",torvalds@linux/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,CVE-2011-3188,https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,2012-05-24T23:55Z,"<S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug>"
2973,CWE-20,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - einval ; if ( args [ size - 1 ] != '\\0' ) { if ( size == page_size ) return - einval ; args [ size ] = '\\0' ; } if ( current != task ) return - eacces ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<s2sv_blank>"" ) ; if ( ! args ) return - einval ; args = skip_spaces ( args ) ; if ( ! * args ) return - einval ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! aa_do_test ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , aa_do_test ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! aa_onexec , ! aa_do_test ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! aa_onexec , aa_do_test ) ; } else if ( strcmp ( command , ""permipc"" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; common_audit_data_init ( & sa , none ) ; sa . aad . op = op_setprocattr ; sa . aad . info = name ; sa . aad . error = - einval ; return aa_audit ( audit_apparmor_denied , null , gfp_kernel , & sa , null ) ; } } else if ( strcmp ( name , ""exec"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , aa_onexec , ! aa_do_test ) ; } else { return - einval ; } if ( ! error ) error = size ; return error ; }","<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; }
",torvalds@linux/a5b2c5b2ad5853591a6cac6134cd0f599a720865,CVE-2011-3619,https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865,2013-06-08T13:05Z,"<S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug>"
8379,CWE-362,"static struct sock * tcp_v6_syn_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * treq ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; struct ipv6_txoptions * opt ; # ifdef config_tcp_md5sig struct tcp_md5sig_key * key ; # endif if ( skb -> protocol == htons ( eth_p_ip ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst ) ; if ( newsk == null ) return null ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef config_tcp_md5sig newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> pktoptions = null ; newnp -> opt = null ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } treq = inet6_rsk ( req ) ; opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , req ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( newsk == null ) goto out_nonewsk ; newsk -> sk_gso_type = skb_gso_tcpv6 ; __ip6_dst_store ( newsk , dst , null , null ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & treq -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & treq -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & treq -> loc_addr ) ; newsk -> sk_bound_dev_if = treq -> iif ; newinet -> opt = null ; newnp -> ipv6_fl_list = null ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = null ; if ( treq -> pktopts != null ) { newnp -> pktoptions = skb_clone ( treq -> pktopts , gfp_atomic ) ; kfree_skb ( treq -> pktopts ) ; treq -> pktopts = null ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = null ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; tcp_mtup_init ( newsk ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = loopback4_ipv6 ; newinet -> inet_rcv_saddr = loopback4_ipv6 ; # ifdef config_tcp_md5sig if ( ( key = tcp_v6_md5_do_lookup ( sk , & newnp -> daddr ) ) != null ) { char * newkey = kmemdup ( key -> key , key -> keylen , gfp_atomic ) ; if ( newkey != null ) tcp_v6_md5_do_add ( newsk , & newnp -> daddr , newkey , key -> keylen ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , null ) ; return newsk ; out_overflow : net_inc_stats_bh ( sock_net ( sk ) , linux_mib_listenoverflows ) ; out_nonewsk : if ( opt && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; dst_release ( dst ) ; out : net_inc_stats_bh ( sock_net ( sk ) , linux_mib_listendrops ) ; return null ; }","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug>
3652,CWE-399,"static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; vmcs_writel ( host_cr0 , read_cr0 ( ) & ~ x86_cr0_ts ) ; vmcs_writel ( host_cr4 , read_cr4 ( ) ) ; vmcs_writel ( host_cr3 , read_cr3 ( ) ) ; vmcs_write16 ( host_cs_selector , __kernel_cs ) ; # ifdef config_x86_64 vmcs_write16 ( host_ds_selector , 0 ) ; vmcs_write16 ( host_es_selector , 0 ) ; # else vmcs_write16 ( host_ds_selector , __kernel_ds ) ; vmcs_write16 ( host_es_selector , __kernel_ds ) ; # endif vmcs_write16 ( host_ss_selector , __kernel_ds ) ; vmcs_write16 ( host_tr_selector , gdt_entry_tss * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( host_idtr_base , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( host_rip , vmx_return ) ; rdmsr ( msr_ia32_sysenter_cs , low32 , high32 ) ; vmcs_write32 ( host_ia32_sysenter_cs , low32 ) ; rdmsrl ( msr_ia32_sysenter_eip , tmpl ) ; vmcs_writel ( host_ia32_sysenter_eip , tmpl ) ; if ( vmcs_config . vmexit_ctrl & vm_exit_load_ia32_pat ) { rdmsr ( msr_ia32_cr_pat , low32 , high32 ) ; vmcs_write64 ( host_ia32_pat , low32 | ( ( u64 ) high32 << 32 ) ) ; } }","<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
",torvalds@linux/d974baa398f34393db76be45f7d4d04fbdbb4a0a,CVE-2014-3690,https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a,2014-11-10T11:55Z,"<S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug>"
8361,CWE-362,"struct dst_entry * inet_csk_route_req ( struct sock * sk , const struct request_sock * req ) { struct rtable * rt ; const struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ip_options * opt = inet_rsk ( req ) -> opt ; struct net * net = sock_net ( sk ) ; struct flowi4 fl4 ; flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , rt_conn_flags ( sk ) , rt_scope_universe , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) , ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( is_err ( rt ) ) goto no_route ; if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) goto route_err ; return & rt -> dst ; route_err : ip_rt_put ( rt ) ; no_route : ip_inc_stats_bh ( net , ipstats_mib_outnoroutes ) ; return null ; }","<S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> struct ip_options * opt = inet_rsk ( req ) -> opt ; <S2SV_EndBug> <S2SV_StartBug> ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <S2SV_EndBug>"
6240,CWE-000,"public void mprdefaultloghandler ( cchar * tags , int level , cchar * msg ) { mprfile * file ; char tbuf [ 128 ] ; static int check = 0 ; if ( ( file = mpr -> logfile ) == 0 ) { return ; } if ( mpr -> logbackup && mpr -> logsize && ( check ++ % 1000 ) == 0 ) { backuplog ( ) ; } if ( tags && * tags ) { if ( mpr -> flags & mpr_log_detailed ) { fmt ( tbuf , sizeof ( tbuf ) , ""%s<s2sv_blank>%d<s2sv_blank>%s,<s2sv_blank>"" , mprgetdate ( mpr_log_date ) , level , tags ) ; mprwritefilestring ( file , tbuf ) ; } else if ( mpr -> flags & mpr_log_tagged ) { if ( schr ( tags , '<s2sv_blank>' ) ) { tags = stok ( sclone ( tags ) , ""<s2sv_blank>"" , null ) ; } if ( ! isupper ( ( uchar ) * tags ) ) { tags = stitle ( tags ) ; } mprwritefilefmt ( file , ""%12s<s2sv_blank>"" , sfmt ( ""[%s]"" , tags ) ) ; } } mprwritefilestring ( file , msg ) ; mprwritefilestring ( file , ""\\n"" ) ; # if me_mpr_oslog if ( level == 0 ) { mprwritetooslog ( sfmt ( ""%s:<s2sv_blank>%d<s2sv_blank>%s:<s2sv_blank>%s"" , mpr -> name , level , tags , msg ) , level ) ; } # endif }","<S2SV_ModStart> { tags = ssplit <S2SV_ModEnd> ( sclone (
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> tags = stok ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ; <S2SV_EndBug>"
3827,CWE-264,"static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; if ( ( clone_flags & ( clone_newns | clone_fs ) ) == ( clone_newns | clone_fs ) ) return err_ptr ( - einval ) ; if ( ( clone_flags & clone_thread ) && ! ( clone_flags & clone_sighand ) ) return err_ptr ( - einval ) ; if ( ( clone_flags & clone_sighand ) && ! ( clone_flags & clone_vm ) ) return err_ptr ( - einval ) ; if ( ( clone_flags & clone_parent ) && current -> signal -> flags & signal_unkillable ) return err_ptr ( - einval ) ; if ( ( clone_flags & ( clone_vm | clone_newpid ) ) && ( task_active_pid_ns ( current ) != current -> nsproxy -> pid_ns ) ) return err_ptr ( - einval ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - enomem ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; get_seccomp_filter ( p ) ; rt_mutex_init_task ( p ) ; # ifdef config_prove_locking debug_locks_warn_on ( ! p -> hardirqs_enabled ) ; debug_locks_warn_on ( ! p -> softirqs_enabled ) ; # endif retval = - eagain ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , rlimit_nproc ) ) { if ( ! capable ( cap_sys_admin ) && ! capable ( cap_sys_resource ) && p -> real_cred -> user != init_user ) goto bad_fork_free ; } current -> flags &= ~ pf_nproc_exceeded ; retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - eagain ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module ) ) goto bad_fork_cleanup_count ; p -> did_exec = 0 ; delayacct_tsk_init ( p ) ; copy_flags ( clone_flags , p ) ; init_list_head ( & p -> children ) ; init_list_head ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = null ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = p -> stime = p -> gtime = 0 ; p -> utimescaled = p -> stimescaled = 0 ; # ifndef config_virt_cpu_accounting p -> prev_cputime . utime = p -> prev_cputime . stime = 0 ; # endif # ifdef config_virt_cpu_accounting_gen seqlock_init ( & p -> vtime_seqlock ) ; p -> vtime_snap = 0 ; p -> vtime_snap_whence = vtime_sleeping ; # endif # if defined ( split_rss_counting ) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat ) ) ; # endif p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cpu_timers_init ( p ) ; do_posix_clock_monotonic_gettime ( & p -> start_time ) ; p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ) ; p -> io_context = null ; p -> audit_context = null ; if ( clone_flags & clone_thread ) threadgroup_change_begin ( current ) ; cgroup_fork ( p ) ; # ifdef config_numa p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( is_err ( p -> mempolicy ) ) { retval = ptr_err ( p -> mempolicy ) ; p -> mempolicy = null ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ) ; # endif # ifdef config_cpusets p -> cpuset_mem_spread_rotor = numa_no_node ; p -> cpuset_slab_spread_rotor = numa_no_node ; seqcount_init ( & p -> mems_allowed_seq ) ; # endif # ifdef config_trace_irqflags p -> irq_events = 0 ; p -> hardirqs_enabled = 0 ; p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _this_ip_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _this_ip_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; # endif # ifdef config_lockdep p -> lockdep_depth = 0 ; p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; # endif # ifdef config_debug_mutexes p -> blocked_on = null ; # endif # ifdef config_memcg p -> memcg_batch . do_batch = 0 ; p -> memcg_batch . memcg = null ; # endif sched_fork ( p ) ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = audit_alloc ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = copy_semundo ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_audit ; retval = copy_files ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_semundo ; retval = copy_fs ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_files ; retval = copy_sighand ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_fs ; retval = copy_signal ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_sighand ; retval = copy_mm ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_signal ; retval = copy_namespaces ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_mm ; retval = copy_io ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p ) ; if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - enomem ; pid = alloc_pid ( p -> nsproxy -> pid_ns ) ; if ( ! pid ) goto bad_fork_cleanup_io ; } p -> pid = pid_nr ( pid ) ; p -> tgid = p -> pid ; if ( clone_flags & clone_thread ) p -> tgid = current -> tgid ; p -> set_child_tid = ( clone_flags & clone_child_settid ) ? child_tidptr : null ; p -> clear_child_tid = ( clone_flags & clone_child_cleartid ) ? child_tidptr : null ; # ifdef config_block p -> plug = null ; # endif # ifdef config_futex p -> robust_list = null ; # ifdef config_compat p -> compat_robust_list = null ; # endif init_list_head ( & p -> pi_state_list ) ; p -> pi_state_cache = null ; # endif uprobe_copy_process ( p ) ; if ( ( clone_flags & ( clone_vm | clone_vfork ) ) == clone_vm ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; user_disable_single_step ( p ) ; clear_tsk_thread_flag ( p , tif_syscall_trace ) ; # ifdef tif_syscall_emu clear_tsk_thread_flag ( p , tif_syscall_emu ) ; # endif clear_all_latency_tracing ( p ) ; if ( clone_flags & clone_thread ) p -> exit_signal = - 1 ; else if ( clone_flags & clone_parent ) p -> exit_signal = current -> group_leader -> exit_signal ; else p -> exit_signal = ( clone_flags & csignal ) ; p -> pdeath_signal = 0 ; p -> exit_state = 0 ; p -> nr_dirtied = 0 ; p -> nr_dirtied_pause = 128 >> ( page_shift - 10 ) ; p -> dirty_paused_when = 0 ; p -> group_leader = p ; init_list_head ( & p -> thread_group ) ; p -> task_works = null ; write_lock_irq ( & tasklist_lock ) ; if ( clone_flags & ( clone_parent | clone_thread ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ) ; recalc_sigpending ( ) ; if ( signal_pending ( current ) ) { spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; retval = - erestartnointr ; goto bad_fork_free_pid ; } if ( clone_flags & clone_thread ) { current -> signal -> nr_threads ++ ; atomic_inc ( & current -> signal -> live ) ; atomic_inc ( & current -> signal -> sigcnt ) ; p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; } if ( likely ( p -> pid ) ) { ptrace_init_task ( p , ( clone_flags & clone_ptrace ) || trace ) ; if ( thread_group_leader ( p ) ) { if ( is_child_reaper ( pid ) ) { ns_of_pid ( pid ) -> child_reaper = p ; p -> signal -> flags |= signal_unkillable ; } p -> signal -> leader_pid = pid ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; attach_pid ( p , pidtype_pgid , task_pgrp ( current ) ) ; attach_pid ( p , pidtype_sid , task_session ( current ) ) ; list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; __this_cpu_inc ( process_counts ) ; } attach_pid ( p , pidtype_pid , pid ) ; nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; cgroup_post_fork ( p ) ; if ( clone_flags & clone_thread ) threadgroup_change_end ( current ) ; perf_event_fork ( p ) ; trace_task_newtask ( p , clone_flags ) ; return p ; bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ; bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ) ; bad_fork_cleanup_signal : if ( ! ( clone_flags & clone_thread ) ) free_signal_struct ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_policy : perf_event_free_task ( p ) ; # ifdef config_numa mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_cgroup : # endif if ( clone_flags & clone_thread ) threadgroup_change_end ( current ) ; cgroup_exit ( p , 0 ) ; delayacct_tsk_free ( p ) ; module_put ( task_thread_info ( p ) -> exec_domain -> module ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : free_task ( p ) ; fork_out : return err_ptr ( retval ) ; }","<S2SV_ModStart> ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
",torvalds@linux/e66eded8309ebf679d3d3c1f5820d1f2ca332c71,CVE-2013-1858,https://github.com/torvalds/linux/commit/e66eded8309ebf679d3d3c1f5820d1f2ca332c71,2013-04-05T21:55Z,<S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug>
3989,CWE-20,"static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ msg_dontwait , flags & msg_dontwait , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != sock_raw ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= msg_trunc ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; if ( ! err ) { if ( sat ) { sat -> sat_family = af_appletalk ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; } msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4663,CWE-255,"static int unix_getpw ( unused void * instance , request * request , value_pair * * vp_list ) { const char * name ; const char * encrypted_pass ; # ifdef have_getspnam struct spwd * spwd = null ; # endif # ifdef osfc2 struct pr_passwd * pr_pw ; # else struct passwd * pwd ; # endif # ifdef have_getusershell char * shell ; # endif value_pair * vp ; if ( ! request -> username ) { return rlm_module_noop ; } name = ( char * ) request -> username -> vp_strvalue ; encrypted_pass = null ; # ifdef osfc2 if ( ( pr_pw = getprpwnam ( name ) ) == null ) return rlm_module_notfound ; encrypted_pass = pr_pw -> ufld . fd_encrypt ; if ( pr_pw -> uflg . fg_lock != 1 ) { radlog ( l_auth , ""rlm_unix:<s2sv_blank>[%s]:<s2sv_blank>account<s2sv_blank>locked"" , name ) ; return rlm_module_userlock ; } # else if ( ( pwd = getpwnam ( name ) ) == null ) { return rlm_module_notfound ; } encrypted_pass = pwd -> pw_passwd ; # endif # ifdef have_getspnam if ( ( encrypted_pass == null ) || ( strlen ( encrypted_pass ) < 10 ) ) { if ( ( spwd = getspnam ( name ) ) == null ) { return rlm_module_notfound ; } encrypted_pass = spwd -> sp_pwdp ; } # endif # ifndef osfc2 # ifdef deny_shell if ( strcmp ( pwd -> pw_shell , deny_shell ) == 0 ) { radlog_request ( l_auth , 0 , request , ""rlm_unix:<s2sv_blank>[%s]:<s2sv_blank>invalid<s2sv_blank>shell"" , name ) ; return rlm_module_reject ; } # endif # ifdef have_getusershell while ( ( shell = getusershell ( ) ) != null ) { if ( strcmp ( shell , pwd -> pw_shell ) == 0 || strcmp ( shell , ""/radiusd/any/shell"" ) == 0 ) { break ; } } endusershell ( ) ; if ( shell == null ) { radlog_request ( l_auth , 0 , request , ""[%s]:<s2sv_blank>invalid<s2sv_blank>shell<s2sv_blank>[%s]"" , name , pwd -> pw_shell ) ; return rlm_module_reject ; } # endif # endif # if defined ( have_getspnam ) && ! defined ( m_unix ) if ( spwd && spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { radlog_request ( l_auth , 0 , request , ""[%s]:<s2sv_blank>password<s2sv_blank>has<s2sv_blank>expired"" , name ) ; return rlm_module_reject ; } # endif # if defined ( __freebsd__ ) || defined ( bsdi ) || defined ( _pwf_expire ) if ( ( pwd -> pw_expire > 0 ) && ( request -> timestamp > pwd -> pw_expire ) ) { radlog_request ( l_auth , 0 , request , ""[%s]:<s2sv_blank>password<s2sv_blank>has<s2sv_blank>expired"" , name ) ; return rlm_module_reject ; } # endif if ( encrypted_pass [ 0 ] == 0 ) return rlm_module_noop ; vp = pairmake ( ""crypt-password"" , encrypted_pass , t_op_set ) ; if ( ! vp ) return rlm_module_fail ; pairmove ( vp_list , & vp ) ; pairfree ( & vp ) ; return rlm_module_updated ; }","<S2SV_ModStart> && spwd -> sp_lstchg > 0 && spwd -> sp_max >= <S2SV_ModEnd> 0 && ( <S2SV_ModStart> 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } if ( spwd && <S2SV_ModStart> spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire <S2SV_ModStart> , request , ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" <S2SV_ModEnd> , name )
",alandekok@freeradius-server/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605,CVE-2011-4966,https://github.com/alandekok/freeradius-server/commit/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605,2013-03-12T23:55Z,"<S2SV_StartBug> if ( spwd && spwd -> sp_expire > 0 && <S2SV_EndBug> <S2SV_StartBug> ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { <S2SV_EndBug> <S2SV_StartBug> radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; <S2SV_EndBug>"
6235,CWE-000,"static int sessioncookiedirective ( mastate * state , cchar * key , cchar * value ) { char * options , * option , * ovalue , * tok ; if ( ! matokenize ( state , value , ""%*"" , & options ) ) { return mpr_err_bad_syntax ; } if ( smatch ( options , ""disable"" ) ) { httpsetauthsession ( state -> route -> auth , 0 ) ; return 0 ; } else if ( smatch ( options , ""enable"" ) ) { httpsetauthsession ( state -> route -> auth , 1 ) ; return 0 ; } for ( option = magetnextarg ( options , & tok ) ; option ; option = magetnextarg ( tok , & tok ) ) { option = stok ( option , ""<s2sv_blank>=\\t,"" , & ovalue ) ; ovalue = strim ( ovalue , ""\\""\'"" , mpr_trim_both ) ; if ( ! ovalue || * ovalue == '\\0' ) continue ; if ( smatch ( option , ""visible"" ) ) { httpsetroutesessionvisibility ( state -> route , scaselessmatch ( ovalue , ""visible"" ) ) ; } else if ( smatch ( option , ""name"" ) ) { httpsetroutecookie ( state -> route , ovalue ) ; } else { mprlog ( ""error<s2sv_blank>appweb<s2sv_blank>config"" , 0 , ""unknown<s2sv_blank>sessioncookie<s2sv_blank>option<s2sv_blank>%s"" , option ) ; return mpr_err_bad_syntax ; } } return 0 ; }","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug>"
5525,CWE-000,"static rfbbool rfbsetclientcolourmapbgr233 ( rfbclientptr cl ) { char buf [ sz_rfbsetcolourmapentriesmsg + 256 * 3 * 2 ] ; rfbsetcolourmapentriesmsg * scme = ( rfbsetcolourmapentriesmsg * ) buf ; uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbsetcolourmapentriesmsg ] ) ; int i , len ; int r , g , b ; if ( cl -> format . bitsperpixel != 8 ) { rfberr ( ""%s:<s2sv_blank>client<s2sv_blank>not<s2sv_blank>8<s2sv_blank>bits<s2sv_blank>per<s2sv_blank>pixel\\n"" , ""rfbsetclientcolourmapbgr233"" ) ; rfbcloseclient ( cl ) ; return false ; } scme -> type = rfbsetcolourmapentries ; scme -> firstcolour = swap16ifle ( 0 ) ; scme -> ncolours = swap16ifle ( 256 ) ; len = sz_rfbsetcolourmapentriesmsg ; i = 0 ; for ( b = 0 ; b < 4 ; b ++ ) { for ( g = 0 ; g < 8 ; g ++ ) { for ( r = 0 ; r < 8 ; r ++ ) { rgb [ i ++ ] = swap16ifle ( r * 65535 / 7 ) ; rgb [ i ++ ] = swap16ifle ( g * 65535 / 7 ) ; rgb [ i ++ ] = swap16ifle ( b * 65535 / 3 ) ; } } } len += 256 * 3 * 2 ; if ( rfbwriteexact ( cl , buf , len ) < 0 ) { rfblogperror ( ""rfbsetclientcolourmapbgr233:<s2sv_blank>write"" ) ; rfbcloseclient ( cl ) ; return false ; } return true ; }","<S2SV_ModStart> cl ) { union { char bytes <S2SV_ModEnd> [ sz_rfbSetColourMapEntriesMsg + <S2SV_ModStart> ] ; rfbSetColourMapEntriesMsg msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <S2SV_ModEnd> ; uint16_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> cl , buf . bytes
",LibVNC@libvncserver/53073c8d7e232151ea2ecd8a1243124121e10e2d,CVE-2020-14400,https://github.com/LibVNC/libvncserver/commit/53073c8d7e232151ea2ecd8a1243124121e10e2d,2020-06-17T16:15Z,"<S2SV_StartBug> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <S2SV_EndBug>"
7773,CWE-125,"stmt_ty asyncwith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int end_lineno , int end_col_offset , pyarena * arena ) { stmt_ty p ; p = ( stmt_ty ) pyarena_malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return null ; p -> kind = asyncwith_kind ; p -> v . asyncwith . items = items ; p -> v . asyncwith . body = body ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> * body , string type_comment , <S2SV_ModStart> ; p -> v . AsyncWith . type_comment = type_comment ; p ->
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug>"
7001,CWE-476,"static int changedline ( const proto * p , int oldpc , int newpc ) { while ( oldpc ++ < newpc ) { if ( p -> lineinfo [ oldpc ] != 0 ) return ( luag_getfuncline ( p , oldpc - 1 ) != luag_getfuncline ( p , newpc ) ) ; } return 0 ; }","<S2SV_ModStart> newpc ) { if ( p -> lineinfo == NULL ) return 0 ;
",lua@lua/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a,CVE-2020-24369,https://github.com/lua/lua/commit/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a,2020-08-17T17:15Z,"<S2SV_StartBug> static int changedline ( const Proto * p , int oldpc , int newpc ) { <S2SV_EndBug>"
2687,CWE-362,"static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = null ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = err_ptr ( - enomem ) ; goto out ; } init_hlist_node ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; init_list_head ( & conn -> c_send_queue ) ; init_list_head ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = err_ptr ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } } if ( trans == null ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = err_ptr ( - enodev ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = err_ptr ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , rds_conn_down ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; init_delayed_work ( & conn -> c_send_w , rds_send_worker ) ; init_delayed_work ( & conn -> c_recv_w , rds_recv_worker ) ; init_delayed_work ( & conn -> c_conn_w , rds_connect_worker ) ; init_work ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( ""allocated<s2sv_blank>conn<s2sv_blank>%p<s2sv_blank>for<s2sv_blank>%pi4<s2sv_blank>-><s2sv_blank>%pi4<s2sv_blank>over<s2sv_blank>%s<s2sv_blank>%s\\n"" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : ""[unknown]"" , is_outgoing ? ""(outgoing)"" : """" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }","<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
",torvalds@linux/8c7188b23474cca017b3ef354c4a58456f68303a,CVE-2015-7990,https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a,2015-12-28T11:59Z,<S2SV_StartBug> } <S2SV_EndBug>
8292,CWE-20,"static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ uio_fastiov ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( msg_cmsg_compat & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - efault ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > uio_fastiov ) { err = - emsgsize ; if ( msg_sys -> msg_iovlen > uio_maxiov ) goto out ; err = - enomem ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , gfp_kernel ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = compat_namelen ( msg ) ; if ( msg_cmsg_compat & flags ) { err = verify_compat_iovec ( msg_sys , iov , & addr , verify_write ) ; } else err = verify_iovec ( msg_sys , iov , & addr , verify_write ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; msg_sys -> msg_flags = flags & ( msg_cmsg_cloexec | msg_cmsg_compat ) ; if ( sock -> file -> f_flags & o_nonblock ) flags |= msg_dontwait ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != null ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ msg_cmsg_compat ) , compat_flags ( msg ) ) ; if ( err ) goto out_freeiov ; if ( msg_cmsg_compat & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }","<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug>
2394,CWE-399,"void free_pipe_info ( struct pipe_inode_info * pipe ) { int i ; for ( i = 0 ; i < pipe -> buffers ; i ++ ) { struct pipe_buffer * buf = pipe -> bufs + i ; if ( buf -> ops ) buf -> ops -> release ( pipe , buf ) ; } if ( pipe -> tmp_page ) __free_page ( pipe -> tmp_page ) ; kfree ( pipe -> bufs ) ; kfree ( pipe ) ; }","<S2SV_ModStart> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
",torvalds@linux/759c01142a5d0f364a462346168a56de28a80f52,CVE-2016-2847,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,2016-04-27T17:59Z,<S2SV_StartBug> int i ; <S2SV_EndBug>
4982,CWE-476,"static void tw5864_handle_frame ( struct tw5864_h264_frame * frame ) { # define skip_vlcbuf_bytes 3 struct tw5864_input * input = frame -> input ; struct tw5864_dev * dev = input -> root ; struct tw5864_buf * vb ; struct vb2_v4l2_buffer * v4l2_buf ; int frame_len = frame -> vlc_len - skip_vlcbuf_bytes ; u8 * dst = input -> buf_cur_ptr ; u8 tail_mask , vlc_mask = 0 ; int i ; u8 vlc_first_byte = ( ( u8 * ) ( frame -> vlc . addr + skip_vlcbuf_bytes ) ) [ 0 ] ; unsigned long flags ; int zero_run ; u8 * src ; u8 * src_end ; # ifdef debug if ( frame -> checksum != tw5864_vlc_checksum ( ( u32 * ) frame -> vlc . addr , frame_len ) ) dev_err ( & dev -> pci -> dev , ""checksum<s2sv_blank>of<s2sv_blank>encoded<s2sv_blank>frame<s2sv_blank>doesn\'t<s2sv_blank>match!\\n"" ) ; # endif spin_lock_irqsave ( & input -> slock , flags ) ; vb = input -> vb ; input -> vb = null ; spin_unlock_irqrestore ( & input -> slock , flags ) ; v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , ""vb<s2sv_blank>is<s2sv_blank>empty,<s2sv_blank>dropping<s2sv_blank>frame\\n"" ) ; return ; } if ( input -> buf_cur_space_left < frame_len * 5 / 4 ) { dev_err_once ( & dev -> pci -> dev , ""left<s2sv_blank>space<s2sv_blank>in<s2sv_blank>vb2<s2sv_blank>buffer,<s2sv_blank>%d<s2sv_blank>bytes,<s2sv_blank>is<s2sv_blank>less<s2sv_blank>than<s2sv_blank>considered<s2sv_blank>safely<s2sv_blank>enough<s2sv_blank>to<s2sv_blank>put<s2sv_blank>frame<s2sv_blank>of<s2sv_blank>length<s2sv_blank>%d.<s2sv_blank>dropping<s2sv_blank>this<s2sv_blank>frame.\\n"" , input -> buf_cur_space_left , frame_len ) ; return ; } for ( i = 0 ; i < 8 - input -> tail_nb_bits ; i ++ ) vlc_mask |= 1 << i ; tail_mask = ( ~ vlc_mask ) & 0xff ; dst [ 0 ] = ( input -> tail & tail_mask ) | ( vlc_first_byte & vlc_mask ) ; frame_len -- ; dst ++ ; src = frame -> vlc . addr + skip_vlcbuf_bytes + 1 ; src_end = src + frame_len ; zero_run = 0 ; for ( ; src < src_end ; src ++ ) { if ( zero_run < 2 ) { if ( * src == 0 ) ++ zero_run ; else zero_run = 0 ; } else { if ( ( * src & ~ 0x03 ) == 0 ) * dst ++ = 0x03 ; zero_run = * src == 0 ; } * dst ++ = * src ; } vb2_set_plane_payload ( & vb -> vb . vb2_buf , 0 , dst - ( u8 * ) vb2_plane_vaddr ( & vb -> vb . vb2_buf , 0 ) ) ; vb -> vb . vb2_buf . timestamp = frame -> timestamp ; v4l2_buf -> field = v4l2_field_interlaced ; v4l2_buf -> sequence = frame -> seqno ; if ( frame -> gop_seqno && tw5864_is_motion_triggered ( frame ) ) { struct v4l2_event ev = { . type = v4l2_event_motion_det , . u . motion_det = { . flags = v4l2_event_md_fl_have_frame_seq , . frame_sequence = v4l2_buf -> sequence , } , } ; v4l2_event_queue ( & input -> vdev , & ev ) ; } vb2_buffer_done ( & vb -> vb . vb2_buf , vb2_buf_state_done ) ; }","<S2SV_ModStart> flags ) ; if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } <S2SV_ModStart> vb2_buf ) ; <S2SV_ModEnd> if ( input
",torvalds@linux/2e7682ebfc750177a4944eeb56e97a3f05734528,CVE-2019-20806,https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528,2020-05-27T12:15Z,<S2SV_StartBug> v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vb ) { <S2SV_EndBug>
8039,CWE-347,"void pointzz_padd ( pointzz_p * rop , const pointzz_p * op1 , const pointzz_p * op2 , const curvezz_p * curve ) { mpz_t xdiff , ydiff , lambda ; mpz_inits ( xdiff , ydiff , lambda , null ) ; mpz_sub ( ydiff , op2 -> y , op1 -> y ) ; mpz_sub ( xdiff , op2 -> x , op1 -> x ) ; mpz_invert ( xdiff , xdiff , curve -> p ) ; mpz_mul ( lambda , ydiff , xdiff ) ; mpz_mod ( lambda , lambda , curve -> p ) ; mpz_mul ( rop -> x , lambda , lambda ) ; mpz_sub ( rop -> x , rop -> x , op1 -> x ) ; mpz_sub ( rop -> x , rop -> x , op2 -> x ) ; mpz_mod ( rop -> x , rop -> x , curve -> p ) ; mpz_sub ( rop -> y , op1 -> x , rop -> x ) ; mpz_mul ( rop -> y , lambda , rop -> y ) ; mpz_sub ( rop -> y , rop -> y , op1 -> y ) ; mpz_mod ( rop -> y , rop -> y , curve -> p ) ; mpz_clears ( xdiff , ydiff , lambda , null ) ; }","<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } else if ( pointZZ_pIsIdentityElement ( op1 ) ) { mpz_set ( rop -> x , op2 -> x ) ; mpz_set ( rop -> y , op2 -> y ) ; return ; } else if ( pointZZ_pIsIdentityElement ( op2 ) ) { mpz_set ( rop -> x , op1 -> x ) ; mpz_set ( rop -> y , op1 -> y ) ; return ; } if ( pointZZ_pEqual ( op1 , op2 ) ) { pointZZ_pDouble ( rop , op1 , curve ) ; return ; } mpz_t negy ; mpz_init ( negy ) ; mpz_sub ( negy , curve -> p , op2 -> y ) ; if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) { mpz_clear ( negy ) ; return pointZZ_pSetToIdentityElement ( rop ) ; } mpz_t <S2SV_ModEnd> xdiff , ydiff <S2SV_ModStart> ; mpz_clears ( negy ,
",AntonKueltz@fastecdsa/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,CVE-2020-12607,https://github.com/AntonKueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,2020-06-02T21:15Z,"<S2SV_StartBug> mpz_t xdiff , ydiff , lambda ; <S2SV_EndBug> <S2SV_StartBug> mpz_clears ( xdiff , ydiff , lambda , NULL ) ; <S2SV_EndBug>"
232,CWE-17,"static int udf_translate_to_linux ( uint8_t * newname , uint8_t * udfname , int udflen , uint8_t * fidname , int fidnamelen ) { int index , newindex = 0 , needscrc = 0 ; int extindex = 0 , newextindex = 0 , hasext = 0 ; unsigned short valuecrc ; uint8_t curr ; if ( udfname [ 0 ] == '.' && ( udflen == 1 || ( udflen == 2 && udfname [ 1 ] == '.' ) ) ) { needscrc = 1 ; newindex = udflen ; memcpy ( newname , udfname , udflen ) ; } else { for ( index = 0 ; index < udflen ; index ++ ) { curr = udfname [ index ] ; if ( curr == '/' || curr == 0 ) { needscrc = 1 ; curr = illegal_char_mark ; while ( index + 1 < udflen && ( udfname [ index + 1 ] == '/' || udfname [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == ext_mark && ( udflen - index - 1 ) <= ext_size ) { if ( udflen == index + 1 ) hasext = 0 ; else { hasext = 1 ; extindex = index ; newextindex = newindex ; } } if ( newindex < 256 ) newname [ newindex ++ ] = curr ; else needscrc = 1 ; } } if ( needscrc ) { uint8_t ext [ ext_size ] ; int localextindex = 0 ; if ( hasext ) { int maxfilenamelen ; for ( index = 0 ; index < ext_size && extindex + index + 1 < udflen ; index ++ ) { curr = udfname [ extindex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needscrc = 1 ; curr = illegal_char_mark ; while ( extindex + index + 2 < udflen && ( index + 1 < ext_size && ( udfname [ extindex + index + 2 ] == '/' || udfname [ extindex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localextindex ++ ] = curr ; } maxfilenamelen = 250 - localextindex ; if ( newindex > maxfilenamelen ) newindex = maxfilenamelen ; else newindex = newextindex ; } else if ( newindex > 250 ) newindex = 250 ; newname [ newindex ++ ] = crc_mark ; valuecrc = crc_itu_t ( 0 , fidname , fidnamelen ) ; newname [ newindex ++ ] = hex_asc_upper_hi ( valuecrc >> 8 ) ; newname [ newindex ++ ] = hex_asc_upper_lo ( valuecrc >> 8 ) ; newname [ newindex ++ ] = hex_asc_upper_hi ( valuecrc ) ; newname [ newindex ++ ] = hex_asc_upper_lo ( valuecrc ) ; if ( hasext ) { newname [ newindex ++ ] = ext_mark ; for ( index = 0 ; index < localextindex ; index ++ ) newname [ newindex ++ ] = ext [ index ] ; } } return newindex ; }","<S2SV_ModStart> * newName , int newLen , <S2SV_ModStart> * udfName , int udfLen , <S2SV_ModEnd> uint8_t * fidName <S2SV_ModStart> ( newIndex < newLen <S2SV_ModEnd> ) newName [ <S2SV_ModStart> } maxFilenameLen = newLen - CRC_LEN <S2SV_ModEnd> - localExtIndex ; <S2SV_ModStart> ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> ; newName [
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug>"
2643,CWE-000,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == null ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & msg_dontwait ) , & err ) ; if ( skb == null ) return - enomem ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = checksum_partial ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = skb_gso_udp ; ipv6_select_ident ( & fhdr ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }","<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt
",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z,"<S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug>"
7757,CWE-000,"static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) { __be32 * p ; reserve_space ( 8 ) ; switch ( open_flags & ( fmode_read | fmode_write ) ) { case fmode_read : write32 ( nfs4_share_access_read ) ; break ; case fmode_write : write32 ( nfs4_share_access_write ) ; break ; case fmode_read | fmode_write : write32 ( nfs4_share_access_both ) ; break ; default : bug ( ) ; } write32 ( 0 ) ; }","<S2SV_ModStart> * xdr , fmode_t fmode <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ <S2SV_ModStart> ; default : WRITE32 ( 0 <S2SV_ModEnd> ) ; }
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug>"
7733,CWE-000,"int nfs4_do_close ( struct path * path , struct nfs4_state * state , int wait ) { struct nfs_server * server = nfs_server ( state -> inode ) ; struct nfs4_closedata * calldata ; struct nfs4_state_owner * sp = state -> owner ; struct rpc_task * task ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ nfsproc4_clnt_close ] , . rpc_cred = state -> owner -> so_cred , } ; struct rpc_task_setup task_setup_data = { . rpc_client = server -> client , . rpc_message = & msg , . callback_ops = & nfs4_close_ops , . workqueue = nfsiod_workqueue , . flags = rpc_task_async , } ; int status = - enomem ; calldata = kmalloc ( sizeof ( * calldata ) , gfp_kernel ) ; if ( calldata == null ) goto out ; calldata -> inode = state -> inode ; calldata -> state = state ; calldata -> arg . fh = nfs_fh ( state -> inode ) ; calldata -> arg . stateid = & state -> open_stateid ; calldata -> arg . seqid = nfs_alloc_seqid ( & state -> owner -> so_seqid ) ; if ( calldata -> arg . seqid == null ) goto out_free_calldata ; calldata -> arg . open_flags = 0 ; calldata -> arg . bitmask = server -> attr_bitmask ; calldata -> res . fattr = & calldata -> fattr ; calldata -> res . seqid = calldata -> arg . seqid ; calldata -> res . server = server ; calldata -> path . mnt = mntget ( path -> mnt ) ; calldata -> path . dentry = dget ( path -> dentry ) ; msg . rpc_argp = & calldata -> arg , msg . rpc_resp = & calldata -> res , task_setup_data . callback_data = calldata ; task = rpc_run_task ( & task_setup_data ) ; if ( is_err ( task ) ) return ptr_err ( task ) ; status = 0 ; if ( wait ) status = rpc_wait_for_completion_task ( task ) ; rpc_put_task ( task ) ; return status ; out_free_calldata : kfree ( calldata ) ; out : nfs4_put_open_state ( state ) ; nfs4_put_state_owner ( sp ) ; return status ; }","<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = 0 ;
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,<S2SV_StartBug> calldata -> arg . open_flags = 0 ; <S2SV_EndBug>
6920,CWE-400,"void handle_ld_nf ( u32 insn , struct pt_regs * regs ) { int rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & tstate_priv ) != 0 ; unsigned long * reg ; perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , regs , 0 ) ; maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ; if ( from_kernel || rd < 16 ) { reg [ 0 ] = 0 ; if ( ( insn & 0x780000 ) == 0x180000 ) reg [ 1 ] = 0 ; } else if ( test_thread_flag ( tif_32bit ) ) { put_user ( 0 , ( int __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( ( int __user * ) reg ) + 1 ) ; } else { put_user ( 0 , ( unsigned long __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( unsigned long __user * ) reg + 1 ) ; } advance ( regs ) ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
2303,CWE-399,"int dev_forward_skb ( struct net_device * dev , struct sk_buff * skb ) { skb_orphan ( skb ) ; if ( ! ( dev -> flags & iff_up ) ) return net_rx_drop ; if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) return net_rx_drop ; skb_set_dev ( skb , dev ) ; skb -> tstamp . tv64 = 0 ; skb -> pkt_type = packet_host ; skb -> protocol = eth_type_trans ( skb , dev ) ; return netif_rx ( skb ) ; }","<S2SV_ModStart> & IFF_UP ) || <S2SV_ModEnd> ( skb -> <S2SV_ModStart> hard_header_len ) ) ) { kfree_skb ( skb ) ; <S2SV_ModStart> return NET_RX_DROP ; }
",torvalds@linux/6ec82562ffc6f297d0de36d65776cff8e5704867,CVE-2013-2017,https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867,2013-05-03T11:57Z,<S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug>
7368,CWE-352,"char * util_monitid ( char * idfile ) { file * file = null ; assert ( idfile ) ; if ( ! file_exist ( idfile ) ) { md5_context_t ctx ; char buf [ strlen ] ; md_t digest ; file = fopen ( idfile , ""w"" ) ; if ( ! file ) { logerror ( ""error<s2sv_blank>opening<s2sv_blank>the<s2sv_blank>idfile<s2sv_blank>\'%s\'<s2sv_blank>--<s2sv_blank>%s\\n"" , idfile , strerror ) ; return null ; } snprintf ( buf , strlen , ""%lu%d%lu"" , ( unsigned long ) time_now ( ) , getpid ( ) , random ( ) ) ; md5_init ( & ctx ) ; md5_append ( & ctx , ( const md5_byte_t * ) buf , strlen - 1 ) ; md5_finish ( & ctx , ( md5_byte_t * ) digest ) ; util_digest2bytes ( ( unsigned char * ) digest , 16 , run . id ) ; fprintf ( file , ""%s"" , run . id ) ; loginfo ( ""<s2sv_blank>new<s2sv_blank>monit<s2sv_blank>id:<s2sv_blank>%s\\n<s2sv_blank>stored<s2sv_blank>in<s2sv_blank>\'%s\'\\n"" , run . id , idfile ) ; } else { if ( ! file_isfile ( idfile ) ) { logerror ( ""idfile<s2sv_blank>\'%s\'<s2sv_blank>is<s2sv_blank>not<s2sv_blank>a<s2sv_blank>regular<s2sv_blank>file\\n"" , idfile ) ; return null ; } if ( ( file = fopen ( idfile , ""r"" ) ) == ( file * ) null ) { logerror ( ""error<s2sv_blank>opening<s2sv_blank>the<s2sv_blank>idfile<s2sv_blank>\'%s\'<s2sv_blank>--<s2sv_blank>%s\\n"" , idfile , strerror ) ; return null ; } if ( fscanf ( file , ""%64s"" , run . id ) != 1 ) { logerror ( ""error<s2sv_blank>reading<s2sv_blank>id<s2sv_blank>from<s2sv_blank>file<s2sv_blank>\'%s\'\\n"" , idfile ) ; if ( fclose ( file ) ) logerror ( ""error<s2sv_blank>closing<s2sv_blank>file<s2sv_blank>\'%s\'<s2sv_blank>--<s2sv_blank>%s\\n"" , idfile , strerror ) ; return null ; } } if ( fclose ( file ) ) logerror ( ""error<s2sv_blank>closing<s2sv_blank>file<s2sv_blank>\'%s\'<s2sv_blank>--<s2sv_blank>%s\\n"" , idfile , strerror ) ; return run . id ; }","<S2SV_ModStart> idfile ) { ASSERT ( idfile ) ; <S2SV_ModStart> file = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> file = fopen <S2SV_ModStart> NULL ; } <S2SV_ModEnd> fprintf ( file <S2SV_ModStart> , ""%s"" , Util_getToken ( Run . id ) <S2SV_ModEnd> ) ; LogInfo
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,"<S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug>"
6376,CWE-401,"static int nfp_flower_spawn_phy_reprs ( struct nfp_app * app , struct nfp_flower_priv * priv ) { struct nfp_eth_table * eth_tbl = app -> pf -> eth_tbl ; atomic_t * replies = & priv -> reify_replies ; struct nfp_flower_repr_priv * repr_priv ; struct nfp_repr * nfp_repr ; struct sk_buff * ctrl_skb ; struct nfp_reprs * reprs ; int err , reify_cnt ; unsigned int i ; ctrl_skb = nfp_flower_cmsg_mac_repr_start ( app , eth_tbl -> count ) ; if ( ! ctrl_skb ) return - enomem ; reprs = nfp_reprs_alloc ( eth_tbl -> max_index + 1 ) ; if ( ! reprs ) { err = - enomem ; goto err_free_ctrl_skb ; } for ( i = 0 ; i < eth_tbl -> count ; i ++ ) { unsigned int phys_port = eth_tbl -> ports [ i ] . index ; struct net_device * repr ; struct nfp_port * port ; u32 cmsg_port_id ; repr = nfp_repr_alloc ( app ) ; if ( ! repr ) { err = - enomem ; goto err_reprs_clean ; } repr_priv = kzalloc ( sizeof ( * repr_priv ) , gfp_kernel ) ; if ( ! repr_priv ) { err = - enomem ; goto err_reprs_clean ; } nfp_repr = netdev_priv ( repr ) ; nfp_repr -> app_priv = repr_priv ; repr_priv -> nfp_repr = nfp_repr ; port = nfp_port_alloc ( app , nfp_port_phys_port , repr ) ; if ( is_err ( port ) ) { err = ptr_err ( port ) ; nfp_repr_free ( repr ) ; goto err_reprs_clean ; } err = nfp_port_init_phy_port ( app -> pf , app , port , i ) ; if ( err ) { nfp_port_free ( port ) ; nfp_repr_free ( repr ) ; goto err_reprs_clean ; } set_netdev_dev ( repr , & priv -> nn -> pdev -> dev ) ; nfp_net_get_mac_addr ( app -> pf , repr , port ) ; cmsg_port_id = nfp_flower_cmsg_phys_port ( phys_port ) ; err = nfp_repr_init ( app , repr , cmsg_port_id , port , priv -> nn -> dp . netdev ) ; if ( err ) { nfp_port_free ( port ) ; nfp_repr_free ( repr ) ; goto err_reprs_clean ; } nfp_flower_cmsg_mac_repr_add ( ctrl_skb , i , eth_tbl -> ports [ i ] . nbi , eth_tbl -> ports [ i ] . base , phys_port ) ; rcu_init_pointer ( reprs -> reprs [ phys_port ] , repr ) ; nfp_info ( app -> cpp , ""phys<s2sv_blank>port<s2sv_blank>%d<s2sv_blank>representor(%s)<s2sv_blank>created\\n"" , phys_port , repr -> name ) ; } nfp_app_reprs_set ( app , nfp_repr_type_phys_port , reprs ) ; atomic_set ( replies , 0 ) ; reify_cnt = nfp_flower_reprs_reify ( app , nfp_repr_type_phys_port , true ) ; if ( reify_cnt < 0 ) { err = reify_cnt ; nfp_warn ( app -> cpp , ""failed<s2sv_blank>to<s2sv_blank>notify<s2sv_blank>firmware<s2sv_blank>about<s2sv_blank>repr<s2sv_blank>creation\\n"" ) ; goto err_reprs_remove ; } err = nfp_flower_wait_repr_reify ( app , replies , reify_cnt ) ; if ( err ) goto err_reprs_remove ; nfp_ctrl_tx ( app -> ctrl , ctrl_skb ) ; return 0 ; err_reprs_remove : reprs = nfp_app_reprs_set ( app , nfp_repr_type_phys_port , null ) ; err_reprs_clean : nfp_reprs_clean_and_free ( app , reprs ) ; err_free_ctrl_skb : kfree_skb ( ctrl_skb ) ; return err ; }","<S2SV_ModStart> - ENOMEM ; nfp_repr_free ( repr ) ; <S2SV_ModStart> port ) ; kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ;
",torvalds@linux/8572cea1461a006bce1d06c0c4b0575869125fa4,CVE-2019-19080,https://github.com/torvalds/linux/commit/8572cea1461a006bce1d06c0c4b0575869125fa4,2019-11-18T06:15Z,<S2SV_StartBug> goto err_reprs_clean ; <S2SV_EndBug> <S2SV_StartBug> nfp_repr_free ( repr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> <S2SV_StartBug> nfp_port_free ( port ) ; <S2SV_EndBug>
3267,CWE-19,"static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = ext2_sb ( sb ) ; dquot_disable ( sb , - 1 , dquot_usage_enabled | dquot_limits_enabled ) ; ext2_xattr_put_super ( sb ) ; if ( ! ( sb -> s_flags & ms_rdonly ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = null ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }","<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,<S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug>
3599,CWE-264,"int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( secure_noroot ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip : if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ lsm_unsafe_ptrace_cap ) { if ( ! capable ( cap_setuid ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( cap_full_set , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( secure_noroot ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 ) return ret ; } } new -> securebits &= ~ issecure_mask ( secure_keep_caps ) ; return 0 ; }","<S2SV_ModStart> : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
",torvalds@linux/d52fc5dde171f030170a6cb78034d166b13c9445,CVE-2012-2123,https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445,2012-05-17T11:00Z,<S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug>
2744,CWE-399,"static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; mapping = ( struct address_space * ) page_private ( page ) ; mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , hpage_resv_owner ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }","<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,<S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug>
4651,CWE-190,"static mongo_message * mongo_message_create ( int len , int id , int responseto , int op ) { mongo_message * mm = ( mongo_message * ) bson_malloc ( len ) ; if ( ! id ) id = rand ( ) ; mm -> head . len = len ; mm -> head . id = id ; mm -> head . responseto = responseto ; mm -> head . op = op ; return mm ; }","<S2SV_ModStart> * mongo_message_create ( size_t <S2SV_ModEnd> len , int <S2SV_ModStart> . len = ( int )
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) { <S2SV_EndBug> <S2SV_StartBug> mm -> head . len = len ; <S2SV_EndBug>"
6423,CWE-120,"void m_loaddefaults ( void ) { int i ; int len ; file * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = m_checkparm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefault<s2sv_blank>file:<s2sv_blank>%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; if ( fscanf ( f , ""%79s<s2sv_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) { if ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }","<S2SV_ModStart> ( f , ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> , def ,
",AXDOOMER@doom-vanille/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,CVE-2020-15007,https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,2020-06-24T11:15Z,"<S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug>"
540,CWE-416,"static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; int ret ; assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; ret = hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ; if ( ret == netdev_tx_ok ) { netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }","<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,CVE-2017-18218,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,2018-03-05T20:29Z,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug>"
7623,CWE-190,"jas_matrix_t * jas_seq2d_input ( file * in ) { jas_matrix_t * matrix ; int i ; int j ; long x ; int numrows ; int numcols ; int xoff ; int yoff ; if ( fscanf ( in , ""%d<s2sv_blank>%d"" , & xoff , & yoff ) != 2 ) return 0 ; if ( fscanf ( in , ""%d<s2sv_blank>%d"" , & numcols , & numrows ) != 2 ) return 0 ; if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) ) return 0 ; if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) { abort ( ) ; } for ( i = 0 ; i < jas_matrix_numrows ( matrix ) ; i ++ ) { for ( j = 0 ; j < jas_matrix_numcols ( matrix ) ; j ++ ) { if ( fscanf ( in , ""%ld"" , & x ) != 1 ) { jas_matrix_destroy ( matrix ) ; return 0 ; } jas_matrix_set ( matrix , i , j , jas_cast ( jas_seqent_t , x ) ) ; } } return matrix ; }","<S2SV_ModStart> * matrix ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; long <S2SV_ModStart> long x ; jas_matind_t numrows ; jas_matind_t numcols ; jas_matind_t xoff ; jas_matind_t yoff ; long tmp_xoff ; long tmp_yoff ; long tmp_numrows ; long tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } xoff = tmp_xoff ; yoff = tmp_yoff <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , ""%ld<S2SV_blank>%ld"" , & tmp_numcols , & tmp_numrows <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } numrows = tmp_numrows ; numcols = tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ) { return 0 ; } <S2SV_ModEnd> if ( jas_matrix_numrows
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int numrows ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>"
8353,CWE-362,void cipso_v4_req_delattr ( struct request_sock * req ) { struct ip_options * opt ; struct inet_request_sock * req_inet ; req_inet = inet_rsk ( req ) ; opt = req_inet -> opt ; if ( opt == null || opt -> cipso == 0 ) return ; cipso_v4_delopt ( & req_inet -> opt ) ; },"<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> || opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug>
8376,CWE-362,"static struct ip_options * tcp_v4_save_options ( struct sock * sk , struct sk_buff * skb ) { struct ip_options * opt = & ( ipcb ( skb ) -> opt ) ; struct ip_options * dopt = null ; if ( opt && opt -> optlen ) { int opt_size = optlength ( opt ) ; dopt = kmalloc ( opt_size , gfp_atomic ) ; if ( dopt ) { if ( ip_options_echo ( dopt , skb ) ) { kfree ( dopt ) ; dopt = null ; } } } return dopt ; }","<S2SV_ModStart> <S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * tcp_v4_save_options ( <S2SV_ModStart> skb ) { const <S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * dopt = <S2SV_ModStart> int opt_size = sizeof ( * dopt ) + opt -> optlen <S2SV_ModEnd> ; dopt = <S2SV_ModStart> ( ip_options_echo ( & dopt -> opt <S2SV_ModEnd> , skb )
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> static struct ip_options * tcp_v4_save_options ( struct sock * sk , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> struct ip_options * dopt = NULL ; <S2SV_EndBug> <S2SV_StartBug> int opt_size = optlength ( opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ip_options_echo ( dopt , skb ) ) { <S2SV_EndBug>"
7175,CWE-552,"static ssize_t _epoll_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = null ; size_t buf_size = 0 ; if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > oe_iov_max ) oe_raise_errno ( oe_einval ) ; if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) oe_raise_errno ( oe_enomem ) ; if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != oe_ok ) { oe_raise_errno ( oe_einval ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>"
4543,CWE-125,"int obj2ast_comprehension ( pyobject * obj , comprehension_ty * out , pyarena * arena ) { pyobject * tmp = null ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; if ( _pyobject_hasattrid ( obj , & pyid_target ) ) { int res ; tmp = _pyobject_getattrid ( obj , & pyid_target ) ; if ( tmp == null ) goto failed ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; py_clear ( tmp ) ; } else { pyerr_setstring ( pyexc_typeerror , ""required<s2sv_blank>field<s2sv_blank>\\""target\\""<s2sv_blank>missing<s2sv_blank>from<s2sv_blank>comprehension"" ) ; return 1 ; } if ( _pyobject_hasattrid ( obj , & pyid_iter ) ) { int res ; tmp = _pyobject_getattrid ( obj , & pyid_iter ) ; if ( tmp == null ) goto failed ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; py_clear ( tmp ) ; } else { pyerr_setstring ( pyexc_typeerror , ""required<s2sv_blank>field<s2sv_blank>\\""iter\\""<s2sv_blank>missing<s2sv_blank>from<s2sv_blank>comprehension"" ) ; return 1 ; } if ( _pyobject_hasattrid ( obj , & pyid_ifs ) ) { int res ; py_ssize_t len ; py_ssize_t i ; tmp = _pyobject_getattrid ( obj , & pyid_ifs ) ; if ( tmp == null ) goto failed ; if ( ! pylist_check ( tmp ) ) { pyerr_format ( pyexc_typeerror , ""comprehension<s2sv_blank>field<s2sv_blank>\\""ifs\\""<s2sv_blank>must<s2sv_blank>be<s2sv_blank>a<s2sv_blank>list,<s2sv_blank>not<s2sv_blank>a<s2sv_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = pylist_get_size ( tmp ) ; ifs = _ta3_asdl_seq_new ( len , arena ) ; if ( ifs == null ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty value ; res = obj2ast_expr ( pylist_get_item ( tmp , i ) , & value , arena ) ; if ( res != 0 ) goto failed ; if ( len != pylist_get_size ( tmp ) ) { pyerr_setstring ( pyexc_runtimeerror , ""comprehension<s2sv_blank>field<s2sv_blank>\\""ifs\\""<s2sv_blank>changed<s2sv_blank>size<s2sv_blank>during<s2sv_blank>iteration"" ) ; goto failed ; } asdl_seq_set ( ifs , i , value ) ; } py_clear ( tmp ) ; } else { pyerr_setstring ( pyexc_typeerror , ""required<s2sv_blank>field<s2sv_blank>\\""ifs\\""<s2sv_blank>missing<s2sv_blank>from<s2sv_blank>comprehension"" ) ; return 1 ; } if ( _pyobject_hasattrid ( obj , & pyid_is_async ) ) { int res ; tmp = _pyobject_getattrid ( obj , & pyid_is_async ) ; if ( tmp == null ) goto failed ; res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; py_clear ( tmp ) ; } else { pyerr_setstring ( pyexc_typeerror , ""required<s2sv_blank>field<s2sv_blank>\\""is_async\\""<s2sv_blank>missing<s2sv_blank>from<s2sv_blank>comprehension"" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : py_xdecref ( tmp ) ; return 1 ; }","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug>"
5333,CWE-22,"char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ path_max ] ; char * name , * ptr ; char dir [ path_max ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; dbg ( ""compose<s2sv_blank>path<s2sv_blank>from<s2sv_blank>cwd:<s2sv_blank>%s,<s2sv_blank>arg:<s2sv_blank>%s"" , ctrl -> cwd , path ? : """" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , ""/"" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , ""//"" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; dbg ( ""server<s2sv_blank>path<s2sv_blank>from<s2sv_blank>cwd:<s2sv_blank>%s"" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; dbg ( ""resulting<s2sv_blank>non-chroot<s2sv_blank>path:<s2sv_blank>%s"" , dir ) ; } if ( ! stat ( dir , & st ) && s_isdir ( st . st_mode ) ) { if ( ! realpath ( dir , rpath ) ) return null ; } else { name = basename ( path ) ; ptr = dirname ( dir ) ; memset ( rpath , 0 , sizeof ( rpath ) ) ; if ( ! realpath ( ptr , rpath ) ) { info ( ""failed<s2sv_blank>realpath(%s):<s2sv_blank>%m"" , ptr ) ; return null ; } if ( rpath [ 1 ] != 0 ) strlcat ( rpath , ""/"" , sizeof ( rpath ) ) ; strlcat ( rpath , name , sizeof ( rpath ) ) ; } if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { dbg ( ""failed<s2sv_blank>non-chroot<s2sv_blank>dir:%s<s2sv_blank>vs<s2sv_blank>home:%s"" , dir , home ) ; return null ; } return rpath ; }","<S2SV_ModStart> && strncmp ( rpath <S2SV_ModEnd> , home ,
",troglobit@uftpd/455b47d3756aed162d2d0ef7f40b549f3b5b30fe,CVE-2020-5221,https://github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe,2020-01-22T19:15Z,"<S2SV_StartBug> if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { <S2SV_EndBug>"
3943,CWE-264,"static int raw_cmd_copyin ( int cmd , void __user * param , struct floppy_raw_cmd * * rcmd ) { struct floppy_raw_cmd * ptr ; int ret ; int i ; * rcmd = null ; loop : ptr = kmalloc ( sizeof ( struct floppy_raw_cmd ) , gfp_user ) ; if ( ! ptr ) return - enomem ; * rcmd = ptr ; ret = copy_from_user ( ptr , param , sizeof ( * ptr ) ) ; if ( ret ) return - efault ; ptr -> next = null ; ptr -> buffer_length = 0 ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ptr -> cmd_count > 33 ) return - einval ; for ( i = 0 ; i < 16 ; i ++ ) ptr -> reply [ i ] = 0 ; ptr -> resultcode = 0 ; ptr -> kernel_data = null ; if ( ptr -> flags & ( fd_raw_read | fd_raw_write ) ) { if ( ptr -> length <= 0 ) return - einval ; ptr -> kernel_data = ( char * ) fd_dma_mem_alloc ( ptr -> length ) ; fallback_on_nodma_alloc ( & ptr -> kernel_data , ptr -> length ) ; if ( ! ptr -> kernel_data ) return - enomem ; ptr -> buffer_length = ptr -> length ; } if ( ptr -> flags & fd_raw_write ) { ret = fd_copyin ( ptr -> data , ptr -> kernel_data , ptr -> length ) ; if ( ret ) return ret ; } if ( ptr -> flags & fd_raw_more ) { rcmd = & ( ptr -> next ) ; ptr -> rate &= 0x43 ; goto loop ; } return 0 ; }","<S2SV_ModStart> ) ) ; ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; param += <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ptr
",torvalds@linux/ef87dbe7614341c2e7bfe8d32fcb7028cc97442c,CVE-2014-1737,https://github.com/torvalds/linux/commit/ef87dbe7614341c2e7bfe8d32fcb7028cc97442c,2014-05-11T21:55Z,<S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug>
920,CWE-476,"void migrate_page_copy ( struct page * newpage , struct page * page ) { int cpupid ; if ( pagehuge ( page ) || pagetranshuge ( page ) ) copy_huge_page ( newpage , page ) ; else copy_highpage ( newpage , page ) ; if ( pageerror ( page ) ) setpageerror ( newpage ) ; if ( pagereferenced ( page ) ) setpagereferenced ( newpage ) ; if ( pageuptodate ( page ) ) setpageuptodate ( newpage ) ; if ( testclearpageactive ( page ) ) { vm_bug_on_page ( pageunevictable ( page ) , page ) ; setpageactive ( newpage ) ; } else if ( testclearpageunevictable ( page ) ) setpageunevictable ( newpage ) ; if ( pagechecked ( page ) ) setpagechecked ( newpage ) ; if ( pagemappedtodisk ( page ) ) setpagemappedtodisk ( newpage ) ; if ( pagedirty ( page ) ) { clear_page_dirty_for_io ( page ) ; if ( pageswapbacked ( page ) ) setpagedirty ( newpage ) ; else __set_page_dirty_nobuffers ( newpage ) ; } if ( page_is_young ( page ) ) set_page_young ( newpage ) ; if ( page_is_idle ( page ) ) set_page_idle ( newpage ) ; cpupid = page_cpupid_xchg_last ( page , - 1 ) ; page_cpupid_xchg_last ( newpage , cpupid ) ; ksm_migrate_page ( newpage , page ) ; if ( pageswapcache ( page ) ) clearpageswapcache ( page ) ; clearpageprivate ( page ) ; set_page_private ( page , 0 ) ; if ( pagewriteback ( newpage ) ) end_page_writeback ( newpage ) ; }","<S2SV_ModStart> page ) ) <S2SV_ModEnd> SetPageDirty ( newpage <S2SV_ModStart> newpage ) ; <S2SV_ModEnd> if ( page_is_young
",torvalds@linux/42cb14b110a5698ccf26ce59c4441722605a3743,CVE-2016-3070,https://github.com/torvalds/linux/commit/42cb14b110a5698ccf26ce59c4441722605a3743,2016-08-06T20:59Z,<S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug>
5925,CWE-125,"static image * readpdbimage ( const imageinfo * image_info , exceptioninfo * exception ) { unsigned char attributes , tag [ 3 ] ; image * image ; magickbooleantype status ; pdbimage pdb_image ; pdbinfo pdb_info ; quantum index ; register ssize_t x ; register quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; if ( image_info -> debug != magickfalse ) ( void ) logmagickevent ( traceevent , getmagickmodule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } count = readblob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; pdb_info . attributes = ( short ) readblobmsbshort ( image ) ; pdb_info . version = ( short ) readblobmsbshort ( image ) ; pdb_info . create_time = readblobmsblong ( image ) ; pdb_info . modify_time = readblobmsblong ( image ) ; pdb_info . archive_time = readblobmsblong ( image ) ; pdb_info . modify_number = readblobmsblong ( image ) ; pdb_info . application_info = readblobmsblong ( image ) ; pdb_info . sort_info = readblobmsblong ( image ) ; ( void ) readblob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) readblob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = readblobmsblong ( image ) ; pdb_info . next_record = readblobmsblong ( image ) ; pdb_info . number_records = ( short ) readblobmsbshort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vimg"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""view"" , 4 ) != 0 ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; if ( pdb_info . next_record != 0 ) throwreaderexception ( codererror , ""multiplerecordlistnotsupported"" ) ; img_offset = ( ssize_t ) ( ( int ) readblobmsblong ( image ) ) ; attributes = ( unsigned char ) readblobbyte ( image ) ; ( void ) attributes ; count = readblob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) throwreaderexception ( corruptimageerror , ""corruptimage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) readblobmsblong ( image ) ) ; attributes = ( unsigned char ) readblobbyte ( image ) ; count = readblob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) throwreaderexception ( corruptimageerror , ""corruptimage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - tellblob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = readblobbyte ( image ) ; if ( c == eof ) break ; } count = readblob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; pdb_image . version = readblobbyte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) readblobbyte ( image ) ) ; pdb_image . reserved_1 = readblobmsblong ( image ) ; pdb_image . note = readblobmsblong ( image ) ; pdb_image . x_last = ( short ) readblobmsbshort ( image ) ; pdb_image . y_last = ( short ) readblobmsbshort ( image ) ; pdb_image . reserved_2 = readblobmsblong ( image ) ; pdb_image . x_anchor = readblobmsbshort ( image ) ; pdb_image . y_anchor = readblobmsbshort ( image ) ; pdb_image . width = ( short ) readblobmsbshort ( image ) ; pdb_image . height = ( short ) readblobmsbshort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; image -> storage_class = pseudoclass ; bits_per_pixel = pdb_image . type == 0 ? 2ul : pdb_image . type == 2 ? 4ul : 1ul ; one = 1 ; if ( acquireimagecolormap ( image , one << bits_per_pixel , exception ) == magickfalse ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; if ( image_info -> ping != magickfalse ) { ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; pixels = ( unsigned char * ) acquirequantummemory ( packets + 256ul , image -> rows * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = nocompression ; count = ( ssize_t ) readblob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = rlecompression ; if ( ! decodeimage ( image , pixels , packets * image -> rows ) ) throwreaderexception ( corruptimageerror , ""rledecodererror"" ) ; break ; } default : throwreaderexception ( corruptimageerror , ""unrecognizedimagecompressiontype"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; setpixelindex ( image , index , q ) ; q += getpixelchannels ( image ) ; } p ++ ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; status = setimageprogress ( image , loadimagetag , ( magickoffsettype ) y , image -> rows ) ; if ( status == magickfalse ) break ; } ( void ) syncimage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = constraincolormapindex ( image , 3ul - ( ( * p >> 6 ) & 0x03 ) , exception ) ; setpixelindex ( image , index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , 3ul - ( ( * p >> 4 ) & 0x03 ) , exception ) ; setpixelindex ( image , index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , 3ul - ( ( * p >> 2 ) & 0x03 ) , exception ) ; setpixelindex ( image , index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , 3ul - ( ( * p ) & 0x03 ) , exception ) ; setpixelindex ( image , index , q ) ; p ++ ; q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; status = setimageprogress ( image , loadimagetag , ( magickoffsettype ) y , image -> rows ) ; if ( status == magickfalse ) break ; } ( void ) syncimage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = constraincolormapindex ( image , 15ul - ( ( * p >> 4 ) & 0x0f ) , exception ) ; setpixelindex ( image , index , q ) ; q += getpixelchannels ( image ) ; index = constraincolormapindex ( image , 15ul - ( ( * p ) & 0x0f ) , exception ) ; setpixelindex ( image , index , q ) ; p ++ ; q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; status = setimageprogress ( image , loadimagetag , ( magickoffsettype ) y , image -> rows ) ; if ( status == magickfalse ) break ; } ( void ) syncimage ( image , exception ) ; break ; } default : throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; } pixels = ( unsigned char * ) relinquishmagickmemory ( pixels ) ; if ( eofblob ( image ) != magickfalse ) throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - tellblob ( image ) ) ; while ( num_pad_bytes -- ) readblobbyte ( image ) ; c = readblobbyte ( image ) ; length = magickpathextent ; comment = acquirestring ( ( char * ) null ) ; for ( p = comment ; c != eof ; p ++ ) { if ( ( size_t ) ( p - comment + magickpathextent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += magickpathextent ; comment = ( char * ) resizequantummemory ( comment , length + magickpathextent , sizeof ( * comment ) ) ; if ( comment == ( char * ) null ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = readblobbyte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; ( void ) setimageproperty ( image , ""comment"" , comment , exception ) ; comment = destroystring ( comment ) ; } ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; }","<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
",ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug>"
4311,CWE-476,"static apr_status_t modsecurity_request_body_store_memory ( modsec_rec * msr , const char * data , apr_size_t length , char * * error_msg ) { * error_msg = null ; if ( ( msr -> msc_reqbody_spilltodisk ) && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) { msc_data_chunk * * chunks ; unsigned int disklen = 0 ; int i ; msr_log ( msr , 4 , ""input<s2sv_blank>filter:<s2sv_blank>request<s2sv_blank>too<s2sv_blank>large<s2sv_blank>to<s2sv_blank>store<s2sv_blank>in<s2sv_blank>memory,<s2sv_blank>switching<s2sv_blank>to<s2sv_blank>disk."" ) ; msr -> msc_reqbody_storage = msc_reqbody_disk ; if ( modsecurity_request_body_start_init ( msr , error_msg ) < 0 ) return - 1 ; chunks = ( msc_data_chunk * * ) msr -> msc_reqbody_chunks -> elts ; for ( i = 0 ; i < msr -> msc_reqbody_chunks -> nelts ; i ++ ) { disklen += chunks [ i ] -> length ; if ( modsecurity_request_body_store_disk ( msr , chunks [ i ] -> data , chunks [ i ] -> length , error_msg ) < 0 ) { return - 1 ; } free ( chunks [ i ] -> data ) ; chunks [ i ] -> data = null ; } msr -> msc_reqbody_chunks = null ; apr_pool_clear ( msr -> msc_reqbody_mp ) ; msr_log ( msr , 4 , ""input<s2sv_blank>filter:<s2sv_blank>wrote<s2sv_blank>%u<s2sv_blank>bytes<s2sv_blank>from<s2sv_blank>memory<s2sv_blank>to<s2sv_blank>disk."" , disklen ) ; return modsecurity_request_body_store_disk ( msr , data , length , error_msg ) ; } { unsigned long int bucket_offset , bucket_left ; bucket_offset = 0 ; bucket_left = length ; while ( bucket_left > 0 ) { if ( msr -> msc_reqbody_chunk_current == null ) { msr -> msc_reqbody_chunk_current = ( msc_data_chunk * ) apr_pcalloc ( msr -> msc_reqbody_mp , sizeof ( msc_data_chunk ) ) ; if ( msr -> msc_reqbody_chunk_current == null ) { * error_msg = apr_psprintf ( msr -> mp , ""input<s2sv_blank>filter:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>%lu<s2sv_blank>bytes<s2sv_blank>"" ""for<s2sv_blank>request<s2sv_blank>body<s2sv_blank>chunk."" , ( unsigned long ) sizeof ( msc_data_chunk ) ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> data = malloc ( chunk_capacity ) ; if ( msr -> msc_reqbody_chunk_current -> data == null ) { * error_msg = apr_psprintf ( msr -> mp , ""input<s2sv_blank>filter:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>%d<s2sv_blank>bytes<s2sv_blank>"" ""for<s2sv_blank>request<s2sv_blank>body<s2sv_blank>chunk<s2sv_blank>data."" , chunk_capacity ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> length = 0 ; msr -> msc_reqbody_chunk_current -> is_permanent = 1 ; * ( const msc_data_chunk * * ) apr_array_push ( msr -> msc_reqbody_chunks ) = msr -> msc_reqbody_chunk_current ; } if ( bucket_left < ( chunk_capacity - msr -> msc_reqbody_chunk_current -> length ) ) { memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , bucket_left ) ; msr -> msc_reqbody_chunk_current -> length += bucket_left ; bucket_left = 0 ; } else { unsigned long int copy_length = chunk_capacity - msr -> msc_reqbody_chunk_current -> length ; memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , copy_length ) ; bucket_offset += copy_length ; bucket_left -= copy_length ; msr -> msc_reqbody_chunk_current -> length += copy_length ; msr -> msc_reqbody_chunk_current = null ; } } msr -> msc_reqbody_length += length ; } return 1 ; }","<S2SV_ModStart> msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON
",SpiderLabs@ModSecurity/0840b13612a0b7ef1ce7441cf811dcfc6b463fba,CVE-2013-2765,https://github.com/SpiderLabs/ModSecurity/commit/0840b13612a0b7ef1ce7441cf811dcfc6b463fba,2013-07-15T15:55Z,<S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug>
3690,CWE-476,"static int skcipher_accept_parent ( void * private , struct sock * sk ) { struct skcipher_ctx * ctx ; struct alg_sock * ask = alg_sk ( sk ) ; unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; ctx = sock_kmalloc ( sk , len , gfp_kernel ) ; if ( ! ctx ) return - enomem ; ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , gfp_kernel ) ; if ( ! ctx -> iv ) { sock_kfree_s ( sk , ctx , len ) ; return - enomem ; } memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; init_list_head ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; skcipher_request_set_tfm ( & ctx -> req , private ) ; skcipher_request_set_callback ( & ctx -> req , crypto_tfm_req_may_backlog , af_alg_complete , & ctx -> completion ) ; sk -> sk_destruct = skcipher_sock_destruct ; return 0 ; }","<S2SV_ModStart> sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback
",torvalds@linux/dd504589577d8e8e70f51f997ad487a4cb6c026f,CVE-2015-8970,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,2016-11-28T03:59Z,"<S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug>"
3364,CWE-000,"static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - eio ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ; if ( ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""%s<s2sv_blank>-<s2sv_blank>interrupt_in_urb<s2sv_blank>is<s2sv_blank>empty!\\n"" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointaddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , gfp_kernel ) ; if ( result ) { dev_err ( & port -> dev , ""%s<s2sv_blank>-<s2sv_blank>failed<s2sv_blank>submitting<s2sv_blank>read<s2sv_blank>urb,<s2sv_blank>error<s2sv_blank>%d\\n"" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }","<S2SV_ModStart> tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
",torvalds@linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,CVE-2016-3137,https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,2016-05-02T10:59Z,<S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug>
1247,CWE-119,"static inline bool unconditional ( const struct arpt_arp * arp ) { static const struct arpt_arp uncond ; return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; }","<S2SV_ModStart> ( const struct arpt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> arp , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug>"
5090,CWE-787,"size_t openmp4source ( char * filename , uint32_t traktype , uint32_t traksubtype ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == null ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _windows fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { uint32_t qttag , qtsize32 , skip , type = 0 , subtype = 0 , num ; size_t len ; int32_t nest = 0 ; uint64_t nestsize [ max_nest_level ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! valid_fourcc ( qttag ) ) { longseek ( mp4 -> mediafp , lastsize - 8 - 8 , seek_cur ) ; nestsize ( lastsize - 8 ) ; continue ; } qtsize32 = byteswap32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = byteswap64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= max_nest_level ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; # if print_mp4_structure for ( int i = 1 ; i < nest ; i ++ ) printf ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>"" ) ; printf ( ""%c%c%c%c<s2sv_blank>(%lld)\\n"" , ( qttag & 0xff ) , ( ( qttag >> 8 ) & 0xff ) , ( ( qttag >> 16 ) & 0xff ) , ( ( qttag >> 24 ) & 0xff ) , qtsize ) ; if ( qttag == makeid ( 'm' , 'd' , 'a' , 't' ) || qttag == makeid ( 'f' , 't' , 'y' , 'p' ) || qttag == makeid ( 'u' , 'd' , 't' , 'a' ) ) { longseek ( mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; continue ; } # else if ( qttag != makeid ( 'm' , 'o' , 'o' , 'v' ) && qttag != makeid ( 'm' , 'v' , 'h' , 'd' ) && qttag != makeid ( 't' , 'r' , 'a' , 'k' ) && qttag != makeid ( 'm' , 'd' , 'i' , 'a' ) && qttag != makeid ( 'm' , 'd' , 'h' , 'd' ) && qttag != makeid ( 'm' , 'i' , 'n' , 'f' ) && qttag != makeid ( 'g' , 'm' , 'i' , 'n' ) && qttag != makeid ( 'd' , 'i' , 'n' , 'f' ) && qttag != makeid ( 'a' , 'l' , 'i' , 's' ) && qttag != makeid ( 's' , 't' , 's' , 'd' ) && qttag != makeid ( 'a' , 'l' , 'i' , 's' ) && qttag != makeid ( 'a' , 'l' , 'i' , 's' ) && qttag != makeid ( 's' , 't' , 'b' , 'l' ) && qttag != makeid ( 's' , 't' , 't' , 's' ) && qttag != makeid ( 's' , 't' , 's' , 'c' ) && qttag != makeid ( 's' , 't' , 's' , 'z' ) && qttag != makeid ( 's' , 't' , 'c' , 'o' ) && qttag != makeid ( 'c' , 'o' , '6' , '4' ) && qttag != makeid ( 'h' , 'd' , 'l' , 'r' ) ) { longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else # endif if ( qttag == makeid ( 'm' , 'v' , 'h' , 'd' ) ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & mp4 -> clockdemon , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockdemon = byteswap32 ( mp4 -> clockdemon ) ; len += fread ( & mp4 -> clockcount , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockcount = byteswap32 ( mp4 -> clockcount ) ; longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 'm' , 'd' , 'h' , 'd' ) ) { media_header md ; len = fread ( & md , 1 , sizeof ( md ) , mp4 -> mediafp ) ; if ( len == sizeof ( md ) ) { md . creation_time = byteswap32 ( md . creation_time ) ; md . modification_time = byteswap32 ( md . modification_time ) ; md . time_scale = byteswap32 ( md . time_scale ) ; md . duration = byteswap32 ( md . duration ) ; mp4 -> trak_clockdemon = md . time_scale ; mp4 -> trak_clockcount = md . duration ; if ( mp4 -> videolength == 0.0 ) { mp4 -> videolength = ( float ) ( ( double ) mp4 -> trak_clockcount / ( double ) mp4 -> trak_clockdemon ) ; } } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 'h' , 'd' , 'l' , 'r' ) ) { uint32_t temp ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & temp , 1 , 4 , mp4 -> mediafp ) ; if ( temp != makeid ( 'a' , 'l' , 'i' , 's' ) ) type = temp ; longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 's' , 't' , 's' , 'd' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & subtype , 1 , 4 , mp4 -> mediafp ) ; if ( len == 16 ) { if ( subtype != traksubtype ) { type = 0 ; } } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; } else longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 's' , 't' , 's' , 'c' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = byteswap32 ( num ) ; if ( num * 12 <= qtsize - 8 - len ) { mp4 -> metastsc_count = num ; if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = ( sampletochunk * ) malloc ( num * 12 ) ; if ( mp4 -> metastsc ) { uint32_t total_stsc = num ; len += fread ( mp4 -> metastsc , 1 , num * sizeof ( sampletochunk ) , mp4 -> mediafp ) ; do { num -- ; mp4 -> metastsc [ num ] . chunk_num = byteswap32 ( mp4 -> metastsc [ num ] . chunk_num ) ; mp4 -> metastsc [ num ] . samples = byteswap32 ( mp4 -> metastsc [ num ] . samples ) ; mp4 -> metastsc [ num ] . id = byteswap32 ( mp4 -> metastsc [ num ] . id ) ; } while ( num > 0 ) ; } if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) { if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = null ; mp4 -> metastsc_count = 0 ; } } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; } else longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 's' , 't' , 's' , 'z' ) ) { if ( type == traktype ) { uint32_t equalsamplesize ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & equalsamplesize , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = byteswap32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { mp4 -> metasize_count = num ; if ( mp4 -> metasizes ) free ( mp4 -> metasizes ) ; mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; if ( mp4 -> metasizes ) { if ( equalsamplesize == 0 ) { len += fread ( mp4 -> metasizes , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metasizes [ num ] = byteswap32 ( mp4 -> metasizes [ num ] ) ; } while ( num > 0 ) ; } else { equalsamplesize = byteswap32 ( equalsamplesize ) ; do { num -- ; mp4 -> metasizes [ num ] = equalsamplesize ; } while ( num > 0 ) ; } } } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; } else longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 's' , 't' , 'c' , 'o' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = byteswap32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) { mp4 -> indexcount = mp4 -> metasize_count ; if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = null ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; int repeat = 1 ; len += fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; metaoffsets32 [ num ] = byteswap32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; mp4 -> metaoffsets [ 0 ] = fileoffset = metaoffsets32 [ stco_pos ] ; num = 1 ; while ( num < mp4 -> metasize_count ) { if ( stsc_pos + 1 < ( int ) mp4 -> metastsc_count && num == stsc_pos ) { stco_pos ++ ; stsc_pos ++ ; fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; repeat = 1 ; } else if ( repeat == mp4 -> metastsc [ stsc_pos ] . samples ) { stco_pos ++ ; fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; repeat ++ ; } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = null ; mp4 -> metastsc_count = 0 ; free ( metaoffsets32 ) ; } } } else { mp4 -> indexcount = num ; if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = null ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { size_t readlen = fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; len += readlen ; do { num -- ; mp4 -> metaoffsets [ num ] = byteswap32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; free ( metaoffsets32 ) ; } } } } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; } else longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 'c' , 'o' , '6' , '4' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = byteswap32 ( num ) ; if ( num * 8 <= qtsize - 8 - len ) { if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) { mp4 -> indexcount = mp4 -> metasize_count ; if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; if ( mp4 -> metaoffsets ) { uint64_t * metaoffsets64 = null ; metaoffsets64 = ( uint64_t * ) malloc ( num * 8 ) ; if ( metaoffsets64 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; len += fread ( metaoffsets64 , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; metaoffsets64 [ num ] = byteswap64 ( metaoffsets64 [ num ] ) ; } while ( num > 0 ) ; fileoffset = metaoffsets64 [ 0 ] ; mp4 -> metaoffsets [ 0 ] = fileoffset ; num = 1 ; while ( num < mp4 -> metasize_count ) { if ( num != mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 && 0 == ( num - ( mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 ) ) % mp4 -> metastsc [ stsc_pos ] . samples ) { stco_pos ++ ; fileoffset = ( uint64_t ) metaoffsets64 [ stco_pos ] ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = null ; mp4 -> metastsc_count = 0 ; free ( metaoffsets64 ) ; } } } else { mp4 -> indexcount = num ; if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { len += fread ( mp4 -> metaoffsets , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metaoffsets [ num ] = byteswap64 ( mp4 -> metaoffsets [ num ] ) ; } while ( num > 0 ) ; } } } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; } else longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else if ( qttag == makeid ( 's' , 't' , 't' , 's' ) ) { if ( type == traktype ) { uint32_t totaldur = 0 , samples = 0 ; int32_t entries = 0 ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = byteswap32 ( num ) ; if ( num * 8 <= qtsize - 8 - len ) { entries = num ; mp4 -> meta_clockdemon = mp4 -> trak_clockdemon ; mp4 -> meta_clockcount = mp4 -> trak_clockcount ; while ( entries > 0 ) { int32_t samplecount ; int32_t duration ; len += fread ( & samplecount , 1 , 4 , mp4 -> mediafp ) ; samplecount = byteswap32 ( samplecount ) ; len += fread ( & duration , 1 , 4 , mp4 -> mediafp ) ; duration = byteswap32 ( duration ) ; samples += samplecount ; entries -- ; totaldur += duration ; mp4 -> metadatalength += ( double ) ( ( double ) samplecount * ( double ) duration / ( double ) mp4 -> meta_clockdemon ) ; } mp4 -> basemetadataduration = mp4 -> metadatalength * ( double ) mp4 -> meta_clockdemon / ( double ) samples ; } longseek ( mp4 -> mediafp , qtsize - 8 - len , seek_cur ) ; } else longseek ( mp4 -> mediafp , qtsize - 8 , seek_cur ) ; nestsize ( qtsize ) ; } else { nestsize ( 8 ) ; } } else { break ; } } while ( len > 0 ) ; } else { free ( mp4 ) ; mp4 = null ; } return ( size_t ) mp4 ; }","<S2SV_ModStart> mp4object ) ) ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mediafp ) ; mp4 -> filepos += len ; <S2SV_ModStart> len == 8 && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> ) ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> ; } qtsize32 <S2SV_ModStart> 1 ) { len = <S2SV_ModStart> -> mediafp ) ; mp4 -> filepos += len <S2SV_ModStart> , 'a' ) || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> != MAKEID ( 's' , 't' , 'b' , 'l' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 's' , 't' , 't' <S2SV_ModEnd> , 's' ) <S2SV_ModStart> , 't' , 's' , 'c' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 's' , 'z' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 'c' , 'o' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 'c' , 'o' , '6' , '4' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( <S2SV_ModEnd> 'h' , 'd' <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> clockcount ) ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> , 's' ) && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> = temp ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metastsc ) ; if ( num > 0 ) { <S2SV_ModStart> ( num * sizeof ( SampleToChunk ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> metastsc ) { <S2SV_ModEnd> len += fread <S2SV_ModStart> ) ; } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metasizes ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> len ) { uint32_t metastco_count = num ; <S2SV_ModStart> -> indexcount = num <S2SV_ModEnd> ; if ( <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> ) malloc ( num <S2SV_ModEnd> * 8 ) <S2SV_ModStart> < mp4 -> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> repeat == mp4 <S2SV_ModStart> samples ) { if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart> stco_pos ] ; <S2SV_ModEnd> } else { <S2SV_ModStart> 1 ] ; } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> if ( num == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> metaoffsets ) ; if ( mp4 -> metasize_count ) { <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> samples ; } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> 0 ) ; if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } }
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z,"<S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
7064,CWE-401,"static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = div_round_up ( size , page_size ) ; table = kcalloc ( nents , sizeof ( * table ) , gfp_kernel ) ; if ( ! table ) return null ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( gfp_kernel ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } return null ; } alloc_size = min_t ( int , size , page_size ) ; size -= page_size ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }","<S2SV_ModStart> ) ; } kfree ( table ) ;
",torvalds@linux/b4b814fec1a5a849383f7b3886b654a13abbda7d,CVE-2019-19058,https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d,2019-11-18T06:15Z,<S2SV_StartBug> return NULL ; <S2SV_EndBug>
2900,CWE-310,"static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) { struct btrfs_trans_handle * trans ; struct btrfs_root * root = btrfs_i ( old_dir ) -> root ; struct btrfs_root * dest = btrfs_i ( new_dir ) -> root ; struct inode * new_inode = new_dentry -> d_inode ; struct inode * old_inode = old_dentry -> d_inode ; struct timespec ctime = current_time ; u64 index = 0 ; u64 root_objectid ; int ret ; u64 old_ino = btrfs_ino ( old_inode ) ; if ( btrfs_ino ( new_dir ) == btrfs_empty_subvol_dir_objectid ) return - eperm ; if ( old_ino != btrfs_first_free_objectid && root != dest ) return - exdev ; if ( old_ino == btrfs_empty_subvol_dir_objectid || ( new_inode && btrfs_ino ( new_inode ) == btrfs_first_free_objectid ) ) return - enotempty ; if ( s_isdir ( old_inode -> i_mode ) && new_inode && new_inode -> i_size > btrfs_empty_dir_size ) return - enotempty ; if ( new_inode && s_isreg ( old_inode -> i_mode ) && new_inode -> i_size && old_inode -> i_size > btrfs_ordered_operations_flush_limit ) filemap_flush ( old_inode -> i_mapping ) ; if ( old_ino == btrfs_first_free_objectid ) down_read ( & root -> fs_info -> subvol_sem ) ; trans = btrfs_start_transaction ( root , 20 ) ; if ( is_err ( trans ) ) { ret = ptr_err ( trans ) ; goto out_notrans ; } if ( dest != root ) btrfs_record_root_in_trans ( trans , dest ) ; ret = btrfs_set_inode_index ( new_dir , & index ) ; if ( ret ) goto out_fail ; if ( unlikely ( old_ino == btrfs_first_free_objectid ) ) { root -> fs_info -> last_trans_log_full_commit = trans -> transid ; } else { ret = btrfs_insert_inode_ref ( trans , dest , new_dentry -> d_name . name , new_dentry -> d_name . len , old_ino , btrfs_ino ( new_dir ) , index ) ; if ( ret ) goto out_fail ; btrfs_pin_log_trans ( root ) ; } if ( new_inode && new_inode -> i_size && s_isreg ( old_inode -> i_mode ) ) btrfs_add_ordered_operation ( trans , root , old_inode ) ; inode_inc_iversion ( old_dir ) ; inode_inc_iversion ( new_dir ) ; inode_inc_iversion ( old_inode ) ; old_dir -> i_ctime = old_dir -> i_mtime = ctime ; new_dir -> i_ctime = new_dir -> i_mtime = ctime ; old_inode -> i_ctime = ctime ; if ( old_dentry -> d_parent != new_dentry -> d_parent ) btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; if ( unlikely ( old_ino == btrfs_first_free_objectid ) ) { root_objectid = btrfs_i ( old_inode ) -> root -> root_key . objectid ; ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; } else { ret = __btrfs_unlink_inode ( trans , root , old_dir , old_dentry -> d_inode , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; if ( ! ret ) ret = btrfs_update_inode ( trans , root , old_inode ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( new_inode ) { inode_inc_iversion ( new_inode ) ; new_inode -> i_ctime = current_time ; if ( unlikely ( btrfs_ino ( new_inode ) == btrfs_empty_subvol_dir_objectid ) ) { root_objectid = btrfs_i ( new_inode ) -> location . objectid ; ret = btrfs_unlink_subvol ( trans , dest , new_dir , root_objectid , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; bug_on ( new_inode -> i_nlink == 0 ) ; } else { ret = btrfs_unlink_inode ( trans , dest , new_dir , new_dentry -> d_inode , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; } if ( ! ret && new_inode -> i_nlink == 0 ) { ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; bug_on ( ret ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } } fixup_inode_flags ( new_dir , old_inode ) ; ret = btrfs_add_link ( trans , new_dir , old_inode , new_dentry -> d_name . name , new_dentry -> d_name . len , 0 , index ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( old_ino != btrfs_first_free_objectid ) { struct dentry * parent = new_dentry -> d_parent ; btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; btrfs_end_log_trans ( root ) ; } out_fail : btrfs_end_transaction ( trans , root ) ; out_notrans : if ( old_ino == btrfs_first_free_objectid ) up_read ( & root -> fs_info -> subvol_sem ) ; return ret ; }","<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;
",torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z,<S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug>
2097,CWE-000,"static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( is_mnt_new ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = cl_make_shared ; } else { struct mount * n , * p ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || is_mnt_marked ( p ) ) { while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = cl_slave ; if ( is_mnt_shared ( m ) ) type |= cl_make_shared ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= cl_unprivileged ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( is_err ( child ) ) return ptr_err ( child ) ; child -> mnt . mnt_flags &= ~ mnt_locked ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; set_mnt_mark ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }","<S2SV_ModStart> , * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE
",torvalds@linux/5ec0811d30378ae104f250bfc9b3640242d81e3f,CVE-2016-4581,https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f,2016-05-23T10:59Z,"<S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug>"
2832,CWE-189,"static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = bpf_op ( insn -> code ) ; int err ; if ( opcode > bpf_jsle ) { verbose ( env , ""invalid<s2sv_blank>bpf_jmp<s2sv_blank>opcode<s2sv_blank>%x\\n"" , opcode ) ; return - einval ; } if ( bpf_src ( insn -> code ) == bpf_x ) { if ( insn -> imm != 0 ) { verbose ( env , ""bpf_jmp<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } err = check_reg_arg ( env , insn -> src_reg , src_op ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>comparison<s2sv_blank>prohibited\\n"" , insn -> src_reg ) ; return - eacces ; } } else { if ( insn -> src_reg != bpf_reg_0 ) { verbose ( env , ""bpf_jmp<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } } err = check_reg_arg ( env , insn -> dst_reg , src_op ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( bpf_src ( insn -> code ) == bpf_k ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; if ( ! other_branch ) return - efault ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( bpf_src ( insn -> code ) == bpf_x ) { if ( dst_reg -> type == scalar_value && regs [ insn -> src_reg ] . type == scalar_value ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == bpf_jeq || opcode == bpf_jne ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == scalar_value ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( bpf_src ( insn -> code ) == bpf_k && insn -> imm == 0 && ( opcode == bpf_jeq || opcode == bpf_jne ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == bpf_jne ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == bpf_jeq ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>comparison<s2sv_blank>prohibited\\n"" , insn -> dst_reg ) ; return - eacces ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }","<S2SV_ModStart> , * insn_idx , false
",torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,CVE-2019-7308,https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,2019-02-01T22:29Z,"<S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug>"
766,CWE-20,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( is_err ( key_ref ) ) { ret = - enokey ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; if ( test_bit ( key_flag_negative , & key -> flags ) ) { ret = - enokey ; goto error2 ; } ret = key_permission ( key_ref , key_need_read ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - eacces ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - eacces ; goto error2 ; } can_read_key : ret = - eopnotsupp ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }","<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug>"
4186,CWE-732,"char * * prepenv ( const struct rule * rule ) { static const char * safeset [ ] = { ""display"" , ""home"" , ""logname"" , ""mail"" , ""path"" , ""term"" , ""user"" , ""username"" , null } ; struct env * env ; env = createenv ( rule ) ; if ( ! ( rule -> options & keepenv ) ) fillenv ( env , safeset ) ; if ( rule -> envlist ) fillenv ( env , rule -> envlist ) ; return flattenenv ( env ) ; }","<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> struct env * <S2SV_ModStart> createenv ( rule , mypw , targpw <S2SV_ModEnd> ) ; if
",Duncaen@OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168,CVE-2019-25016,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,2021-01-28T20:15Z,<S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug>
2970,CWE-200,"static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & msg_dontwait ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; if ( ( sk -> sk_state == iucv_disconn ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( msg_oob ) ) return - eopnotsupp ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & rcv_shutdown ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | rcv_shutdown ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & msg_peek ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - efault ; } if ( sk -> sk_type == sock_seqpacket ) { if ( copied < rlen ) msg -> msg_flags |= msg_trunc ; msg -> msg_flags |= msg_eor ; } err = put_cmsg ( msg , sol_iucv , scm_iucv_trgcls , cb_trgcls_len , cb_trgcls ( skb ) ) ; if ( err ) { if ( ! ( flags & msg_peek ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & msg_peek ) ) { if ( sk -> sk_type == sock_stream ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == af_iucv_trans_hiper ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { warn_on ( 1 ) ; iucv_sock_close ( sk ) ; return - efault ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , af_iucv_flag_win ) ; if ( err ) { sk -> sk_state = iucv_disconn ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == sock_seqpacket && ( flags & msg_trunc ) ) copied = rlen ; return copied ; }","<S2SV_ModStart> ; int err = 0 ; msg -> msg_namelen
",torvalds@linux/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,CVE-2013-3229,https://github.com/torvalds/linux/commit/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,2013-04-22T11:41Z,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug>
3955,CWE-476,"static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < pcd_units ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , blk_mq_f_should_merge ) ; if ( is_err ( disk -> queue ) ) { disk -> queue = null ; continue ; } init_list_head ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , blk_bounce_high ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ d_slv ] ; if ( ( * drives [ unit ] ) [ d_prt ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , ""%s%d"" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = genhd_fl_block_events_on_excl_write ; } }","<S2SV_ModStart> ) ) { put_disk ( disk ) ;
",torvalds@linux/f0d1762554014ce0ae347b9f0d088f2c157c8c72,CVE-2019-15923,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,2019-09-04T19:15Z,<S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug>
1293,CWE-476,"unsigned int ip6t_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ ifnamsiz ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = nf_drop ; const char * indev , * outdev ; const void * table_base ; struct ip6t_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . hotdrop = false ; acpar . state = state ; warn_on ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = read_once ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ip6t_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; warn_on ( ! e ) ; acpar . thoff = 0 ; if ( ! ip6_packet_match ( skb , indev , outdev , & e -> ipv6 , & acpar . thoff , & acpar . fragoff , & acpar . hotdrop ) ) { no_match : e = ip6t_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; add_counter ( * counter , skb -> len , 1 ) ; t = ip6t_get_target_c ( e ) ; warn_on ( ! t -> u . kernel . target ) ; # if is_enabled ( config_netfilter_xt_target_trace ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != xt_return ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) e = get_entry ( table_base , private -> underflow [ hook ] ) ; else e = ip6t_next_entry ( jumpstack [ -- stackidx ] ) ; continue ; } if ( table_base + v != ip6t_next_entry ( e ) && ! ( e -> ipv6 . flags & ip6t_f_goto ) ) { jumpstack [ stackidx ++ ] = e ; } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == xt_continue ) e = ip6t_next_entry ( e ) ; else break ; } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return nf_drop ; else return verdict ; }","<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
",torvalds@linux/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,CVE-2018-1065,https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,2018-03-02T08:29Z,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug>
3476,CWE-284,"void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( ! mp ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; umount_tree ( mnt , 0 ) ; } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","<S2SV_ModStart> mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z,"<S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug>"
1265,CWE-264,"void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= iff_802_1q_vlan ; dev -> priv_flags &= ~ iff_xmit_dst_release ; dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , eth_alen ) ; }","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug>
3563,CWE-400,"static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! is_err ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ; list_add ( & mnt -> mnt_list , & new_ns -> list ) ; } else { mntput ( m ) ; } return new_ns ; }","<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z,"<S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug>"
2420,CWE-416,"static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; kfree ( user ) ; }","<S2SV_ModStart> refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
",torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z,<S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug>
6560,CWE-119,static const char * skip ( const char * in ) { while ( in && * in && ( unsigned char ) * in <= 32 ) in ++ ; return in ; },"
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
110,CWE-119,"int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) { u16 * op ; int size ; unicode_t u ; op = pwcs ; while ( * s && len > 0 ) { if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - einval ; if ( u >= plane_size ) { u -= plane_size ; * op ++ = ( wchar_t ) ( surrogate_pair | ( ( u >> 10 ) & surrogate_bits ) ) ; * op ++ = ( wchar_t ) ( surrogate_pair | surrogate_low | ( u & surrogate_bits ) ) ; } else { * op ++ = ( wchar_t ) u ; } s += size ; len -= size ; } else { * op ++ = * s ++ ; len -- ; } } return op - pwcs ; }","<S2SV_ModStart> int len , enum utf16_endian endian , <S2SV_ModStart> wchar_t * pwcs , int maxlen <S2SV_ModStart> ; while ( <S2SV_ModEnd> len > 0 <S2SV_ModStart> len > 0 && maxlen > 0 && * s <S2SV_ModStart> - EINVAL ; s += size ; len -= size ; <S2SV_ModStart> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <S2SV_ModStart> -= PLANE_SIZE ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | ( <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | SURROGATE_LOW <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> -- ; }
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug>"
3020,CWE-399,"static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = vm_fault_badcontext ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __fail_addr_mask ; perf_sw_event ( perf_count_sw_page_faults , 1 , 0 , regs , address ) ; flags = fault_flag_allow_retry ; if ( access == vm_write || ( trans_exc_code & store_indication ) == 0x400 ) flags |= fault_flag_write ; retry : down_read ( & mm -> mmap_sem ) ; fault = vm_fault_badmap ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & vm_growsdown ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = vm_fault_badaccess ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= hpage_mask ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & vm_fault_error ) ) goto out_up ; if ( flags & fault_flag_allow_retry ) { if ( fault & vm_fault_major ) { tsk -> maj_flt ++ ; perf_sw_event ( perf_count_sw_page_faults_maj , 1 , 0 , regs , address ) ; } else { tsk -> min_flt ++ ; perf_sw_event ( perf_count_sw_page_faults_min , 1 , 0 , regs , address ) ; } if ( fault & vm_fault_retry ) { flags &= ~ fault_flag_allow_retry ; goto retry ; } } clear_tsk_thread_flag ( tsk , tif_per_trap ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug>"
4806,CWE-444,"value request_env ( agooreq req , value self ) { if ( qnil == ( value ) req -> env ) { volatile value env = rb_hash_new ( ) ; rb_hash_aset ( env , request_method_val , req_method ( req ) ) ; rb_hash_aset ( env , script_name_val , req_script_name ( req ) ) ; rb_hash_aset ( env , path_info_val , req_path_info ( req ) ) ; rb_hash_aset ( env , query_string_val , req_query_string ( req ) ) ; rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; fill_headers ( req , env ) ; rb_hash_aset ( env , rack_version_val , rack_version_val_val ) ; rb_hash_aset ( env , rack_url_scheme_val , req_rack_url_scheme ( req ) ) ; rb_hash_aset ( env , rack_input_val , req_rack_input ( req ) ) ; rb_hash_aset ( env , rack_errors_val , req_rack_errors ( req ) ) ; rb_hash_aset ( env , rack_multithread_val , req_rack_multithread ( req ) ) ; rb_hash_aset ( env , rack_multiprocess_val , qfalse ) ; rb_hash_aset ( env , rack_run_once_val , qfalse ) ; rb_hash_aset ( env , rack_logger_val , req_rack_logger ( req ) ) ; rb_hash_aset ( env , rack_upgrade_val , req_rack_upgrade ( req ) ) ; rb_hash_aset ( env , rack_hijackq_val , qtrue ) ; rb_hash_aset ( env , rack_hijack_val , self ) ; rb_hash_aset ( env , rack_hijack_io_val , qnil ) ; if ( agoo_server . rack_early_hints ) { volatile value eh = agoo_early_hints_new ( req ) ; rb_hash_aset ( env , early_hints_val , eh ) ; } req -> env = ( void * ) env ; } return ( value ) req -> env ; }","<S2SV_ModStart> ( env , remote_addr_val , req_remote_addr ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; rb_hash_aset ( env , <S2SV_ModStart> server_name_val , req_server_name <S2SV_ModEnd> ( req )
",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z,"<S2SV_StartBug> rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; <S2SV_EndBug>"
4537,CWE-125,"static int ast_type_init ( pyobject * self , pyobject * args , pyobject * kw ) { _py_identifier ( _fields ) ; py_ssize_t i , numfields = 0 ; int res = - 1 ; pyobject * key , * value , * fields ; fields = _pyobject_getattrid ( ( pyobject * ) py_type ( self ) , & pyid__fields ) ; if ( ! fields ) pyerr_clear ( ) ; if ( fields ) { numfields = pysequence_size ( fields ) ; if ( numfields == - 1 ) goto cleanup ; } res = 0 ; if ( pytuple_get_size ( args ) > 0 ) { if ( numfields != pytuple_get_size ( args ) ) { pyerr_format ( pyexc_typeerror , ""%.400s<s2sv_blank>constructor<s2sv_blank>takes<s2sv_blank>%s"" ""%zd<s2sv_blank>positional<s2sv_blank>argument%s"" , py_type ( self ) -> tp_name , numfields == 0 ? """" : ""either<s2sv_blank>0<s2sv_blank>or<s2sv_blank>"" , numfields , numfields == 1 ? """" : ""s"" ) ; res = - 1 ; goto cleanup ; } for ( i = 0 ; i < pytuple_get_size ( args ) ; i ++ ) { pyobject * name = pysequence_getitem ( fields , i ) ; if ( ! name ) { res = - 1 ; goto cleanup ; } res = pyobject_setattr ( self , name , pytuple_get_item ( args , i ) ) ; py_decref ( name ) ; if ( res < 0 ) goto cleanup ; } } if ( kw ) { i = 0 ; while ( pydict_next ( kw , & i , & key , & value ) ) { res = pyobject_setattr ( self , key , value ) ; if ( res < 0 ) goto cleanup ; } } cleanup : py_xdecref ( fields ) ; return res ; }","<S2SV_ModStart> kw ) { <S2SV_ModEnd> Py_ssize_t i , <S2SV_ModStart> * fields ; if ( lookup_attr_id <S2SV_ModEnd> ( ( PyObject <S2SV_ModStart> , & PyId__fields , & fields ) < 0 ) { goto cleanup ; } <S2SV_ModEnd> if ( fields <S2SV_ModStart> ; if ( numfields < <S2SV_ModStart> ( args ) <S2SV_ModEnd> ) { PyErr_Format <S2SV_ModStart> ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>at<S2SV_blank>most<S2SV_blank>"" <S2SV_ModEnd> ""%zd<S2SV_blank>positional<S2SV_blank>argument%s"" , Py_TYPE <S2SV_ModStart> ) -> tp_name <S2SV_ModEnd> , numfields , <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> if ( kw
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> _Py_IDENTIFIER ( _fields ) ; <S2SV_EndBug> <S2SV_StartBug> fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ; <S2SV_EndBug> <S2SV_StartBug> if ( PyTuple_GET_SIZE ( args ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> PyErr_Format ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>%s"" <S2SV_EndBug> <S2SV_StartBug> Py_TYPE ( self ) -> tp_name , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
3107,CWE-20,"static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; if ( dh == null ) { msg = ""nf_ct_dccp:<s2sv_blank>short<s2sv_blank>packet<s2sv_blank>"" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = ""nf_ct_dccp:<s2sv_blank>truncated/malformed<s2sv_blank>packet<s2sv_blank>"" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = ""nf_ct_dccp:<s2sv_blank>bad<s2sv_blank>checksum<s2sv_blank>coverage<s2sv_blank>"" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == nf_inet_pre_routing && nf_checksum_partial ( skb , hooknum , dataoff , cscov , ipproto_dccp , pf ) ) { msg = ""nf_ct_dccp:<s2sv_blank>bad<s2sv_blank>checksum<s2sv_blank>"" ; goto out_invalid ; } if ( dh -> dccph_type >= dccp_pkt_invalid ) { msg = ""nf_ct_dccp:<s2sv_blank>reserved<s2sv_blank>packet<s2sv_blank>type<s2sv_blank>"" ; goto out_invalid ; } return nf_accept ; out_invalid : if ( log_invalid ( net , ipproto_dccp ) ) nf_log_packet ( net , pf , 0 , skb , null , null , null , ""%s"" , msg ) ; return - nf_accept ; }","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug>"
4518,CWE-125,static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) pymem_malloc ( sizeof ( struct tok_state ) ) ; if ( tok == null ) return null ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = null ; tok -> done = e_ok ; tok -> fp = null ; tok -> input = null ; tok -> tabsize = tabsize ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = null ; tok -> lineno = 0 ; tok -> level = 0 ; tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = state_init ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = null ; tok -> encoding = null ; tok -> cont_line = 0 ; # ifndef pgen tok -> filename = null ; tok -> decoding_readline = null ; tok -> decoding_buffer = null ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; return tok ; },"<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> <S2SV_StartBug> return tok ; <S2SV_EndBug>
1085,CWE-000,"int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == acl_type_access ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return 0 ; if ( error == 0 ) acl = null ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
",torvalds@linux/497de07d89c1410d76a15bec2bb41f24a2a89f31,CVE-2017-5551,https://github.com/torvalds/linux/commit/497de07d89c1410d76a15bec2bb41f24a2a89f31,2017-02-06T06:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug>"
626,CWE-476,"static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == null ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; } is_request = ( pinfo -> srcport == no_endpoint ) ; col_set_str ( pinfo -> cinfo , col_protocol , ""usbms"" ) ; col_clear ( pinfo -> cinfo , col_info ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , ""usb<s2sv_blank>mass<s2sv_blank>storage"" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dcbwsignature , tvb , offset , 4 , enc_little_endian ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dcbwtag , tvb , offset , 4 , enc_little_endian ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dcbwdatatransferlength , tvb , offset , 4 , enc_little_endian ) ; datalen = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dcbwflags , tvb , offset , 1 , enc_little_endian ) ; flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; proto_tree_add_item ( tree , hf_usb_ms_dcbwtarget , tvb , offset , 1 , enc_little_endian ) ; proto_tree_add_item ( tree , hf_usb_ms_dcbwlun , tvb , offset , 1 , enc_little_endian ) ; lun = tvb_get_guint8 ( tvb , offset ) & 0x0f ; offset += 1 ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , lun ) ; if ( ! itl ) { itl = wmem_new ( wmem_file_scope ( ) , itl_nexus_t ) ; itl -> cmdset = 0xff ; itl -> conversation = null ; wmem_tree_insert32 ( usb_ms_conv_info -> itl , lun , itl ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { itlq = wmem_new ( wmem_file_scope ( ) , itlq_nexus_t ) ; itlq -> lun = lun ; itlq -> scsi_opcode = 0xffff ; itlq -> task_flags = 0 ; if ( datalen ) { if ( flags & 0x80 ) { itlq -> task_flags |= scsi_data_read ; } else { itlq -> task_flags |= scsi_data_write ; } } itlq -> data_length = datalen ; itlq -> bidir_data_length = 0 ; itlq -> fc_time = pinfo -> abs_ts ; itlq -> first_exchange_frame = pinfo -> num ; itlq -> last_exchange_frame = 0 ; itlq -> flags = 0 ; itlq -> alloc_len = 0 ; itlq -> extra_data = null ; wmem_tree_insert32 ( usb_ms_conv_info -> itlq , pinfo -> num , itlq ) ; } proto_tree_add_item ( tree , hf_usb_ms_dcbwcblength , tvb , offset , 1 , enc_little_endian ) ; cdbrlen = tvb_get_guint8 ( tvb , offset ) & 0x1f ; offset += 1 ; cdblen = cdbrlen ; if ( cdblen > tvb_captured_length_remaining ( tvb , offset ) ) { cdblen = tvb_captured_length_remaining ( tvb , offset ) ; } if ( cdblen ) { cdb_tvb = tvb_new_subset ( tvb , offset , cdblen , cdbrlen ) ; dissect_scsi_cdb ( cdb_tvb , pinfo , parent_tree , scsi_dev_unknown , itlq , itl ) ; } return tvb_captured_length ( tvb ) ; } if ( ( ! is_request ) && ( signature == 0x53425355 ) && ( tvb_reported_length ( tvb ) == 13 ) ) { guint8 status ; proto_tree_add_item ( tree , hf_usb_ms_dcswsignature , tvb , offset , 4 , enc_little_endian ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dcbwtag , tvb , offset , 4 , enc_little_endian ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dcswdataresidue , tvb , offset , 4 , enc_little_endian ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dcswstatus , tvb , offset , 1 , enc_little_endian ) ; status = tvb_get_guint8 ( tvb , offset ) ; itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itlq -> last_exchange_frame = pinfo -> num ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } if ( ! status ) { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0 ) ; } else { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0x02 ) ; } return tvb_captured_length ( tvb ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } dissect_scsi_payload ( tvb , pinfo , parent_tree , is_request , itlq , itl , 0 ) ; return tvb_captured_length ( tvb ) ; }","<S2SV_ModStart> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
",wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z,<S2SV_StartBug> } <S2SV_EndBug>
6946,CWE-400,"int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , int nmi , int sample ) { struct ring_buffer * rb ; unsigned long tail , offset , head ; int have_lost ; struct perf_sample_data sample_data ; struct { struct perf_event_header header ; u64 id ; u64 lost ; } lost_event ; rcu_read_lock ( ) ; if ( event -> parent ) event = event -> parent ; rb = rcu_dereference ( event -> rb ) ; if ( ! rb ) goto out ; handle -> rb = rb ; handle -> event = event ; handle -> nmi = nmi ; handle -> sample = sample ; if ( ! rb -> nr_pages ) goto out ; have_lost = local_read ( & rb -> lost ) ; if ( have_lost ) { lost_event . header . size = sizeof ( lost_event ) ; perf_event_header__init_id ( & lost_event . header , & sample_data , event ) ; size += lost_event . header . size ; } perf_output_get_handle ( handle ) ; do { tail = access_once ( rb -> user_page -> data_tail ) ; smp_rmb ( ) ; offset = head = local_read ( & rb -> head ) ; head += size ; if ( unlikely ( ! perf_output_space ( rb , tail , offset , head ) ) ) goto fail ; } while ( local_cmpxchg ( & rb -> head , offset , head ) != offset ) ; if ( head - local_read ( & rb -> wakeup ) > rb -> watermark ) local_add ( rb -> watermark , & rb -> wakeup ) ; handle -> page = offset >> ( page_shift + page_order ( rb ) ) ; handle -> page &= rb -> nr_pages - 1 ; handle -> size = offset & ( ( page_size << page_order ( rb ) ) - 1 ) ; handle -> addr = rb -> data_pages [ handle -> page ] ; handle -> addr += handle -> size ; handle -> size = ( page_size << page_order ( rb ) ) - handle -> size ; if ( have_lost ) { lost_event . header . type = perf_record_lost ; lost_event . header . misc = 0 ; lost_event . id = event -> id ; lost_event . lost = local_xchg ( & rb -> lost , 0 ) ; perf_output_put ( handle , lost_event ) ; perf_event__output_id_sample ( event , handle , & sample_data ) ; } return 0 ; fail : local_inc ( & rb -> lost ) ; perf_output_put_handle ( handle ) ; out : rcu_read_unlock ( ) ; return - enospc ; }","<S2SV_ModStart> size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug>"
238,CWE-17,"static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = null ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! s_isreg ( inode -> i_mode ) ) return - einval ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , pagecache_tag_dirty ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - einval ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; flags = ext4_get_blocks_create_unwrit_ext | ext4_get_blocks_convert_unwritten | ext4_ex_nocache ; if ( mode & falloc_fl_keep_size ) flags |= ext4_get_blocks_keep_size ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , ext4_inode_extents ) ) ) { ret = - eopnotsupp ; goto out_mutex ; } if ( ! ( mode & falloc_fl_keep_size ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; } if ( max_blocks > 0 ) { truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , ext_max_blocks ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , ext4_ht_misc , credits ) ; if ( is_err ( handle ) ) { ret = ptr_err ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , ext4_inode_eofblocks ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & o_sync ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
",torvalds@linux/0f2af21aae11972fa924374ddcf52e88347cf5a8,CVE-2015-0275,https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8,2015-10-19T10:59Z,<S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug>
3170,CWE-125,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = bpf_op ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( bpf_class ( insn -> code ) == bpf_alu64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != bpf_add && opcode != bpf_sub && opcode != bpf_and ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case bpf_add : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case bpf_sub : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case bpf_mul : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > u32_max || dst_reg -> umax_value > u32_max ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > s64_max ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case bpf_and : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case bpf_or : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case bpf_lsh : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; if ( dst_reg -> umax_value > 1ull << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case bpf_rsh : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case bpf_arsh : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( bpf_class ( insn -> code ) != bpf_alu64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds (
",torvalds@linux/b799207e1e1816b09e7a5920fbb2d5fcf6edd681,CVE-2018-18445,https://github.com/torvalds/linux/commit/b799207e1e1816b09e7a5920fbb2d5fcf6edd681,2018-10-17T19:29Z,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug>"
7846,CWE-20,"error_t udpreceivedatagram ( socket * socket , socketmsg * message , uint_t flags ) { error_t error ; socketqueueitem * queueitem ; if ( ( flags & socket_flag_dont_wait ) == 0 ) { if ( socket -> receivequeue == null ) { socket -> eventmask = socket_event_rx_ready ; osresetevent ( & socket -> event ) ; osreleasemutex ( & netmutex ) ; oswaitforevent ( & socket -> event , socket -> timeout ) ; osacquiremutex ( & netmutex ) ; } } if ( socket -> receivequeue != null ) { queueitem = socket -> receivequeue ; message -> length = netbufferread ( message -> data , queueitem -> buffer , queueitem -> offset , message -> size ) ; message -> srcipaddr = queueitem -> srcipaddr ; message -> srcport = queueitem -> srcport ; message -> destipaddr = queueitem -> destipaddr ; message -> ttl = queueitem -> ancillary . ttl ; # if ( eth_support == enabled ) message -> srcmacaddr = queueitem -> ancillary . srcmacaddr ; message -> destmacaddr = queueitem -> ancillary . destmacaddr ; # endif # if ( eth_port_tagging_support == enabled ) message -> switchport = queueitem -> ancillary . port ; # endif # if ( eth_timestamp_support == enabled ) message -> timestamp = queueitem -> ancillary . timestamp ; # endif if ( ( flags & socket_flag_peek ) == 0 ) { socket -> receivequeue = queueitem -> next ; netbufferfree ( queueitem -> buffer ) ; } udpupdateevents ( socket ) ; error = no_error ; } else { message -> length = 0 ; error = error_timeout ; } return error ; }","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug>
7641,CWE-190,"int pnm_validate ( jas_stream_t * in ) { uchar buf [ 2 ] ; int i ; int n ; assert ( jas_stream_maxputback >= 2 ) ; if ( ( n = jas_stream_read ( in , buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == eof ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == 'p' && isdigit ( buf [ 1 ] ) ) { return 0 ; } return - 1 ; }","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ 2
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug>
2642,CWE-000,"int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : null ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , icmpv6_pkt_toobig , 0 , mtu ) ; ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; kfree_skb ( skb ) ; return - emsgsize ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < hlen ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; bug_on ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; * prevhdr = nexthdr_fragment ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , gfp_atomic ) ; if ( ! tmp_hdr ) { ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; return - enomem ; } __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; ipv6_select_ident ( fh ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( ip6_mf ) ; frag_id = fh -> identification ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = checksum_none ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next != null ) fh -> frag_off |= htons ( ip6_mf ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( skb ) ; if ( ! err ) ip6_inc_stats ( net , ip6_dst_idev ( & rt -> dst ) , ipstats_mib_fragcreates ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = null ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { ip6_inc_stats ( net , ip6_dst_idev ( & rt -> dst ) , ipstats_mib_fragoks ) ; dst_release ( & rt -> dst ) ; return 0 ; } while ( frag ) { skb = frag -> next ; kfree_skb ( frag ) ; frag = skb ; } ip6_inc_stats ( net , ip6_dst_idev ( & rt -> dst ) , ipstats_mib_fragfails ) ; dst_release ( & rt -> dst ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = null ; frag2 -> destructor = null ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; * prevhdr = nexthdr_fragment ; while ( left > 0 ) { len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } if ( ( frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + ll_allocated_space ( rt -> dst . dev ) , gfp_atomic ) ) == null ) { netdebug ( kern_info ""ipv6:<s2sv_blank>frag:<s2sv_blank>no<s2sv_blank>memory<s2sv_blank>for<s2sv_blank>new<s2sv_blank>fragment!\\n"" ) ; ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; err = - enomem ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , ll_reserved_space ( rt -> dst . dev ) ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; if ( ! frag_id ) { ipv6_select_ident ( fh ) ; frag_id = fh -> identification ; } else fh -> identification = frag_id ; if ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) bug ( ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( ip6_mf ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( frag ) ; if ( err ) goto fail ; ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragcreates ) ; } ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragoks ) ; kfree_skb ( skb ) ; return err ; fail : ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; kfree_skb ( skb ) ; return err ; }","<S2SV_ModStart> ipv6_select_ident ( fh , rt <S2SV_ModStart> ipv6_select_ident ( fh , rt
",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z,<S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug>
2410,CWE-264,"asmlinkage long sys_oabi_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) { struct oabi_flock64 user ; struct flock64 kernel ; mm_segment_t fs = user_ds ; unsigned long local_arg = arg ; int ret ; switch ( cmd ) { case f_ofd_getlk : case f_ofd_setlk : case f_ofd_setlkw : case f_getlk64 : case f_setlk64 : case f_setlkw64 : if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , sizeof ( user ) ) ) return - efault ; kernel . l_type = user . l_type ; kernel . l_whence = user . l_whence ; kernel . l_start = user . l_start ; kernel . l_len = user . l_len ; kernel . l_pid = user . l_pid ; local_arg = ( unsigned long ) & kernel ; fs = get_fs ( ) ; set_fs ( kernel_ds ) ; } ret = sys_fcntl64 ( fd , cmd , local_arg ) ; switch ( cmd ) { case f_getlk64 : if ( ! ret ) { user . l_type = kernel . l_type ; user . l_whence = kernel . l_whence ; user . l_start = kernel . l_start ; user . l_len = kernel . l_len ; user . l_pid = kernel . l_pid ; if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - efault ; } case f_setlk64 : case f_setlkw64 : set_fs ( fs ) ; } return ret ; }","<S2SV_ModStart> arg ) { <S2SV_ModEnd> switch ( cmd <S2SV_ModStart> case F_SETLKW64 : return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> sys_fcntl64 ( fd <S2SV_ModStart> , cmd , arg <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/76cc404bfdc0d419c720de4daaf2584542734f42,CVE-2015-8966,https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42,2016-12-08T21:59Z,"<S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
2322,CWE-119,"int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; int req_len ; struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; qeth_card_text ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - eopnotsupp ; if ( ( ! qeth_adp_supported ( card , ipa_setadp_set_snmp_control ) ) && ( ! card -> options . layer2 ) ) { return - eopnotsupp ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - efault ; ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( is_err ( ureq ) ) { qeth_card_text ( card , 2 , ""snmpnome"" ) ; return ptr_err ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , gfp_kernel ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - enomem ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , ipa_setadp_set_snmp_control , qeth_snmp_setadp_cmdlength + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + ipa_pdu_header_size ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , qeth_setadp_base_len + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) qeth_dbf_message ( 2 , ""snmp<s2sv_blank>command<s2sv_blank>failed<s2sv_blank>on<s2sv_blank>%s:<s2sv_blank>(0x%x)\\n"" , qeth_card_ifname ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - efault ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }","<S2SV_ModStart> * ureq ; unsigned <S2SV_ModStart> return - EFAULT ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL
",torvalds@linux/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,CVE-2013-6381,https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,2013-11-27T04:43Z,<S2SV_StartBug> int req_len ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
3639,CWE-20,"static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= uio_maxiov ) ) { r = - enobufs ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , array_size ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<s2sv_blank>descriptor<s2sv_blank>format<s2sv_blank>for<s2sv_blank>rx:<s2sv_blank>"" ""out<s2sv_blank>%d,<s2sv_blank>in<s2sv_blank>%d\\n"" , out , in ) ; r = - einval ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; return headcount ; err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }","<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,<S2SV_StartBug> return headcount ; <S2SV_EndBug>
5494,CWE-668,"int main ( int argc , const char * argv [ ] ) { struct group * grent ; const char * cmd ; const char * path ; int i ; struct passwd * pw ; grent = getgrnam ( abuild_group ) ; if ( grent == null ) errx ( 1 , ""%s:<s2sv_blank>group<s2sv_blank>not<s2sv_blank>found"" , abuild_group ) ; char * name = null ; pw = getpwuid ( getuid ( ) ) ; if ( pw ) name = pw -> pw_name ; if ( ! is_in_group ( grent -> gr_gid ) ) { errx ( 1 , ""user<s2sv_blank>%s<s2sv_blank>is<s2sv_blank>not<s2sv_blank>a<s2sv_blank>member<s2sv_blank>of<s2sv_blank>group<s2sv_blank>%s\\n"" , name ? name : ""(unknown)"" , abuild_group ) ; } if ( name == null ) warnx ( ""could<s2sv_blank>not<s2sv_blank>find<s2sv_blank>username<s2sv_blank>for<s2sv_blank>uid<s2sv_blank>%d\\n"" , getuid ( ) ) ; setenv ( ""user"" , name ? : """" , 1 ) ; cmd = strrchr ( argv [ 0 ] , '/' ) ; if ( cmd ) cmd ++ ; else cmd = argv [ 0 ] ; cmd = strchr ( cmd , '-' ) ; if ( cmd == null ) errx ( 1 , ""calling<s2sv_blank>command<s2sv_blank>has<s2sv_blank>no<s2sv_blank>\'-\'"" ) ; cmd ++ ; path = get_command_path ( cmd ) ; if ( path == null ) errx ( 1 , ""%s:<s2sv_blank>not<s2sv_blank>a<s2sv_blank>valid<s2sv_blank>subcommand"" , cmd ) ; for ( i = 1 ; i < argc ; i ++ ) if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) errx ( 1 , ""%s:<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>option"" , ""--allow-untrusted"" ) ; argv [ 0 ] = path ; setuid ( 0 ) ; setgid ( 0 ) ; execv ( path , ( char * const * ) argv ) ; perror ( path ) ; return 1 ; }","<S2SV_ModStart> i ++ ) check_option ( argv [ i ] <S2SV_ModEnd> ) ; argv
",sroracle@abuild/4f90ce92778d0ee302e288def75591b96a397c8b,CVE-2019-12875,https://github.com/sroracle/abuild/commit/4f90ce92778d0ee302e288def75591b96a397c8b,2019-06-18T19:15Z,"<S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug>"
3660,CWE-000,"long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - einval ; if ( info -> si_code >= 0 ) return - eperm ; info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }","<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
",torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z,<S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug>
4209,CWE-78,"r_api char * r_socket_http_get ( const char * url , int * code , int * rlen ) { char * curl_env = r_sys_getenv ( ""r2_curl"" ) ; if ( curl_env && * curl_env ) { char * encoded_url = r_str_escape ( url ) ; char * res = r_sys_cmd_strf ( ""curl<s2sv_blank>\'%s\'"" , encoded_url ) ; free ( encoded_url ) ; if ( res ) { if ( code ) { * code = 200 ; } if ( rlen ) { * rlen = strlen ( res ) ; } } free ( curl_env ) ; return res ; } free ( curl_env ) ; rsocket * s ; int ssl = r_str_startswith ( url , ""https://"" ) ; char * response , * host , * path , * port = ""80"" ; char * uri = strdup ( url ) ; if ( ! uri ) { return null ; } if ( code ) { * code = 0 ; } if ( rlen ) { * rlen = 0 ; } host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; eprintf ( ""r_socket_http_get:<s2sv_blank>invalid<s2sv_blank>uri"" ) ; return null ; } host += 3 ; port = strchr ( host , ':' ) ; if ( ! port ) { port = ssl ? ""443"" : ""80"" ; path = host ; } else { * port ++ = 0 ; path = port ; } path = strchr ( path , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { eprintf ( ""r_socket_http_get:<s2sv_blank>cannot<s2sv_blank>create<s2sv_blank>socket\\n"" ) ; free ( uri ) ; return null ; } if ( r_socket_connect_tcp ( s , host , port , 0 ) ) { r_socket_printf ( s , ""get<s2sv_blank>/%s<s2sv_blank>http/1.1\\r\\n"" ""user-agent:<s2sv_blank>radare2<s2sv_blank>"" r2_version ""\\r\\n"" ""accept:<s2sv_blank>*/*\\r\\n"" ""host:<s2sv_blank>%s:%s\\r\\n"" ""\\r\\n"" , path , host , port ) ; response = r_socket_http_answer ( s , code , rlen ) ; } else { eprintf ( ""cannot<s2sv_blank>connect<s2sv_blank>to<s2sv_blank>%s:%s\\n"" , host , port ) ; response = null ; } free ( uri ) ; r_socket_free ( s ) ; return response ; }","<S2SV_ModStart> rlen ) { return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,"<S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
4511,CWE-125,"static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = e_nomem ; ta3tokenizer_free ( tok ) ; return null ; } if ( ( ps = ta3parser_new ( g , start ) ) == null ) { err_ret -> error = e_nomem ; ta3tokenizer_free ( tok ) ; return null ; } # ifdef py_parser_requires_future_keyword if ( * flags & pyparse_barry_as_bdfl ) ps -> p_flags |= co_future_barry_as_bdfl ; # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; int col_offset ; type = ta3tokenizer_get ( tok , & a , & b ) ; if ( type == errortoken ) { err_ret -> error = tok -> done ; break ; } if ( type == endmarker && started ) { type = newline ; started = 0 ; if ( tok -> indent && ! ( * flags & pyparse_dont_imply_dedent ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = b - a ; str = ( char * ) pyobject_malloc ( len + 1 ) ; if ( str == null ) { err_ret -> error = e_nomem ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef py_parser_requires_future_keyword if ( type == notequal ) { if ( ! ( ps -> p_flags & co_future_barry_as_bdfl ) && strcmp ( str , ""!="" ) ) { pyobject_free ( str ) ; err_ret -> error = e_syntax ; break ; } else if ( ( ps -> p_flags & co_future_barry_as_bdfl ) && strcmp ( str , ""<>"" ) ) { pyobject_free ( str ) ; err_ret -> text = ""with<s2sv_blank>barry<s2sv_blank>as<s2sv_blank>bdfl,<s2sv_blank>use<s2sv_blank>\'<>\'<s2sv_blank>"" ""instead<s2sv_blank>of<s2sv_blank>\'!=\'"" ; err_ret -> error = e_syntax ; break ; } } # endif if ( a >= tok -> line_start ) col_offset = py_safe_downcast ( a - tok -> line_start , intptr_t , int ) ; else col_offset = - 1 ; if ( type == type_ignore ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = e_nomem ; break ; } continue ; } if ( ( err_ret -> error = ta3parser_addtoken ( ps , ( int ) type , str , tok -> lineno , col_offset , & ( err_ret -> expected ) ) ) != e_ok ) { if ( err_ret -> error != e_done ) { pyobject_free ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == e_done ) { n = ps -> p_tree ; ps -> p_tree = null ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = nch ( n ) ; ch = child ( n , num - 1 ) ; req ( ch , endmarker ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { ta3node_addchild ( ch , type_ignore , null , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores ) ; # ifndef pgen if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<s2sv_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = e_badsingle ; ta3node_free ( n ) ; n = null ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = null ; # ifdef py_parser_requires_future_keyword * flags = ps -> p_flags ; # endif ta3parser_delete ( ps ) ; if ( n == null ) { if ( tok -> done == e_eof ) err_ret -> error = e_eof ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != null ) { size_t len ; assert ( tok -> cur - tok -> buf < int_max ) ; err_ret -> offset = ( int ) ( tok -> cur - tok -> buf ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) pyobject_malloc ( len + 1 ) ; if ( err_ret -> text != null ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != null ) { node * r = ta3node_new ( encoding_decl ) ; if ( r ) r -> n_str = pyobject_malloc ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = e_nomem ; if ( r ) pyobject_free ( r ) ; n = null ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; pymem_free ( tok -> encoding ) ; tok -> encoding = null ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : ta3tokenizer_free ( tok ) ; return n ; }","<S2SV_ModStart> ; len = ( a != NULL && b != NULL ) ? <S2SV_ModStart> b - a : 0 <S2SV_ModStart> ; err_ret -> expected = NOTEQUAL <S2SV_ModEnd> ; err_ret -> <S2SV_ModStart> if ( a != NULL && a <S2SV_ModStart> -> line_start ) { <S2SV_ModStart> int ) ; } else { <S2SV_ModEnd> col_offset = - <S2SV_ModStart> - 1 ; }
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> len = b - a ; <S2SV_EndBug> <S2SV_StartBug> err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\'<>\'<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> if ( a >= tok -> line_start ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> col_offset = - 1 ; <S2SV_EndBug>"
7877,CWE-20,"void ksz8851eventhandler ( netinterface * interface ) { uint16_t status ; uint_t framecount ; status = ksz8851readreg ( interface , ksz8851_reg_isr ) ; if ( ( status & isr_lcis ) != 0 ) { ksz8851writereg ( interface , ksz8851_reg_isr , isr_lcis ) ; status = ksz8851readreg ( interface , ksz8851_reg_p1sr ) ; if ( ( status & p1sr_link_good ) != 0 ) { if ( ( status & p1sr_operation_speed ) != 0 ) { interface -> linkspeed = nic_link_speed_100mbps ; } else { interface -> linkspeed = nic_link_speed_10mbps ; } if ( ( status & p1sr_operation_duplex ) != 0 ) { interface -> duplexmode = nic_full_duplex_mode ; } else { interface -> duplexmode = nic_half_duplex_mode ; } interface -> linkstate = true ; } else { interface -> linkstate = false ; } nicnotifylinkchange ( interface ) ; } if ( ( status & isr_rxis ) != 0 ) { ksz8851writereg ( interface , ksz8851_reg_isr , isr_rxis ) ; framecount = msb ( ksz8851readreg ( interface , ksz8851_reg_rxfctr ) ) ; while ( framecount > 0 ) { ksz8851receivepacket ( interface ) ; framecount -- ; } } ksz8851setbit ( interface , ksz8851_reg_ier , ier_lcie | ier_rxie ) ; }","<S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( status & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , KSZ8851_P1SR ) ; if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) { if ( ( status & KSZ8851_P1SR_OPERATION_SPEED <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_P1SR_OPERATION_DUPLEX <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_RXIS <S2SV_ModEnd> ) ; frameCount <S2SV_ModStart> ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ; <S2SV_EndBug> <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_RXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ; <S2SV_EndBug> <S2SV_StartBug> frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ; <S2SV_EndBug>"
2717,CWE-200,"static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( cd_do_ioctl , ""entering<s2sv_blank>cdrom_drive_status\\n"" ) ; if ( ! ( cdi -> ops -> capability & cdc_drive_status ) ) return - enosys ; if ( ! cdrom_can ( cdc_select_disc ) || ( arg == cdsl_current || arg == cdsl_none ) ) return cdi -> ops -> drive_status ( cdi , cdsl_current ) ; if ( ( ( int ) arg >= cdi -> capacity ) ) return - einval ; return cdrom_slot_status ( cdi , arg ) ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
",torvalds@linux/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4,CVE-2018-16658,https://github.com/torvalds/linux/commit/8f3fafc9c2f0ece10832c25f7ffcb07c97a32ad4,2018-09-07T14:29Z,<S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug>
3478,CWE-284,"static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { list_head ( tmp_list ) ; struct mount * p ; if ( how & umount_propagate ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= mnt_umount ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & umount_propagate ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = null ; if ( how & umount_sync ) p -> mnt . mnt_flags |= mnt_sync_umount ; pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; umount_mnt ( p ) ; } change_mnt_propagation ( p , ms_private ) ; } }","<S2SV_ModStart> ) ) { bool disconnect ; <S2SV_ModStart> |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> ) ; } }
",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z,"<S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug>"
2434,CWE-399,"int hugepage_madvise ( struct vm_area_struct * vma , unsigned long * vm_flags , int advice ) { switch ( advice ) { case madv_hugepage : if ( * vm_flags & ( vm_hugepage | vm_shared | vm_mayshare | vm_pfnmap | vm_io | vm_dontexpand | vm_reserved | vm_hugetlb | vm_insertpage | vm_mixedmap | vm_sao ) ) return - einval ; * vm_flags &= ~ vm_nohugepage ; * vm_flags |= vm_hugepage ; if ( unlikely ( khugepaged_enter_vma_merge ( vma ) ) ) return - enomem ; break ; case madv_nohugepage : if ( * vm_flags & ( vm_nohugepage | vm_shared | vm_mayshare | vm_pfnmap | vm_io | vm_dontexpand | vm_reserved | vm_hugetlb | vm_insertpage | vm_mixedmap | vm_sao ) ) return - einval ; * vm_flags &= ~ vm_hugepage ; * vm_flags |= vm_nohugepage ; break ; } return 0 ; }","<S2SV_ModStart> ( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return
",torvalds@linux/78f11a255749d09025f54d4e2df4fbcb031530e2,CVE-2011-2479,https://github.com/torvalds/linux/commit/78f11a255749d09025f54d4e2df4fbcb031530e2,2013-03-01T12:37Z,<S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug>
6872,CWE-000,"static int selectexpander ( walker * pwalker , select * p ) { parse * pparse = pwalker -> pparse ; int i , j , k ; srclist * ptablist ; exprlist * pelist ; struct srclist_item * pfrom ; sqlite3 * db = pparse -> db ; expr * pe , * pright , * pexpr ; u16 selflags = p -> selflags ; u32 elistflags = 0 ; p -> selflags |= sf_expanded ; if ( db -> mallocfailed ) { return wrc_abort ; } assert ( p -> psrc != 0 ) ; if ( ( selflags & sf_expanded ) != 0 ) { return wrc_prune ; } if ( pwalker -> ecode ) { p -> selid = ++ pparse -> nselect ; } ptablist = p -> psrc ; pelist = p -> pelist ; sqlite3withpush ( pparse , p -> pwith , 0 ) ; sqlite3srclistassigncursors ( pparse , ptablist ) ; for ( i = 0 , pfrom = ptablist -> a ; i < ptablist -> nsrc ; i ++ , pfrom ++ ) { table * ptab ; assert ( pfrom -> fg . isrecursive == 0 || pfrom -> ptab != 0 ) ; if ( pfrom -> fg . isrecursive ) continue ; assert ( pfrom -> ptab == 0 ) ; # ifndef sqlite_omit_cte if ( withexpand ( pwalker , pfrom ) ) return wrc_abort ; if ( pfrom -> ptab ) { } else # endif if ( pfrom -> zname == 0 ) { # ifndef sqlite_omit_subquery select * psel = pfrom -> pselect ; assert ( psel != 0 ) ; assert ( pfrom -> ptab == 0 ) ; if ( sqlite3walkselect ( pwalker , psel ) ) return wrc_abort ; if ( sqlite3expandsubquery ( pparse , pfrom ) ) return wrc_abort ; # endif } else { assert ( pfrom -> ptab == 0 ) ; pfrom -> ptab = ptab = sqlite3locatetableitem ( pparse , 0 , pfrom ) ; if ( ptab == 0 ) return wrc_abort ; if ( ptab -> ntabref >= 0xffff ) { sqlite3errormsg ( pparse , ""too<s2sv_blank>many<s2sv_blank>references<s2sv_blank>to<s2sv_blank>\\""%s\\"":<s2sv_blank>max<s2sv_blank>65535"" , ptab -> zname ) ; pfrom -> ptab = 0 ; return wrc_abort ; } ptab -> ntabref ++ ; if ( ! isvirtual ( ptab ) && cannotbefunction ( pparse , pfrom ) ) { return wrc_abort ; } # if ! defined ( sqlite_omit_view ) || ! defined ( sqlite_omit_virtualtable ) if ( isvirtual ( ptab ) || ptab -> pselect ) { i16 ncol ; u8 ecodeorig = pwalker -> ecode ; if ( sqlite3viewgetcolumnnames ( pparse , ptab ) ) return wrc_abort ; assert ( pfrom -> pselect == 0 ) ; if ( ptab -> pselect && ( db -> flags & sqlite_enableview ) == 0 ) { sqlite3errormsg ( pparse , ""access<s2sv_blank>to<s2sv_blank>view<s2sv_blank>\\""%s\\""<s2sv_blank>prohibited"" , ptab -> zname ) ; } pfrom -> pselect = sqlite3selectdup ( db , ptab -> pselect , 0 ) ; ncol = ptab -> ncol ; ptab -> ncol = - 1 ; pwalker -> ecode = 1 ; sqlite3walkselect ( pwalker , pfrom -> pselect ) ; pwalker -> ecode = ecodeorig ; ptab -> ncol = ncol ; } # endif } if ( sqlite3indexedbylookup ( pparse , pfrom ) ) { return wrc_abort ; } } if ( db -> mallocfailed || sqliteprocessjoin ( pparse , p ) ) { return wrc_abort ; } for ( k = 0 ; k < pelist -> nexpr ; k ++ ) { pe = pelist -> a [ k ] . pexpr ; if ( pe -> op == tk_asterisk ) break ; assert ( pe -> op != tk_dot || pe -> pright != 0 ) ; assert ( pe -> op != tk_dot || ( pe -> pleft != 0 && pe -> pleft -> op == tk_id ) ) ; if ( pe -> op == tk_dot && pe -> pright -> op == tk_asterisk ) break ; elistflags |= pe -> flags ; } if ( k < pelist -> nexpr ) { struct exprlist_item * a = pelist -> a ; exprlist * pnew = 0 ; int flags = pparse -> db -> flags ; int longnames = ( flags & sqlite_fullcolnames ) != 0 && ( flags & sqlite_shortcolnames ) == 0 ; for ( k = 0 ; k < pelist -> nexpr ; k ++ ) { pe = a [ k ] . pexpr ; elistflags |= pe -> flags ; pright = pe -> pright ; assert ( pe -> op != tk_dot || pright != 0 ) ; if ( pe -> op != tk_asterisk && ( pe -> op != tk_dot || pright -> op != tk_asterisk ) ) { pnew = sqlite3exprlistappend ( pparse , pnew , a [ k ] . pexpr ) ; if ( pnew ) { pnew -> a [ pnew -> nexpr - 1 ] . zname = a [ k ] . zname ; pnew -> a [ pnew -> nexpr - 1 ] . zspan = a [ k ] . zspan ; a [ k ] . zname = 0 ; a [ k ] . zspan = 0 ; } a [ k ] . pexpr = 0 ; } else { int tableseen = 0 ; char * ztname = 0 ; if ( pe -> op == tk_dot ) { assert ( pe -> pleft != 0 ) ; assert ( ! exprhasproperty ( pe -> pleft , ep_intvalue ) ) ; ztname = pe -> pleft -> u . ztoken ; } for ( i = 0 , pfrom = ptablist -> a ; i < ptablist -> nsrc ; i ++ , pfrom ++ ) { table * ptab = pfrom -> ptab ; select * psub = pfrom -> pselect ; char * ztabname = pfrom -> zalias ; const char * zschemaname = 0 ; int idb ; if ( ztabname == 0 ) { ztabname = ptab -> zname ; } if ( db -> mallocfailed ) break ; if ( psub == 0 || ( psub -> selflags & sf_nestedfrom ) == 0 ) { psub = 0 ; if ( ztname && sqlite3stricmp ( ztname , ztabname ) != 0 ) { continue ; } idb = sqlite3schematoindex ( db , ptab -> pschema ) ; zschemaname = idb >= 0 ? db -> adb [ idb ] . zdbsname : ""*"" ; } for ( j = 0 ; j < ptab -> ncol ; j ++ ) { char * zname = ptab -> acol [ j ] . zname ; char * zcolname ; char * ztofree ; token scolname ; assert ( zname ) ; if ( ztname && psub && sqlite3matchspanname ( psub -> pelist -> a [ j ] . zspan , 0 , ztname , 0 ) == 0 ) { continue ; } if ( ( p -> selflags & sf_includehidden ) == 0 && ishiddencolumn ( & ptab -> acol [ j ] ) ) { continue ; } tableseen = 1 ; if ( i > 0 && ztname == 0 ) { if ( ( pfrom -> fg . jointype & jt_natural ) != 0 && tableandcolumnindex ( ptablist , i , zname , 0 , 0 ) ) { continue ; } if ( sqlite3idlistindex ( pfrom -> pusing , zname ) >= 0 ) { continue ; } } pright = sqlite3expr ( db , tk_id , zname ) ; zcolname = zname ; ztofree = 0 ; if ( longnames || ptablist -> nsrc > 1 ) { expr * pleft ; pleft = sqlite3expr ( db , tk_id , ztabname ) ; pexpr = sqlite3pexpr ( pparse , tk_dot , pleft , pright ) ; if ( zschemaname ) { pleft = sqlite3expr ( db , tk_id , zschemaname ) ; pexpr = sqlite3pexpr ( pparse , tk_dot , pleft , pexpr ) ; } if ( longnames ) { zcolname = sqlite3mprintf ( db , ""%s.%s"" , ztabname , zname ) ; ztofree = zcolname ; } } else { pexpr = pright ; } pnew = sqlite3exprlistappend ( pparse , pnew , pexpr ) ; sqlite3tokeninit ( & scolname , zcolname ) ; sqlite3exprlistsetname ( pparse , pnew , & scolname , 0 ) ; if ( pnew && ( p -> selflags & sf_nestedfrom ) != 0 ) { struct exprlist_item * px = & pnew -> a [ pnew -> nexpr - 1 ] ; if ( psub ) { px -> zspan = sqlite3dbstrdup ( db , psub -> pelist -> a [ j ] . zspan ) ; testcase ( px -> zspan == 0 ) ; } else { px -> zspan = sqlite3mprintf ( db , ""%s.%s.%s"" , zschemaname , ztabname , zcolname ) ; testcase ( px -> zspan == 0 ) ; } px -> bspanistab = 1 ; } sqlite3dbfree ( db , ztofree ) ; } } if ( ! tableseen ) { if ( ztname ) { sqlite3errormsg ( pparse , ""no<s2sv_blank>such<s2sv_blank>table:<s2sv_blank>%s"" , ztname ) ; } else { sqlite3errormsg ( pparse , ""no<s2sv_blank>tables<s2sv_blank>specified"" ) ; } } } } sqlite3exprlistdelete ( db , pelist ) ; p -> pelist = pnew ; } if ( p -> pelist ) { if ( p -> pelist -> nexpr > db -> alimit [ sqlite_limit_column ] ) { sqlite3errormsg ( pparse , ""too<s2sv_blank>many<s2sv_blank>columns<s2sv_blank>in<s2sv_blank>result<s2sv_blank>set"" ) ; return wrc_abort ; } if ( ( elistflags & ( ep_hasfunc | ep_subquery ) ) != 0 ) { p -> selflags |= sf_complexresult ; } } return wrc_continue ; }","<S2SV_ModStart> } if ( pParse -> nErr ||
",sqlite@sqlite/a6c1a71cde082e09750465d5675699062922e387,CVE-2019-20218,https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387,2020-01-02T14:16Z,"<S2SV_StartBug> if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) { <S2SV_EndBug>"
4874,CWE-362,"static int mptctl_gettargetinfo ( unsigned long arg ) { struct mpt_ioctl_targetinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_targetinfo karg ; mpt_adapter * ioc ; virtdevice * vdevice ; char * pmem ; int * pdata ; int iocnum ; int numdevices = 0 ; int lun ; int maxwordsleft ; int numbytes ; u8 port ; struct scsi_device * sdev ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( kern_err mynam ""%s@%d::mptctl_gettargetinfo<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>read<s2sv_blank>in<s2sv_blank>mpt_ioctl_targetinfo<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , __file__ , __line__ , uarg ) ; return - efault ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == null ) ) { printk ( kern_debug mynam ""%s::mptctl_gettargetinfo()<s2sv_blank>@%d<s2sv_blank>-<s2sv_blank>ioc%d<s2sv_blank>not<s2sv_blank>found!\\n"" , __file__ , __line__ , iocnum ) ; return - enodev ; } dctlprintk ( ioc , printk ( myioc_s_debug_fmt ""mptctl_gettargetinfo<s2sv_blank>called.\\n"" , ioc -> name ) ) ; numbytes = karg . hdr . maxdatasize - sizeof ( mpt_ioctl_header ) ; maxwordsleft = numbytes / sizeof ( int ) ; port = karg . hdr . port ; if ( maxwordsleft <= 0 ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_gettargetinfo()<s2sv_blank>-<s2sv_blank>no<s2sv_blank>memory<s2sv_blank>available!\\n"" , ioc -> name , __file__ , __line__ ) ; return - enomem ; } pmem = kzalloc ( numbytes , gfp_kernel ) ; if ( ! pmem ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_gettargetinfo()<s2sv_blank>-<s2sv_blank>no<s2sv_blank>memory<s2sv_blank>available!\\n"" , ioc -> name , __file__ , __line__ ) ; return - enomem ; } pdata = ( int * ) pmem ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { if ( ! maxwordsleft ) continue ; vdevice = sdev -> hostdata ; if ( vdevice == null || vdevice -> vtarget == null ) continue ; if ( vdevice -> vtarget -> tflags & mpt_target_flags_raid_component ) continue ; lun = ( vdevice -> vtarget -> raidvolume ) ? 0x80 : vdevice -> lun ; * pdata = ( ( ( u8 ) lun << 16 ) + ( vdevice -> vtarget -> channel << 8 ) + ( vdevice -> vtarget -> id ) ) ; pdata ++ ; numdevices ++ ; -- maxwordsleft ; } } karg . numdevices = numdevices ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_gettargetinfo<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>out<s2sv_blank>mpt_ioctl_targetinfo<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , uarg ) ; kfree ( pmem ) ; return - efault ; } if ( copy_to_user ( uarg -> targetinfo , pmem , numbytes ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_gettargetinfo<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>out<s2sv_blank>mpt_ioctl_targetinfo<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , pdata ) ; kfree ( pmem ) ; return - efault ; } kfree ( pmem ) ; return 0 ; }","<S2SV_ModStart> int mptctl_gettargetinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_targetinfo karg ; <S2SV_ModEnd> VirtDevice * vdevice <S2SV_ModStart> int * pdata <S2SV_ModEnd> ; int numDevices <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,<S2SV_StartBug> mptctl_gettargetinfo ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int * pdata ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
5994,CWE-119,"int psf_binheader_readf ( sf_private * psf , char const * format , ... ) { va_list argptr ; sf_count_t * countptr , countdata ; unsigned char * ucptr , sixteen_bytes [ 16 ] ; unsigned int * intptr , intdata ; unsigned short * shortptr ; char * charptr ; float * floatptr ; double * doubleptr ; char c ; int byte_count = 0 , count ; if ( ! format ) return psf_ftell ( psf ) ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) { switch ( c ) { case 'e' : psf -> rwf_endian = sf_endian_little ; break ; case 'e' : psf -> rwf_endian = sf_endian_big ; break ; case 'm' : intptr = va_arg ( argptr , unsigned int * ) ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; * intptr = get_marker ( ucptr ) ; break ; case 'h' : intptr = va_arg ( argptr , unsigned int * ) ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , sixteen_bytes , sizeof ( sixteen_bytes ) ) ; { int k ; intdata = 0 ; for ( k = 0 ; k < 16 ; k ++ ) intdata ^= sixteen_bytes [ k ] << k ; } * intptr = intdata ; break ; case '1' : charptr = va_arg ( argptr , char * ) ; * charptr = 0 ; byte_count += header_read ( psf , charptr , sizeof ( char ) ) ; break ; case '2' : shortptr = va_arg ( argptr , unsigned short * ) ; * shortptr = 0 ; ucptr = ( unsigned char * ) shortptr ; byte_count += header_read ( psf , ucptr , sizeof ( short ) ) ; if ( psf -> rwf_endian == sf_endian_big ) * shortptr = get_be_short ( ucptr ) ; else * shortptr = get_le_short ( ucptr ) ; break ; case '3' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 3 ) ; if ( psf -> rwf_endian == sf_endian_big ) * intptr = get_be_3byte ( sixteen_bytes ) ; else * intptr = get_le_3byte ( sixteen_bytes ) ; break ; case '4' : intptr = va_arg ( argptr , unsigned int * ) ; * intptr = 0 ; ucptr = ( unsigned char * ) intptr ; byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ; if ( psf -> rwf_endian == sf_endian_big ) * intptr = psf_get_be32 ( ucptr , 0 ) ; else * intptr = psf_get_le32 ( ucptr , 0 ) ; break ; case '8' : countptr = va_arg ( argptr , sf_count_t * ) ; * countptr = 0 ; byte_count += header_read ( psf , sixteen_bytes , 8 ) ; if ( psf -> rwf_endian == sf_endian_big ) countdata = psf_get_be64 ( sixteen_bytes , 0 ) ; else countdata = psf_get_le64 ( sixteen_bytes , 0 ) ; * countptr = countdata ; break ; case 'f' : floatptr = va_arg ( argptr , float * ) ; * floatptr = 0.0 ; byte_count += header_read ( psf , floatptr , sizeof ( float ) ) ; if ( psf -> rwf_endian == sf_endian_big ) * floatptr = float32_be_read ( ( unsigned char * ) floatptr ) ; else * floatptr = float32_le_read ( ( unsigned char * ) floatptr ) ; break ; case 'd' : doubleptr = va_arg ( argptr , double * ) ; * doubleptr = 0.0 ; byte_count += header_read ( psf , doubleptr , sizeof ( double ) ) ; if ( psf -> rwf_endian == sf_endian_big ) * doubleptr = double64_be_read ( ( unsigned char * ) doubleptr ) ; else * doubleptr = double64_le_read ( ( unsigned char * ) doubleptr ) ; break ; case 's' : psf_log_printf ( psf , ""format<s2sv_blank>conversion<s2sv_blank>\'s\'<s2sv_blank>not<s2sv_blank>implemented<s2sv_blank>yet.\\n"" ) ; break ; case 'b' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; if ( count > 0 ) byte_count += header_read ( psf , charptr , count ) ; break ; case 'g' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; if ( count > 0 ) byte_count += header_gets ( psf , charptr , count ) ; break ; case 'z' : psf_log_printf ( psf , ""format<s2sv_blank>conversion<s2sv_blank>\'z\'<s2sv_blank>not<s2sv_blank>implemented<s2sv_blank>yet.\\n"" ) ; break ; case 'p' : count = va_arg ( argptr , size_t ) ; header_seek ( psf , count , seek_set ) ; byte_count = count ; break ; case 'j' : count = va_arg ( argptr , size_t ) ; if ( count ) { header_seek ( psf , count , seek_cur ) ; byte_count += count ; } ; break ; default : psf_log_printf ( psf , ""***<s2sv_blank>invalid<s2sv_blank>format<s2sv_blank>specifier<s2sv_blank>`%c\'\\n"" , c ) ; psf -> error = sfe_internal ; break ; } ; } ; va_end ( argptr ) ; return byte_count ; }","<S2SV_ModStart> 0 , count = 0 <S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * ) ; * intptr = 0 ; <S2SV_ModStart> int * ) ; * intptr = 0 <S2SV_ModStart> size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> ( psf , <S2SV_ModStart> break ; case 'z' : psf_log_printf ( psf , ""Format<S2SV_blank>conversion<S2SV_blank>\'z\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n"" ) ; break ; case 'p' : <S2SV_ModEnd> count = va_arg <S2SV_ModStart> size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> : count = <S2SV_ModStart> , count , <S2SV_ModEnd> SEEK_CUR ) ; <S2SV_ModStart> byte_count += count <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> case 'G' : <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> byte_count += count ; <S2SV_EndBug>"
6362,CWE-134,static int bad_format_imginfo ( char * fmt ) { char * ptr ; int n = 0 ; ptr = fmt ; while ( * ptr != '\\0' ) if ( * ptr ++ == '%' ) { if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 's' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '<s2sv_blank>' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; },"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int bad_format_imginfo ( <S2SV_ModStart> fmt ) { return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> ) ; }
",oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z,<S2SV_StartBug> static int bad_format_imginfo ( <S2SV_EndBug> <S2SV_StartBug> char * ptr ; <S2SV_EndBug>
6972,CWE-787,"static int websocketsdecodehybi ( rfbclientptr cl , char * dst , int len ) { char * buf , * payload ; uint32_t * payload32 ; int ret = - 1 , result = - 1 ; int total = 0 ; ws_mask_t mask ; ws_header_t * header ; int i ; unsigned char opcode ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; int flength , fhlen ; if ( wsctx -> readbuflen ) { if ( wsctx -> readbuflen > len ) { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , len ) ; result = len ; wsctx -> readbuflen -= len ; wsctx -> readbufstart += len ; } else { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , wsctx -> readbuflen ) ; result = wsctx -> readbuflen ; wsctx -> readbuflen = 0 ; wsctx -> readbufstart = 0 ; } goto spor ; } buf = wsctx -> codebufdecode ; header = ( ws_header_t * ) wsctx -> codebufdecode ; ret = ws_peek ( cl , buf , b64len ( len ) + wshlenmax ) ; if ( ret < 2 ) { if ( - 1 == ret ) { int olderrno = errno ; rfberr ( ""%s:<s2sv_blank>peek;<s2sv_blank>%m\\n"" , __func__ ) ; errno = olderrno ; } else if ( 0 == ret ) { result = 0 ; } else { errno = eagain ; } goto spor ; } opcode = header -> b0 & 0x0f ; flength = header -> b1 & 0x7f ; if ( ! ( header -> b1 & 0x80 ) ) { rfberr ( ""%s:<s2sv_blank>got<s2sv_blank>frame<s2sv_blank>without<s2sv_blank>mask\\n"" , __func__ , ret ) ; errno = eio ; goto spor ; } if ( flength < 126 ) { fhlen = 2 ; mask = header -> u . m ; } else if ( flength == 126 && 4 <= ret ) { flength = ws_ntoh16 ( header -> u . s16 . l16 ) ; fhlen = 4 ; mask = header -> u . s16 . m16 ; } else if ( flength == 127 && 10 <= ret ) { flength = ws_ntoh64 ( header -> u . s64 . l64 ) ; fhlen = 10 ; mask = header -> u . s64 . m64 ; } else { rfberr ( ""%s:<s2sv_blank>incomplete<s2sv_blank>frame<s2sv_blank>header\\n"" , __func__ , ret ) ; errno = eio ; goto spor ; } total = fhlen + flength + 4 ; payload = buf + fhlen + 4 ; if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) { int olderrno = errno ; rfberr ( ""%s:<s2sv_blank>read;<s2sv_blank>%m"" , __func__ ) ; errno = olderrno ; return ret ; } else if ( ret < total ) { rfblog ( ""%s:<s2sv_blank>read;<s2sv_blank>got<s2sv_blank>partial<s2sv_blank>data\\n"" , __func__ ) ; } else { buf [ ret ] = '\\0' ; } payload32 = ( uint32_t * ) payload ; for ( i = 0 ; i < flength / 4 ; i ++ ) { payload32 [ i ] ^= mask . u ; } for ( i *= 4 ; i < flength ; i ++ ) { payload [ i ] ^= mask . c [ i % 4 ] ; } switch ( opcode ) { case ws_opcode_close : rfblog ( ""got<s2sv_blank>closure,<s2sv_blank>reason<s2sv_blank>%d\\n"" , ws_ntoh16 ( ( ( uint16_t * ) payload ) [ 0 ] ) ) ; errno = econnreset ; break ; case ws_opcode_text_frame : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codebufdecode , sizeof ( wsctx -> codebufdecode ) ) ) ) { rfberr ( ""%s:<s2sv_blank>base64<s2sv_blank>decode<s2sv_blank>error;<s2sv_blank>%m\\n"" , __func__ ) ; break ; } payload = wsctx -> codebufdecode ; case ws_opcode_binary_frame : if ( flength > len ) { memcpy ( wsctx -> readbuf , payload + len , flength - len ) ; wsctx -> readbufstart = 0 ; wsctx -> readbuflen = flength - len ; flength = len ; } memcpy ( dst , payload , flength ) ; result = flength ; break ; default : rfberr ( ""%s:<s2sv_blank>unhandled<s2sv_blank>opcode<s2sv_blank>%d,<s2sv_blank>b0:<s2sv_blank>%02x,<s2sv_blank>b1:<s2sv_blank>%02x\\n"" , __func__ , ( int ) opcode , header -> b0 , header -> b1 ) ; } spor : return result ; }","<S2SV_ModStart> len ) { int result <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> result = - <S2SV_ModStart> - 1 ; errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> result ; }
",LibVNC@libvncserver/aac95a9dcf4bbba87b76c72706c3221a842ca433,CVE-2017-18922,https://github.com/LibVNC/libvncserver/commit/aac95a9dcf4bbba87b76c72706c3221a842ca433,2020-06-30T11:15Z,"<S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug>"
5124,CWE-119,"static bool rdp_read_font_capability_set ( wstream * s , uint16 length , rdpsettings * settings ) { winpr_unused ( settings ) ; if ( length > 4 ) stream_seek_uint16 ( s ) ; if ( length > 6 ) stream_seek_uint16 ( s ) ; return true ; }","<S2SV_ModStart> ( length > 5 <S2SV_ModEnd> ) Stream_Seek_UINT16 ( <S2SV_ModStart> ( length > 7 <S2SV_ModEnd> ) Stream_Seek_UINT16 (
",FreeRDP@FreeRDP/3627aaf7d289315b614a584afb388f04abfb5bbf,CVE-2020-11058,https://github.com/FreeRDP/FreeRDP/commit/3627aaf7d289315b614a584afb388f04abfb5bbf,2020-05-12T21:15Z,<S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug>
4023,CWE-119,"int x509_cmp_time ( const asn1_time * ctm , time_t * cmp_time ) { char * str ; asn1_time atm ; long offset ; char buff1 [ 24 ] , buff2 [ 24 ] , * p ; int i , j ; p = buff1 ; i = ctm -> length ; str = ( char * ) ctm -> data ; if ( ctm -> type == v_asn1_utctime ) { if ( ( i < 11 ) || ( i > 17 ) ) return 0 ; memcpy ( p , str , 10 ) ; p += 10 ; str += 10 ; } else { if ( i < 13 ) return 0 ; memcpy ( p , str , 12 ) ; p += 12 ; str += 12 ; } if ( ( * str == 'z' ) || ( * str == '-' ) || ( * str == '+' ) ) { * ( p ++ ) = '0' ; * ( p ++ ) = '0' ; } else { * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; if ( * str == '.' ) { str ++ ; while ( ( * str >= '0' ) && ( * str <= '9' ) ) str ++ ; } } * ( p ++ ) = 'z' ; * ( p ++ ) = '\\0' ; if ( * str == 'z' ) offset = 0 ; else { if ( ( * str != '+' ) && ( * str != '-' ) ) return 0 ; offset = ( ( str [ 1 ] - '0' ) * 10 + ( str [ 2 ] - '0' ) ) * 60 ; offset += ( str [ 3 ] - '0' ) * 10 + ( str [ 4 ] - '0' ) ; if ( * str == '-' ) offset = - offset ; } atm . type = ctm -> type ; atm . flags = 0 ; atm . length = sizeof ( buff2 ) ; atm . data = ( unsigned char * ) buff2 ; if ( x509_time_adj ( & atm , offset * 60 , cmp_time ) == null ) return 0 ; if ( ctm -> type == v_asn1_utctime ) { i = ( buff1 [ 0 ] - '0' ) * 10 + ( buff1 [ 1 ] - '0' ) ; if ( i < 50 ) i += 100 ; j = ( buff2 [ 0 ] - '0' ) * 10 + ( buff2 [ 1 ] - '0' ) ; if ( j < 50 ) j += 100 ; if ( i < j ) return - 1 ; if ( i > j ) return 1 ; } i = strcmp ( buff1 , buff2 ) ; if ( i == 0 ) return - 1 ; else return i ; }","<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
",openssl@openssl/f48b83b4fb7d6689584cf25f61ca63a4891f5b11,CVE-2015-1789,https://github.com/openssl/openssl/commit/f48b83b4fb7d6689584cf25f61ca63a4891f5b11,2015-06-12T19:59Z,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug>"
3996,CWE-20,"static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - eopnotsupp ; if ( m -> msg_flags & msg_oob ) goto read_error ; m -> msg_namelen = 0 ; skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= msg_trunc ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & msg_trunc ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }","<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> goto read_error ; <S2SV_EndBug>
797,CWE-416,"static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; declare_waitqueue ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; list_head ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = null ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( task_interruptible ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == uffd_event_fork ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - erestartsys ; break ; } if ( no_wait ) { ret = - eagain ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( task_running ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == uffd_event_fork ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; if ( ! ret ) { spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { uwq = list_first_entry ( & fork_event , typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; userfaultfd_event_complete ( ctx , uwq ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; } } return ret ; }","<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
",torvalds@linux/384632e67e0829deb8015ee6ad916b180049d252,CVE-2017-15126,https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252,2018-01-14T06:29Z,"<S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug>"
337,CWE-264,"int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) { if ( policy -> version != 0 ) return - einval ; if ( ! inode_has_encryption_context ( inode ) ) { if ( ! inode -> i_sb -> s_cop -> empty_dir ) return - eopnotsupp ; if ( ! inode -> i_sb -> s_cop -> empty_dir ( inode ) ) return - enotempty ; return create_encryption_context_from_policy ( inode , policy ) ; } if ( is_encryption_context_consistent_with_policy ( inode , policy ) ) return 0 ; printk ( kern_warning ""%s:<s2sv_blank>policy<s2sv_blank>inconsistent<s2sv_blank>with<s2sv_blank>encryption<s2sv_blank>context\\n"" , __func__ ) ; return - einval ; }","<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
",torvalds@linux/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,CVE-2016-10318,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,2017-04-04T16:59Z,<S2SV_StartBug> { <S2SV_EndBug>
6045,CWE-125,"static int update_write_order_info ( rdpcontext * context , wstream * s , order_info * orderinfo , size_t offset ) { size_t position ; winpr_unused ( context ) ; position = stream_getposition ( s ) ; stream_setposition ( s , offset ) ; stream_write_uint8 ( s , orderinfo -> controlflags ) ; if ( orderinfo -> controlflags & order_type_change ) stream_write_uint8 ( s , orderinfo -> ordertype ) ; update_write_field_flags ( s , orderinfo -> fieldflags , orderinfo -> controlflags , primary_drawing_order_field_bytes [ orderinfo -> ordertype ] ) ; update_write_bounds ( s , orderinfo ) ; stream_setposition ( s , position ) ; return 0 ; }","<S2SV_ModStart> -> controlFlags , get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ) ; update_write_bounds
",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z,<S2SV_StartBug> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ; <S2SV_EndBug>
4440,CWE-401,"struct resource_pool * dce100_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , gfp_kernel ) ; if ( ! pool ) return null ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; break_to_debugger ( ) ; return null ; }","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
2804,CWE-416,"void ion_free ( struct ion_client * client , struct ion_handle * handle ) { bool valid_handle ; bug_on ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; valid_handle = ion_handle_validate ( client , handle ) ; if ( ! valid_handle ) { warn ( 1 , ""%s:<s2sv_blank>invalid<s2sv_blank>handle<s2sv_blank>passed<s2sv_blank>to<s2sv_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; return ; } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }","<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z,"<S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug>"
8301,CWE-120,"void choose_windows ( s ) const char * s ; { register int i ; for ( i = 0 ; winchoices [ i ] . procs ; i ++ ) { if ( '+' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( '-' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( ! strcmpi ( s , winchoices [ i ] . procs -> name ) ) { windowprocs = * winchoices [ i ] . procs ; if ( last_winchoice && last_winchoice -> ini_routine ) ( * last_winchoice -> ini_routine ) ( wininit_undo ) ; if ( winchoices [ i ] . ini_routine ) ( * winchoices [ i ] . ini_routine ) ( wininit ) ; last_winchoice = & winchoices [ i ] ; return ; } } if ( ! windowprocs . win_raw_print ) windowprocs . win_raw_print = def_raw_print ; if ( ! windowprocs . win_wait_synch ) windowprocs . win_wait_synch = def_wait_synch ; if ( ! winchoices [ 0 ] . procs ) { raw_printf ( ""no<s2sv_blank>window<s2sv_blank>types?"" ) ; nh_terminate ( exit_failure ) ; } if ( ! winchoices [ 1 ] . procs ) { config_error_add ( ""window<s2sv_blank>type<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>recognized.<s2sv_blank><s2sv_blank>the<s2sv_blank>only<s2sv_blank>choice<s2sv_blank>is:<s2sv_blank>%s"" , s , winchoices [ 0 ] . procs -> name ) ; } else { char buf [ bufsz ] ; boolean first = true ; buf [ 0 ] = '\\0' ; for ( i = 0 ; winchoices [ i ] . procs ; i ++ ) { if ( '+' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( '-' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; sprintf ( eos ( buf ) , ""%s%s"" , first ? """" : "",<s2sv_blank>"" , winchoices [ i ] . procs -> name ) ; first = false ; } config_error_add ( ""window<s2sv_blank>type<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>recognized.<s2sv_blank><s2sv_blank>choices<s2sv_blank>are:<s2sv_blank><s2sv_blank>%s"" , s , buf ) ; } if ( windowprocs . win_raw_print == def_raw_print || windowport ( ""safe-startup"" ) ) nh_terminate ( exit_success ) ; }","<S2SV_ModStart> s ; { int i ; char * tmps = 0 <S2SV_ModEnd> ; for ( <S2SV_ModStart> { raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?"" <S2SV_ModEnd> ) ; nh_terminate <S2SV_ModStart> ) ; } # define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) { tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ; ( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ; tmps [ WINDOW_TYPE_MAXLEN - 1 ] = '\\0' ; s = tmps ; } # undef WINDOW_TYPE_MAXLEN <S2SV_ModStart> } if ( tmps ) free ( ( genericptr_t ) tmps ) ; if (
",NetHack@NetHack/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,CVE-2020-5210,https://github.com/NetHack/NetHack/commit/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,2020-01-28T18:15Z,"<S2SV_StartBug> register int i ; <S2SV_EndBug> <S2SV_StartBug> raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( windowprocs . win_raw_print == def_raw_print <S2SV_EndBug>"
4564,CWE-125,"static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = null ; expr_ty name_expr ; req ( n , decorator ) ; req ( child ( n , 0 ) , at ) ; req ( rchild ( n , - 1 ) , newline ) ; name_expr = ast_for_dotted_name ( c , child ( n , 1 ) ) ; if ( ! name_expr ) return null ; if ( nch ( n ) == 3 ) { d = name_expr ; name_expr = null ; } else if ( nch ( n ) == 5 ) { d = call ( name_expr , null , null , lineno ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return null ; name_expr = null ; } else { d = ast_for_call ( c , child ( n , 3 ) , name_expr ) ; if ( ! d ) return null ; name_expr = null ; } return d ; }","<S2SV_ModStart> ) , name_expr , true
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug>"
8354,CWE-362,"int cipso_v4_req_setattr ( struct request_sock * req , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - eperm ; unsigned char * buf = null ; u32 buf_len ; u32 opt_len ; struct ip_options * opt = null ; struct inet_request_sock * req_inet ; buf_len = cipso_v4_opt_len_max ; buf = kmalloc ( buf_len , gfp_atomic ) ; if ( buf == null ) { ret_val = - enomem ; goto req_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto req_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , gfp_atomic ) ; if ( opt == null ) { ret_val = - enomem ; goto req_setattr_failure ; } memcpy ( opt -> __data , buf , buf_len ) ; opt -> optlen = opt_len ; opt -> cipso = sizeof ( struct iphdr ) ; kfree ( buf ) ; buf = null ; req_inet = inet_rsk ( req ) ; opt = xchg ( & req_inet -> opt , opt ) ; kfree ( opt ) ; return 0 ; req_setattr_failure : kfree ( buf ) ; kfree ( opt ) ; return ret_val ; }","<S2SV_ModStart> opt_len ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> opt ) ; if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug>"
2219,CWE-310,"int x509_verify ( x509 * a , evp_pkey * r ) { return ( asn1_item_verify ( asn1_item_rptr ( x509_cinf ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }","<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
",openssl@openssl/684400ce192dac51df3d3e92b61830a6ef90be3e,CVE-2014-8275,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,2015-01-09T02:59Z,<S2SV_StartBug> { <S2SV_EndBug>
2756,CWE-000,"static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case bpf_type_prog : atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; break ; case bpf_type_map : bpf_map_inc ( raw , true ) ; break ; default : warn_on_once ( 1 ) ; break ; } return raw ; }","<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
",torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z,"<S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug>"
2488,CWE-000,"static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= pollerr | ( sock_flag ( sk , sock_select_err_queue ) ? pollpri : 0 ) ; if ( sk -> sk_shutdown & rcv_shutdown ) mask |= pollrdhup | pollin | pollrdnorm ; if ( sk -> sk_shutdown == shutdown_mask ) mask |= pollhup ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= pollin | pollrdnorm ; if ( sk -> sk_type == sock_seqpacket ) { if ( sk -> sk_state == tcp_close ) mask |= pollhup ; if ( sk -> sk_state == tcp_syn_sent ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( pollwrband | pollwrnorm | pollout ) ) ) return mask ; writable = unix_writable ( sk ) ; other = unix_peer_get ( sk ) ; if ( other ) { if ( unix_peer ( other ) != sk ) { sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; if ( unix_recvq_full ( other ) ) writable = 0 ; } sock_put ( other ) ; } if ( writable ) mask |= pollout | pollwrnorm | pollwrband ; else set_bit ( sock_async_nospace , & sk -> sk_socket -> flags ) ; return mask ; }","<S2SV_ModStart> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> other ) != <S2SV_ModStart> ) != sk && <S2SV_ModEnd> unix_recvq_full ( other <S2SV_ModStart> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> = 0 ; unix_state_unlock ( sk <S2SV_ModEnd> ) ; }
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,<S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
8374,CWE-362,"struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) { struct tcp_options_received tcp_opt ; u8 * hash_location ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct rtable * rt ; __u8 rcv_wscale ; bool ecn_ok ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) || ( mss = cookie_check ( skb , cookie ) ) == 0 ) { net_inc_stats_bh ( sock_net ( sk ) , linux_mib_syncookiesfailed ) ; goto out ; } net_inc_stats_bh ( sock_net ( sk ) , linux_mib_syncookiesrecv ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , & hash_location , 0 ) ; if ( ! cookie_check_timestamp ( & tcp_opt , & ecn_ok ) ) goto out ; ret = null ; req = inet_reqsk_alloc ( & tcp_request_sock_ops ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; req -> mss = mss ; ireq -> loc_port = th -> dest ; ireq -> rmt_port = th -> source ; ireq -> loc_addr = ip_hdr ( skb ) -> daddr ; ireq -> rmt_addr = ip_hdr ( skb ) -> saddr ; ireq -> ecn_ok = ecn_ok ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; if ( opt && opt -> optlen ) { int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; ireq -> opt = kmalloc ( opt_size , gfp_atomic ) ; if ( ireq -> opt != null && ip_options_echo ( ireq -> opt , skb ) ) { kfree ( ireq -> opt ) ; ireq -> opt = null ; } } if ( security_inet_conn_request ( sk , skb , req ) ) { reqsk_free ( req ) ; goto out ; } req -> expires = 0ul ; req -> retrans = 0 ; { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , 0 , sk -> sk_mark , rt_conn_flags ( sk ) , rt_scope_universe , ipproto_tcp , inet_sk_flowi_flags ( sk ) , ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , ireq -> loc_addr , th -> source , th -> dest ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( sock_net ( sk ) , & fl4 ) ; if ( is_err ( rt ) ) { reqsk_free ( req ) ; goto out ; } } req -> window_clamp = tp -> window_clamp ? : dst_metric ( & rt -> dst , rtax_window ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rcv_wnd , & req -> window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( & rt -> dst , rtax_initrwnd ) ) ; ireq -> rcv_wscale = rcv_wscale ; ret = get_cookie_sock ( sk , skb , req , & rt -> dst ) ; out : return ret ; }","<S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + opt <S2SV_ModStart> && ip_options_echo ( & ireq -> opt <S2SV_ModEnd> -> opt ,
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,"<S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug>"
3220,CWE-190,"static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = bpf_op ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( warn_on_once ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<s2sv_blank>internal<s2sv_blank>error:<s2sv_blank>known<s2sv_blank>but<s2sv_blank>bad<s2sv_blank>sbounds\\n"" ) ; return - einval ; } if ( warn_on_once ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<s2sv_blank>internal<s2sv_blank>error:<s2sv_blank>known<s2sv_blank>but<s2sv_blank>bad<s2sv_blank>ubounds\\n"" ) ; return - einval ; } if ( bpf_class ( insn -> code ) != bpf_alu64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>32-bit<s2sv_blank>pointer<s2sv_blank>arithmetic<s2sv_blank>prohibited\\n"" , dst ) ; return - eacces ; } if ( ptr_reg -> type == ptr_to_map_value_or_null ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>arithmetic<s2sv_blank>on<s2sv_blank>ptr_to_map_value_or_null<s2sv_blank>prohibited,<s2sv_blank>null-check<s2sv_blank>it<s2sv_blank>first\\n"" , dst ) ; return - eacces ; } if ( ptr_reg -> type == const_ptr_to_map ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>arithmetic<s2sv_blank>on<s2sv_blank>const_ptr_to_map<s2sv_blank>prohibited\\n"" , dst ) ; return - eacces ; } if ( ptr_reg -> type == ptr_to_packet_end ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>arithmetic<s2sv_blank>on<s2sv_blank>ptr_to_packet_end<s2sv_blank>prohibited\\n"" , dst ) ; return - eacces ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; switch ( opcode ) { case bpf_add : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case bpf_sub : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>tried<s2sv_blank>to<s2sv_blank>subtract<s2sv_blank>pointer<s2sv_blank>from<s2sv_blank>scalar\\n"" , dst ) ; return - eacces ; } if ( ptr_reg -> type == ptr_to_stack ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>subtraction<s2sv_blank>from<s2sv_blank>stack<s2sv_blank>pointer<s2sv_blank>prohibited\\n"" , dst ) ; return - eacces ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case bpf_and : case bpf_or : case bpf_xor : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>bitwise<s2sv_blank>operator<s2sv_blank>%s<s2sv_blank>on<s2sv_blank>pointer<s2sv_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - eacces ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>arithmetic<s2sv_blank>with<s2sv_blank>%s<s2sv_blank>operator<s2sv_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - eacces ; } __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","<S2SV_ModStart> ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
",torvalds@linux/bb7f0f989ca7de1153bd128a40a71709e339fa03,CVE-2017-17854,https://github.com/torvalds/linux/commit/bb7f0f989ca7de1153bd128a40a71709e339fa03,2017-12-27T17:08Z,<S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug>
7863,CWE-20,"void enc28j60selectbank ( netinterface * interface , uint16_t address ) { uint16_t bank ; enc28j60context * context ; context = ( enc28j60context * ) interface -> niccontext ; bank = address & reg_bank_mask ; if ( bank != context -> currentbank ) { switch ( bank ) { case bank_0 : enc28j60clearbit ( interface , enc28j60_reg_econ1 , econ1_bsel1 | econ1_bsel0 ) ; break ; case bank_1 : enc28j60setbit ( interface , enc28j60_reg_econ1 , econ1_bsel0 ) ; enc28j60clearbit ( interface , enc28j60_reg_econ1 , econ1_bsel1 ) ; break ; case bank_2 : enc28j60clearbit ( interface , enc28j60_reg_econ1 , econ1_bsel0 ) ; enc28j60setbit ( interface , enc28j60_reg_econ1 , econ1_bsel1 ) ; break ; case bank_3 : enc28j60setbit ( interface , enc28j60_reg_econ1 , econ1_bsel1 | econ1_bsel0 ) ; break ; default : break ; } context -> currentbank = bank ; } }","<S2SV_ModStart> currentBank ) { if ( bank == BANK_0 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ; } else if ( bank == BANK_1 ) { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else if ( bank == BANK_2 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60SetBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) <S2SV_ModEnd> ; } context
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> switch ( bank ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug>"
2340,CWE-20,"static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ; int delta_munlocked ; struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( testclearpagemlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ; } pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = null ; } delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; __mod_zone_page_state ( zone , nr_mlock , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }","<S2SV_ModStart> ; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone
",torvalds@linux/70feee0e1ef331b22cc51f383d532a0d043fbdcc,CVE-2017-18221,https://github.com/torvalds/linux/commit/70feee0e1ef331b22cc51f383d532a0d043fbdcc,2018-03-07T08:29Z,<S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug>
8336,CWE-264,"int perf_event_refresh ( struct perf_event * event , int refresh ) { if ( event -> attr . inherit || ! is_sampling_event ( event ) ) return - einval ; atomic_add ( refresh , & event -> event_limit ) ; perf_event_enable ( event ) ; return 0 ; }","<S2SV_ModStart> refresh ) { struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z,<S2SV_StartBug> if ( event -> attr . inherit || ! is_sampling_event ( event ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
7045,CWE-772,"int button_open ( button * b ) { char * p , name [ 256 ] ; int r ; assert ( b ) ; b -> fd = safe_close ( b -> fd ) ; p = strjoina ( ""/dev/input/"" , b -> name ) ; b -> fd = open ( p , o_rdwr | o_cloexec | o_noctty | o_nonblock ) ; if ( b -> fd < 0 ) return log_warning_errno ( errno , ""failed<s2sv_blank>to<s2sv_blank>open<s2sv_blank>%s:<s2sv_blank>%m"" , p ) ; r = button_suitable ( b ) ; if ( r < 0 ) return log_warning_errno ( r , ""failed<s2sv_blank>to<s2sv_blank>determine<s2sv_blank>whether<s2sv_blank>input<s2sv_blank>device<s2sv_blank>is<s2sv_blank>relevant<s2sv_blank>to<s2sv_blank>us:<s2sv_blank>%m"" ) ; if ( r == 0 ) return log_debug_errno ( synthetic_errno ( eaddrnotavail ) , ""device<s2sv_blank>%s<s2sv_blank>does<s2sv_blank>not<s2sv_blank>expose<s2sv_blank>keys<s2sv_blank>or<s2sv_blank>switches<s2sv_blank>relevant<s2sv_blank>to<s2sv_blank>us,<s2sv_blank>ignoring."" , p ) ; if ( ioctl ( b -> fd , eviocgname ( sizeof ( name ) ) , name ) < 0 ) { r = log_error_errno ( errno , ""failed<s2sv_blank>to<s2sv_blank>get<s2sv_blank>input<s2sv_blank>name:<s2sv_blank>%m"" ) ; goto fail ; } ( void ) button_set_mask ( b ) ; r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , epollin , button_dispatch , b ) ; if ( r < 0 ) { log_error_errno ( r , ""failed<s2sv_blank>to<s2sv_blank>add<s2sv_blank>button<s2sv_blank>event:<s2sv_blank>%m"" ) ; goto fail ; } log_info ( ""watching<s2sv_blank>system<s2sv_blank>buttons<s2sv_blank>on<s2sv_blank>/dev/input/%s<s2sv_blank>(%s)"" , b -> name , name ) ; return 0 ; fail : b -> fd = safe_close ( b -> fd ) ; return r ; }","<S2SV_ModStart> b ) ; b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;
",systemd@systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,CVE-2019-20386,https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,2020-01-21T06:15Z,"<S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug>"
4428,CWE-120,"static void handle_port ( ctrl_t * ctrl , char * str ) { int a , b , c , d , e , f ; char addr [ inet_addrstrlen ] ; struct sockaddr_in sin ; if ( ctrl -> data_sd > 0 ) { uev_io_stop ( & ctrl -> data_watcher ) ; close ( ctrl -> data_sd ) ; ctrl -> data_sd = - 1 ; } sscanf ( str , ""%d,%d,%d,%d,%d,%d"" , & a , & b , & c , & d , & e , & f ) ; sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) { err ( 0 , ""invalid<s2sv_blank>address<s2sv_blank>\'%s\'<s2sv_blank>given<s2sv_blank>to<s2sv_blank>port<s2sv_blank>command"" , addr ) ; send_msg ( ctrl -> sd , ""500<s2sv_blank>illegal<s2sv_blank>port<s2sv_blank>command.\\r\\n"" ) ; return ; } strlcpy ( ctrl -> data_address , addr , sizeof ( ctrl -> data_address ) ) ; ctrl -> data_port = e * 256 + f ; dbg ( ""client<s2sv_blank>port<s2sv_blank>command<s2sv_blank>accepted<s2sv_blank>for<s2sv_blank>%s:%d"" , ctrl -> data_address , ctrl -> data_port ) ; send_msg ( ctrl -> sd , ""200<s2sv_blank>port<s2sv_blank>command<s2sv_blank>successful.\\r\\n"" ) ; }","<S2SV_ModStart> f ) ; snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> , ""%d.%d.%d.%d"" ,
",troglobit@uftpd/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd,CVE-2020-5204,https://github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd,2020-01-06T20:15Z,"<S2SV_StartBug> sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; <S2SV_EndBug>"
2774,CWE-119,"static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = null ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , gfp_kernel ) ; if ( ! uref_multi ) return - enomem ; uref = & uref_multi -> uref ; if ( cmd == hidiocgusages || cmd == hidiocsusages ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case hidiocgucode : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == null ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != hidiocgusage && cmd != hidiocgusages && uref -> report_type == hid_report_type_input ) goto inval ; if ( uref -> report_id == hid_report_id_unknown ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == null ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == null ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == hidiocgcollectionindex ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; else if ( ( cmd == hidiocgusages || cmd == hidiocsusages ) && ( uref_multi -> num_values > hid_max_multi_usages || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; } switch ( cmd ) { case hidiocgusage : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case hidiocsusage : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case hidiocgcollectionindex : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case hidiocgusages : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case hidiocsusages : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - efault ; inval : kfree ( uref_multi ) ; return - einval ; } }","<S2SV_ModStart> goto inval ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> goto inval ; <S2SV_ModEnd> switch ( cmd
",torvalds@linux/93a2001bdfd5376c3dc2158653034c20392d15c5,CVE-2016-5829,https://github.com/torvalds/linux/commit/93a2001bdfd5376c3dc2158653034c20392d15c5,2016-06-27T10:59Z,<S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2619,CWE-119,"static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , gfp_atomic ) ; if ( ! skb_out ) return - enobufs ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = sadb_x_spdflush ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = pf_key_v2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; pfkey_broadcast ( skb_out , gfp_atomic , broadcast_all , null , c -> net ) ; return 0 ; }","<S2SV_ModStart> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->
",torvalds@linux/85dfb745ee40232876663ae206cba35f24ab2a40,CVE-2013-2237,https://github.com/torvalds/linux/commit/85dfb745ee40232876663ae206cba35f24ab2a40,2013-07-04T21:55Z,<S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug>
7295,CWE-787,"rfbbool initialiserfbconnection ( rfbclient * client ) { rfbprotocolversionmsg pv ; int major , minor ; uint32_t authscheme ; uint32_t subauthscheme ; rfbclientinitmsg ci ; if ( client -> listenspecified ) errormessageonreadfailure = false ; if ( ! readfromrfbserver ( client , pv , sz_rfbprotocolversionmsg ) ) return false ; pv [ sz_rfbprotocolversionmsg ] = 0 ; errormessageonreadfailure = true ; pv [ sz_rfbprotocolversionmsg ] = 0 ; if ( sscanf ( pv , rfbprotocolversionformat , & major , & minor ) != 2 ) { rfbclientlog ( ""not<s2sv_blank>a<s2sv_blank>valid<s2sv_blank>vnc<s2sv_blank>server<s2sv_blank>(%s)\\n"" , pv ) ; return false ; } defaultsupportedmessages ( client ) ; client -> major = major ; client -> minor = minor ; if ( ( major == rfbprotocolmajorversion ) && ( minor > rfbprotocolminorversion ) ) client -> minor = rfbprotocolminorversion ; if ( major == 3 && ( minor == 4 || minor == 6 ) ) { rfbclientlog ( ""ultravnc<s2sv_blank>server<s2sv_blank>detected,<s2sv_blank>enabling<s2sv_blank>ultravnc<s2sv_blank>specific<s2sv_blank>messages\\n"" , pv ) ; defaultsupportedmessagesultravnc ( client ) ; } if ( major == 3 && ( minor == 14 || minor == 16 ) ) { minor = minor - 10 ; client -> minor = minor ; rfbclientlog ( ""ultravnc<s2sv_blank>single<s2sv_blank>click<s2sv_blank>server<s2sv_blank>detected,<s2sv_blank>enabling<s2sv_blank>ultravnc<s2sv_blank>specific<s2sv_blank>messages\\n"" , pv ) ; defaultsupportedmessagesultravnc ( client ) ; } if ( major == 3 && minor == 5 ) { rfbclientlog ( ""tightvnc<s2sv_blank>server<s2sv_blank>detected,<s2sv_blank>enabling<s2sv_blank>tightvnc<s2sv_blank>specific<s2sv_blank>messages\\n"" , pv ) ; defaultsupportedmessagestightvnc ( client ) ; } if ( ( major == 3 && minor > 8 ) || major > 3 ) { client -> major = 3 ; client -> minor = 8 ; } rfbclientlog ( ""vnc<s2sv_blank>server<s2sv_blank>supports<s2sv_blank>protocol<s2sv_blank>version<s2sv_blank>%d.%d<s2sv_blank>(viewer<s2sv_blank>%d.%d)\\n"" , major , minor , rfbprotocolmajorversion , rfbprotocolminorversion ) ; sprintf ( pv , rfbprotocolversionformat , client -> major , client -> minor ) ; if ( ! writetorfbserver ( client , pv , sz_rfbprotocolversionmsg ) ) return false ; if ( client -> major == 3 && client -> minor > 6 ) { if ( ! readsupportedsecuritytype ( client , & authscheme , false ) ) return false ; } else { if ( ! readfromrfbserver ( client , ( char * ) & authscheme , 4 ) ) return false ; authscheme = rfbclientswap32ifle ( authscheme ) ; } rfbclientlog ( ""selected<s2sv_blank>security<s2sv_blank>scheme<s2sv_blank>%d\\n"" , authscheme ) ; client -> authscheme = authscheme ; switch ( authscheme ) { case rfbconnfailed : readreason ( client ) ; return false ; case rfbnoauth : rfbclientlog ( ""no<s2sv_blank>authentication<s2sv_blank>needed\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbhandleauthresult ( client ) ) return false ; break ; case rfbvncauth : if ( ! handlevncauth ( client ) ) return false ; break ; # ifdef libvncserver_have_sasl case rfbsasl : if ( ! handlesaslauth ( client ) ) return false ; break ; # endif case rfbmslogon : if ( ! handlemslogonauth ( client ) ) return false ; break ; case rfbard : # ifndef libvncserver_with_client_gcrypt rfbclientlog ( ""gcrypt<s2sv_blank>support<s2sv_blank>was<s2sv_blank>not<s2sv_blank>compiled<s2sv_blank>in\\n"" ) ; return false ; # else if ( ! handleardauth ( client ) ) return false ; # endif break ; case rfbtls : if ( ! handleanontlsauth ( client ) ) return false ; if ( ! readsupportedsecuritytype ( client , & subauthscheme , true ) ) return false ; client -> subauthscheme = subauthscheme ; switch ( subauthscheme ) { case rfbconnfailed : readreason ( client ) ; return false ; case rfbnoauth : rfbclientlog ( ""no<s2sv_blank>sub<s2sv_blank>authentication<s2sv_blank>needed\\n"" ) ; if ( ( client -> major == 3 && client -> minor > 7 ) || client -> major > 3 ) if ( ! rfbhandleauthresult ( client ) ) return false ; break ; case rfbvncauth : if ( ! handlevncauth ( client ) ) return false ; break ; # ifdef libvncserver_have_sasl case rfbsasl : if ( ! handlesaslauth ( client ) ) return false ; break ; # endif default : rfbclientlog ( ""unknown<s2sv_blank>sub<s2sv_blank>authentication<s2sv_blank>scheme<s2sv_blank>from<s2sv_blank>vnc<s2sv_blank>server:<s2sv_blank>%d\\n"" , ( int ) subauthscheme ) ; return false ; } break ; case rfbvencrypt : if ( ! handlevencryptauth ( client ) ) return false ; switch ( client -> subauthscheme ) { case rfbvencrypttlsnone : case rfbvencryptx509none : rfbclientlog ( ""no<s2sv_blank>sub<s2sv_blank>authentication<s2sv_blank>needed\\n"" ) ; if ( ! rfbhandleauthresult ( client ) ) return false ; break ; case rfbvencrypttlsvnc : case rfbvencryptx509vnc : if ( ! handlevncauth ( client ) ) return false ; break ; case rfbvencrypttlsplain : case rfbvencryptx509plain : if ( ! handleplainauth ( client ) ) return false ; break ; # ifdef libvncserver_have_sasl case rfbvencryptx509sasl : case rfbvencrypttlssasl : if ( ! handlesaslauth ( client ) ) return false ; break ; # endif default : rfbclientlog ( ""unknown<s2sv_blank>sub<s2sv_blank>authentication<s2sv_blank>scheme<s2sv_blank>from<s2sv_blank>vnc<s2sv_blank>server:<s2sv_blank>%d\\n"" , client -> subauthscheme ) ; return false ; } break ; default : { rfbbool authhandled = false ; rfbclientprotocolextension * e ; for ( e = rfbclientextensions ; e ; e = e -> next ) { uint32_t const * sectype ; if ( ! e -> handleauthentication ) continue ; for ( sectype = e -> securitytypes ; sectype && * sectype ; sectype ++ ) { if ( authscheme == * sectype ) { if ( ! e -> handleauthentication ( client , authscheme ) ) return false ; if ( ! rfbhandleauthresult ( client ) ) return false ; authhandled = true ; } } } if ( authhandled ) break ; } rfbclientlog ( ""unknown<s2sv_blank>authentication<s2sv_blank>scheme<s2sv_blank>from<s2sv_blank>vnc<s2sv_blank>server:<s2sv_blank>%d\\n"" , ( int ) authscheme ) ; return false ; } ci . shared = ( client -> appdata . sharedesktop ? 1 : 0 ) ; if ( ! writetorfbserver ( client , ( char * ) & ci , sz_rfbclientinitmsg ) ) return false ; if ( ! readfromrfbserver ( client , ( char * ) & client -> si , sz_rfbserverinitmsg ) ) return false ; client -> si . framebufferwidth = rfbclientswap16ifle ( client -> si . framebufferwidth ) ; client -> si . framebufferheight = rfbclientswap16ifle ( client -> si . framebufferheight ) ; client -> si . format . redmax = rfbclientswap16ifle ( client -> si . format . redmax ) ; client -> si . format . greenmax = rfbclientswap16ifle ( client -> si . format . greenmax ) ; client -> si . format . bluemax = rfbclientswap16ifle ( client -> si . format . bluemax ) ; client -> si . namelength = rfbclientswap32ifle ( client -> si . namelength ) ; client -> desktopname = malloc ( ( uint64_t ) client -> si . namelength + 1 ) ; if ( ! client -> desktopname ) { rfbclientlog ( ""error<s2sv_blank>allocating<s2sv_blank>memory<s2sv_blank>for<s2sv_blank>desktop<s2sv_blank>name,<s2sv_blank>%lu<s2sv_blank>bytes\\n"" , ( unsigned long ) client -> si . namelength ) ; return false ; } if ( ! readfromrfbserver ( client , client -> desktopname , client -> si . namelength ) ) return false ; client -> desktopname [ client -> si . namelength ] = 0 ; rfbclientlog ( ""desktop<s2sv_blank>name<s2sv_blank>\\""%s\\""\\n"" , client -> desktopname ) ; rfbclientlog ( ""connected<s2sv_blank>to<s2sv_blank>vnc<s2sv_blank>server,<s2sv_blank>using<s2sv_blank>protocol<s2sv_blank>version<s2sv_blank>%d.%d\\n"" , client -> major , client -> minor ) ; rfbclientlog ( ""vnc<s2sv_blank>server<s2sv_blank>default<s2sv_blank>format:\\n"" ) ; printpixelformat ( & client -> si . format ) ; return true ; }","<S2SV_ModStart> nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( ""Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> client -> si
",LibVNC@libvncserver/c2c4b81e6cb3b485fb1ec7ba9e7defeb889f6ba7,CVE-2018-20748,https://github.com/LibVNC/libvncserver/commit/c2c4b81e6cb3b485fb1ec7ba9e7defeb889f6ba7,2019-01-30T18:29Z,<S2SV_StartBug> client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ; <S2SV_EndBug>
2280,CWE-119,"static ssize_t k90_show_macro_mode ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; const char * macro_mode ; char data [ 8 ] ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , k90_request_get_mode , usb_dir_in | usb_type_vendor | usb_recip_device , 0 , 0 , data , 2 , usb_ctrl_set_timeout ) ; if ( ret < 0 ) { dev_warn ( dev , ""failed<s2sv_blank>to<s2sv_blank>get<s2sv_blank>k90<s2sv_blank>initial<s2sv_blank>mode<s2sv_blank>(error<s2sv_blank>%d).\\n"" , ret ) ; return - eio ; } switch ( data [ 0 ] ) { case k90_macro_mode_hw : macro_mode = ""hw"" ; break ; case k90_macro_mode_sw : macro_mode = ""sw"" ; break ; default : dev_warn ( dev , ""k90<s2sv_blank>in<s2sv_blank>unknown<s2sv_blank>mode:<s2sv_blank>%02hhx.\\n"" , data [ 0 ] ) ; return - eio ; } return snprintf ( buf , page_size , ""%s\\n"" , macro_mode ) ; }","<S2SV_ModStart> macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/6d104af38b570d37aa32a5803b04c354f8ed513d,CVE-2017-5547,https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d,2017-02-06T06:59Z,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2178,CWE-191,"static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - econnreset : case - enoent : case - eshutdown : dev_dbg ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>urb<s2sv_blank>shutting<s2sv_blank>down<s2sv_blank>with<s2sv_blank>status:<s2sv_blank>%d\\n"" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>nonzero<s2sv_blank>read<s2sv_blank>bulk<s2sv_blank>status<s2sv_blank>received:<s2sv_blank>%d\\n"" , __func__ , status ) ; } if ( status == - epipe ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>stopping<s2sv_blank>read!\\n"" , __func__ ) ; return ; } port_number = edge_port -> port -> port_number ; if ( edge_port -> lsr_event ) { edge_port -> lsr_event = 0 ; dev_dbg ( dev , ""%s<s2sv_blank>=====<s2sv_blank>port<s2sv_blank>%u<s2sv_blank>lsr<s2sv_blank>status<s2sv_blank>=<s2sv_blank>%02x,<s2sv_blank>data<s2sv_blank>=<s2sv_blank>%02x<s2sv_blank>======\\n"" , __func__ , port_number , edge_port -> lsr_mask , * data ) ; handle_new_lsr ( edge_port , 1 , edge_port -> lsr_mask , * data ) ; -- urb -> actual_length ; ++ data ; } if ( urb -> actual_length ) { usb_serial_debug_data ( dev , __func__ , urb -> actual_length , data ) ; if ( edge_port -> close_pending ) dev_dbg ( dev , ""%s<s2sv_blank>-<s2sv_blank>close<s2sv_blank>pending,<s2sv_blank>dropping<s2sv_blank>data<s2sv_blank>on<s2sv_blank>the<s2sv_blank>floor\\n"" , __func__ ) ; else edge_tty_recv ( edge_port -> port , data , urb -> actual_length ) ; edge_port -> port -> icount . rx += urb -> actual_length ; } exit : spin_lock ( & edge_port -> ep_lock ) ; if ( edge_port -> ep_read_urb_state == edge_read_urb_running ) retval = usb_submit_urb ( urb , gfp_atomic ) ; else if ( edge_port -> ep_read_urb_state == edge_read_urb_stopping ) edge_port -> ep_read_urb_state = edge_read_urb_stopped ; spin_unlock ( & edge_port -> ep_lock ) ; if ( retval ) dev_err ( dev , ""%s<s2sv_blank>-<s2sv_blank>usb_submit_urb<s2sv_blank>failed<s2sv_blank>with<s2sv_blank>result<s2sv_blank>%d\\n"" , __func__ , retval ) ; }","<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
",torvalds@linux/654b404f2a222f918af9b0cd18ad469d0c941a8e,CVE-2017-8924,https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e,2017-05-12T21:29Z,<S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug>
2524,CWE-399,"static void kiocb_batch_free ( struct kiocb_batch * batch ) { struct kiocb * req , * n ; list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) { list_del ( & req -> ki_batch ) ; kmem_cache_free ( kiocb_cachep , req ) ; } }","<S2SV_ModStart> void kiocb_batch_free ( struct kioctx * ctx , <S2SV_ModStart> , * n ; if ( list_empty ( & batch -> head ) ) return ; spin_lock_irq ( & ctx -> ctx_lock ) <S2SV_ModStart> ki_batch ) ; list_del ( & req -> ki_list ) ; <S2SV_ModStart> req ) ; ctx -> reqs_active -- ; } spin_unlock_irq ( & ctx -> ctx_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z,"<S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
545,CWE-119,"int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = null ; unsigned int maxfraglen , fragheaderlen , mtu ; int exthdrlen ; int dst_exthdrlen ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & msg_probe ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( warn_on ( np -> cork . opt ) ) return - einval ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == null ) ) return - enobufs ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - enobufs ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - enobufs ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - enobufs ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - enobufs ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; if ( rt -> dst . flags & dst_xfrm_tunnel ) mtu = np -> pmtudisc == ipv6_pmtudisc_probe ? rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; else mtu = np -> pmtudisc == ipv6_pmtudisc_probe ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= ipcork_allfrag ; cork -> length = 0 ; exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; length += exthdrlen ; transhdrlen += exthdrlen ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = ll_reserved_space ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + ipv6_maxplen ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + ipv6_maxplen - fragheaderlen ) { ipv6_local_error ( sk , emsgsize , fl6 , mtu - exthdrlen ) ; return - emsgsize ; } } if ( sk -> sk_type == sock_dgram ) sock_tx_timestamp ( sk , & tx_flags ) ; cork -> length += length ; if ( length > mtu ) { int proto = sk -> sk_protocol ; if ( dontfrag && ( proto == ipproto_udp || proto == ipproto_raw ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - emsgsize ; } if ( proto == ipproto_udp && ( rt -> dst . dev -> features & netif_f_ufo ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ; if ( err ) goto error ; return 0 ; } } if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == null ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & ipcork_allfrag ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( skb == null || skb_prev == null ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == ipv6_pmtudisc_probe ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & ipcork_allfrag ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & msg_more ) && ! ( rt -> dst . dev -> features & netif_f_sg ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & msg_dontwait ) , & err ) ; } else { skb = null ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == null ) ) err = - enobufs ; else { tx_flags = 0 ; } } if ( skb == null ) goto error ; skb -> protocol = htons ( eth_p_ipv6 ) ; skb -> ip_summed = checksum_none ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; if ( sk -> sk_type == sock_dgram ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - einval ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - efault ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & netif_f_sg ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - efault ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; struct page_frag * pfrag = sk_page_frag ( sk ) ; err = - enomem ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - emsgsize ; if ( i == max_skb_frags ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - efault ; error : cork -> length -= length ; ip6_inc_stats ( sock_net ( sk ) , rt -> rt6i_idev , ipstats_mib_outdiscards ) ; return err ; }","<S2SV_ModStart> tx_flags ) ; if ( <S2SV_ModEnd> ( length > <S2SV_ModStart> > mtu ) && <S2SV_ModEnd> dontfrag && ( <S2SV_ModStart> dontfrag && ( sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_UDP || <S2SV_ModStart> == IPPROTO_UDP || sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_RAW ) <S2SV_ModStart> EMSGSIZE ; } skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> && ( rt <S2SV_ModStart> 0 ; } if ( ! skb <S2SV_ModEnd> ) goto alloc_new_skb
",torvalds@linux/2811ebac2521ceac84f2bdae402455baa6a7fb47,CVE-2013-4387,https://github.com/torvalds/linux/commit/2811ebac2521ceac84f2bdae402455baa6a7fb47,2013-10-10T10:55Z,<S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
79,CWE-000,"void sas_unregister_dev ( struct asd_sas_port * port , struct domain_device * dev ) { if ( ! test_bit ( sas_dev_destroy , & dev -> state ) && ! list_empty ( & dev -> disco_list_node ) ) { list_del_init ( & dev -> disco_list_node ) ; sas_rphy_free ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; return ; } if ( ! test_and_set_bit ( sas_dev_destroy , & dev -> state ) ) { sas_rphy_unlink ( dev -> rphy ) ; list_move_tail ( & dev -> disco_list_node , & port -> destroy_list ) ; sas_discover_event ( dev -> port , disce_destruct ) ; } }","<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
",torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug>"
2232,CWE-264,"static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) { struct path lowerpath ; struct path upperpath ; struct path workpath ; struct inode * root_inode ; struct dentry * root_dentry ; struct ovl_entry * oe ; struct ovl_fs * ufs ; struct kstatfs statfs ; int err ; err = - enomem ; ufs = kzalloc ( sizeof ( struct ovl_fs ) , gfp_kernel ) ; if ( ! ufs ) goto out ; err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; if ( err ) goto out_free_config ; err = - einval ; if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || ! ufs -> config . workdir ) { pr_err ( ""overlayfs:<s2sv_blank>missing<s2sv_blank>upperdir<s2sv_blank>or<s2sv_blank>lowerdir<s2sv_blank>or<s2sv_blank>workdir\\n"" ) ; goto out_free_config ; } err = - enomem ; oe = ovl_alloc_entry ( ) ; if ( oe == null ) goto out_free_config ; err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; if ( err ) goto out_free_oe ; err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; if ( err ) goto out_put_upperpath ; err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; if ( err ) goto out_put_lowerpath ; err = - einval ; if ( ! s_isdir ( upperpath . dentry -> d_inode -> i_mode ) || ! s_isdir ( lowerpath . dentry -> d_inode -> i_mode ) || ! s_isdir ( workpath . dentry -> d_inode -> i_mode ) ) { pr_err ( ""overlayfs:<s2sv_blank>upperdir<s2sv_blank>or<s2sv_blank>lowerdir<s2sv_blank>or<s2sv_blank>workdir<s2sv_blank>not<s2sv_blank>a<s2sv_blank>directory\\n"" ) ; goto out_put_workpath ; } if ( upperpath . mnt != workpath . mnt ) { pr_err ( ""overlayfs:<s2sv_blank>workdir<s2sv_blank>and<s2sv_blank>upperdir<s2sv_blank>must<s2sv_blank>reside<s2sv_blank>under<s2sv_blank>the<s2sv_blank>same<s2sv_blank>mount\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { pr_err ( ""overlayfs:<s2sv_blank>workdir<s2sv_blank>and<s2sv_blank>upperdir<s2sv_blank>must<s2sv_blank>be<s2sv_blank>separate<s2sv_blank>subtrees\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { pr_err ( ""overlayfs:<s2sv_blank>filesystem<s2sv_blank>of<s2sv_blank>upperdir<s2sv_blank>is<s2sv_blank>not<s2sv_blank>supported\\n"" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { pr_err ( ""overlayfs:<s2sv_blank>filesystem<s2sv_blank>of<s2sv_blank>lowerdir<s2sv_blank>is<s2sv_blank>not<s2sv_blank>supported\\n"" ) ; goto out_put_workpath ; } err = vfs_statfs ( & lowerpath , & statfs ) ; if ( err ) { pr_err ( ""overlayfs:<s2sv_blank>statfs<s2sv_blank>failed<s2sv_blank>on<s2sv_blank>lowerpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_namelen = statfs . f_namelen ; ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; err = ptr_err ( ufs -> upper_mnt ) ; if ( is_err ( ufs -> upper_mnt ) ) { pr_err ( ""overlayfs:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>clone<s2sv_blank>upperpath\\n"" ) ; goto out_put_workpath ; } ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; err = ptr_err ( ufs -> lower_mnt ) ; if ( is_err ( ufs -> lower_mnt ) ) { pr_err ( ""overlayfs:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>clone<s2sv_blank>lowerpath\\n"" ) ; goto out_put_upper_mnt ; } ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; err = ptr_err ( ufs -> workdir ) ; if ( is_err ( ufs -> workdir ) ) { pr_err ( ""overlayfs:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>directory<s2sv_blank>%s/%s\\n"" , ufs -> config . workdir , ovl_workdir_name ) ; goto out_put_lower_mnt ; } ufs -> lower_mnt -> mnt_flags |= mnt_readonly ; if ( ufs -> upper_mnt -> mnt_sb -> s_flags & ms_rdonly ) sb -> s_flags |= ms_rdonly ; sb -> s_d_op = & ovl_dentry_operations ; err = - enomem ; root_inode = ovl_new_inode ( sb , s_ifdir , oe ) ; if ( ! root_inode ) goto out_put_workdir ; root_dentry = d_make_root ( root_inode ) ; if ( ! root_dentry ) goto out_put_workdir ; mntput ( upperpath . mnt ) ; mntput ( lowerpath . mnt ) ; path_put ( & workpath ) ; oe -> __upperdentry = upperpath . dentry ; oe -> lowerdentry = lowerpath . dentry ; root_dentry -> d_fsdata = oe ; sb -> s_magic = overlayfs_super_magic ; sb -> s_op = & ovl_super_operations ; sb -> s_root = root_dentry ; sb -> s_fs_info = ufs ; return 0 ; out_put_workdir : dput ( ufs -> workdir ) ; out_put_lower_mnt : mntput ( ufs -> lower_mnt ) ; out_put_upper_mnt : mntput ( ufs -> upper_mnt ) ; out_put_workpath : path_put ( & workpath ) ; out_put_lowerpath : path_put ( & lowerpath ) ; out_put_upperpath : path_put ( & upperpath ) ; out_free_oe : kfree ( oe ) ; out_free_config : kfree ( ufs -> config . lowerdir ) ; kfree ( ufs -> config . upperdir ) ; kfree ( ufs -> config . workdir ) ; kfree ( ufs ) ; out : return err ; }","<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; }
",torvalds@linux/69c433ed2ecd2d3264efd7afec4439524b319121,CVE-2014-9922,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,2017-04-04T05:59Z,<S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug>
3737,CWE-415,"int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) return - einval ; if ( ! sctp_style ( sk , udp ) ) return - einval ; err = sock_create ( sk -> sk_family , sock_seqpacket , ipproto_sctp , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , sctp_socket_udp_high_bandwidth ) ; * sockp = sock ; return err ; }","<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
",torvalds@linux/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,CVE-2017-6353,https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1,2017-03-01T20:59Z,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>
7627,CWE-190,"int bmp_validate ( jas_stream_t * in ) { int n ; int i ; uchar buf [ 2 ] ; assert ( jas_stream_maxputback >= 2 ) ; if ( ( n = jas_stream_read ( in , ( char * ) buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == eof ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == ( bmp_magic & 0xff ) && buf [ 1 ] == ( bmp_magic >> 8 ) ) { return 0 ; } return - 1 ; }","<S2SV_ModStart> int i ; jas_uchar <S2SV_ModEnd> buf [ 2
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug>
3310,CWE-20,"static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , gfp_kernel ) ; if ( ! state ) return - enomem ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = null ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , ""invalid<s2sv_blank>insn<s2sv_blank>idx<s2sv_blank>%d<s2sv_blank>insn_cnt<s2sv_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - efault ; } insn = & insns [ insn_idx ] ; class = bpf_class ( insn -> code ) ; if ( ++ insn_processed > bpf_complexity_limit_insns ) { verbose ( env , ""bpf<s2sv_blank>program<s2sv_blank>is<s2sv_blank>too<s2sv_blank>large.<s2sv_blank>processed<s2sv_blank>%d<s2sv_blank>insn\\n"" , insn_processed ) ; return - e2big ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , ""\\nfrom<s2sv_blank>%d<s2sv_blank>to<s2sv_blank>%d:<s2sv_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( env , ""%d:<s2sv_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , ""%d:"" , insn_idx ) ; else verbose ( env , ""\\nfrom<s2sv_blank>%d<s2sv_blank>to<s2sv_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( env , state ) ; do_print_state = false ; } if ( env -> log . level ) { verbose ( env , ""%d:<s2sv_blank>"" , insn_idx ) ; print_bpf_insn ( verbose , env , insn , env -> allow_ptr_leaks ) ; } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; regs = cur_regs ( env ) ; if ( class == bpf_alu || class == bpf_alu64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == bpf_ldx ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , src_op ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , dst_op_no_mark ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , bpf_size ( insn -> code ) , bpf_read , insn -> dst_reg ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == not_init ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == ptr_to_ctx || * prev_src_type == ptr_to_ctx ) ) { verbose ( env , ""same<s2sv_blank>insn<s2sv_blank>cannot<s2sv_blank>be<s2sv_blank>used<s2sv_blank>with<s2sv_blank>different<s2sv_blank>pointers\\n"" ) ; return - einval ; } } else if ( class == bpf_stx ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( bpf_mode ( insn -> code ) == bpf_xadd ) { err = check_xadd ( env , insn_idx , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , src_op ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , src_op ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , bpf_size ( insn -> code ) , bpf_write , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == not_init ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == ptr_to_ctx || * prev_dst_type == ptr_to_ctx ) ) { verbose ( env , ""same<s2sv_blank>insn<s2sv_blank>cannot<s2sv_blank>be<s2sv_blank>used<s2sv_blank>with<s2sv_blank>different<s2sv_blank>pointers\\n"" ) ; return - einval ; } } else if ( class == bpf_st ) { if ( bpf_mode ( insn -> code ) != bpf_mem || insn -> src_reg != bpf_reg_0 ) { verbose ( env , ""bpf_st<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } err = check_reg_arg ( env , insn -> dst_reg , src_op ) ; if ( err ) return err ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , bpf_size ( insn -> code ) , bpf_write , - 1 ) ; if ( err ) return err ; } else if ( class == bpf_jmp ) { u8 opcode = bpf_op ( insn -> code ) ; if ( opcode == bpf_call ) { if ( bpf_src ( insn -> code ) != bpf_k || insn -> off != 0 || insn -> src_reg != bpf_reg_0 || insn -> dst_reg != bpf_reg_0 ) { verbose ( env , ""bpf_call<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == bpf_ja ) { if ( bpf_src ( insn -> code ) != bpf_k || insn -> imm != 0 || insn -> src_reg != bpf_reg_0 || insn -> dst_reg != bpf_reg_0 ) { verbose ( env , ""bpf_ja<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == bpf_exit ) { if ( bpf_src ( insn -> code ) != bpf_k || insn -> imm != 0 || insn -> src_reg != bpf_reg_0 || insn -> dst_reg != bpf_reg_0 ) { verbose ( env , ""bpf_exit<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } err = check_reg_arg ( env , bpf_reg_0 , src_op ) ; if ( err ) return err ; if ( is_pointer_value ( env , bpf_reg_0 ) ) { verbose ( env , ""r0<s2sv_blank>leaks<s2sv_blank>addr<s2sv_blank>as<s2sv_blank>return<s2sv_blank>value\\n"" ) ; return - eacces ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; if ( err < 0 ) { if ( err != - enoent ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == bpf_ld ) { u8 mode = bpf_mode ( insn -> code ) ; if ( mode == bpf_abs || mode == bpf_ind ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == bpf_imm ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; } else { verbose ( env , ""invalid<s2sv_blank>bpf_ld<s2sv_blank>mode\\n"" ) ; return - einval ; } } else { verbose ( env , ""unknown<s2sv_blank>insn<s2sv_blank>class<s2sv_blank>%d\\n"" , class ) ; return - einval ; } insn_idx ++ ; } verbose ( env , ""processed<s2sv_blank>%d<s2sv_blank>insns,<s2sv_blank>stack<s2sv_blank>depth<s2sv_blank>%d\\n"" , insn_processed , env -> prog -> aux -> stack_depth ) ; return 0 ; }","<S2SV_ModStart> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
",torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z,<S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug>
7911,CWE-20,"error_t websocketparserequestline ( websocket * websocket , char_t * line ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; trace_debug ( ""%s"" , line ) ; token = osstrtok_r ( line , ""<s2sv_blank>\\r\\n"" , & p ) ; if ( token == null ) return error_invalid_request ; if ( osstrcasecmp ( token , ""get"" ) ) return error_invalid_request ; token = osstrtok_r ( null , ""<s2sv_blank>\\r\\n"" , & p ) ; if ( token == null ) return error_invalid_request ; s = strchr ( token , '?' ) ; if ( s != null ) { * s = '\\0' ; error = websocketdecodepercentencodedstring ( token , websocket -> uri , web_socket_uri_max_len ) ; if ( error ) return error_invalid_request ; if ( osstrlen ( s + 1 ) > web_socket_query_string_max_len ) return error_invalid_request ; osstrcpy ( websocket -> querystring , s + 1 ) ; } else { error = websocketdecodepercentencodedstring ( token , websocket -> uri , web_socket_uri_max_len ) ; if ( error ) return error_invalid_request ; websocket -> querystring [ 0 ] = '\\0' ; } token = osstrtok_r ( null , ""<s2sv_blank>\\r\\n"" , & p ) ; if ( token == null ) { websocket -> handshakecontext . version = ws_http_version_0_9 ; websocket -> handshakecontext . connectionclose = true ; } else if ( ! osstrcasecmp ( token , ""http/1.0"" ) ) { websocket -> handshakecontext . version = ws_http_version_1_0 ; websocket -> handshakecontext . connectionclose = true ; } else if ( ! osstrcasecmp ( token , ""http/1.1"" ) ) { websocket -> handshakecontext . version = ws_http_version_1_1 ; websocket -> handshakecontext . connectionclose = false ; } else { return error_invalid_request ; } return no_error ; }","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug>"
2728,CWE-264,"static int validate_event ( struct pmu_hw_events * hw_events , struct perf_event * event ) { struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; if ( event -> pmu != leader_pmu || event -> state < perf_event_state_off ) return 1 ; if ( event -> state == perf_event_state_off && ! event -> attr . enable_on_exec ) return 1 ; return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; }","<S2SV_ModStart> int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;
",torvalds@linux/8fff105e13041e49b82f92eef034f363a6b1c071,CVE-2015-8955,https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071,2016-10-10T10:59Z,"<S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug>"
3829,CWE-20,"int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) { struct svc_procedure * proc ; kxdrproc_t xdr ; __be32 nfserr ; __be32 * nfserrp ; dprintk ( ""nfsd_dispatch:<s2sv_blank>vers<s2sv_blank>%d<s2sv_blank>proc<s2sv_blank>%d\\n"" , rqstp -> rq_vers , rqstp -> rq_proc ) ; proc = rqstp -> rq_procinfo ; rqstp -> rq_cachetype = proc -> pc_cachetype ; xdr = proc -> pc_decode ; if ( xdr && ! xdr ( rqstp , ( __be32 * ) rqstp -> rq_arg . head [ 0 ] . iov_base , rqstp -> rq_argp ) ) { dprintk ( ""nfsd:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>decode<s2sv_blank>arguments!\\n"" ) ; * statp = rpc_garbage_args ; return 1 ; } switch ( nfsd_cache_lookup ( rqstp ) ) { case rc_dropit : return 0 ; case rc_reply : return 1 ; case rc_doit : ; } nfserrp = rqstp -> rq_res . head [ 0 ] . iov_base + rqstp -> rq_res . head [ 0 ] . iov_len ; rqstp -> rq_res . head [ 0 ] . iov_len += sizeof ( __be32 ) ; nfserr = proc -> pc_func ( rqstp , rqstp -> rq_argp , rqstp -> rq_resp ) ; nfserr = map_new_errors ( rqstp -> rq_vers , nfserr ) ; if ( nfserr == nfserr_dropit || test_bit ( rq_dropme , & rqstp -> rq_flags ) ) { dprintk ( ""nfsd:<s2sv_blank>dropping<s2sv_blank>request;<s2sv_blank>may<s2sv_blank>be<s2sv_blank>revisited<s2sv_blank>later\\n"" ) ; nfsd_cache_update ( rqstp , rc_nocache , null ) ; return 0 ; } if ( rqstp -> rq_proc != 0 ) * nfserrp ++ = nfserr ; if ( ! ( nfserr && rqstp -> rq_vers == 2 ) ) { xdr = proc -> pc_encode ; if ( xdr && ! xdr ( rqstp , nfserrp , rqstp -> rq_resp ) ) { dprintk ( ""nfsd:<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>encode<s2sv_blank>result!\\n"" ) ; nfsd_cache_update ( rqstp , rc_nocache , null ) ; * statp = rpc_system_err ; return 1 ; } } nfsd_cache_update ( rqstp , rqstp -> rq_cachetype , statp + 1 ) ; return 1 ; }","<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
",torvalds@linux/e6838a29ecb484c97e4efef9429643b9851fba6e,CVE-2017-7645,https://github.com/torvalds/linux/commit/e6838a29ecb484c97e4efef9429643b9851fba6e,2017-04-18T14:59Z,<S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug>
1171,CWE-264,static unsigned int stack_maxrandom_size ( void ) { unsigned int max = 0 ; if ( ( current -> flags & pf_randomize ) && ! ( current -> personality & addr_no_randomize ) ) { max = ( ( - 1u ) & stack_rnd_mask ) << page_shift ; } return max ; },"<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK
",torvalds@linux/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,CVE-2015-1593,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,2015-03-16T10:59Z,<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug>
2984,CWE-119,"static gboolean parse_cosine_packet ( file_t fh , struct wtap_pkthdr * phdr , buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; int yy , mm , dd , hr , min , sec , csec ; guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ cosine_max_if_name_len ] = """" , direction [ 6 ] = """" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<s2sv_blank>%5s<s2sv_blank>(%127[a-za-z0-9/:]),<s2sv_blank>length:%9u,<s2sv_blank>pro:%9d,<s2sv_blank>off:%9d,<s2sv_blank>pri:%9d,<s2sv_blank>rm:%9d,<s2sv_blank>err:%9d<s2sv_blank>[%8x,<s2sv_blank>%8x]"" , & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""cosine:<s2sv_blank>purported<s2sv_blank>control<s2sv_blank>blade<s2sv_blank>line<s2sv_blank>doesn\'t<s2sv_blank>have<s2sv_blank>code<s2sv_blank>values"" ) ; return false ; } } else { num_items_scanned = sscanf ( line , ""%5s<s2sv_blank>(%127[a-za-z0-9/:]),<s2sv_blank>length:%9u,<s2sv_blank>pro:%9d,<s2sv_blank>off:%9d,<s2sv_blank>pri:%9d,<s2sv_blank>rm:%9d,<s2sv_blank>err:%9d<s2sv_blank>[%8x,<s2sv_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""cosine:<s2sv_blank>header<s2sv_blank>line<s2sv_blank>is<s2sv_blank>neither<s2sv_blank>control<s2sv_blank>blade<s2sv_blank>nor<s2sv_blank>pe<s2sv_blank>output"" ) ; return false ; } yy = mm = dd = hr = min = sec = csec = 0 ; } if ( pkt_len > wtap_max_packet_size ) { * err = wtap_err_bad_file ; * err_info = g_strdup_printf ( ""cosine:<s2sv_blank>file<s2sv_blank>has<s2sv_blank>%u-byte<s2sv_blank>packet,<s2sv_blank>bigger<s2sv_blank>than<s2sv_blank>maximum<s2sv_blank>of<s2sv_blank>%u"" , pkt_len , wtap_max_packet_size ) ; return false ; } phdr -> rec_type = rec_type_packet ; phdr -> presence_flags = wtap_has_ts | wtap_has_cap_len ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , ""test:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_test ; } else if ( strncmp ( if_name , ""ppoatm:"" , 7 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_ppoatm ; } else if ( strncmp ( if_name , ""ppofr:"" , 6 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_ppofr ; } else if ( strncmp ( if_name , ""atm:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_atm ; } else if ( strncmp ( if_name , ""fr:"" , 3 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_fr ; } else if ( strncmp ( if_name , ""hdlc:"" , 5 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_hdlc ; } else if ( strncmp ( if_name , ""ppp:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_ppp ; } else if ( strncmp ( if_name , ""eth:"" , 4 ) == 0 ) { pseudo_header -> cosine . encap = cosine_encap_eth ; } else { pseudo_header -> cosine . encap = cosine_encap_unknown ; } if ( strncmp ( direction , ""l2-tx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = cosine_dir_tx ; } else if ( strncmp ( direction , ""l2-rx"" , 5 ) == 0 ) { pseudo_header -> cosine . direction = cosine_dir_rx ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , cosine_max_if_name_len ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , cosine_line_length , fh ) == null ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = wtap_err_short_read ; } return false ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = wtap_err_bad_file ; * err_info = g_strdup ( ""cosine:<s2sv_blank>hex<s2sv_blank>dump<s2sv_blank>line<s2sv_blank>doesn\'t<s2sv_blank>have<s2sv_blank>16<s2sv_blank>numbers"" ) ; return false ; } caplen += n ; } phdr -> caplen = caplen ; return true ; }","<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE
",wireshark@wireshark/a66628e425db725df1ac52a3c573a03357060ddd,CVE-2016-5356,https://github.com/wireshark/wireshark/commit/a66628e425db725df1ac52a3c573a03357060ddd,2016-08-07T16:59Z,"<S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug>"
6888,CWE-310,"int test_sqr ( bio * bp , bn_ctx * ctx ) { bignum a , c , d , e ; int i ; bn_init ( & a ) ; bn_init ( & c ) ; bn_init ( & d ) ; bn_init ( & e ) ; for ( i = 0 ; i < num0 ; i ++ ) { bn_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; a . neg = rand_neg ( ) ; bn_sqr ( & c , & a , ctx ) ; if ( bp != null ) { if ( ! results ) { bn_print ( bp , & a ) ; bio_puts ( bp , ""<s2sv_blank>*<s2sv_blank>"" ) ; bn_print ( bp , & a ) ; bio_puts ( bp , ""<s2sv_blank>-<s2sv_blank>"" ) ; } bn_print ( bp , & c ) ; bio_puts ( bp , ""\\n"" ) ; } bn_div ( & d , & e , & c , & a , ctx ) ; bn_sub ( & d , & d , & a ) ; if ( ! bn_is_zero ( & d ) || ! bn_is_zero ( & e ) ) { fprintf ( stderr , ""square<s2sv_blank>test<s2sv_blank>failed!\\n"" ) ; return 0 ; } } bn_free ( & a ) ; bn_free ( & c ) ; bn_free ( & d ) ; bn_free ( & e ) ; return ( 1 ) ; }","<S2SV_ModStart> ) { BIGNUM * a , * c , * d , * <S2SV_ModEnd> e ; int <S2SV_ModStart> ; int i , ret = 0 ; a = BN_new ( ) ; c = BN_new ( ) ; d = BN_new ( ) ; e = BN_new ( ) ; if ( a == NULL || c == NULL || d == NULL || e == NULL ) { goto err ; } <S2SV_ModEnd> for ( i <S2SV_ModStart> { BN_bntest_rand ( <S2SV_ModEnd> a , 40 <S2SV_ModStart> ) ; a -> <S2SV_ModEnd> neg = rand_neg <S2SV_ModStart> ; BN_sqr ( c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> c ) ; <S2SV_ModStart> } BN_div ( d , e , c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ; BN_sub ( d , d , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ! BN_is_zero ( <S2SV_ModEnd> d ) || <S2SV_ModStart> ! BN_is_zero ( e ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; goto err ; } } BN_hex2bn ( & a , ""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } ret = 1 ; err : if ( a != NULL ) BN_free ( a ) ; if ( c != NULL ) BN_free ( c ) ; if ( d != NULL ) BN_free ( d ) ; if ( e != NULL ) BN_free ( e <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z,"<S2SV_StartBug> BIGNUM a , c , d , e ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> a . neg = rand_neg ( ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sqr ( & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & c ) ; <S2SV_EndBug> <S2SV_StartBug> BN_div ( & d , & e , & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sub ( & d , & d , & a ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>"
6917,CWE-400,"asmlinkage void do_page_fault ( struct pt_regs * regs , unsigned long writeaccess , unsigned long textaccess , unsigned long address ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; const struct exception_table_entry * fixup ; pte_t * pte ; int fault ; tsk = current ; mm = tsk -> mm ; local_irq_enable ( ) ; perf_sw_event ( perf_count_sw_page_faults , 1 , 0 , regs , address ) ; if ( in_atomic ( ) || ! mm ) goto no_context ; down_read ( & mm -> mmap_sem ) ; vma = find_vma ( mm , address ) ; if ( ! vma ) { # ifdef debug_fault print_task ( tsk ) ; printk ( ""%s:%d<s2sv_blank>fault,<s2sv_blank>address<s2sv_blank>is<s2sv_blank>0x%08x<s2sv_blank>pc<s2sv_blank>%016lx<s2sv_blank>textaccess<s2sv_blank>%d<s2sv_blank>writeaccess<s2sv_blank>%d\\n"" , __func__ , __line__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } if ( vma -> vm_start <= address ) { goto good_area ; } if ( ! ( vma -> vm_flags & vm_growsdown ) ) { # ifdef debug_fault print_task ( tsk ) ; printk ( ""%s:%d<s2sv_blank>fault,<s2sv_blank>address<s2sv_blank>is<s2sv_blank>0x%08x<s2sv_blank>pc<s2sv_blank>%016lx<s2sv_blank>textaccess<s2sv_blank>%d<s2sv_blank>writeaccess<s2sv_blank>%d\\n"" , __func__ , __line__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; print_vma ( vma ) ; # endif goto bad_area ; } if ( expand_stack ( vma , address ) ) { # ifdef debug_fault print_task ( tsk ) ; printk ( ""%s:%d<s2sv_blank>fault,<s2sv_blank>address<s2sv_blank>is<s2sv_blank>0x%08x<s2sv_blank>pc<s2sv_blank>%016lx<s2sv_blank>textaccess<s2sv_blank>%d<s2sv_blank>writeaccess<s2sv_blank>%d\\n"" , __func__ , __line__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } good_area : if ( textaccess ) { if ( ! ( vma -> vm_flags & vm_exec ) ) goto bad_area ; } else { if ( writeaccess ) { if ( ! ( vma -> vm_flags & vm_write ) ) goto bad_area ; } else { if ( ! ( vma -> vm_flags & vm_read ) ) goto bad_area ; } } fault = handle_mm_fault ( mm , vma , address , writeaccess ? fault_flag_write : 0 ) ; if ( unlikely ( fault & vm_fault_error ) ) { if ( fault & vm_fault_oom ) goto out_of_memory ; else if ( fault & vm_fault_sigbus ) goto do_sigbus ; bug ( ) ; } if ( fault & vm_fault_major ) { tsk -> maj_flt ++ ; perf_sw_event ( perf_count_sw_page_faults_maj , 1 , 0 , regs , address ) ; } else { tsk -> min_flt ++ ; perf_sw_event ( perf_count_sw_page_faults_min , 1 , 0 , regs , address ) ; } pte = lookup_pte ( mm , address ) ; if ( ! pte ) { goto no_pte ; } __do_tlb_refill ( address , textaccess , pte ) ; no_pte : up_read ( & mm -> mmap_sem ) ; return ; bad_area : # ifdef debug_fault printk ( ""fault:bad<s2sv_blank>area\\n"" ) ; # endif up_read ( & mm -> mmap_sem ) ; if ( user_mode ( regs ) ) { static int count = 0 ; siginfo_t info ; if ( count < 4 ) { count ++ ; printk ( ""user<s2sv_blank>mode<s2sv_blank>bad_area<s2sv_blank>address=%08lx<s2sv_blank>pid=%d<s2sv_blank>(%s)<s2sv_blank>pc=%08lx\\n"" , address , task_pid_nr ( current ) , current -> comm , ( unsigned long ) regs -> pc ) ; # if 0 show_regs ( regs ) ; # endif } if ( is_global_init ( tsk ) ) { panic ( ""init<s2sv_blank>had<s2sv_blank>user<s2sv_blank>mode<s2sv_blank>bad_area\\n"" ) ; } tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; info . si_signo = sigsegv ; info . si_errno = 0 ; info . si_addr = ( void * ) address ; force_sig_info ( sigsegv , & info , tsk ) ; return ; } no_context : # ifdef debug_fault printk ( ""fault:no<s2sv_blank>context\\n"" ) ; # endif fixup = search_exception_tables ( regs -> pc ) ; if ( fixup ) { regs -> pc = fixup -> fixup ; return ; } if ( address < page_size ) printk ( kern_alert ""unable<s2sv_blank>to<s2sv_blank>handle<s2sv_blank>kernel<s2sv_blank>null<s2sv_blank>pointer<s2sv_blank>dereference"" ) ; else printk ( kern_alert ""unable<s2sv_blank>to<s2sv_blank>handle<s2sv_blank>kernel<s2sv_blank>paging<s2sv_blank>request"" ) ; printk ( ""<s2sv_blank>at<s2sv_blank>virtual<s2sv_blank>address<s2sv_blank>%08lx\\n"" , address ) ; printk ( kern_alert ""pc<s2sv_blank>=<s2sv_blank>%08lx%08lx\\n"" , regs -> pc >> 32 , regs -> pc & 0xffffffff ) ; die ( ""oops"" , regs , writeaccess ) ; do_exit ( sigkill ) ; out_of_memory : up_read ( & mm -> mmap_sem ) ; if ( ! user_mode ( regs ) ) goto no_context ; pagefault_out_of_memory ( ) ; return ; do_sigbus : printk ( ""fault:do<s2sv_blank>sigbus\\n"" ) ; up_read ( & mm -> mmap_sem ) ; tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; tsk -> thread . trap_no = 14 ; force_sig ( sigbus , tsk ) ; if ( ! user_mode ( regs ) ) goto no_context ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug>"
1290,CWE-264,"static int try_to_unmap_cluster ( unsigned long cursor , unsigned int * mapcount , struct vm_area_struct * vma , struct page * check_page ) { struct mm_struct * mm = vma -> vm_mm ; pmd_t * pmd ; pte_t * pte ; pte_t pteval ; spinlock_t * ptl ; struct page * page ; unsigned long address ; unsigned long mmun_start ; unsigned long mmun_end ; unsigned long end ; int ret = swap_again ; int locked_vma = 0 ; address = ( vma -> vm_start + cursor ) & cluster_mask ; end = address + cluster_size ; if ( address < vma -> vm_start ) address = vma -> vm_start ; if ( end > vma -> vm_end ) end = vma -> vm_end ; pmd = mm_find_pmd ( mm , address ) ; if ( ! pmd ) return ret ; mmun_start = address ; mmun_end = end ; mmu_notifier_invalidate_range_start ( mm , mmun_start , mmun_end ) ; if ( down_read_trylock ( & vma -> vm_mm -> mmap_sem ) ) { locked_vma = ( vma -> vm_flags & vm_locked ) ; if ( ! locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; } pte = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; update_hiwater_rss ( mm ) ; for ( ; address < end ; pte ++ , address += page_size ) { if ( ! pte_present ( * pte ) ) continue ; page = vm_normal_page ( vma , address , * pte ) ; bug_on ( ! page || pageanon ( page ) ) ; if ( locked_vma ) { mlock_vma_page ( page ) ; if ( page == check_page ) ret = swap_mlock ; continue ; } if ( ptep_clear_flush_young_notify ( vma , address , pte ) ) continue ; flush_cache_page ( vma , address , pte_pfn ( * pte ) ) ; pteval = ptep_clear_flush ( vma , address , pte ) ; if ( page -> index != linear_page_index ( vma , address ) ) { pte_t ptfile = pgoff_to_pte ( page -> index ) ; if ( pte_soft_dirty ( pteval ) ) pte_file_mksoft_dirty ( ptfile ) ; set_pte_at ( mm , address , pte , ptfile ) ; } if ( pte_dirty ( pteval ) ) set_page_dirty ( page ) ; page_remove_rmap ( page ) ; page_cache_release ( page ) ; dec_mm_counter ( mm , mm_filepages ) ; ( * mapcount ) -- ; } pte_unmap_unlock ( pte - 1 , ptl ) ; mmu_notifier_invalidate_range_end ( mm , mmun_start , mmun_end ) ; if ( locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; return ret ; }","<S2SV_ModStart> locked_vma ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> == check_page ) { mlock_vma_page ( page ) ; <S2SV_ModStart> = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; }
",torvalds@linux/57e68e9cd65b4b8eb4045a1e0d0746458502554c,CVE-2014-3122,https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c,2014-05-11T21:55Z,<S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug>
5288,CWE-000,"void csync_daemon_session ( ) { static char line [ 4 * 4096 ] ; struct stat sb ; address_t peername = { . sa . sa_family = af_unspec , } ; socklen_t peerlen = sizeof ( peername ) ; char * peer = 0 , * tag [ 32 ] ; int i ; if ( fstat ( 0 , & sb ) ) csync_fatal ( ""can\'t<s2sv_blank>run<s2sv_blank>fstat<s2sv_blank>on<s2sv_blank>fd<s2sv_blank>0:<s2sv_blank>%s"" , strerror ( errno ) ) ; switch ( sb . st_mode & s_ifmt ) { case s_ifsock : if ( getpeername ( 0 , & peername . sa , & peerlen ) == - 1 ) csync_fatal ( ""can\'t<s2sv_blank>run<s2sv_blank>getpeername<s2sv_blank>on<s2sv_blank>fd<s2sv_blank>0:<s2sv_blank>%s"" , strerror ( errno ) ) ; break ; case s_ififo : set_peername_from_env ( & peername , ""ssh_client"" ) ; break ; default : csync_fatal ( ""i\'m<s2sv_blank>only<s2sv_blank>talking<s2sv_blank>to<s2sv_blank>sockets<s2sv_blank>or<s2sv_blank>pipes!<s2sv_blank>%x\\n"" , sb . st_mode & s_ifmt ) ; break ; } while ( conn_gets ( line , sizeof ( line ) ) ) { int cmdnr ; if ( ! setup_tag ( tag , line ) ) continue ; for ( cmdnr = 0 ; cmdtab [ cmdnr ] . text ; cmdnr ++ ) if ( ! strcasecmp ( cmdtab [ cmdnr ] . text , tag [ 0 ] ) ) break ; if ( ! cmdtab [ cmdnr ] . text ) { cmd_error = conn_response ( cr_err_unknown_command ) ; goto abort_cmd ; } cmd_error = 0 ; if ( cmdtab [ cmdnr ] . need_ident && ! peer ) { conn_printf ( ""dear<s2sv_blank>%s,<s2sv_blank>please<s2sv_blank>identify<s2sv_blank>first.\\n"" , csync_inet_ntop ( & peername ) ? : ""stranger"" ) ; goto next_cmd ; } if ( cmdtab [ cmdnr ] . check_perm ) on_cygwin_lowercase ( tag [ 2 ] ) ; if ( cmdtab [ cmdnr ] . check_perm ) { if ( cmdtab [ cmdnr ] . check_perm == 2 ) csync_compare_mode = 1 ; int perm = csync_perm ( tag [ 2 ] , tag [ 1 ] , peer ) ; if ( cmdtab [ cmdnr ] . check_perm == 2 ) csync_compare_mode = 0 ; if ( perm ) { if ( perm == 2 ) { csync_mark ( tag [ 2 ] , peer , 0 ) ; cmd_error = conn_response ( cr_err_perm_denied_for_slave ) ; } else cmd_error = conn_response ( cr_err_perm_denied ) ; goto abort_cmd ; } } if ( cmdtab [ cmdnr ] . check_dirty && csync_check_dirty ( tag [ 2 ] , peer , cmdtab [ cmdnr ] . action == a_flush ) ) goto abort_cmd ; if ( cmdtab [ cmdnr ] . unlink ) csync_unlink ( tag [ 2 ] , cmdtab [ cmdnr ] . unlink ) ; switch ( cmdtab [ cmdnr ] . action ) { case a_sig : { struct stat st ; if ( lstat_strict ( prefixsubst ( tag [ 2 ] ) , & st ) != 0 ) { if ( errno == enoent ) { struct stat sb ; char parent_dirname [ strlen ( tag [ 2 ] ) ] ; split_dirname_basename ( parent_dirname , null , tag [ 2 ] ) ; if ( lstat_strict ( prefixsubst ( parent_dirname ) , & sb ) != 0 ) cmd_error = conn_response ( cr_err_parent_dir_missing ) ; else conn_resp_zero ( cr_ok_path_not_found ) ; } else cmd_error = strerror ( errno ) ; break ; } else if ( csync_check_pure ( tag [ 2 ] ) ) { conn_resp_zero ( cr_ok_not_found ) ; break ; } conn_resp ( cr_ok_data_follows ) ; conn_printf ( ""%s\\n"" , csync_genchecktxt ( & st , tag [ 2 ] , 1 ) ) ; if ( s_isreg ( st . st_mode ) ) csync_rs_sig ( tag [ 2 ] ) ; else conn_printf ( ""octet-stream<s2sv_blank>0\\n"" ) ; } break ; case a_mark : csync_mark ( tag [ 2 ] , peer , 0 ) ; break ; case a_type : { file * f = fopen ( prefixsubst ( tag [ 2 ] ) , ""rb"" ) ; if ( ! f && errno == enoent ) f = fopen ( ""/dev/null"" , ""rb"" ) ; if ( f ) { char buffer [ 512 ] ; size_t rc ; conn_resp ( cr_ok_data_follows ) ; while ( ( rc = fread ( buffer , 1 , 512 , f ) ) > 0 ) if ( conn_write ( buffer , rc ) != rc ) { conn_printf ( ""[[<s2sv_blank>%s<s2sv_blank>]]"" , strerror ( errno ) ) ; break ; } fclose ( f ) ; return ; } cmd_error = strerror ( errno ) ; } break ; case a_gettm : case a_getsz : { struct stat sbuf ; conn_resp ( cr_ok_data_follows ) ; if ( ! lstat_strict ( prefixsubst ( tag [ 2 ] ) , & sbuf ) ) conn_printf ( ""%ld\\n"" , cmdtab [ cmdnr ] . action == a_gettm ? ( long ) sbuf . st_mtime : ( long ) sbuf . st_size ) ; else conn_printf ( ""-1\\n"" ) ; goto next_cmd ; } break ; case a_flush : sql ( ""flushing<s2sv_blank>dirty<s2sv_blank>entry<s2sv_blank>(if<s2sv_blank>any)<s2sv_blank>for<s2sv_blank>file"" , ""delete<s2sv_blank>from<s2sv_blank>dirty<s2sv_blank>where<s2sv_blank>filename<s2sv_blank>=<s2sv_blank>\'%s\'"" , url_encode ( tag [ 2 ] ) ) ; break ; case a_del : if ( ! csync_file_backup ( tag [ 2 ] ) ) csync_unlink ( tag [ 2 ] , 0 ) ; break ; case a_patch : if ( ! csync_file_backup ( tag [ 2 ] ) ) { conn_resp ( cr_ok_send_data ) ; csync_rs_sig ( tag [ 2 ] ) ; if ( csync_rs_patch ( tag [ 2 ] ) ) cmd_error = strerror ( errno ) ; } break ; case a_mkdir : # ifdef __cygwin__ { char winfilename [ max_path ] ; cygwin_conv_to_win32_path ( prefixsubst ( tag [ 2 ] ) , winfilename ) ; if ( ! createdirectory ( text ( winfilename ) , null ) ) { struct stat st ; if ( lstat_strict ( prefixsubst ( tag [ 2 ] ) , & st ) != 0 || ! s_isdir ( st . st_mode ) ) { csync_debug ( 1 , ""win32<s2sv_blank>i/o<s2sv_blank>error<s2sv_blank>%d<s2sv_blank>in<s2sv_blank>mkdir<s2sv_blank>command:<s2sv_blank>%s\\n"" , ( int ) getlasterror ( ) , winfilename ) ; cmd_error = conn_response ( cr_err_win32_eio_create_dir ) ; } } } # else if ( mkdir ( prefixsubst ( tag [ 2 ] ) , 0700 ) ) { struct stat st ; if ( lstat_strict ( ( prefixsubst ( tag [ 2 ] ) ) , & st ) != 0 || ! s_isdir ( st . st_mode ) ) cmd_error = strerror ( errno ) ; } # endif break ; case a_mkchr : if ( mknod ( prefixsubst ( tag [ 2 ] ) , 0700 | s_ifchr , atoi ( tag [ 3 ] ) ) ) cmd_error = strerror ( errno ) ; break ; case a_mkblk : if ( mknod ( prefixsubst ( tag [ 2 ] ) , 0700 | s_ifblk , atoi ( tag [ 3 ] ) ) ) cmd_error = strerror ( errno ) ; break ; case a_mkfifo : if ( mknod ( prefixsubst ( tag [ 2 ] ) , 0700 | s_ififo , 0 ) ) cmd_error = strerror ( errno ) ; break ; case a_mklink : if ( symlink ( tag [ 3 ] , prefixsubst ( tag [ 2 ] ) ) ) cmd_error = strerror ( errno ) ; break ; case a_mksock : break ; case a_setown : if ( ! csync_ignore_uid || ! csync_ignore_gid ) { int uid = csync_ignore_uid ? - 1 : atoi ( tag [ 3 ] ) ; int gid = csync_ignore_gid ? - 1 : atoi ( tag [ 4 ] ) ; if ( lchown ( prefixsubst ( tag [ 2 ] ) , uid , gid ) ) cmd_error = strerror ( errno ) ; } break ; case a_setmod : if ( ! csync_ignore_mod ) { if ( chmod ( prefixsubst ( tag [ 2 ] ) , atoi ( tag [ 3 ] ) ) ) cmd_error = strerror ( errno ) ; } break ; case a_setime : { struct utimbuf utb ; utb . actime = atoll ( tag [ 3 ] ) ; utb . modtime = atoll ( tag [ 3 ] ) ; if ( utime ( prefixsubst ( tag [ 2 ] ) , & utb ) ) cmd_error = strerror ( errno ) ; } break ; case a_list : sql_begin ( ""db<s2sv_blank>dump<s2sv_blank>-<s2sv_blank>files<s2sv_blank>for<s2sv_blank>sync<s2sv_blank>pair"" , ""select<s2sv_blank>checktxt,<s2sv_blank>filename<s2sv_blank>from<s2sv_blank>file<s2sv_blank>%s%s%s<s2sv_blank>order<s2sv_blank>by<s2sv_blank>filename"" , strcmp ( tag [ 2 ] , ""-"" ) ? ""where<s2sv_blank>filename<s2sv_blank>=<s2sv_blank>\'"" : """" , strcmp ( tag [ 2 ] , ""-"" ) ? url_encode ( tag [ 2 ] ) : """" , strcmp ( tag [ 2 ] , ""-"" ) ? ""\'"" : """" ) { if ( csync_match_file_host ( url_decode ( sql_v ( 1 ) ) , tag [ 1 ] , peer , ( const char * * ) & tag [ 3 ] ) ) conn_printf ( ""%s\\t%s\\n"" , sql_v ( 0 ) , sql_v ( 1 ) ) ; } sql_end ; break ; case a_debug : csync_debug_out = stdout ; if ( tag [ 1 ] [ 0 ] ) csync_debug_level = atoi ( tag [ 1 ] ) ; break ; case a_hello : if ( peer ) { free ( peer ) ; peer = null ; } if ( verify_peername ( tag [ 1 ] , & peername ) ) { peer = strdup ( tag [ 1 ] ) ; } else { peer = null ; cmd_error = conn_response ( cr_err_identification_failed ) ; break ; } # ifdef have_libgnutls if ( ! csync_conn_usessl ) { struct csync_nossl * t ; for ( t = csync_nossl ; t ; t = t -> next ) { if ( ! fnmatch ( t -> pattern_from , myhostname , 0 ) && ! fnmatch ( t -> pattern_to , peer , 0 ) ) goto conn_without_ssl_ok ; } cmd_error = conn_response ( cr_err_ssl_expected ) ; } conn_without_ssl_ok : ; # endif break ; case a_group : if ( active_grouplist ) { cmd_error = conn_response ( cr_err_group_list_already_set ) ; } else { const struct csync_group * g ; int i , gnamelen ; active_grouplist = strdup ( tag [ 1 ] ) ; for ( g = csync_group ; g ; g = g -> next ) { if ( ! g -> myname ) continue ; i = 0 ; gnamelen = strlen ( csync_group -> gname ) ; while ( active_grouplist [ i ] ) { if ( ! strncmp ( active_grouplist + i , csync_group -> gname , gnamelen ) && ( active_grouplist [ i + gnamelen ] == ',' || ! active_grouplist [ i + gnamelen ] ) ) goto found_asactive ; while ( active_grouplist [ i ] ) if ( active_grouplist [ i ++ ] == ',' ) break ; } csync_group -> myname = 0 ; found_asactive : ; } } break ; case a_bye : for ( i = 0 ; i < 32 ; i ++ ) free ( tag [ i ] ) ; conn_resp ( cr_ok_cu_later ) ; return ; } if ( cmdtab [ cmdnr ] . update ) csync_file_update ( tag [ 2 ] , peer ) ; if ( cmdtab [ cmdnr ] . update == 1 ) { csync_debug ( 1 , ""updated<s2sv_blank>%s<s2sv_blank>from<s2sv_blank>%s.\\n"" , tag [ 2 ] , peer ? peer : ""???"" ) ; csync_schedule_commands ( tag [ 2 ] , 0 ) ; } abort_cmd : if ( cmd_error ) conn_printf ( ""%s\\n"" , cmd_error ) ; else conn_resp ( cr_ok_cmd_finished ) ; next_cmd : destroy_tag ( tag ) ; } }","<S2SV_ModStart> CR_ERR_SSL_EXPECTED ) ; peer = NULL ;
",LINBIT@csync2/416f1de878ef97e27e27508914f7ba8599a0be22,CVE-2019-15522,https://github.com/LINBIT/csync2/commit/416f1de878ef97e27e27508914f7ba8599a0be22,2020-03-20T21:15Z,<S2SV_StartBug> } <S2SV_EndBug>
796,CWE-000,"int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - ebusy ; if ( keyring ) { if ( keyring -> restrict_link ) return - eperm ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( key_flag_instantiated , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( key_flag_negative , & key -> flags ) ; set_bit ( key_flag_instantiated , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( key_flag_user_construct , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; if ( keyring ) __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , key_flag_user_construct ) ; return ret == 0 ? link_ret : ret ; }","<S2SV_ModStart> if ( keyring && link_ret == 0
",torvalds@linux/38327424b40bcebe2de92d07312c89360ac9229a,CVE-2016-4470,https://github.com/torvalds/linux/commit/38327424b40bcebe2de92d07312c89360ac9229a,2016-06-27T10:59Z,<S2SV_StartBug> if ( keyring ) <S2SV_EndBug>
7458,CWE-415,"void ddgifslurp ( gifinfo * info , bool decode , bool exitafterframe ) { gifrecordtype recordtype ; gifbytetype * extdata ; int extfunction ; giffiletype * giffileptr ; giffileptr = info -> giffileptr ; uint_fast32_t lastallocatedgcbindex = 0 ; do { if ( dgifgetrecordtype ( giffileptr , & recordtype ) == gif_error ) { break ; } bool isinitialpass = ! decode && ! exitafterframe ; switch ( recordtype ) { case image_desc_record_type : if ( dgifgetimagedesc ( giffileptr , isinitialpass ) == gif_error ) { break ; } if ( isinitialpass ) { int_fast32_t widthoverflow = giffileptr -> image . width - giffileptr -> swidth ; int_fast32_t heightoverflow = giffileptr -> image . height - giffileptr -> sheight ; if ( widthoverflow > 0 || heightoverflow > 0 ) { giffileptr -> swidth += widthoverflow ; giffileptr -> sheight += heightoverflow ; } savedimage * sp = & giffileptr -> savedimages [ giffileptr -> imagecount - 1 ] ; int_fast32_t topoverflow = giffileptr -> image . top + giffileptr -> image . height - giffileptr -> sheight ; if ( topoverflow > 0 ) { sp -> imagedesc . top -= topoverflow ; } int_fast32_t leftoverflow = giffileptr -> image . left + giffileptr -> image . width - giffileptr -> swidth ; if ( leftoverflow > 0 ) { sp -> imagedesc . left -= leftoverflow ; } if ( ! updategcb ( info , & lastallocatedgcbindex ) ) { break ; } } if ( decode ) { int_fast32_t widthoverflow = giffileptr -> image . width - info -> originalwidth ; int_fast32_t heightoverflow = giffileptr -> image . height - info -> originalheight ; const uint_fast32_t newrastersize = giffileptr -> image . width * giffileptr -> image . height ; if ( newrastersize > info -> rastersize || widthoverflow > 0 || heightoverflow > 0 ) { void * tmprasterbits = reallocarray ( info -> rasterbits , newrastersize , sizeof ( gifpixeltype ) ) ; if ( tmprasterbits == null ) { giffileptr -> error = d_gif_err_not_enough_mem ; break ; } info -> rasterbits = tmprasterbits ; info -> rastersize = newrastersize ; } if ( giffileptr -> image . interlace ) { uint_fast16_t i , j ; uint_fast8_t interlacedoffset [ ] = { 0 , 4 , 2 , 1 } ; uint_fast8_t interlacedjumps [ ] = { 8 , 8 , 4 , 2 } ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = interlacedoffset [ i ] ; j < giffileptr -> image . height ; j += interlacedjumps [ i ] ) { if ( dgifgetline ( giffileptr , info -> rasterbits + j * giffileptr -> image . width , giffileptr -> image . width ) == gif_error ) break ; } } else { if ( dgifgetline ( giffileptr , info -> rasterbits , giffileptr -> image . width * giffileptr -> image . height ) == gif_error ) { break ; } } if ( info -> samplesize > 1 ) { unsigned char * dst = info -> rasterbits ; unsigned char * src = info -> rasterbits ; unsigned char * const srcendimage = info -> rasterbits + giffileptr -> image . width * giffileptr -> image . height ; do { unsigned char * srcnextlinestart = src + giffileptr -> image . width * info -> samplesize ; unsigned char * const srcendline = src + giffileptr -> image . width ; unsigned char * dstendline = dst + giffileptr -> image . width / info -> samplesize ; do { * dst = * src ; dst ++ ; src += info -> samplesize ; } while ( src < srcendline ) ; dst = dstendline ; src = srcnextlinestart ; } while ( src < srcendimage ) ; } return ; } else { do { if ( dgifgetcodenext ( giffileptr , & extdata ) == gif_error ) { break ; } } while ( extdata != null ) ; if ( exitafterframe ) { return ; } } break ; case extension_record_type : if ( dgifgetextension ( giffileptr , & extfunction , & extdata ) == gif_error ) { break ; } if ( isinitialpass ) { updategcb ( info , & lastallocatedgcbindex ) ; if ( readextensions ( extfunction , extdata , info ) == gif_error ) { break ; } } while ( extdata != null ) { if ( dgifgetextensionnext ( giffileptr , & extdata ) == gif_error ) { break ; } if ( isinitialpass && readextensions ( extfunction , extdata , info ) == gif_error ) { break ; } } break ; case terminate_record_type : break ; default : break ; } } while ( recordtype != terminate_record_type ) ; info -> rewindfunction ( info ) ; }","<S2SV_ModStart> decode ) { <S2SV_ModEnd> const uint_fast32_t newRasterSize <S2SV_ModStart> Image . Height ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight
",koral--@android-gif-drawable/cc5b4f8e43463995a84efd594f89a21f906c2d20,CVE-2019-11932,https://github.com/koral--/android-gif-drawable/commit/cc5b4f8e43463995a84efd594f89a21f906c2d20,2019-10-03T22:15Z,<S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug>
6232,CWE-000,"static int makedirdirective ( mastate * state , cchar * key , cchar * value ) { mprpath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! matokenize ( state , value , ""%s<s2sv_blank>?*"" , & auth , & dirs ) ) { return mpr_err_bad_syntax ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) { owner = stok ( auth , "":"" , & tok ) ; if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""appweb"" ) ) { uid = http -> uid ; } else { uid = usertoid ( owner ) ; } } group = stok ( tok , "":"" , & perms ) ; if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""appweb"" ) ) { gid = http -> gid ; } else { gid = grouptoid ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , null ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return mpr_err_bad_syntax ; } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpmakepath ( state -> route , state -> configdir , dir ) ; if ( mprgetpathinfo ( path , & info ) == 0 && info . isdir ) { continue ; } if ( mprmakedir ( path , mode , uid , gid , 1 ) < 0 ) { return mpr_err_bad_syntax ; } } return 0 ; }","<S2SV_ModStart> { owner = ssplit <S2SV_ModEnd> ( auth , <S2SV_ModStart> } group = ssplit <S2SV_ModEnd> ( tok ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug>"
4160,CWE-20,"static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , dict_path_shared ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( dict_path_shared ) ) ; ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; if ( ret <= 0 ) { auth_request_log_error ( iter -> auth_request , auth_subsys_db , ""failed<s2sv_blank>to<s2sv_blank>expand<s2sv_blank>key<s2sv_blank>%s:<s2sv_blank>%s"" , key -> key -> key , error ) ; return - 1 ; } ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , auth_subsys_db , ""lookup:<s2sv_blank>%s<s2sv_blank>=<s2sv_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , auth_subsys_db , ""failed<s2sv_blank>to<s2sv_blank>lookup<s2sv_blank>key<s2sv_blank>%s:<s2sv_blank>%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != null ) { auth_request_log_debug ( iter -> auth_request , auth_subsys_db , ""lookup:<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>found,<s2sv_blank>using<s2sv_blank>default<s2sv_blank>value<s2sv_blank>%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }","<S2SV_ModStart> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> , & error <S2SV_ModStart> if ( ret > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> , error ) <S2SV_ModStart> 1 ; } <S2SV_ModEnd> else if (
",dovecot@core/000030feb7a30f193197f1aab8a7b04a26b42735,CVE-2017-2669,https://github.com/dovecot/core/commit/000030feb7a30f193197f1aab8a7b04a26b42735,2018-06-21T13:29Z,"<S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug>"
7831,CWE-20,"error_t ipstringtoaddr ( const char_t * str , ipaddr * ipaddr ) { error_t error ; # if ( ipv6_support == enabled ) if ( strchr ( str , ':' ) ) { ipaddr -> length = sizeof ( ipv6addr ) ; error = ipv6stringtoaddr ( str , & ipaddr -> ipv6addr ) ; } else # endif # if ( ipv4_support == enabled ) if ( strchr ( str , '.' ) ) { ipaddr -> length = sizeof ( ipv4addr ) ; error = ipv4stringtoaddr ( str , & ipaddr -> ipv4addr ) ; } else # endif { error = error_failure ; } return error ; }","<S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , ':' ) != NULL <S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , '.' ) != NULL
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug>"
4849,CWE-252,"size_t _dl_dst_count ( const char * name , int is_path ) { size_t cnt = 0 ; do { size_t len = 1 ; if ( ( ( ( ! __libc_enable_secure && strncmp ( & name [ 1 ] , ""origin"" , 6 ) == 0 && ( len = 7 ) != 0 ) || ( strncmp ( & name [ 1 ] , ""platform"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( ! __libc_enable_secure && strncmp ( & name [ 2 ] , ""origin}"" , 7 ) == 0 && ( len = 9 ) != 0 ) || ( strncmp ( & name [ 2 ] , ""platform}"" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) ++ cnt ; name = strchr ( name + len , '$' ) ; } while ( name != null ) ; return cnt ; }","<S2SV_ModStart> is_path ) { const char * const start = name ; <S2SV_ModStart> ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == '\\0' || ( is_path && name [ 7 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) && ( len = 7 ) != 0 ) || ( <S2SV_ModEnd> strncmp ( & <S2SV_ModStart> 1 ] , ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && <S2SV_ModEnd> ( ! __libc_enable_secure <S2SV_ModStart> ( ! __libc_enable_secure || ( ( name [ 9 ] == '\\0' || ( is_path && name [ 9 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) <S2SV_ModEnd> && ( len
",bminor@glibc/2864e767053317538feafa815046fff89e5a16be,CVE-1999-0199,https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be,2020-10-06T13:15Z,"<S2SV_StartBug> size_t cnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( ( ! __libc_enable_secure <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) <S2SV_EndBug>"
3834,CWE-264,"static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; if ( count < sizeof hdr ) return - einval ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - efault ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - eio ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( ib_user_verbs_cmd_flags_mask | ib_user_verbs_cmd_command_mask ) ) { ret = - einval ; goto out ; } command = hdr . command & ib_user_verbs_cmd_command_mask ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - eopnotsupp ; goto out ; } if ( ! file -> ucontext && command != ib_user_verbs_cmd_get_context ) { ret = - einval ; goto out ; } flags = ( hdr . command & ib_user_verbs_cmd_flags_mask ) >> ib_user_verbs_cmd_flags_shift ; if ( ! flags ) { if ( command >= array_size ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - einval ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - einval ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == ib_user_verbs_cmd_flag_extended ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= array_size ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - enosys ; goto out ; } if ( ! file -> ucontext ) { ret = - einval ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - einval ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - efault ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - einval ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - einval ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - einval ; goto out ; } if ( ! access_ok ( verify_write , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - efault ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - einval ; goto out ; } } init_udata_buf_or_null ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; init_udata_buf_or_null ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - enosys ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
",torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z,<S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug>
3902,CWE-119,"static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = tp_status_user ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = null ; struct timespec ts ; __u32 ts_status ; bool is_drop_n_account = false ; build_bug_on ( tpacket_align ( sizeof ( * h . h2 ) ) != 32 ) ; build_bug_on ( tpacket_align ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == packet_loopback ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != sock_dgram ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == packet_outgoing ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == checksum_partial ) status |= tp_status_csumnotready ; else if ( skb -> pkt_type != packet_outgoing && ( skb -> ip_summed == checksum_complete || skb_csum_unnecessary ( skb ) ) ) status |= tp_status_csum_valid ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == sock_dgram ) { macoff = netoff = tpacket_align ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = tpacket_align ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; if ( po -> has_vnet_hdr ) netoff += sizeof ( struct virtio_net_hdr ) ; macoff = netoff - maclen ; } if ( po -> tp_version <= tpacket_v2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , gfp_atomic ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) snaplen = 0 ; } } else if ( unlikely ( macoff + snaplen > get_pbdqc_from_rb ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = get_pbdqc_from_rb ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<s2sv_blank>packet<s2sv_blank>too<s2sv_blank>big,<s2sv_blank>clamped<s2sv_blank>from<s2sv_blank>%u<s2sv_blank>to<s2sv_blank>%u.<s2sv_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = get_pbdqc_from_rb ( & po -> rx_ring ) -> max_frame_len ; } } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , tp_status_kernel , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= tpacket_v2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= tp_status_losing ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= tp_status_copy ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ; if ( po -> has_vnet_hdr ) { if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case tpacket_v1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / nsec_per_usec ; hdrlen = sizeof ( * h . h1 ) ; break ; case tpacket_v2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= tp_status_vlan_valid | tp_status_vlan_tpid_valid ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case tpacket_v3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : bug ( ) ; } sll = h . raw + tpacket_align ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = af_packet ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if arch_implements_flush_dcache_page == 1 if ( po -> tp_version <= tpacket_v2 ) { u8 * start , * end ; end = ( u8 * ) page_align ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += page_size ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= tpacket_v2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }","<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
",torvalds@linux/edbd58be15a957f6a760c4a514cd475217eb97fd,CVE-2017-14497,https://github.com/torvalds/linux/commit/edbd58be15a957f6a760c4a514cd475217eb97fd,2017-09-15T18:29Z,<S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug>
863,CWE-264,"static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != sol_pppol2tp ) return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - efault ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - einval ; err = - enotconn ; if ( sk -> sk_user_data == null ) goto end ; err = - ebadf ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == null ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - ebadf ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == null ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - efault ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }","<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
",torvalds@linux/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf,CVE-2014-4943,https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf,2014-07-19T19:55Z,"<S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug>"
3450,CWE-000,"static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ; if ( serial -> num_ports < 2 ) return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointaddress = serial -> port [ 1 ] -> bulk_out_endpointaddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointaddress ) ; for ( j = 0 ; j < array_size ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }","<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
",torvalds@linux/cb3232138e37129e88240a98a1d2aba2187ff57c,CVE-2015-7566,https://github.com/torvalds/linux/commit/cb3232138e37129e88240a98a1d2aba2187ff57c,2016-02-08T03:59Z,<S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug>
6068,CWE-000,"static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( page_cache_shift - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( page_cache_shift - inode -> i_blkbits ) ; cur_logical = index << ( page_cache_shift - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , pagevec_size ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; bug_on ( ! pagelocked ( page ) ) ; bug_on ( pagewriteback ( page ) ) ; bug_on ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { bug_on ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; bug_on ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) bug_on ( bh -> b_blocknr != pblock ) ; cur_logical ++ ; pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }","<S2SV_ModStart> pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,<S2SV_StartBug> cur_logical ++ ; <S2SV_EndBug>
3325,CWE-399,"static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * * p , void * end , void * dbuf , void * ticket_buf ) { struct ceph_x_info * xi = ac -> private ; int type ; u8 tkt_struct_v , blob_struct_v ; struct ceph_x_ticket_handler * th ; void * dp , * dend ; int dlen ; char is_enc ; struct timespec validity ; struct ceph_crypto_key old_key ; void * tp , * tpend ; struct ceph_timespec new_validity ; struct ceph_crypto_key new_session_key ; struct ceph_buffer * new_ticket_blob ; unsigned long new_expires , new_renew_after ; u64 new_secret_id ; int ret ; ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ; type = ceph_decode_32 ( p ) ; dout ( ""<s2sv_blank>ticket<s2sv_blank>type<s2sv_blank>%d<s2sv_blank>%s\\n"" , type , ceph_entity_type_name ( type ) ) ; tkt_struct_v = ceph_decode_8 ( p ) ; if ( tkt_struct_v != 1 ) goto bad ; th = get_ticket_handler ( ac , type ) ; if ( is_err ( th ) ) { ret = ptr_err ( th ) ; goto out ; } dlen = ceph_x_decrypt ( secret , p , end , dbuf , temp_ticket_buf_len ) ; if ( dlen <= 0 ) { ret = dlen ; goto out ; } dout ( ""<s2sv_blank>decrypted<s2sv_blank>%d<s2sv_blank>bytes\\n"" , dlen ) ; dp = dbuf ; dend = dp + dlen ; tkt_struct_v = ceph_decode_8 ( & dp ) ; if ( tkt_struct_v != 1 ) goto bad ; memcpy ( & old_key , & th -> session_key , sizeof ( old_key ) ) ; ret = ceph_crypto_key_decode ( & new_session_key , & dp , dend ) ; if ( ret ) goto out ; ceph_decode_copy ( & dp , & new_validity , sizeof ( new_validity ) ) ; ceph_decode_timespec ( & validity , & new_validity ) ; new_expires = get_seconds ( ) + validity . tv_sec ; new_renew_after = new_expires - ( validity . tv_sec / 4 ) ; dout ( ""<s2sv_blank>expires=%lu<s2sv_blank>renew_after=%lu\\n"" , new_expires , new_renew_after ) ; ceph_decode_8_safe ( p , end , is_enc , bad ) ; tp = ticket_buf ; if ( is_enc ) { dout ( ""<s2sv_blank>encrypted<s2sv_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , temp_ticket_buf_len ) ; if ( dlen < 0 ) { ret = dlen ; goto out ; } dlen = ceph_decode_32 ( & tp ) ; } else { ceph_decode_32_safe ( p , end , dlen , bad ) ; ceph_decode_need ( p , end , dlen , bad ) ; ceph_decode_copy ( p , ticket_buf , dlen ) ; } tpend = tp + dlen ; dout ( ""<s2sv_blank>ticket<s2sv_blank>blob<s2sv_blank>is<s2sv_blank>%d<s2sv_blank>bytes\\n"" , dlen ) ; ceph_decode_need ( & tp , tpend , 1 + sizeof ( u64 ) , bad ) ; blob_struct_v = ceph_decode_8 ( & tp ) ; new_secret_id = ceph_decode_64 ( & tp ) ; ret = ceph_decode_buffer ( & new_ticket_blob , & tp , tpend ) ; if ( ret ) goto out ; ceph_crypto_key_destroy ( & th -> session_key ) ; if ( th -> ticket_blob ) ceph_buffer_put ( th -> ticket_blob ) ; th -> session_key = new_session_key ; th -> ticket_blob = new_ticket_blob ; th -> validity = new_validity ; th -> secret_id = new_secret_id ; th -> expires = new_expires ; th -> renew_after = new_renew_after ; dout ( ""<s2sv_blank>got<s2sv_blank>ticket<s2sv_blank>service<s2sv_blank>%d<s2sv_blank>(%s)<s2sv_blank>secret_id<s2sv_blank>%lld<s2sv_blank>len<s2sv_blank>%d\\n"" , type , ceph_entity_type_name ( type ) , th -> secret_id , ( int ) th -> ticket_blob -> vec . iov_len ) ; xi -> have_keys |= th -> service ; out : return ret ; bad : ret = - einval ; goto out ; }","<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6418,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z,"<S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
6343,CWE-772,"gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; om_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = null ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = kadm5_bad_principal ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( changepw_service ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , acl_inquire , arg -> princ , null ) ) ) { ret . code = kadm5_auth_get ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_strings"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != null ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug>"
3361,CWE-264,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == null ) { struct frag_hdr fhdr ; skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & msg_dontwait ) , & err ) ; if ( skb == null ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( eth_p_ipv6 ) ; skb -> ip_summed = checksum_partial ; skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = skb_gso_udp ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }","<S2SV_ModStart> * skb ; struct frag_hdr fhdr ; <S2SV_ModStart> NULL ) { <S2SV_ModEnd> skb = sock_alloc_send_skb <S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> . identification ; append : <S2SV_ModEnd> return skb_append_datato_frags (
",torvalds@linux/c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,CVE-2013-4470,https://github.com/torvalds/linux/commit/c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,2013-11-04T15:55Z,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug>"
8134,CWE-754,"void sqlite3pragma ( parse * pparse , token * pid1 , token * pid2 , token * pvalue , int minusflag ) { char * zleft = 0 ; char * zright = 0 ; const char * zdb = 0 ; token * pid ; char * afcntl [ 4 ] ; int idb ; int rc ; sqlite3 * db = pparse -> db ; db * pdb ; vdbe * v = sqlite3getvdbe ( pparse ) ; const pragmaname * ppragma ; if ( v == 0 ) return ; sqlite3vdberunonlyonce ( v ) ; pparse -> nmem = 2 ; idb = sqlite3twopartname ( pparse , pid1 , pid2 , & pid ) ; if ( idb < 0 ) return ; pdb = & db -> adb [ idb ] ; if ( idb == 1 && sqlite3opentempdatabase ( pparse ) ) { return ; } zleft = sqlite3namefromtoken ( db , pid ) ; if ( ! zleft ) return ; if ( minusflag ) { zright = sqlite3mprintf ( db , ""-%t"" , pvalue ) ; } else { zright = sqlite3namefromtoken ( db , pvalue ) ; } assert ( pid2 ) ; zdb = pid2 -> n > 0 ? pdb -> zdbsname : 0 ; if ( sqlite3authcheck ( pparse , sqlite_pragma , zleft , zright , zdb ) ) { goto pragma_out ; } afcntl [ 0 ] = 0 ; afcntl [ 1 ] = zleft ; afcntl [ 2 ] = zright ; afcntl [ 3 ] = 0 ; db -> busyhandler . nbusy = 0 ; rc = sqlite3_file_control ( db , zdb , sqlite_fcntl_pragma , ( void * ) afcntl ) ; if ( rc == sqlite_ok ) { sqlite3vdbesetnumcols ( v , 1 ) ; sqlite3vdbesetcolname ( v , 0 , colname_name , afcntl [ 0 ] , sqlite_transient ) ; returnsingletext ( v , afcntl [ 0 ] ) ; sqlite3_free ( afcntl [ 0 ] ) ; goto pragma_out ; } if ( rc != sqlite_notfound ) { if ( afcntl [ 0 ] ) { sqlite3errormsg ( pparse , ""%s"" , afcntl [ 0 ] ) ; sqlite3_free ( afcntl [ 0 ] ) ; } pparse -> nerr ++ ; pparse -> rc = rc ; goto pragma_out ; } ppragma = pragmalocate ( zleft ) ; if ( ppragma == 0 ) goto pragma_out ; if ( ( ppragma -> mpragflg & pragflg_needschema ) != 0 ) { if ( sqlite3readschema ( pparse ) ) goto pragma_out ; } if ( ( ppragma -> mpragflg & pragflg_nocolumns ) == 0 && ( ( ppragma -> mpragflg & pragflg_nocolumns1 ) == 0 || zright == 0 ) ) { setpragmaresultcolumnnames ( v , ppragma ) ; } switch ( ppragma -> epragtyp ) { # if ! defined ( sqlite_omit_pager_pragmas ) && ! defined ( sqlite_omit_deprecated ) case pragtyp_default_cache_size : { static const int iln = vdbe_offset_lineno ( 2 ) ; static const vdbeoplist getcachesize [ ] = { { op_transaction , 0 , 0 , 0 } , { op_readcookie , 0 , 1 , btree_default_cache_size } , { op_ifpos , 1 , 8 , 0 } , { op_integer , 0 , 2 , 0 } , { op_subtract , 1 , 2 , 1 } , { op_ifpos , 1 , 8 , 0 } , { op_integer , 0 , 1 , 0 } , { op_noop , 0 , 0 , 0 } , { op_resultrow , 1 , 1 , 0 } , } ; vdbeop * aop ; sqlite3vdbeusesbtree ( v , idb ) ; if ( ! zright ) { pparse -> nmem += 2 ; sqlite3vdbeverifynomallocrequired ( v , arraysize ( getcachesize ) ) ; aop = sqlite3vdbeaddoplist ( v , arraysize ( getcachesize ) , getcachesize , iln ) ; if ( only_if_realloc_stress ( aop == 0 ) ) break ; aop [ 0 ] . p1 = idb ; aop [ 1 ] . p1 = idb ; aop [ 6 ] . p1 = sqlite_default_cache_size ; } else { int size = sqlite3absint32 ( sqlite3atoi ( zright ) ) ; sqlite3beginwriteoperation ( pparse , 0 , idb ) ; sqlite3vdbeaddop3 ( v , op_setcookie , idb , btree_default_cache_size , size ) ; assert ( sqlite3schemamutexheld ( db , idb , 0 ) ) ; pdb -> pschema -> cache_size = size ; sqlite3btreesetcachesize ( pdb -> pbt , pdb -> pschema -> cache_size ) ; } break ; } # endif # if ! defined ( sqlite_omit_pager_pragmas ) case pragtyp_page_size : { btree * pbt = pdb -> pbt ; assert ( pbt != 0 ) ; if ( ! zright ) { int size = always ( pbt ) ? sqlite3btreegetpagesize ( pbt ) : 0 ; returnsingleint ( v , size ) ; } else { db -> nextpagesize = sqlite3atoi ( zright ) ; if ( sqlite_nomem == sqlite3btreesetpagesize ( pbt , db -> nextpagesize , - 1 , 0 ) ) { sqlite3oomfault ( db ) ; } } break ; } case pragtyp_secure_delete : { btree * pbt = pdb -> pbt ; int b = - 1 ; assert ( pbt != 0 ) ; if ( zright ) { if ( sqlite3_stricmp ( zright , ""fast"" ) == 0 ) { b = 2 ; } else { b = sqlite3getboolean ( zright , 0 ) ; } } if ( pid2 -> n == 0 && b >= 0 ) { int ii ; for ( ii = 0 ; ii < db -> ndb ; ii ++ ) { sqlite3btreesecuredelete ( db -> adb [ ii ] . pbt , b ) ; } } b = sqlite3btreesecuredelete ( pbt , b ) ; returnsingleint ( v , b ) ; break ; } case pragtyp_page_count : { int ireg ; sqlite3codeverifyschema ( pparse , idb ) ; ireg = ++ pparse -> nmem ; if ( sqlite3tolower ( zleft [ 0 ] ) == 'p' ) { sqlite3vdbeaddop2 ( v , op_pagecount , idb , ireg ) ; } else { sqlite3vdbeaddop3 ( v , op_maxpgcnt , idb , ireg , sqlite3absint32 ( sqlite3atoi ( zright ) ) ) ; } sqlite3vdbeaddop2 ( v , op_resultrow , ireg , 1 ) ; break ; } case pragtyp_locking_mode : { const char * zret = ""normal"" ; int emode = getlockingmode ( zright ) ; if ( pid2 -> n == 0 && emode == pager_lockingmode_query ) { emode = db -> dfltlockmode ; } else { pager * ppager ; if ( pid2 -> n == 0 ) { int ii ; assert ( pdb == & db -> adb [ 0 ] ) ; for ( ii = 2 ; ii < db -> ndb ; ii ++ ) { ppager = sqlite3btreepager ( db -> adb [ ii ] . pbt ) ; sqlite3pagerlockingmode ( ppager , emode ) ; } db -> dfltlockmode = ( u8 ) emode ; } ppager = sqlite3btreepager ( pdb -> pbt ) ; emode = sqlite3pagerlockingmode ( ppager , emode ) ; } assert ( emode == pager_lockingmode_normal || emode == pager_lockingmode_exclusive ) ; if ( emode == pager_lockingmode_exclusive ) { zret = ""exclusive"" ; } returnsingletext ( v , zret ) ; break ; } case pragtyp_journal_mode : { int emode ; int ii ; if ( zright == 0 ) { emode = pager_journalmode_query ; } else { const char * zmode ; int n = sqlite3strlen30 ( zright ) ; for ( emode = 0 ; ( zmode = sqlite3journalmodename ( emode ) ) != 0 ; emode ++ ) { if ( sqlite3strnicmp ( zright , zmode , n ) == 0 ) break ; } if ( ! zmode ) { emode = pager_journalmode_query ; } if ( emode == pager_journalmode_off && ( db -> flags & sqlite_defensive ) != 0 ) { emode = pager_journalmode_query ; } } if ( emode == pager_journalmode_query && pid2 -> n == 0 ) { idb = 0 ; pid2 -> n = 1 ; } for ( ii = db -> ndb - 1 ; ii >= 0 ; ii -- ) { if ( db -> adb [ ii ] . pbt && ( ii == idb || pid2 -> n == 0 ) ) { sqlite3vdbeusesbtree ( v , ii ) ; sqlite3vdbeaddop3 ( v , op_journalmode , ii , 1 , emode ) ; } } sqlite3vdbeaddop2 ( v , op_resultrow , 1 , 1 ) ; break ; } case pragtyp_journal_size_limit : { pager * ppager = sqlite3btreepager ( pdb -> pbt ) ; i64 ilimit = - 2 ; if ( zright ) { sqlite3decorhextoi64 ( zright , & ilimit ) ; if ( ilimit < - 1 ) ilimit = - 1 ; } ilimit = sqlite3pagerjournalsizelimit ( ppager , ilimit ) ; returnsingleint ( v , ilimit ) ; break ; } # endif # ifndef sqlite_omit_autovacuum case pragtyp_auto_vacuum : { btree * pbt = pdb -> pbt ; assert ( pbt != 0 ) ; if ( ! zright ) { returnsingleint ( v , sqlite3btreegetautovacuum ( pbt ) ) ; } else { int eauto = getautovacuum ( zright ) ; assert ( eauto >= 0 && eauto <= 2 ) ; db -> nextautovac = ( u8 ) eauto ; rc = sqlite3btreesetautovacuum ( pbt , eauto ) ; if ( rc == sqlite_ok && ( eauto == 1 || eauto == 2 ) ) { static const int iln = vdbe_offset_lineno ( 2 ) ; static const vdbeoplist setmeta6 [ ] = { { op_transaction , 0 , 1 , 0 } , { op_readcookie , 0 , 1 , btree_largest_root_page } , { op_if , 1 , 0 , 0 } , { op_halt , sqlite_ok , oe_abort , 0 } , { op_setcookie , 0 , btree_incr_vacuum , 0 } , } ; vdbeop * aop ; int iaddr = sqlite3vdbecurrentaddr ( v ) ; sqlite3vdbeverifynomallocrequired ( v , arraysize ( setmeta6 ) ) ; aop = sqlite3vdbeaddoplist ( v , arraysize ( setmeta6 ) , setmeta6 , iln ) ; if ( only_if_realloc_stress ( aop == 0 ) ) break ; aop [ 0 ] . p1 = idb ; aop [ 1 ] . p1 = idb ; aop [ 2 ] . p2 = iaddr + 4 ; aop [ 4 ] . p1 = idb ; aop [ 4 ] . p3 = eauto - 1 ; sqlite3vdbeusesbtree ( v , idb ) ; } } break ; } # endif # ifndef sqlite_omit_autovacuum case pragtyp_incremental_vacuum : { int ilimit , addr ; if ( zright == 0 || ! sqlite3getint32 ( zright , & ilimit ) || ilimit <= 0 ) { ilimit = 0x7fffffff ; } sqlite3beginwriteoperation ( pparse , 0 , idb ) ; sqlite3vdbeaddop2 ( v , op_integer , ilimit , 1 ) ; addr = sqlite3vdbeaddop1 ( v , op_incrvacuum , idb ) ; vdbecoverage ( v ) ; sqlite3vdbeaddop1 ( v , op_resultrow , 1 ) ; sqlite3vdbeaddop2 ( v , op_addimm , 1 , - 1 ) ; sqlite3vdbeaddop2 ( v , op_ifpos , 1 , addr ) ; vdbecoverage ( v ) ; sqlite3vdbejumphere ( v , addr ) ; break ; } # endif # ifndef sqlite_omit_pager_pragmas case pragtyp_cache_size : { assert ( sqlite3schemamutexheld ( db , idb , 0 ) ) ; if ( ! zright ) { returnsingleint ( v , pdb -> pschema -> cache_size ) ; } else { int size = sqlite3atoi ( zright ) ; pdb -> pschema -> cache_size = size ; sqlite3btreesetcachesize ( pdb -> pbt , pdb -> pschema -> cache_size ) ; } break ; } case pragtyp_cache_spill : { assert ( sqlite3schemamutexheld ( db , idb , 0 ) ) ; if ( ! zright ) { returnsingleint ( v , ( db -> flags & sqlite_cachespill ) == 0 ? 0 : sqlite3btreesetspillsize ( pdb -> pbt , 0 ) ) ; } else { int size = 1 ; if ( sqlite3getint32 ( zright , & size ) ) { sqlite3btreesetspillsize ( pdb -> pbt , size ) ; } if ( sqlite3getboolean ( zright , size != 0 ) ) { db -> flags |= sqlite_cachespill ; } else { db -> flags &= ~ ( u64 ) sqlite_cachespill ; } setallpagerflags ( db ) ; } break ; } case pragtyp_mmap_size : { sqlite3_int64 sz ; # if sqlite_max_mmap_size > 0 assert ( sqlite3schemamutexheld ( db , idb , 0 ) ) ; if ( zright ) { int ii ; sqlite3decorhextoi64 ( zright , & sz ) ; if ( sz < 0 ) sz = sqlite3globalconfig . szmmap ; if ( pid2 -> n == 0 ) db -> szmmap = sz ; for ( ii = db -> ndb - 1 ; ii >= 0 ; ii -- ) { if ( db -> adb [ ii ] . pbt && ( ii == idb || pid2 -> n == 0 ) ) { sqlite3btreesetmmaplimit ( db -> adb [ ii ] . pbt , sz ) ; } } } sz = - 1 ; rc = sqlite3_file_control ( db , zdb , sqlite_fcntl_mmap_size , & sz ) ; # else sz = 0 ; rc = sqlite_ok ; # endif if ( rc == sqlite_ok ) { returnsingleint ( v , sz ) ; } else if ( rc != sqlite_notfound ) { pparse -> nerr ++ ; pparse -> rc = rc ; } break ; } case pragtyp_temp_store : { if ( ! zright ) { returnsingleint ( v , db -> temp_store ) ; } else { changetempstorage ( pparse , zright ) ; } break ; } case pragtyp_temp_store_directory : { if ( ! zright ) { returnsingletext ( v , sqlite3_temp_directory ) ; } else { # ifndef sqlite_omit_wsd if ( zright [ 0 ] ) { int res ; rc = sqlite3osaccess ( db -> pvfs , zright , sqlite_access_readwrite , & res ) ; if ( rc != sqlite_ok || res == 0 ) { sqlite3errormsg ( pparse , ""not<s2sv_blank>a<s2sv_blank>writable<s2sv_blank>directory"" ) ; goto pragma_out ; } } if ( sqlite_temp_store == 0 || ( sqlite_temp_store == 1 && db -> temp_store <= 1 ) || ( sqlite_temp_store == 2 && db -> temp_store == 1 ) ) { invalidatetempstorage ( pparse ) ; } sqlite3_free ( sqlite3_temp_directory ) ; if ( zright [ 0 ] ) { sqlite3_temp_directory = sqlite3_mprintf ( ""%s"" , zright ) ; } else { sqlite3_temp_directory = 0 ; } # endif } break ; } # if sqlite_os_win case pragtyp_data_store_directory : { if ( ! zright ) { returnsingletext ( v , sqlite3_data_directory ) ; } else { # ifndef sqlite_omit_wsd if ( zright [ 0 ] ) { int res ; rc = sqlite3osaccess ( db -> pvfs , zright , sqlite_access_readwrite , & res ) ; if ( rc != sqlite_ok || res == 0 ) { sqlite3errormsg ( pparse , ""not<s2sv_blank>a<s2sv_blank>writable<s2sv_blank>directory"" ) ; goto pragma_out ; } } sqlite3_free ( sqlite3_data_directory ) ; if ( zright [ 0 ] ) { sqlite3_data_directory = sqlite3_mprintf ( ""%s"" , zright ) ; } else { sqlite3_data_directory = 0 ; } # endif } break ; } # endif # if sqlite_enable_locking_style case pragtyp_lock_proxy_file : { if ( ! zright ) { pager * ppager = sqlite3btreepager ( pdb -> pbt ) ; char * proxy_file_path = null ; sqlite3_file * pfile = sqlite3pagerfile ( ppager ) ; sqlite3osfilecontrolhint ( pfile , sqlite_get_lockproxyfile , & proxy_file_path ) ; returnsingletext ( v , proxy_file_path ) ; } else { pager * ppager = sqlite3btreepager ( pdb -> pbt ) ; sqlite3_file * pfile = sqlite3pagerfile ( ppager ) ; int res ; if ( zright [ 0 ] ) { res = sqlite3osfilecontrol ( pfile , sqlite_set_lockproxyfile , zright ) ; } else { res = sqlite3osfilecontrol ( pfile , sqlite_set_lockproxyfile , null ) ; } if ( res != sqlite_ok ) { sqlite3errormsg ( pparse , ""failed<s2sv_blank>to<s2sv_blank>set<s2sv_blank>lock<s2sv_blank>proxy<s2sv_blank>file"" ) ; goto pragma_out ; } } break ; } # endif case pragtyp_synchronous : { if ( ! zright ) { returnsingleint ( v , pdb -> safety_level - 1 ) ; } else { if ( ! db -> autocommit ) { sqlite3errormsg ( pparse , ""safety<s2sv_blank>level<s2sv_blank>may<s2sv_blank>not<s2sv_blank>be<s2sv_blank>changed<s2sv_blank>inside<s2sv_blank>a<s2sv_blank>transaction"" ) ; } else if ( idb != 1 ) { int ilevel = ( getsafetylevel ( zright , 0 , 1 ) + 1 ) & pager_synchronous_mask ; if ( ilevel == 0 ) ilevel = 1 ; pdb -> safety_level = ilevel ; pdb -> bsyncset = 1 ; setallpagerflags ( db ) ; } } break ; } # endif # ifndef sqlite_omit_flag_pragmas case pragtyp_flag : { if ( zright == 0 ) { setpragmaresultcolumnnames ( v , ppragma ) ; returnsingleint ( v , ( db -> flags & ppragma -> iarg ) != 0 ) ; } else { u64 mask = ppragma -> iarg ; if ( db -> autocommit == 0 ) { mask &= ~ ( sqlite_foreignkeys ) ; } # if sqlite_user_authentication if ( db -> auth . authlevel == uauth_user ) { mask &= ~ ( sqlite_writeschema ) ; } # endif if ( sqlite3getboolean ( zright , 0 ) ) { db -> flags |= mask ; } else { db -> flags &= ~ mask ; if ( mask == sqlite_deferfks ) db -> ndeferredimmcons = 0 ; } sqlite3vdbeaddop0 ( v , op_expire ) ; setallpagerflags ( db ) ; } break ; } # endif # ifndef sqlite_omit_schema_pragmas case pragtyp_table_info : if ( zright ) { table * ptab ; ptab = sqlite3locatetable ( pparse , locate_noerr , zright , zdb ) ; if ( ptab ) { int itabdb = sqlite3schematoindex ( db , ptab -> pschema ) ; int i , k ; int nhidden = 0 ; column * pcol ; index * ppk = sqlite3primarykeyindex ( ptab ) ; pparse -> nmem = 7 ; sqlite3codeverifyschema ( pparse , itabdb ) ; sqlite3viewgetcolumnnames ( pparse , ptab ) ; for ( i = 0 , pcol = ptab -> acol ; i < ptab -> ncol ; i ++ , pcol ++ ) { int ishidden = 0 ; if ( pcol -> colflags & colflag_noinsert ) { if ( ppragma -> iarg == 0 ) { nhidden ++ ; continue ; } if ( pcol -> colflags & colflag_virtual ) { ishidden = 2 ; } else if ( pcol -> colflags & colflag_stored ) { ishidden = 3 ; } else { assert ( pcol -> colflags & colflag_hidden ) ; ishidden = 1 ; } } if ( ( pcol -> colflags & colflag_primkey ) == 0 ) { k = 0 ; } else if ( ppk == 0 ) { k = 1 ; } else { for ( k = 1 ; k <= ptab -> ncol && ppk -> aicolumn [ k - 1 ] != i ; k ++ ) { } } assert ( pcol -> pdflt == 0 || pcol -> pdflt -> op == tk_span || ishidden >= 2 ) ; sqlite3vdbemultiload ( v , 1 , ppragma -> iarg ? ""issisii"" : ""issisi"" , i - nhidden , pcol -> zname , sqlite3columntype ( pcol , """" ) , pcol -> notnull ? 1 : 0 , pcol -> pdflt && ishidden < 2 ? pcol -> pdflt -> u . ztoken : 0 , k , ishidden ) ; } } } break ; # ifdef sqlite_debug case pragtyp_stats : { index * pidx ; hashelem * i ; pparse -> nmem = 5 ; sqlite3codeverifyschema ( pparse , idb ) ; for ( i = sqlitehashfirst ( & pdb -> pschema -> tblhash ) ; i ; i = sqlitehashnext ( i ) ) { table * ptab = sqlitehashdata ( i ) ; sqlite3vdbemultiload ( v , 1 , ""ssiii"" , ptab -> zname , 0 , ptab -> sztabrow , ptab -> nrowlogest , ptab -> tabflags ) ; for ( pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext ) { sqlite3vdbemultiload ( v , 2 , ""siiix"" , pidx -> zname , pidx -> szidxrow , pidx -> airowlogest [ 0 ] , pidx -> hasstat1 ) ; sqlite3vdbeaddop2 ( v , op_resultrow , 1 , 5 ) ; } } } break ; # endif case pragtyp_index_info : if ( zright ) { index * pidx ; table * ptab ; pidx = sqlite3findindex ( db , zright , zdb ) ; if ( pidx == 0 ) { ptab = sqlite3locatetable ( pparse , locate_noerr , zright , zdb ) ; if ( ptab && ! hasrowid ( ptab ) ) { pidx = sqlite3primarykeyindex ( ptab ) ; } } if ( pidx ) { int iidxdb = sqlite3schematoindex ( db , pidx -> pschema ) ; int i ; int mx ; if ( ppragma -> iarg ) { mx = pidx -> ncolumn ; pparse -> nmem = 6 ; } else { mx = pidx -> nkeycol ; pparse -> nmem = 3 ; } ptab = pidx -> ptable ; sqlite3codeverifyschema ( pparse , iidxdb ) ; assert ( pparse -> nmem <= ppragma -> npragcname ) ; for ( i = 0 ; i < mx ; i ++ ) { i16 cnum = pidx -> aicolumn [ i ] ; sqlite3vdbemultiload ( v , 1 , ""iisx"" , i , cnum , cnum < 0 ? 0 : ptab -> acol [ cnum ] . zname ) ; if ( ppragma -> iarg ) { sqlite3vdbemultiload ( v , 4 , ""isix"" , pidx -> asortorder [ i ] , pidx -> azcoll [ i ] , i < pidx -> nkeycol ) ; } sqlite3vdbeaddop2 ( v , op_resultrow , 1 , pparse -> nmem ) ; } } } break ; case pragtyp_index_list : if ( zright ) { index * pidx ; table * ptab ; int i ; ptab = sqlite3findtable ( db , zright , zdb ) ; if ( ptab ) { int itabdb = sqlite3schematoindex ( db , ptab -> pschema ) ; pparse -> nmem = 5 ; sqlite3codeverifyschema ( pparse , itabdb ) ; for ( pidx = ptab -> pindex , i = 0 ; pidx ; pidx = pidx -> pnext , i ++ ) { const char * azorigin [ ] = { ""c"" , ""u"" , ""pk"" } ; sqlite3vdbemultiload ( v , 1 , ""isisi"" , i , pidx -> zname , isuniqueindex ( pidx ) , azorigin [ pidx -> idxtype ] , pidx -> ppartidxwhere != 0 ) ; } } } break ; case pragtyp_database_list : { int i ; pparse -> nmem = 3 ; for ( i = 0 ; i < db -> ndb ; i ++ ) { if ( db -> adb [ i ] . pbt == 0 ) continue ; assert ( db -> adb [ i ] . zdbsname != 0 ) ; sqlite3vdbemultiload ( v , 1 , ""iss"" , i , db -> adb [ i ] . zdbsname , sqlite3btreegetfilename ( db -> adb [ i ] . pbt ) ) ; } } break ; case pragtyp_collation_list : { int i = 0 ; hashelem * p ; pparse -> nmem = 2 ; for ( p = sqlitehashfirst ( & db -> acollseq ) ; p ; p = sqlitehashnext ( p ) ) { collseq * pcoll = ( collseq * ) sqlitehashdata ( p ) ; sqlite3vdbemultiload ( v , 1 , ""is"" , i ++ , pcoll -> zname ) ; } } break ; # ifndef sqlite_omit_introspection_pragmas case pragtyp_function_list : { int i ; hashelem * j ; funcdef * p ; pparse -> nmem = 2 ; for ( i = 0 ; i < sqlite_func_hash_sz ; i ++ ) { for ( p = sqlite3builtinfunctions . a [ i ] ; p ; p = p -> u . phash ) { if ( p -> funcflags & sqlite_func_internal ) continue ; sqlite3vdbemultiload ( v , 1 , ""si"" , p -> zname , 1 ) ; } } for ( j = sqlitehashfirst ( & db -> afunc ) ; j ; j = sqlitehashnext ( j ) ) { p = ( funcdef * ) sqlitehashdata ( j ) ; sqlite3vdbemultiload ( v , 1 , ""si"" , p -> zname , 0 ) ; } } break ; # ifndef sqlite_omit_virtualtable case pragtyp_module_list : { hashelem * j ; pparse -> nmem = 1 ; for ( j = sqlitehashfirst ( & db -> amodule ) ; j ; j = sqlitehashnext ( j ) ) { module * pmod = ( module * ) sqlitehashdata ( j ) ; sqlite3vdbemultiload ( v , 1 , ""s"" , pmod -> zname ) ; } } break ; # endif case pragtyp_pragma_list : { int i ; for ( i = 0 ; i < arraysize ( apragmaname ) ; i ++ ) { sqlite3vdbemultiload ( v , 1 , ""s"" , apragmaname [ i ] . zname ) ; } } break ; # endif # endif # ifndef sqlite_omit_foreign_key case pragtyp_foreign_key_list : if ( zright ) { fkey * pfk ; table * ptab ; ptab = sqlite3findtable ( db , zright , zdb ) ; if ( ptab ) { pfk = ptab -> pfkey ; if ( pfk ) { int itabdb = sqlite3schematoindex ( db , ptab -> pschema ) ; int i = 0 ; pparse -> nmem = 8 ; sqlite3codeverifyschema ( pparse , itabdb ) ; while ( pfk ) { int j ; for ( j = 0 ; j < pfk -> ncol ; j ++ ) { sqlite3vdbemultiload ( v , 1 , ""iissssss"" , i , j , pfk -> zto , ptab -> acol [ pfk -> acol [ j ] . ifrom ] . zname , pfk -> acol [ j ] . zcol , actionname ( pfk -> aaction [ 1 ] ) , actionname ( pfk -> aaction [ 0 ] ) , ""none"" ) ; } ++ i ; pfk = pfk -> pnextfrom ; } } } } break ; # endif # ifndef sqlite_omit_foreign_key # ifndef sqlite_omit_trigger case pragtyp_foreign_key_check : { fkey * pfk ; table * ptab ; table * pparent ; index * pidx ; int i ; int j ; hashelem * k ; int x ; int regresult ; int regkey ; int regrow ; int addrtop ; int addrok ; int * aicols ; regresult = pparse -> nmem + 1 ; pparse -> nmem += 4 ; regkey = ++ pparse -> nmem ; regrow = ++ pparse -> nmem ; k = sqlitehashfirst ( & db -> adb [ idb ] . pschema -> tblhash ) ; while ( k ) { int itabdb ; if ( zright ) { ptab = sqlite3locatetable ( pparse , 0 , zright , zdb ) ; k = 0 ; } else { ptab = ( table * ) sqlitehashdata ( k ) ; k = sqlitehashnext ( k ) ; } if ( ptab == 0 || ptab -> pfkey == 0 ) continue ; itabdb = sqlite3schematoindex ( db , ptab -> pschema ) ; sqlite3codeverifyschema ( pparse , itabdb ) ; sqlite3tablelock ( pparse , itabdb , ptab -> tnum , 0 , ptab -> zname ) ; if ( ptab -> ncol + regrow > pparse -> nmem ) pparse -> nmem = ptab -> ncol + regrow ; sqlite3opentable ( pparse , 0 , itabdb , ptab , op_openread ) ; sqlite3vdbeloadstring ( v , regresult , ptab -> zname ) ; for ( i = 1 , pfk = ptab -> pfkey ; pfk ; i ++ , pfk = pfk -> pnextfrom ) { pparent = sqlite3findtable ( db , pfk -> zto , zdb ) ; if ( pparent == 0 ) continue ; pidx = 0 ; sqlite3tablelock ( pparse , itabdb , pparent -> tnum , 0 , pparent -> zname ) ; x = sqlite3fklocateindex ( pparse , pparent , pfk , & pidx , 0 ) ; if ( x == 0 ) { if ( pidx == 0 ) { sqlite3opentable ( pparse , i , itabdb , pparent , op_openread ) ; } else { sqlite3vdbeaddop3 ( v , op_openread , i , pidx -> tnum , itabdb ) ; sqlite3vdbesetp4keyinfo ( pparse , pidx ) ; } } else { k = 0 ; break ; } } assert ( pparse -> nerr > 0 || pfk == 0 ) ; if ( pfk ) break ; if ( pparse -> ntab < i ) pparse -> ntab = i ; addrtop = sqlite3vdbeaddop1 ( v , op_rewind , 0 ) ; vdbecoverage ( v ) ; for ( i = 1 , pfk = ptab -> pfkey ; pfk ; i ++ , pfk = pfk -> pnextfrom ) { pparent = sqlite3findtable ( db , pfk -> zto , zdb ) ; pidx = 0 ; aicols = 0 ; if ( pparent ) { x = sqlite3fklocateindex ( pparse , pparent , pfk , & pidx , & aicols ) ; assert ( x == 0 ) ; } addrok = sqlite3vdbemakelabel ( pparse ) ; for ( j = 0 ; j < pfk -> ncol ; j ++ ) { int icol = aicols ? aicols [ j ] : pfk -> acol [ j ] . ifrom ; sqlite3exprcodegetcolumnoftable ( v , ptab , 0 , icol , regrow + j ) ; sqlite3vdbeaddop2 ( v , op_isnull , regrow + j , addrok ) ; vdbecoverage ( v ) ; } if ( pidx ) { sqlite3vdbeaddop4 ( v , op_makerecord , regrow , pfk -> ncol , regkey , sqlite3indexaffinitystr ( db , pidx ) , pfk -> ncol ) ; sqlite3vdbeaddop4int ( v , op_found , i , addrok , regkey , 0 ) ; vdbecoverage ( v ) ; } else if ( pparent ) { int jmp = sqlite3vdbecurrentaddr ( v ) + 2 ; sqlite3vdbeaddop3 ( v , op_seekrowid , i , jmp , regrow ) ; vdbecoverage ( v ) ; sqlite3vdbegoto ( v , addrok ) ; assert ( pfk -> ncol == 1 ) ; } if ( hasrowid ( ptab ) ) { sqlite3vdbeaddop2 ( v , op_rowid , 0 , regresult + 1 ) ; } else { sqlite3vdbeaddop2 ( v , op_null , 0 , regresult + 1 ) ; } sqlite3vdbemultiload ( v , regresult + 2 , ""six"" , pfk -> zto , i - 1 ) ; sqlite3vdbeaddop2 ( v , op_resultrow , regresult , 4 ) ; sqlite3vdberesolvelabel ( v , addrok ) ; sqlite3dbfree ( db , aicols ) ; } sqlite3vdbeaddop2 ( v , op_next , 0 , addrtop + 1 ) ; vdbecoverage ( v ) ; sqlite3vdbejumphere ( v , addrtop ) ; } } break ; # endif # endif # ifndef sqlite_omit_case_sensitive_like_pragma case pragtyp_case_sensitive_like : { if ( zright ) { sqlite3registerlikefunctions ( db , sqlite3getboolean ( zright , 0 ) ) ; } } break ; # endif # ifndef sqlite_integrity_check_error_max # define sqlite_integrity_check_error_max 100 # endif # ifndef sqlite_omit_integrity_check case pragtyp_integrity_check : { int i , j , addr , mxerr ; int isquick = ( sqlite3tolower ( zleft [ 0 ] ) == 'q' ) ; assert ( idb >= 0 ) ; assert ( idb == 0 || pid2 -> z ) ; if ( pid2 -> z == 0 ) idb = - 1 ; pparse -> nmem = 6 ; mxerr = sqlite_integrity_check_error_max ; if ( zright ) { sqlite3getint32 ( zright , & mxerr ) ; if ( mxerr <= 0 ) { mxerr = sqlite_integrity_check_error_max ; } } sqlite3vdbeaddop2 ( v , op_integer , mxerr - 1 , 1 ) ; for ( i = 0 ; i < db -> ndb ; i ++ ) { hashelem * x ; hash * ptbls ; int * aroot ; int cnt = 0 ; int mxidx = 0 ; if ( omit_tempdb && i == 1 ) continue ; if ( idb >= 0 && i != idb ) continue ; sqlite3codeverifyschema ( pparse , i ) ; assert ( sqlite3schemamutexheld ( db , i , 0 ) ) ; ptbls = & db -> adb [ i ] . pschema -> tblhash ; for ( cnt = 0 , x = sqlitehashfirst ( ptbls ) ; x ; x = sqlitehashnext ( x ) ) { table * ptab = sqlitehashdata ( x ) ; index * pidx ; int nidx ; if ( hasrowid ( ptab ) ) cnt ++ ; for ( nidx = 0 , pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext , nidx ++ ) { cnt ++ ; } if ( nidx > mxidx ) mxidx = nidx ; } aroot = sqlite3dbmallocrawnn ( db , sizeof ( int ) * ( cnt + 1 ) ) ; if ( aroot == 0 ) break ; for ( cnt = 0 , x = sqlitehashfirst ( ptbls ) ; x ; x = sqlitehashnext ( x ) ) { table * ptab = sqlitehashdata ( x ) ; index * pidx ; if ( hasrowid ( ptab ) ) aroot [ ++ cnt ] = ptab -> tnum ; for ( pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext ) { aroot [ ++ cnt ] = pidx -> tnum ; } } aroot [ 0 ] = cnt ; pparse -> nmem = max ( pparse -> nmem , 8 + mxidx ) ; sqlite3cleartempregcache ( pparse ) ; sqlite3vdbeaddop4 ( v , op_integrityck , 2 , cnt , 1 , ( char * ) aroot , p4_intarray ) ; sqlite3vdbechangep5 ( v , ( u8 ) i ) ; addr = sqlite3vdbeaddop1 ( v , op_isnull , 2 ) ; vdbecoverage ( v ) ; sqlite3vdbeaddop4 ( v , op_string8 , 0 , 3 , 0 , sqlite3mprintf ( db , ""***<s2sv_blank>in<s2sv_blank>database<s2sv_blank>%s<s2sv_blank>***\\n"" , db -> adb [ i ] . zdbsname ) , p4_dynamic ) ; sqlite3vdbeaddop3 ( v , op_concat , 2 , 3 , 3 ) ; integritycheckresultrow ( v ) ; sqlite3vdbejumphere ( v , addr ) ; for ( x = sqlitehashfirst ( ptbls ) ; x ; x = sqlitehashnext ( x ) ) { table * ptab = sqlitehashdata ( x ) ; index * pidx , * ppk ; index * pprior = 0 ; int looptop ; int idatacur , iidxcur ; int r1 = - 1 ; if ( ptab -> tnum < 1 ) continue ; ppk = hasrowid ( ptab ) ? 0 : sqlite3primarykeyindex ( ptab ) ; sqlite3opentableandindices ( pparse , ptab , op_openread , 0 , 1 , 0 , & idatacur , & iidxcur ) ; sqlite3vdbeaddop2 ( v , op_integer , 0 , 7 ) ; for ( j = 0 , pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext , j ++ ) { sqlite3vdbeaddop2 ( v , op_integer , 0 , 8 + j ) ; } assert ( pparse -> nmem >= 8 + j ) ; assert ( sqlite3notempsinrange ( pparse , 1 , 7 + j ) ) ; sqlite3vdbeaddop2 ( v , op_rewind , idatacur , 0 ) ; vdbecoverage ( v ) ; looptop = sqlite3vdbeaddop2 ( v , op_addimm , 7 , 1 ) ; if ( ! isquick ) { sqlite3vdbeaddop3 ( v , op_column , idatacur , ptab -> nnvcol - 1 , 3 ) ; sqlite3vdbechangep5 ( v , opflag_typeofarg ) ; } for ( j = 0 ; j < ptab -> ncol ; j ++ ) { char * zerr ; int jmp2 ; if ( j == ptab -> ipkey ) continue ; if ( ptab -> acol [ j ] . notnull == 0 ) continue ; sqlite3exprcodegetcolumnoftable ( v , ptab , idatacur , j , 3 ) ; sqlite3vdbechangep5 ( v , opflag_typeofarg ) ; jmp2 = sqlite3vdbeaddop1 ( v , op_notnull , 3 ) ; vdbecoverage ( v ) ; zerr = sqlite3mprintf ( db , ""null<s2sv_blank>value<s2sv_blank>in<s2sv_blank>%s.%s"" , ptab -> zname , ptab -> acol [ j ] . zname ) ; sqlite3vdbeaddop4 ( v , op_string8 , 0 , 3 , 0 , zerr , p4_dynamic ) ; integritycheckresultrow ( v ) ; sqlite3vdbejumphere ( v , jmp2 ) ; } if ( ptab -> pcheck && ( db -> flags & sqlite_ignorechecks ) == 0 ) { exprlist * pcheck = sqlite3exprlistdup ( db , ptab -> pcheck , 0 ) ; if ( db -> mallocfailed == 0 ) { int addrckfault = sqlite3vdbemakelabel ( pparse ) ; int addrckok = sqlite3vdbemakelabel ( pparse ) ; char * zerr ; int k ; pparse -> iselftab = idatacur + 1 ; for ( k = pcheck -> nexpr - 1 ; k > 0 ; k -- ) { sqlite3expriffalse ( pparse , pcheck -> a [ k ] . pexpr , addrckfault , 0 ) ; } sqlite3expriftrue ( pparse , pcheck -> a [ 0 ] . pexpr , addrckok , sqlite_jumpifnull ) ; sqlite3vdberesolvelabel ( v , addrckfault ) ; pparse -> iselftab = 0 ; zerr = sqlite3mprintf ( db , ""check<s2sv_blank>constraint<s2sv_blank>failed<s2sv_blank>in<s2sv_blank>%s"" , ptab -> zname ) ; sqlite3vdbeaddop4 ( v , op_string8 , 0 , 3 , 0 , zerr , p4_dynamic ) ; integritycheckresultrow ( v ) ; sqlite3vdberesolvelabel ( v , addrckok ) ; } sqlite3exprlistdelete ( db , pcheck ) ; } if ( ! isquick ) { for ( j = 0 , pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext , j ++ ) { int jmp2 , jmp3 , jmp4 , jmp5 ; int ckuniq = sqlite3vdbemakelabel ( pparse ) ; if ( ppk == pidx ) continue ; r1 = sqlite3generateindexkey ( pparse , pidx , idatacur , 0 , 0 , & jmp3 , pprior , r1 ) ; pprior = pidx ; sqlite3vdbeaddop2 ( v , op_addimm , 8 + j , 1 ) ; jmp2 = sqlite3vdbeaddop4int ( v , op_found , iidxcur + j , ckuniq , r1 , pidx -> ncolumn ) ; vdbecoverage ( v ) ; sqlite3vdbeloadstring ( v , 3 , ""row<s2sv_blank>"" ) ; sqlite3vdbeaddop3 ( v , op_concat , 7 , 3 , 3 ) ; sqlite3vdbeloadstring ( v , 4 , ""<s2sv_blank>missing<s2sv_blank>from<s2sv_blank>index<s2sv_blank>"" ) ; sqlite3vdbeaddop3 ( v , op_concat , 4 , 3 , 3 ) ; jmp5 = sqlite3vdbeloadstring ( v , 4 , pidx -> zname ) ; sqlite3vdbeaddop3 ( v , op_concat , 4 , 3 , 3 ) ; jmp4 = integritycheckresultrow ( v ) ; sqlite3vdbejumphere ( v , jmp2 ) ; if ( isuniqueindex ( pidx ) ) { int uniqok = sqlite3vdbemakelabel ( pparse ) ; int jmp6 ; int kk ; for ( kk = 0 ; kk < pidx -> nkeycol ; kk ++ ) { int icol = pidx -> aicolumn [ kk ] ; assert ( icol != xn_rowid && icol < ptab -> ncol ) ; if ( icol >= 0 && ptab -> acol [ icol ] . notnull ) continue ; sqlite3vdbeaddop2 ( v , op_isnull , r1 + kk , uniqok ) ; vdbecoverage ( v ) ; } jmp6 = sqlite3vdbeaddop1 ( v , op_next , iidxcur + j ) ; vdbecoverage ( v ) ; sqlite3vdbegoto ( v , uniqok ) ; sqlite3vdbejumphere ( v , jmp6 ) ; sqlite3vdbeaddop4int ( v , op_idxgt , iidxcur + j , uniqok , r1 , pidx -> nkeycol ) ; vdbecoverage ( v ) ; sqlite3vdbeloadstring ( v , 3 , ""non-unique<s2sv_blank>entry<s2sv_blank>in<s2sv_blank>index<s2sv_blank>"" ) ; sqlite3vdbegoto ( v , jmp5 ) ; sqlite3vdberesolvelabel ( v , uniqok ) ; } sqlite3vdbejumphere ( v , jmp4 ) ; sqlite3resolvepartidxlabel ( pparse , jmp3 ) ; } } sqlite3vdbeaddop2 ( v , op_next , idatacur , looptop ) ; vdbecoverage ( v ) ; sqlite3vdbejumphere ( v , looptop - 1 ) ; # ifndef sqlite_omit_btreecount if ( ! isquick ) { sqlite3vdbeloadstring ( v , 2 , ""wrong<s2sv_blank>#<s2sv_blank>of<s2sv_blank>entries<s2sv_blank>in<s2sv_blank>index<s2sv_blank>"" ) ; for ( j = 0 , pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext , j ++ ) { if ( ppk == pidx ) continue ; sqlite3vdbeaddop2 ( v , op_count , iidxcur + j , 3 ) ; addr = sqlite3vdbeaddop3 ( v , op_eq , 8 + j , 0 , 3 ) ; vdbecoverage ( v ) ; sqlite3vdbechangep5 ( v , sqlite_notnull ) ; sqlite3vdbeloadstring ( v , 4 , pidx -> zname ) ; sqlite3vdbeaddop3 ( v , op_concat , 4 , 2 , 3 ) ; integritycheckresultrow ( v ) ; sqlite3vdbejumphere ( v , addr ) ; } } # endif } } { static const int iln = vdbe_offset_lineno ( 2 ) ; static const vdbeoplist endcode [ ] = { { op_addimm , 1 , 0 , 0 } , { op_ifnotzero , 1 , 4 , 0 } , { op_string8 , 0 , 3 , 0 } , { op_resultrow , 3 , 1 , 0 } , { op_halt , 0 , 0 , 0 } , { op_string8 , 0 , 3 , 0 } , { op_goto , 0 , 3 , 0 } , } ; vdbeop * aop ; aop = sqlite3vdbeaddoplist ( v , arraysize ( endcode ) , endcode , iln ) ; if ( aop ) { aop [ 0 ] . p2 = 1 - mxerr ; aop [ 2 ] . p4type = p4_static ; aop [ 2 ] . p4 . z = ""ok"" ; aop [ 5 ] . p4type = p4_static ; aop [ 5 ] . p4 . z = ( char * ) sqlite3errstr ( sqlite_corrupt ) ; } sqlite3vdbechangep3 ( v , 0 , sqlite3vdbecurrentaddr ( v ) - 2 ) ; } } break ; # endif # ifndef sqlite_omit_utf16 case pragtyp_encoding : { static const struct encname { char * zname ; u8 enc ; } encnames [ ] = { { ""utf8"" , sqlite_utf8 } , { ""utf-8"" , sqlite_utf8 } , { ""utf-16le"" , sqlite_utf16le } , { ""utf-16be"" , sqlite_utf16be } , { ""utf16le"" , sqlite_utf16le } , { ""utf16be"" , sqlite_utf16be } , { ""utf-16"" , 0 } , { ""utf16"" , 0 } , { 0 , 0 } } ; const struct encname * penc ; if ( ! zright ) { if ( sqlite3readschema ( pparse ) ) goto pragma_out ; assert ( encnames [ sqlite_utf8 ] . enc == sqlite_utf8 ) ; assert ( encnames [ sqlite_utf16le ] . enc == sqlite_utf16le ) ; assert ( encnames [ sqlite_utf16be ] . enc == sqlite_utf16be ) ; returnsingletext ( v , encnames [ enc ( pparse -> db ) ] . zname ) ; } else { if ( ! ( dbhasproperty ( db , 0 , db_schemaloaded ) ) || dbhasproperty ( db , 0 , db_empty ) ) { for ( penc = & encnames [ 0 ] ; penc -> zname ; penc ++ ) { if ( 0 == sqlite3stricmp ( zright , penc -> zname ) ) { schema_enc ( db ) = enc ( db ) = penc -> enc ? penc -> enc : sqlite_utf16native ; break ; } } if ( ! penc -> zname ) { sqlite3errormsg ( pparse , ""unsupported<s2sv_blank>encoding:<s2sv_blank>%s"" , zright ) ; } } } } break ; # endif # ifndef sqlite_omit_schema_version_pragmas case pragtyp_header_value : { int icookie = ppragma -> iarg ; sqlite3vdbeusesbtree ( v , idb ) ; if ( zright && ( ppragma -> mpragflg & pragflg_readonly ) == 0 ) { static const vdbeoplist setcookie [ ] = { { op_transaction , 0 , 1 , 0 } , { op_setcookie , 0 , 0 , 0 } , } ; vdbeop * aop ; sqlite3vdbeverifynomallocrequired ( v , arraysize ( setcookie ) ) ; aop = sqlite3vdbeaddoplist ( v , arraysize ( setcookie ) , setcookie , 0 ) ; if ( only_if_realloc_stress ( aop == 0 ) ) break ; aop [ 0 ] . p1 = idb ; aop [ 1 ] . p1 = idb ; aop [ 1 ] . p2 = icookie ; aop [ 1 ] . p3 = sqlite3atoi ( zright ) ; } else { static const vdbeoplist readcookie [ ] = { { op_transaction , 0 , 0 , 0 } , { op_readcookie , 0 , 1 , 0 } , { op_resultrow , 1 , 1 , 0 } } ; vdbeop * aop ; sqlite3vdbeverifynomallocrequired ( v , arraysize ( readcookie ) ) ; aop = sqlite3vdbeaddoplist ( v , arraysize ( readcookie ) , readcookie , 0 ) ; if ( only_if_realloc_stress ( aop == 0 ) ) break ; aop [ 0 ] . p1 = idb ; aop [ 1 ] . p1 = idb ; aop [ 1 ] . p3 = icookie ; sqlite3vdbereusable ( v ) ; } } break ; # endif # ifndef sqlite_omit_compileoption_diags case pragtyp_compile_options : { int i = 0 ; const char * zopt ; pparse -> nmem = 1 ; while ( ( zopt = sqlite3_compileoption_get ( i ++ ) ) != 0 ) { sqlite3vdbeloadstring ( v , 1 , zopt ) ; sqlite3vdbeaddop2 ( v , op_resultrow , 1 , 1 ) ; } sqlite3vdbereusable ( v ) ; } break ; # endif # ifndef sqlite_omit_wal case pragtyp_wal_checkpoint : { int ibt = ( pid2 -> z ? idb : sqlite_max_attached ) ; int emode = sqlite_checkpoint_passive ; if ( zright ) { if ( sqlite3stricmp ( zright , ""full"" ) == 0 ) { emode = sqlite_checkpoint_full ; } else if ( sqlite3stricmp ( zright , ""restart"" ) == 0 ) { emode = sqlite_checkpoint_restart ; } else if ( sqlite3stricmp ( zright , ""truncate"" ) == 0 ) { emode = sqlite_checkpoint_truncate ; } } pparse -> nmem = 3 ; sqlite3vdbeaddop3 ( v , op_checkpoint , ibt , emode , 1 ) ; sqlite3vdbeaddop2 ( v , op_resultrow , 1 , 3 ) ; } break ; case pragtyp_wal_autocheckpoint : { if ( zright ) { sqlite3_wal_autocheckpoint ( db , sqlite3atoi ( zright ) ) ; } returnsingleint ( v , db -> xwalcallback == sqlite3waldefaulthook ? sqlite_ptr_to_int ( db -> pwalarg ) : 0 ) ; } break ; # endif case pragtyp_shrink_memory : { sqlite3_db_release_memory ( db ) ; break ; } case pragtyp_optimize : { int idblast ; int itabcur ; hashelem * k ; schema * pschema ; table * ptab ; index * pidx ; logest szthreshold ; char * zsubsql ; u32 opmask ; if ( zright ) { opmask = ( u32 ) sqlite3atoi ( zright ) ; if ( ( opmask & 0x02 ) == 0 ) break ; } else { opmask = 0xfffe ; } itabcur = pparse -> ntab ++ ; for ( idblast = zdb ? idb : db -> ndb - 1 ; idb <= idblast ; idb ++ ) { if ( idb == 1 ) continue ; sqlite3codeverifyschema ( pparse , idb ) ; pschema = db -> adb [ idb ] . pschema ; for ( k = sqlitehashfirst ( & pschema -> tblhash ) ; k ; k = sqlitehashnext ( k ) ) { ptab = ( table * ) sqlitehashdata ( k ) ; if ( ( ptab -> tabflags & tf_statsused ) == 0 ) continue ; szthreshold = ptab -> nrowlogest + 46 ; assert ( sqlite3logest ( 25 ) == 46 ) ; for ( pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext ) { if ( ! pidx -> hasstat1 ) { szthreshold = 0 ; break ; } } if ( szthreshold ) { sqlite3opentable ( pparse , itabcur , idb , ptab , op_openread ) ; sqlite3vdbeaddop3 ( v , op_ifsmaller , itabcur , sqlite3vdbecurrentaddr ( v ) + 2 + ( opmask & 1 ) , szthreshold ) ; vdbecoverage ( v ) ; } zsubsql = sqlite3mprintf ( db , ""analyze<s2sv_blank>\\""%w\\"".\\""%w\\"""" , db -> adb [ idb ] . zdbsname , ptab -> zname ) ; if ( opmask & 0x01 ) { int r1 = sqlite3gettempreg ( pparse ) ; sqlite3vdbeaddop4 ( v , op_string8 , 0 , r1 , 0 , zsubsql , p4_dynamic ) ; sqlite3vdbeaddop2 ( v , op_resultrow , r1 , 1 ) ; } else { sqlite3vdbeaddop4 ( v , op_sqlexec , 0 , 0 , 0 , zsubsql , p4_dynamic ) ; } } } sqlite3vdbeaddop0 ( v , op_expire ) ; break ; } default : { assert ( ppragma -> epragtyp == pragtyp_busy_timeout ) ; if ( zright ) { sqlite3_busy_timeout ( db , sqlite3atoi ( zright ) ) ; } returnsingleint ( v , db -> busytimeout ) ; break ; } case pragtyp_soft_heap_limit : { sqlite3_int64 n ; if ( zright && sqlite3decorhextoi64 ( zright , & n ) == sqlite_ok ) { sqlite3_soft_heap_limit64 ( n ) ; } returnsingleint ( v , sqlite3_soft_heap_limit64 ( - 1 ) ) ; break ; } case pragtyp_hard_heap_limit : { sqlite3_int64 n ; if ( zright && sqlite3decorhextoi64 ( zright , & n ) == sqlite_ok ) { sqlite3_int64 iprior = sqlite3_hard_heap_limit64 ( - 1 ) ; if ( n > 0 && ( iprior == 0 || iprior > n ) ) sqlite3_hard_heap_limit64 ( n ) ; } returnsingleint ( v , sqlite3_hard_heap_limit64 ( - 1 ) ) ; break ; } case pragtyp_threads : { sqlite3_int64 n ; if ( zright && sqlite3decorhextoi64 ( zright , & n ) == sqlite_ok && n >= 0 ) { sqlite3_limit ( db , sqlite_limit_worker_threads , ( int ) ( n & 0x7fffffff ) ) ; } returnsingleint ( v , sqlite3_limit ( db , sqlite_limit_worker_threads , - 1 ) ) ; break ; } # if defined ( sqlite_debug ) || defined ( sqlite_test ) case pragtyp_lock_status : { static const char * const azlockname [ ] = { ""unlocked"" , ""shared"" , ""reserved"" , ""pending"" , ""exclusive"" } ; int i ; pparse -> nmem = 2 ; for ( i = 0 ; i < db -> ndb ; i ++ ) { btree * pbt ; const char * zstate = ""unknown"" ; int j ; if ( db -> adb [ i ] . zdbsname == 0 ) continue ; pbt = db -> adb [ i ] . pbt ; if ( pbt == 0 || sqlite3btreepager ( pbt ) == 0 ) { zstate = ""closed"" ; } else if ( sqlite3_file_control ( db , i ? db -> adb [ i ] . zdbsname : 0 , sqlite_fcntl_lockstate , & j ) == sqlite_ok ) { zstate = azlockname [ j ] ; } sqlite3vdbemultiload ( v , 1 , ""ss"" , db -> adb [ i ] . zdbsname , zstate ) ; } break ; } # endif # ifdef sqlite_has_codec case pragtyp_key : { if ( zright ) { char zbuf [ 40 ] ; const char * zkey = zright ; int n ; if ( ppragma -> iarg == 2 || ppragma -> iarg == 3 ) { u8 ibyte ; int i ; for ( i = 0 , ibyte = 0 ; i < sizeof ( zbuf ) * 2 && sqlite3isxdigit ( zright [ i ] ) ; i ++ ) { ibyte = ( ibyte << 4 ) + sqlite3hextoint ( zright [ i ] ) ; if ( ( i & 1 ) != 0 ) zbuf [ i / 2 ] = ibyte ; } zkey = zbuf ; n = i / 2 ; } else { n = ppragma -> iarg < 4 ? sqlite3strlen30 ( zright ) : - 1 ; } if ( ( ppragma -> iarg & 1 ) == 0 ) { rc = sqlite3_key_v2 ( db , zdb , zkey , n ) ; } else { rc = sqlite3_rekey_v2 ( db , zdb , zkey , n ) ; } if ( rc == sqlite_ok && n != 0 ) { sqlite3vdbesetnumcols ( v , 1 ) ; sqlite3vdbesetcolname ( v , 0 , colname_name , ""ok"" , sqlite_static ) ; returnsingletext ( v , ""ok"" ) ; } } break ; } # endif # if defined ( sqlite_has_codec ) || defined ( sqlite_enable_cerod ) case pragtyp_activate_extensions : if ( zright ) { # ifdef sqlite_has_codec if ( sqlite3strnicmp ( zright , ""see-"" , 4 ) == 0 ) { sqlite3_activate_see ( & zright [ 4 ] ) ; } # endif # ifdef sqlite_enable_cerod if ( sqlite3strnicmp ( zright , ""cerod-"" , 6 ) == 0 ) { sqlite3_activate_cerod ( & zright [ 6 ] ) ; } # endif } break ; # endif } if ( ( ppragma -> mpragflg & pragflg_nocolumns1 ) && zright ) { sqlite3vdbeverifynoresultrow ( v ) ; } pragma_out : sqlite3dbfree ( db , zleft ) ; sqlite3dbfree ( db , zright ) ; }","<S2SV_ModStart> 3 ) ; if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) { <S2SV_ModStart> OPFLAG_TYPEOFARG ) ; }
",sqlite@sqlite/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd,CVE-2019-19646,https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd,2019-12-09T19:15Z,"<S2SV_StartBug> sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; <S2SV_EndBug>"
4,CWE-362,"static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { rq = blk_mq_tag_to_rq ( tags , off + bit ) ; fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }","<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug>"
1118,CWE-119,"static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcddevice , rev_maj , rev_min ; if ( ( drv_data -> quirks & lg_rdesc ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>keyboard<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } if ( ( drv_data -> quirks & lg_rdesc_rel_abs ) && * rsize >= 50 && rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>rel/abs<s2sv_blank>in<s2sv_blank>logitech<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case usb_device_id_logitech_wheel : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , ""null<s2sv_blank>usb<s2sv_blank>device<s2sv_blank>descriptor\\n"" ) ; break ; } bcddevice = le16_to_cpu ( udesc -> bcddevice ) ; rev_maj = bcddevice >> 8 ; rev_min = bcddevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == df_rdesc_orig_size ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>driving<s2sv_blank>force<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case usb_device_id_logitech_momo_wheel : if ( * rsize == momo_rdesc_orig_size ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>momo<s2sv_blank>force<s2sv_blank>(red)<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case usb_device_id_logitech_momo_wheel2 : if ( * rsize == momo2_rdesc_orig_size ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>momo<s2sv_blank>racing<s2sv_blank>force<s2sv_blank>(black)<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case usb_device_id_logitech_vibration_wheel : if ( * rsize == fv_rdesc_orig_size ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>formula<s2sv_blank>vibration<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case usb_device_id_logitech_dfp_wheel : if ( * rsize == dfp_rdesc_orig_size ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>driving<s2sv_blank>force<s2sv_blank>pro<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case usb_device_id_logitech_wii_wheel : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0b && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>logitech<s2sv_blank>speed<s2sv_blank>force<s2sv_blank>wireless<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0b ; } break ; } return rdesc ; }","<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [
",torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z,<S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug>
4916,CWE-908,"int im_vips2dz ( image * in , const char * filename ) { char * p , * q ; char name [ filename_max ] ; char mode [ filename_max ] ; char buf [ filename_max ] ; int i ; vipsforeigndzlayout layout = vips_foreign_dz_layout_dz ; char * suffix = "".jpeg"" ; int overlap = 0 ; int tile_size = 256 ; vipsforeigndzdepth depth = vips_foreign_dz_depth_onepixel ; gboolean centre = false ; vipsangle angle = vips_angle_d0 ; im_strncpy ( name , filename , filename_max ) ; if ( ( p = strchr ( name , ':' ) ) ) { * p = '\\0' ; im_strncpy ( mode , p + 1 , filename_max ) ; } strcpy ( buf , mode ) ; p = & buf [ 0 ] ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , vips_type_foreign_dz_layout , q ) ) < 0 ) return ( - 1 ) ; layout = i ; } if ( ( q = im_getnextoption ( & p ) ) ) suffix = g_strdup ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) overlap = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) tile_size = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , vips_type_foreign_dz_depth , q ) ) < 0 ) return ( - 1 ) ; depth = i ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( im_isprefix ( ""cen"" , q ) ) centre = true ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , vips_type_angle , q ) ) < 0 ) return ( - 1 ) ; angle = i ; } if ( vips_dzsave ( in , name , ""layout"" , layout , ""suffix"" , suffix , ""overlap"" , overlap , ""tile_size"" , tile_size , ""depth"" , depth , ""centre"" , centre , ""angle"" , angle , null ) ) return ( - 1 ) ; return ( 0 ) ; }","<S2SV_ModStart> ) ; } else strcpy ( mode , """" ) ;
",libvips@libvips/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a,CVE-2020-20739,https://github.com/libvips/libvips/commit/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a,2020-11-20T19:15Z,"<S2SV_StartBug> strcpy ( buf , mode ) ; <S2SV_EndBug>"
2408,CWE-264,"static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ max_opt_args ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ; if ( ! options ) { rc = - einval ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "","" ) ) != null ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( kern_err ""error<s2sv_blank>attempting<s2sv_blank>to<s2sv_blank>register<s2sv_blank>"" ""global<s2sv_blank>sig;<s2sv_blank>rc<s2sv_blank>=<s2sv_blank>[%d]\\n"" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ecryptfs_max_cipher_name_size ) ; cipher_name_dst [ ecryptfs_max_cipher_name_size ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ecryptfs_plaintext_passthrough_enabled ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ecryptfs_xattr_metadata_enabled ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ecryptfs_xattr_metadata_enabled ; mount_crypt_stat -> flags |= ecryptfs_encrypted_view_enabled ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ecryptfs_sig_size_hex ) ; mount_crypt_stat -> global_default_fnek_sig [ ecryptfs_sig_size_hex ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ecryptfs_auth_tok_fnek ) ; if ( rc ) { printk ( kern_err ""error<s2sv_blank>attempting<s2sv_blank>to<s2sv_blank>register<s2sv_blank>"" ""global<s2sv_blank>fnek<s2sv_blank>sig<s2sv_blank>[%s];<s2sv_blank>rc<s2sv_blank>=<s2sv_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ecryptfs_global_encrypt_filenames | ecryptfs_global_encfn_use_mount_fnek ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ecryptfs_max_cipher_name_size ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ecryptfs_max_cipher_name_size ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ecryptfs_unlink_sigs ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ecryptfs_global_mount_auth_tok_only ; break ; case ecryptfs_opt_err : default : printk ( kern_warning ""%s:<s2sv_blank>ecryptfs:<s2sv_blank>unrecognized<s2sv_blank>option<s2sv_blank>[%s]\\n"" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - einval ; ecryptfs_printk ( kern_err , ""you<s2sv_blank>must<s2sv_blank>supply<s2sv_blank>at<s2sv_blank>least<s2sv_blank>one<s2sv_blank>valid<s2sv_blank>"" ""auth<s2sv_blank>tok<s2sv_blank>signature<s2sv_blank>as<s2sv_blank>a<s2sv_blank>mount<s2sv_blank>"" ""parameter;<s2sv_blank>see<s2sv_blank>the<s2sv_blank>ecryptfs<s2sv_blank>readme\\n"" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ecryptfs_default_cipher ) ; bug_on ( cipher_name_len >= ecryptfs_max_cipher_name_size ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ecryptfs_default_cipher ) ; } if ( ( mount_crypt_stat -> flags & ecryptfs_global_encrypt_filenames ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ecryptfs_global_encrypt_filenames ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , null ) ) { rc = ecryptfs_add_new_key_tfm ( null , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( kern_err ""error<s2sv_blank>attempting<s2sv_blank>to<s2sv_blank>initialize<s2sv_blank>"" ""cipher<s2sv_blank>with<s2sv_blank>name<s2sv_blank>=<s2sv_blank>[%s]<s2sv_blank>and<s2sv_blank>key<s2sv_blank>size<s2sv_blank>=<s2sv_blank>[%td];<s2sv_blank>"" ""rc<s2sv_blank>=<s2sv_blank>[%d]\\n"" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - einval ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ecryptfs_global_encrypt_filenames ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , null ) ) { rc = ecryptfs_add_new_key_tfm ( null , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( kern_err ""error<s2sv_blank>attempting<s2sv_blank>to<s2sv_blank>initialize<s2sv_blank>"" ""cipher<s2sv_blank>with<s2sv_blank>name<s2sv_blank>=<s2sv_blank>[%s]<s2sv_blank>and<s2sv_blank>key<s2sv_blank>size<s2sv_blank>=<s2sv_blank>[%td];<s2sv_blank>"" ""rc<s2sv_blank>=<s2sv_blank>[%d]\\n"" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - einval ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( kern_warning ""one<s2sv_blank>or<s2sv_blank>more<s2sv_blank>global<s2sv_blank>auth<s2sv_blank>toks<s2sv_blank>could<s2sv_blank>not<s2sv_blank>"" ""properly<s2sv_blank>register;<s2sv_blank>rc<s2sv_blank>=<s2sv_blank>[%d]\\n"" , rc ) ; out : return rc ; }","<S2SV_ModStart> char * options , uid_t * check_ruid <S2SV_ModStart> * fn_cipher_key_bytes_src ; * check_ruid = 0 ; <S2SV_ModStart> break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case
",torvalds@linux/764355487ea220fdc2faf128d577d7f679b91f97,CVE-2011-1833,https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97,2012-10-03T11:02Z,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug>"
3016,CWE-399,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( sprn_pmc5 ) , mfspr ( sprn_pmc6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }","<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug>"
7369,CWE-835,"int dwg_decode_add_object ( dwg_data * restrict dwg , bit_chain * dat , bit_chain * hdl_dat , long unsigned int address ) { long unsigned int objpos , restartpos ; bit_chain abs_dat = { null } ; unsigned char previous_bit ; dwg_object * restrict obj ; bitcode_bl num = dwg -> num_objects ; int error = 0 ; int realloced = 0 ; abs_dat = * dat ; dat -> byte = address ; dat -> bit = 0 ; realloced = dwg_add_object ( dwg ) ; if ( realloced > 0 ) { * dat = abs_dat ; return realloced ; } obj = & dwg -> object [ num ] ; log_info ( ""==========================================\\n"" ""object<s2sv_blank>number:<s2sv_blank>%lu/%lx"" , ( unsigned long ) num , ( unsigned long ) num ) obj -> size = bit_read_ms ( dat ) ; log_info ( "",<s2sv_blank>size:<s2sv_blank>%d<s2sv_blank>[ms]"" , obj -> size ) since ( r_2010 ) { obj -> handlestream_size = bit_read_umc ( dat ) ; log_info ( "",<s2sv_blank>hdlsize:<s2sv_blank>"" format_umc ""<s2sv_blank>[umc]<s2sv_blank>"" , obj -> handlestream_size ) ; obj -> bitsize = obj -> size * 8 - obj -> handlestream_size ; } objpos = bit_position ( dat ) ; obj -> address = dat -> byte ; bit_reset_chain ( dat ) ; if ( obj -> size > dat -> size ) { log_error ( ""\\ninvalid<s2sv_blank>object<s2sv_blank>size.<s2sv_blank>would<s2sv_blank>overflow"" ) ; * dat = abs_dat ; return dwg_err_valueoutofbounds ; } dat -> size = obj -> size ; since ( r_2010 ) { obj -> type = bit_read_bot ( dat ) ; } else { obj -> type = bit_read_bs ( dat ) ; } log_info ( "",<s2sv_blank>type:<s2sv_blank>%d<s2sv_blank>[%s]\\n"" , obj -> type , dat -> version >= r_2010 ? ""bot"" : ""bs"" ) ; restartpos = bit_position ( dat ) ; switch ( obj -> type ) { case dwg_type_text : error = dwg_decode_text ( dat , obj ) ; break ; case dwg_type_attrib : error = dwg_decode_attrib ( dat , obj ) ; break ; case dwg_type_attdef : error = dwg_decode_attdef ( dat , obj ) ; break ; case dwg_type_block : error = dwg_decode_block ( dat , obj ) ; break ; case dwg_type_endblk : error = dwg_decode_endblk ( dat , obj ) ; break ; case dwg_type_seqend : error = dwg_decode_seqend ( dat , obj ) ; if ( dat -> version >= r_13 && obj -> tio . entity -> ownerhandle ) { dwg_object * restrict owner = dwg_resolve_handle ( dwg , obj -> tio . entity -> ownerhandle -> absolute_ref ) ; if ( ! owner ) { log_warn ( ""no<s2sv_blank>seqend.ownerhandle"" ) } else if ( owner -> fixedtype == dwg_type_insert || owner -> fixedtype == dwg_type_minsert ) { hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_insert ( owner ) ; } else if ( owner -> fixedtype == dwg_type_polyline_2d || owner -> fixedtype == dwg_type_polyline_3d || owner -> fixedtype == dwg_type_polyline_pface || owner -> fixedtype == dwg_type_polyline_mesh ) { dwg_entity_polyline_2d * restrict _obj = owner -> tio . entity -> tio . polyline_2d ; if ( ! _obj -> seqend ) hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_polyline ( owner ) ; } } break ; case dwg_type_insert : error = dwg_decode_insert ( dat , obj ) ; break ; case dwg_type_minsert : error = dwg_decode_minsert ( dat , obj ) ; break ; case dwg_type_vertex_2d : error = dwg_decode_vertex_2d ( dat , obj ) ; break ; case dwg_type_vertex_3d : error = dwg_decode_vertex_3d ( dat , obj ) ; break ; case dwg_type_vertex_mesh : error = dwg_decode_vertex_mesh ( dat , obj ) ; break ; case dwg_type_vertex_pface : error = dwg_decode_vertex_pface ( dat , obj ) ; break ; case dwg_type_vertex_pface_face : error = dwg_decode_vertex_pface_face ( dat , obj ) ; break ; case dwg_type_polyline_2d : error = dwg_decode_polyline_2d ( dat , obj ) ; if ( dat -> version >= r_2010 ) check_polyline_handles ( obj ) ; break ; case dwg_type_polyline_3d : error = dwg_decode_polyline_3d ( dat , obj ) ; if ( dat -> version >= r_2010 ) check_polyline_handles ( obj ) ; break ; case dwg_type_arc : error = dwg_decode_arc ( dat , obj ) ; break ; case dwg_type_circle : error = dwg_decode_circle ( dat , obj ) ; break ; case dwg_type_line : error = dwg_decode_line ( dat , obj ) ; break ; case dwg_type_dimension_ordinate : error = dwg_decode_dimension_ordinate ( dat , obj ) ; break ; case dwg_type_dimension_linear : error = dwg_decode_dimension_linear ( dat , obj ) ; break ; case dwg_type_dimension_aligned : error = dwg_decode_dimension_aligned ( dat , obj ) ; break ; case dwg_type_dimension_ang3pt : error = dwg_decode_dimension_ang3pt ( dat , obj ) ; break ; case dwg_type_dimension_ang2ln : error = dwg_decode_dimension_ang2ln ( dat , obj ) ; break ; case dwg_type_dimension_radius : error = dwg_decode_dimension_radius ( dat , obj ) ; break ; case dwg_type_dimension_diameter : error = dwg_decode_dimension_diameter ( dat , obj ) ; break ; case dwg_type_point : error = dwg_decode_point ( dat , obj ) ; break ; case dwg_type__3dface : error = dwg_decode__3dface ( dat , obj ) ; break ; case dwg_type_polyline_pface : error = dwg_decode_polyline_pface ( dat , obj ) ; if ( dat -> version >= r_2010 ) check_polyline_handles ( obj ) ; break ; case dwg_type_polyline_mesh : error = dwg_decode_polyline_mesh ( dat , obj ) ; if ( dat -> version >= r_2010 ) check_polyline_handles ( obj ) ; break ; case dwg_type_solid : error = dwg_decode_solid ( dat , obj ) ; break ; case dwg_type_trace : error = dwg_decode_trace ( dat , obj ) ; break ; case dwg_type_shape : error = dwg_decode_shape ( dat , obj ) ; break ; case dwg_type_viewport : error = dwg_decode_viewport ( dat , obj ) ; break ; case dwg_type_ellipse : error = dwg_decode_ellipse ( dat , obj ) ; break ; case dwg_type_spline : error = dwg_decode_spline ( dat , obj ) ; break ; case dwg_type_region : error = dwg_decode_region ( dat , obj ) ; break ; case dwg_type__3dsolid : error = dwg_decode__3dsolid ( dat , obj ) ; break ; case dwg_type_body : error = dwg_decode_body ( dat , obj ) ; break ; case dwg_type_ray : error = dwg_decode_ray ( dat , obj ) ; break ; case dwg_type_xline : error = dwg_decode_xline ( dat , obj ) ; break ; case dwg_type_dictionary : error = dwg_decode_dictionary ( dat , obj ) ; break ; case dwg_type_mtext : error = dwg_decode_mtext ( dat , obj ) ; break ; case dwg_type_leader : error = dwg_decode_leader ( dat , obj ) ; break ; case dwg_type_tolerance : error = dwg_decode_tolerance ( dat , obj ) ; break ; case dwg_type_mline : error = dwg_decode_mline ( dat , obj ) ; break ; case dwg_type_block_control : error = dwg_decode_block_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . block_control ) { obj -> tio . object -> tio . block_control -> objid = num ; if ( ! dwg -> block_control . parent ) dwg -> block_control = * obj -> tio . object -> tio . block_control ; else log_warn ( ""second<s2sv_blank>block_control<s2sv_blank>object<s2sv_blank>ignored"" ) ; } break ; case dwg_type_block_header : error = dwg_decode_block_header ( dat , obj ) ; break ; case dwg_type_layer_control : error = dwg_decode_layer_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . layer_control ) { obj -> tio . object -> tio . layer_control -> objid = num ; dwg -> layer_control = * obj -> tio . object -> tio . layer_control ; } break ; case dwg_type_layer : error = dwg_decode_layer ( dat , obj ) ; break ; case dwg_type_style_control : error = dwg_decode_style_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . style_control ) { obj -> tio . object -> tio . style_control -> objid = num ; dwg -> style_control = * obj -> tio . object -> tio . style_control ; } break ; case dwg_type_style : error = dwg_decode_style ( dat , obj ) ; break ; case dwg_type_ltype_control : error = dwg_decode_ltype_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . ltype_control ) { obj -> tio . object -> tio . ltype_control -> objid = num ; dwg -> ltype_control = * obj -> tio . object -> tio . ltype_control ; } break ; case dwg_type_ltype : error = dwg_decode_ltype ( dat , obj ) ; break ; case dwg_type_view_control : error = dwg_decode_view_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . view_control ) { obj -> tio . object -> tio . view_control -> objid = num ; dwg -> view_control = * obj -> tio . object -> tio . view_control ; } break ; case dwg_type_view : error = dwg_decode_view ( dat , obj ) ; break ; case dwg_type_ucs_control : error = dwg_decode_ucs_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . ucs_control ) { obj -> tio . object -> tio . ucs_control -> objid = num ; dwg -> ucs_control = * obj -> tio . object -> tio . ucs_control ; } break ; case dwg_type_ucs : error = dwg_decode_ucs ( dat , obj ) ; break ; case dwg_type_vport_control : error = dwg_decode_vport_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . vport_control ) { obj -> tio . object -> tio . vport_control -> objid = num ; dwg -> vport_control = * obj -> tio . object -> tio . vport_control ; } break ; case dwg_type_vport : error = dwg_decode_vport ( dat , obj ) ; break ; case dwg_type_appid_control : error = dwg_decode_appid_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . appid_control ) { obj -> tio . object -> tio . appid_control -> objid = num ; dwg -> appid_control = * obj -> tio . object -> tio . appid_control ; } break ; case dwg_type_appid : error = dwg_decode_appid ( dat , obj ) ; break ; case dwg_type_dimstyle_control : error = dwg_decode_dimstyle_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . dimstyle_control ) { obj -> tio . object -> tio . dimstyle_control -> objid = num ; dwg -> dimstyle_control = * obj -> tio . object -> tio . dimstyle_control ; } break ; case dwg_type_dimstyle : error = dwg_decode_dimstyle ( dat , obj ) ; break ; case dwg_type_vport_entity_control : error = dwg_decode_vport_entity_control ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . vport_entity_control ) { obj -> tio . object -> tio . vport_entity_control -> objid = num ; dwg -> vport_entity_control = * obj -> tio . object -> tio . vport_entity_control ; } break ; case dwg_type_vport_entity_header : error = dwg_decode_vport_entity_header ( dat , obj ) ; break ; case dwg_type_group : error = dwg_decode_group ( dat , obj ) ; break ; case dwg_type_mlinestyle : error = dwg_decode_mlinestyle ( dat , obj ) ; break ; case dwg_type_ole2frame : error = dwg_decode_ole2frame ( dat , obj ) ; break ; case dwg_type_dummy : error = dwg_decode_dummy ( dat , obj ) ; break ; case dwg_type_long_transaction : error = dwg_decode_long_transaction ( dat , obj ) ; break ; case dwg_type_lwpolyline : error = dwg_decode_lwpolyline ( dat , obj ) ; break ; case dwg_type_hatch : error = dwg_decode_hatch ( dat , obj ) ; break ; case dwg_type_xrecord : error = dwg_decode_xrecord ( dat , obj ) ; break ; case dwg_type_placeholder : error = dwg_decode_placeholder ( dat , obj ) ; break ; case dwg_type_oleframe : error = dwg_decode_oleframe ( dat , obj ) ; break ; case dwg_type_vba_project : log_error ( ""unhandled<s2sv_blank>object<s2sv_blank>vba_project.<s2sv_blank>has<s2sv_blank>its<s2sv_blank>own<s2sv_blank>section"" ) ; error = dwg_err_unhandledclass ; break ; case dwg_type_layout : error = dwg_decode_layout ( dat , obj ) ; break ; case dwg_type_proxy_entity : error = dwg_decode_proxy_entity ( dat , obj ) ; break ; case dwg_type_proxy_object : error = dwg_decode_proxy_object ( dat , obj ) ; break ; default : if ( obj -> type == dwg -> layout_type ) error = dwg_decode_layout ( dat , obj ) ; else if ( ( error = dwg_decode_variable_type ( dwg , dat , hdl_dat , obj ) ) & dwg_err_unhandledclass ) { int is_entity = 0 ; int i = obj -> type - 500 ; dwg_class * klass = null ; bit_set_position ( dat , restartpos ) ; if ( i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = dwg_class_is_entity ( klass ) ; } else { if ( i < 0 ) { log_error ( ""invalid<s2sv_blank>class<s2sv_blank>index<s2sv_blank>%d<s2sv_blank><0"" , i ) ; } else { log_error ( ""invalid<s2sv_blank>class<s2sv_blank>index<s2sv_blank>%d<s2sv_blank>>%d"" , i , ( int ) dwg -> num_classes ) ; } obj -> supertype = dwg_supertype_unknown ; obj -> type = 0 ; * dat = abs_dat ; return error | dwg_err_valueoutofbounds ; } if ( klass && ! is_entity ) { int err = dwg_decode_unknown_obj ( dat , obj ) ; error |= err ; obj -> supertype = dwg_supertype_unknown ; if ( ! dat ) return error ; if ( err >= dwg_err_critical ) * dat = abs_dat ; } else if ( klass ) { int err ; # if 0 && ! defined ( is_release ) if ( streqc ( klass -> dxfname , ""multileader"" ) ) { char * mleader = bit_read_tf ( dat , obj -> size ) ; log_insane_tf ( mleader , ( int ) obj -> size ) bit_set_position ( dat , restartpos ) ; free ( mleader ) ; } # endif err = dwg_decode_unknown_ent ( dat , obj ) ; error |= err ; obj -> supertype = dwg_supertype_unknown ; if ( ! dat ) return error ; if ( err >= dwg_err_critical ) * dat = abs_dat ; } else { log_warn ( ""unknown<s2sv_blank>object,<s2sv_blank>skipping<s2sv_blank>eed/reactors/xdic"" ) ; since ( r_2000 ) { obj -> bitsize = bit_read_rl ( dat ) ; log_trace ( ""bitsize:<s2sv_blank>"" format_rl ""<s2sv_blank>[rl]<s2sv_blank>@%lu.%u\\n"" , obj -> bitsize , dat -> byte - 2 , dat -> bit ) ; if ( obj -> bitsize > obj -> size * 8 ) { log_error ( ""invalid<s2sv_blank>bitsize<s2sv_blank>"" format_rl ""<s2sv_blank>=><s2sv_blank>"" format_rl , obj -> bitsize , obj -> size * 8 ) ; obj -> bitsize = obj -> size * 8 ; error |= dwg_err_valueoutofbounds ; } } if ( ! bit_read_h ( dat , & obj -> handle ) ) { log_trace ( ""handle:<s2sv_blank>"" format_h ""<s2sv_blank>[h<s2sv_blank>5]\\n"" , args_h ( obj -> handle ) ) ; } restartpos = dat -> byte ; obj -> supertype = dwg_supertype_unknown ; obj -> tio . unknown = bit_read_tf ( dat , obj -> size ) ; dat -> byte = restartpos ; } } } if ( obj -> handle . value ) { log_handle ( ""<s2sv_blank>object_map{%lx}<s2sv_blank>=<s2sv_blank>%lu\\n"" , obj -> handle . value , ( unsigned long ) num ) ; hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; } if ( dat -> byte > 8 * dat -> size ) { log_error ( ""invalid<s2sv_blank>object<s2sv_blank>address<s2sv_blank>(overflow):<s2sv_blank>%lu<s2sv_blank>><s2sv_blank>%lu"" , dat -> byte , 8 * dat -> size ) ; * dat = abs_dat ; return error | dwg_err_invaliddwg ; } restartpos = bit_position ( dat ) ; * dat = abs_dat ; bit_set_position ( dat , objpos + restartpos ) ; if ( dat -> bit ) { unsigned char r = 8 - dat -> bit ; log_handle ( ""<s2sv_blank>padding:<s2sv_blank>%x/%x<s2sv_blank>(%d<s2sv_blank>bits)\\n"" , dat -> chain [ dat -> byte ] , dat -> chain [ dat -> byte ] & ( ( 1 << r ) - 1 ) , r ) ; bit_advance_position ( dat , r ) ; } bit_set_position ( dat , ( obj -> address + obj -> size ) * 8 - 2 ) ; if ( ! bit_check_crc ( dat , address , 0xc0c1 ) ) error |= dwg_err_wrongcrc ; * dat = abs_dat ; return realloced ? - 1 : error ; }","<S2SV_ModStart> , restartpos ) ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN <S2SV_ModStart> } obj -> <S2SV_ModEnd> type = 0 <S2SV_ModStart> } if ( is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ; else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; if ( ! <S2SV_ModEnd> dat ) return <S2SV_ModStart> ; if ( error <S2SV_ModEnd> >= DWG_ERR_CRITICAL ) <S2SV_ModStart> = abs_dat ; <S2SV_ModEnd> } } if
",LibreDWG@libredwg/c6f6668b82bfe595899cc820279ac37bb9ef16f5,CVE-2019-20911,https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5,2020-07-16T18:15Z,"<S2SV_StartBug> bit_set_position ( dat , restartpos ) ; <S2SV_EndBug> <S2SV_StartBug> obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> if ( err >= DWG_ERR_CRITICAL ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
7516,CWE-20,"static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = null ; char_u * s , * p ; int did_chartab = false ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & p_alloced ) ; # ifdef feat_gui int redraw_gui_only = false ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , opt_global ) ; if ( ( secure # ifdef have_sandbox || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & p_secure ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & p_nfname ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != null ) { errmsg = e_invarg ; } else if ( varp == & t_name ) { if ( t_name [ 0 ] == nul ) errmsg = ( char_u * ) n_ ( ""e529:<s2sv_blank>cannot<s2sv_blank>set<s2sv_blank>\'term\'<s2sv_blank>to<s2sv_blank>empty<s2sv_blank>string"" ) ; # ifdef feat_gui if ( gui . in_use ) errmsg = ( char_u * ) n_ ( ""e530:<s2sv_blank>cannot<s2sv_blank>change<s2sv_blank>term<s2sv_blank>in<s2sv_blank>gui"" ) ; else if ( term_is_gui ( t_name ) ) errmsg = ( char_u * ) n_ ( ""e531:<s2sv_blank>use<s2sv_blank>\\"":gui\\""<s2sv_blank>to<s2sv_blank>start<s2sv_blank>the<s2sv_blank>gui"" ) ; # endif else if ( set_termname ( t_name ) == fail ) errmsg = ( char_u * ) n_ ( ""e522:<s2sv_blank>not<s2sv_blank>found<s2sv_blank>in<s2sv_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & opt_local ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & opt_local ) && * bkc == nul ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , true ) != ok ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & bkc_auto ) != 0 ) + ( ( ( int ) * flags & bkc_yes ) != 0 ) + ( ( ( int ) * flags & bkc_no ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , true ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( strcmp ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) n_ ( ""e589:<s2sv_blank>\'backupext\'<s2sv_blank>and<s2sv_blank>\'patchmode\'<s2sv_blank>are<s2sv_blank>equal"" ) ; } # ifdef feat_linebreak else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == fail ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == fail ) { did_chartab = true ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""vim"" , ( char_u * ) """" ) ; didset_vim = false ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""vimruntime"" , ( char_u * ) """" ) ; didset_vimruntime = false ; } } # ifdef feat_syn_hl else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef feat_multi_lang else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != nul ; s += 3 ) { if ( s [ 1 ] == nul || ( ( s [ 2 ] != ',' || s [ 3 ] == nul ) && s [ 2 ] != nul ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == nul ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == fail ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , true ) != ok ) errmsg = e_invarg ; } # ifdef feat_session else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , true ) != ok ) errmsg = e_invarg ; if ( ( ssop_flags & ssop_curdir ) && ( ssop_flags & ssop_sesdir ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , true ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , true ) != ok ) errmsg = e_invarg ; } # endif # ifdef feat_scrollbind else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , true ) != ok ) errmsg = e_invarg ; } # endif # ifdef feat_mbyte else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , false ) != ok ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != null ) errmsg = ( char_u * ) _ ( ""e834:<s2sv_blank>conflicts<s2sv_blank>with<s2sv_blank>value<s2sv_blank>of<s2sv_blank>\'listchars\'"" ) ; # if defined ( feat_windows ) || defined ( feat_folding ) else if ( set_chars_option ( & p_fcs ) != null ) errmsg = ( char_u * ) _ ( ""e835:<s2sv_blank>conflicts<s2sv_blank>with<s2sv_blank>value<s2sv_blank>of<s2sv_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , false ) == ok ) { # ifdef feat_eval int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( false , false ) ; # ifdef feat_eval if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != null ) { do_unlet ( ( char_u * ) ""g:colors_name"" , true ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( false , false ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == fail ) errmsg = e_invarg ; } # ifdef feat_cmdl_compl else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , true ) != ok ) errmsg = e_invarg ; } # endif # ifdef feat_wak else if ( varp == & p_wak ) { if ( * p_wak == nul || check_opt_strings ( p_wak , p_wak_values , false ) != ok ) errmsg = e_invarg ; # ifdef feat_menu # ifdef feat_gui_motif else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef feat_gui_gtk else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef feat_autocmd else if ( varp == & p_ei ) { if ( check_ei ( ) == fail ) errmsg = e_invarg ; } # endif # ifdef feat_mbyte else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != opt_global ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != null ) errmsg = e_invarg ; else { # ifdef feat_title redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == null ) { p = enc_canonize ( * varp ) ; if ( p != null ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef feat_title redraw_titles ( ) ; # endif } } # if defined ( feat_gui_gtk ) if ( errmsg == null && varp == & p_tenc && gui . in_use ) { if ( strcmp ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) n_ ( ""e617:<s2sv_blank>cannot<s2sv_blank>be<s2sv_blank>changed<s2sv_blank>in<s2sv_blank>the<s2sv_blank>gtk+<s2sv_blank>2<s2sv_blank>gui"" ) ; } # endif if ( errmsg == null ) { # ifdef feat_keymap if ( varp == & p_enc && * curbuf -> b_p_keymap != nul ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != nul ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( win3264 ) && defined ( feat_mbyte ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( feat_postscript ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != null ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != nul ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = tolower_asc ( * s ) ; } } } # endif # if defined ( feat_xim ) && defined ( feat_gui_gtk ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef feat_keymap else if ( varp == & curbuf -> b_p_keymap ) { errmsg = keymap_init ( ) ; if ( errmsg == null ) { if ( * curbuf -> b_p_keymap != nul ) { curbuf -> b_p_iminsert = b_imode_lmap ; if ( curbuf -> b_p_imsearch != b_imode_use_insert ) curbuf -> b_p_imsearch = b_imode_lmap ; } else { if ( curbuf -> b_p_iminsert == b_imode_lmap ) curbuf -> b_p_iminsert = b_imode_none ; if ( curbuf -> b_p_imsearch == b_imode_lmap ) curbuf -> b_p_imsearch = b_imode_use_insert ; } if ( ( opt_flags & opt_local ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef feat_windows status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & opt_global ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , false ) != ok ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == eol_dos ) curbuf -> b_p_tx = true ; else curbuf -> b_p_tx = false ; # ifdef feat_title redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == eol_mac || * oldval == 'm' ) redraw_curbuf_later ( not_valid ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , true ) != ok ) errmsg = e_invarg ; else { if ( * p_ffs == nul ) p_ta = false ; else p_ta = true ; } } # if defined ( feat_crypt ) else if ( gvarp == & p_key ) { # if defined ( feat_cmdhist ) remove_key_from_history ( ) ; # endif if ( strcmp ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == nul ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & opt_local ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , true ) != ok ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == fail ) errmsg = e_invarg ; else { if ( * p_cm == nul ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = true ; } if ( ( opt_flags & ( opt_local | opt_global ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & opt_local ) && * oldval == nul ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == nul ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( strcmp ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & opt_global ) && strcmp ( p_cm , oldval ) != 0 ) { buf_t * buf ; for_all_buffers ( buf ) if ( buf != curbuf && * buf -> b_p_cm == nul ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef feat_mbyte if ( has_mbyte ) { for ( p = * varp ; * p != nul ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != nul ) p += mb_ptr2len ( p ) ; if ( * p != nul ) x2 = * p ++ ; if ( * p != nul ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != nul && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == nul ) break ; } } else # endif { for ( p = * varp ; * p != nul ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == nul || ( p [ 3 ] != nul && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == nul ) break ; } } } # ifdef feat_comments else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) com_all , * s ) == null && ! vim_isdigit ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == nul ) errmsg = ( char_u * ) n_ ( ""e524:<s2sv_blank>missing<s2sv_blank>colon"" ) ; else if ( * s == ',' || * s == nul ) errmsg = ( char_u * ) n_ ( ""e525:<s2sv_blank>zero<s2sv_blank>length<s2sv_blank>string"" ) ; if ( errmsg != null ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != nul ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( feat_windows ) || defined ( feat_folding ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef feat_cmdwin else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != nul && verbose_open ( ) == fail ) errmsg = e_invarg ; } # ifdef feat_viminfo else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == null ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! vim_isdigit ( * ( s - 1 ) ) ) { if ( errbuf != null ) { sprintf ( ( char * ) errbuf , _ ( ""e526:<s2sv_blank>missing<s2sv_blank>number<s2sv_blank>after<s2sv_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != null ) errmsg = ( char_u * ) n_ ( ""e527:<s2sv_blank>missing<s2sv_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == null && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) n_ ( ""e528:<s2sv_blank>must<s2sv_blank>specify<s2sv_blank>a<s2sv_blank>\'<s2sv_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & t_cco ) { int colors = atoi ( ( char * ) t_cco ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( t_cco ) ; t_cco = empty_option ; } init_highlight ( true , false ) ; } } ttest ( false ) ; if ( varp == & t_me ) { out_str ( t_me ) ; redraw_later ( clear ) ; # if defined ( win3264 ) && ! defined ( feat_gui_w32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef feat_linebreak else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) n_ ( ""e595:<s2sv_blank>contains<s2sv_blank>unprintable<s2sv_blank>or<s2sv_blank>wide<s2sv_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef feat_gui else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( feat_gui_gtk ) if ( strcmp ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != null ) ? p : vim_strsave ( oldval ) ; new_value_alloced = true ; } # endif if ( p != null && gui_init_font ( p_guifont , false ) != ok ) { # if defined ( feat_gui_mswin ) || defined ( feat_gui_photon ) if ( strcmp ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = true ; } else # endif errmsg = ( char_u * ) n_ ( ""e596:<s2sv_blank>invalid<s2sv_blank>font(s)"" ) ; } } redraw_gui_only = true ; } # ifdef feat_xfontset else if ( varp == & p_guifontset ) { if ( strcmp ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) n_ ( ""e597:<s2sv_blank>can\'t<s2sv_blank>select<s2sv_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , true ) != ok ) errmsg = ( char_u * ) n_ ( ""e598:<s2sv_blank>invalid<s2sv_blank>fontset"" ) ; redraw_gui_only = true ; } # endif # ifdef feat_mbyte else if ( varp == & p_guifontwide ) { if ( strcmp ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) n_ ( ""e533:<s2sv_blank>can\'t<s2sv_blank>select<s2sv_blank>wide<s2sv_blank>font"" ) ; else if ( gui_get_wide_font ( ) == fail ) errmsg = ( char_u * ) n_ ( ""e534:<s2sv_blank>invalid<s2sv_blank>wide<s2sv_blank>font"" ) ; redraw_gui_only = true ; } # endif # endif # ifdef cursor_shape else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( shape_cursor ) ; # endif # ifdef feat_mouseshape else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( shape_mouse ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef feat_printer else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( feat_mbyte ) && defined ( feat_postscript ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef feat_langmap else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef feat_linebreak else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef feat_title else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef feat_stl_opt int flagval = ( varp == & p_titlestring ) ? stl_in_title : stl_in_icon ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == null ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef feat_gui else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = true ; } # endif # if defined ( feat_gui_tabline ) else if ( varp == & p_gtl ) { redraw_tabline = true ; redraw_gui_only = true ; } else if ( varp == & p_gtt ) { redraw_gui_only = true ; } # endif # if defined ( feat_mouse_tty ) && ( defined ( unix ) || defined ( vms ) ) else if ( varp == & p_ttym ) { mch_setmouse ( false ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , false ) != ok ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == nul || check_opt_strings ( p_sel , p_sel_values , false ) != ok ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , true ) != ok ) errmsg = e_invarg ; } # ifdef feat_browse else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , false ) != ok && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , true ) != ok ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != null ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != null ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , false ) != ok ) errmsg = e_invarg ; # if defined ( feat_gui_motif ) && defined ( feat_menu ) && ( xmversion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , true ) != ok ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , true ) != ok ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , true ) != ok ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef feat_windows else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , false ) != ok ) errmsg = e_invarg ; } # endif # ifdef feat_clipboard else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef feat_spell else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != ok ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != ok ) errmsg = e_invarg ; } # endif # ifdef feat_quickfix else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , false ) != ok ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , false ) != ok ) errmsg = e_invarg ; else { # ifdef feat_windows if ( curwin -> w_status_height ) { curwin -> w_redr_status = true ; redraw_later ( valid ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef feat_title redraw_titles ( ) ; # endif } } # endif # ifdef feat_stl_opt else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == null ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == null ) comp_col ( ) ; } # endif # ifdef feat_ins_expand else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<s2sv_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tu"" , * s ) == null ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != nul && * s != ',' && * s != '<s2sv_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<s2sv_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != null ) { sprintf ( ( char * ) errbuf , _ ( ""e535:<s2sv_blank>illegal<s2sv_blank>character<s2sv_blank>after<s2sv_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , true ) != ok ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef feat_signs else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , false ) != ok ) errmsg = e_invarg ; } # endif # if defined ( feat_toolbar ) && ! defined ( feat_gui_w32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , true ) != ok ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( toolbar_text | toolbar_icons ) ) != 0 ) ; } } # endif # if defined ( feat_toolbar ) && defined ( feat_gui_gtk ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , false ) != ok ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( toolbar_text | toolbar_icons ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , true , true , false ) ; if ( p != null ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = true ; } } } else if ( varp == & p_bs ) { if ( vim_isdigit ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != nul ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , true ) != ok ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , true ) != ok ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & opt_local ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & opt_local ) && * p == nul ) * flags = 0 ; else if ( * p == nul || opt_strings_flags ( p , p_tc_values , flags , false ) != ok ) errmsg = e_invarg ; } # ifdef feat_mbyte else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , true ) != ok ) errmsg = e_invarg ; } # endif # ifdef feat_diff else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == fail ) errmsg = e_invarg ; } # endif # ifdef feat_folding else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , false ) != ok || * curwin -> w_p_fdm == nul ) errmsg = e_invarg ; else { foldupdateall ( curwin ) ; if ( foldmethodisdiff ( curwin ) ) newfoldlevel ( ) ; } } # ifdef feat_eval else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodisexpr ( curwin ) ) foldupdateall ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == null ) errmsg = ( char_u * ) n_ ( ""e536:<s2sv_blank>comma<s2sv_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == nul ) errmsg = e_invarg ; else if ( foldmethodismarker ( curwin ) ) foldupdateall ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != nul && strstr ( ( char * ) * varp , ""%s"" ) == null ) errmsg = ( char_u * ) n_ ( ""e537:<s2sv_blank>\'commentstring\'<s2sv_blank>must<s2sv_blank>be<s2sv_blank>empty<s2sv_blank>or<s2sv_blank>contain<s2sv_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , true ) != ok ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , true ) != ok ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodisindent ( curwin ) ) foldupdateall ( curwin ) ; } # endif # ifdef feat_virtualedit else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , true ) != ok ) errmsg = e_invarg ; else if ( strcmp ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( feat_cscope ) && defined ( feat_quickfix ) else if ( varp == & p_csqf ) { if ( p_csqf != null ) { p = p_csqf ; while ( * p != nul ) { if ( vim_strchr ( ( char_u * ) csqf_cmds , * p ) == null || p [ 1 ] == nul || vim_strchr ( ( char_u * ) csqf_flags , p [ 1 ] ) == null || ( p [ 2 ] != nul && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == nul ) break ; else p += 3 ; } } } # endif # ifdef feat_cindent else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( feat_render_options ) else if ( varp == & p_rop && gui . in_use ) { if ( ! gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif else { p = null ; if ( varp == & p_ww ) p = ( char_u * ) ww_all ; if ( varp == & p_shm ) p = ( char_u * ) shm_all ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) cpo_all ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) fo_all ; # ifdef feat_conceal else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) cocu_all ; # endif else if ( varp == & p_mouse ) { # ifdef feat_mouse p = ( char_u * ) mouse_all ; # else if ( * p_mouse != nul ) errmsg = ( char_u * ) n_ ( ""e538:<s2sv_blank>no<s2sv_blank>mouse<s2sv_blank>support"" ) ; # endif } # if defined ( feat_gui ) else if ( varp == & p_go ) p = ( char_u * ) go_all ; # endif if ( p != null ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == null ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != null ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef feat_eval set_option_scriptid_idx ( opt_idx , opt_flags , current_sid ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= p_alloced ; else options [ opt_idx ] . flags &= ~ p_alloced ; if ( ( opt_flags & ( opt_local | opt_global ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & pv_both ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , opt_local ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & opt_local ) && opt_flags != opt_global ) set_string_option_global ( opt_idx , varp ) ; # ifdef feat_autocmd # ifdef feat_syn_hl if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( event_syntax , curbuf -> b_p_syn , curbuf -> b_fname , true , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = true ; apply_autocmds ( event_filetype , curbuf -> b_p_ft , curbuf -> b_fname , true , curbuf ) ; } # endif # ifdef feat_spell if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( strncmp ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != nul ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != null ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , dip_all ) ; } # endif } # ifdef feat_mouse if ( varp == & p_mouse ) { # ifdef feat_mouse_tty if ( * p_mouse == nul ) mch_setmouse ( false ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != maxcol && ( options [ opt_idx ] . flags & ( p_curswant | p_rall ) ) != 0 ) curwin -> w_set_curswant = true ; # ifdef feat_gui if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }","<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
",vim@vim/d0b5138ba4bccff8a744c99836041ef6322ed39a,CVE-2016-1248,https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a,2016-11-23T15:59Z,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug>
6925,CWE-400,"asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( regs , insn ) ; int orig_asi , asi ; current_thread_info ( ) -> kern_una_regs = regs ; current_thread_info ( ) -> kern_una_insn = insn ; orig_asi = asi = decode_asi ( insn , regs ) ; if ( asi == asi_aius ) { kernel_mna_trap_fault ( 0 ) ; return ; } log_unaligned ( regs ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""unsupported<s2sv_blank>unaligned<s2sv_blank>load/store<s2sv_blank>trap<s2sv_blank>for<s2sv_blank>kernel<s2sv_blank>"" ""at<s2sv_blank><%016lx>.\\n"" , regs -> tpc ) ; unaligned_panic ( ""kernel<s2sv_blank>does<s2sv_blank>fpu/atomic<s2sv_blank>"" ""unaligned<s2sv_blank>load/store."" , regs ) ; kernel_mna_trap_fault ( 0 ) ; } else { unsigned long addr , * reg_addr ; int err ; addr = compute_effective_address ( regs , insn , ( ( insn >> 25 ) & 0x1f ) ) ; perf_sw_event ( perf_count_sw_alignment_faults , 1 , 0 , regs , addr ) ; switch ( asi ) { case asi_nl : case asi_aiupl : case asi_aiusl : case asi_pl : case asi_sl : case asi_pnfl : case asi_snfl : asi &= ~ 0x08 ; break ; } switch ( dir ) { case load : reg_addr = fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) ; err = do_int_load ( reg_addr , size , ( unsigned long * ) addr , decode_signedness ( insn ) , asi ) ; if ( likely ( ! err ) && unlikely ( asi != orig_asi ) ) { unsigned long val_in = * reg_addr ; switch ( size ) { case 2 : val_in = swab16 ( val_in ) ; break ; case 4 : val_in = swab32 ( val_in ) ; break ; case 8 : val_in = swab64 ( val_in ) ; break ; case 16 : default : bug ( ) ; break ; } * reg_addr = val_in ; } break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs , asi , orig_asi ) ; break ; default : panic ( ""impossible<s2sv_blank>kernel<s2sv_blank>unaligned<s2sv_blank>trap."" ) ; } if ( unlikely ( err ) ) kernel_mna_trap_fault ( 1 ) ; else advance ( regs ) ; } }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug>"
636,CWE-119,"static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct device * dev = & intf -> dev ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct net_device * netdev ; struct catc * catc ; u8 broadcast [ eth_alen ] ; int i , pktsz , ret ; if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . binterfacenumber , 1 ) ) { dev_err ( dev , ""can\'t<s2sv_blank>set<s2sv_blank>altsetting<s2sv_blank>1.\\n"" ) ; return - eio ; } netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; if ( ! netdev ) return - enomem ; catc = netdev_priv ( netdev ) ; netdev -> netdev_ops = & catc_netdev_ops ; netdev -> watchdog_timeo = tx_timeout ; netdev -> ethtool_ops = & ops ; catc -> usbdev = usbdev ; catc -> netdev = netdev ; spin_lock_init ( & catc -> tx_lock ) ; spin_lock_init ( & catc -> ctrl_lock ) ; init_timer ( & catc -> timer ) ; catc -> timer . data = ( long ) catc ; catc -> timer . function = catc_stats_timer ; catc -> ctrl_urb = usb_alloc_urb ( 0 , gfp_kernel ) ; catc -> tx_urb = usb_alloc_urb ( 0 , gfp_kernel ) ; catc -> rx_urb = usb_alloc_urb ( 0 , gfp_kernel ) ; catc -> irq_urb = usb_alloc_urb ( 0 , gfp_kernel ) ; if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { dev_err ( & intf -> dev , ""no<s2sv_blank>free<s2sv_blank>urbs<s2sv_blank>available.\\n"" ) ; ret = - enomem ; goto fail_free ; } if ( le16_to_cpu ( usbdev -> descriptor . idvendor ) == 0x0423 && le16_to_cpu ( usbdev -> descriptor . idproduct ) == 0xa && le16_to_cpu ( catc -> usbdev -> descriptor . bcddevice ) == 0x0130 ) { dev_dbg ( dev , ""testing<s2sv_blank>for<s2sv_blank>f5u011\\n"" ) ; catc -> is_f5u011 = 1 ; atomic_set ( & catc -> recq_sz , 0 ) ; pktsz = rx_pkt_sz ; } else { pktsz = rx_max_burst * ( pkt_sz + 2 ) ; } usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , null , null , 0 , catc_ctrl_done , catc ) ; usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , null , 0 , catc_tx_done , catc ) ; usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , catc -> rx_buf , pktsz , catc_rx_done , catc ) ; usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; if ( ! catc -> is_f5u011 ) { dev_dbg ( dev , ""checking<s2sv_blank>memory<s2sv_blank>size\\n"" ) ; i = 0x12345678 ; catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; i = 0x87654321 ; catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; switch ( i ) { case 0x12345678 : catc_set_reg ( catc , txbufcount , 8 ) ; catc_set_reg ( catc , rxbufcount , 32 ) ; dev_dbg ( dev , ""64k<s2sv_blank>memory\\n"" ) ; break ; default : dev_warn ( & intf -> dev , ""couldn\'t<s2sv_blank>detect<s2sv_blank>memory<s2sv_blank>size,<s2sv_blank>assuming<s2sv_blank>32k\\n"" ) ; case 0x87654321 : catc_set_reg ( catc , txbufcount , 4 ) ; catc_set_reg ( catc , rxbufcount , 16 ) ; dev_dbg ( dev , ""32k<s2sv_blank>memory\\n"" ) ; break ; } dev_dbg ( dev , ""getting<s2sv_blank>mac<s2sv_blank>from<s2sv_blank>seerom.\\n"" ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""setting<s2sv_blank>mac<s2sv_blank>into<s2sv_blank>registers.\\n"" ) ; for ( i = 0 ; i < 6 ; i ++ ) catc_set_reg ( catc , stationaddr0 - i , netdev -> dev_addr [ i ] ) ; dev_dbg ( dev , ""filling<s2sv_blank>the<s2sv_blank>multicast<s2sv_blank>list.\\n"" ) ; eth_broadcast_addr ( broadcast ) ; catc_multicast ( broadcast , catc -> multicast ) ; catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; dev_dbg ( dev , ""clearing<s2sv_blank>error<s2sv_blank>counters.\\n"" ) ; for ( i = 0 ; i < 8 ; i ++ ) catc_set_reg ( catc , ethstats + i , 0 ) ; catc -> last_stats = jiffies ; dev_dbg ( dev , ""enabling.\\n"" ) ; catc_set_reg ( catc , maxburst , rx_max_burst ) ; catc_set_reg ( catc , opmodes , optxmerge | oprxmerge | opleninclude | op3memwaits ) ; catc_set_reg ( catc , ledctrl , ledlink ) ; catc_set_reg ( catc , rxunit , rxenable | rxpolarity | rxmulticast ) ; } else { dev_dbg ( dev , ""performing<s2sv_blank>reset\\n"" ) ; catc_reset ( catc ) ; catc_get_mac ( catc , netdev -> dev_addr ) ; dev_dbg ( dev , ""setting<s2sv_blank>rx<s2sv_blank>mode\\n"" ) ; catc -> rxmode [ 0 ] = rxenable | rxpolarity | rxmulticast ; catc -> rxmode [ 1 ] = 0 ; f5u011_rxmode ( catc , catc -> rxmode ) ; } dev_dbg ( dev , ""init<s2sv_blank>done.\\n"" ) ; printk ( kern_info ""%s:<s2sv_blank>%s<s2sv_blank>usb<s2sv_blank>ethernet<s2sv_blank>at<s2sv_blank>usb-%s-%s,<s2sv_blank>%pm.\\n"" , netdev -> name , ( catc -> is_f5u011 ) ? ""belkin<s2sv_blank>f5u011"" : ""catc<s2sv_blank>el1210a<s2sv_blank>netmate"" , usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; usb_set_intfdata ( intf , catc ) ; set_netdev_dev ( netdev , & intf -> dev ) ; ret = register_netdev ( netdev ) ; if ( ret ) goto fail_clear_intfdata ; return 0 ; fail_clear_intfdata : usb_set_intfdata ( intf , null ) ; fail_free : usb_free_urb ( catc -> ctrl_urb ) ; usb_free_urb ( catc -> tx_urb ) ; usb_free_urb ( catc -> rx_urb ) ; usb_free_urb ( catc -> irq_urb ) ; free_netdev ( netdev ) ; return ret ; }","<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;
",torvalds@linux/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478,CVE-2017-8070,https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478,2017-04-23T05:59Z,"<S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
7247,CWE-125,"int pure_strcmp ( const char * const s1 , const char * const s2 ) { return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1u ) ; }","<S2SV_ModStart> s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> , s2 , len + 1 <S2SV_ModEnd> ) ; }
",jedisct1@pure-ftpd/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,CVE-2020-9365,https://github.com/jedisct1/pure-ftpd/commit/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,2020-02-24T16:15Z,"<S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug>"
4514,CWE-125,"static char * fp_readl ( char * s , int size , struct tok_state * tok ) { pyobject * bufobj ; const char * buf ; py_ssize_t buflen ; assert ( size > 0 ) ; size -- ; if ( tok -> decoding_buffer ) { bufobj = tok -> decoding_buffer ; py_incref ( bufobj ) ; } else { bufobj = pyobject_callobject ( tok -> decoding_readline , null ) ; if ( bufobj == null ) goto error ; } if ( pyunicode_checkexact ( bufobj ) ) { buf = pyunicode_asutf8andsize ( bufobj , & buflen ) ; if ( buf == null ) { goto error ; } } else { buf = pybytearray_asstring ( bufobj ) ; if ( buf == null ) { goto error ; } buflen = pybytearray_get_size ( bufobj ) ; } py_xdecref ( tok -> decoding_buffer ) ; if ( buflen > size ) { tok -> decoding_buffer = pybytearray_fromstringandsize ( buf + size , buflen - size ) ; if ( tok -> decoding_buffer == null ) goto error ; buflen = size ; } else tok -> decoding_buffer = null ; memcpy ( s , buf , buflen ) ; s [ buflen ] = '\\0' ; if ( buflen == 0 ) s = null ; py_decref ( bufobj ) ; return s ; error : py_xdecref ( bufobj ) ; return error_ret ( tok ) ; }","<S2SV_ModStart> { bufobj = _PyObject_CallNoArg <S2SV_ModEnd> ( tok -> <S2SV_ModStart> tok -> decoding_readline <S2SV_ModEnd> ) ; if
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug>"
4550,CWE-125,"int obj2ast_type_ignore ( pyobject * obj , type_ignore_ty * out , pyarena * arena ) { int isinstance ; pyobject * tmp = null ; if ( obj == py_none ) { * out = null ; return 0 ; } isinstance = pyobject_isinstance ( obj , ( pyobject * ) typeignore_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { int lineno ; if ( _pyobject_hasattrid ( obj , & pyid_lineno ) ) { int res ; tmp = _pyobject_getattrid ( obj , & pyid_lineno ) ; if ( tmp == null ) goto failed ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; py_clear ( tmp ) ; } else { pyerr_setstring ( pyexc_typeerror , ""required<s2sv_blank>field<s2sv_blank>\\""lineno\\""<s2sv_blank>missing<s2sv_blank>from<s2sv_blank>typeignore"" ) ; return 1 ; } * out = typeignore ( lineno , arena ) ; if ( * out == null ) goto failed ; return 0 ; } pyerr_format ( pyexc_typeerror , ""expected<s2sv_blank>some<s2sv_blank>sort<s2sv_blank>of<s2sv_blank>type_ignore,<s2sv_blank>but<s2sv_blank>got<s2sv_blank>%r"" , obj ) ; failed : py_xdecref ( tmp ) ; return 1 ; }","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } * out = TypeIgnore ( <S2SV_ModEnd> lineno , arena <S2SV_ModStart> ; if ( * out == NULL <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; <S2SV_ModEnd> return 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res != 0 ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug>"
3863,CWE-125,"static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , ""missing<s2sv_blank>descriptor<s2sv_blank>data\\n"" ) ; return null ; } if ( ! buflen ) { dev_err ( & intf -> dev , ""zero<s2sv_blank>length<s2sv_blank>descriptor\\n"" ) ; return null ; } while ( buflen > 0 ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bdescriptortype == usb_dt_cs_interface && union_desc -> bdescriptorsubtype == usb_cdc_union_type ) { dev_dbg ( & intf -> dev , ""found<s2sv_blank>union<s2sv_blank>header\\n"" ) ; return union_desc ; } buflen -= union_desc -> blength ; buf += union_desc -> blength ; } dev_err ( & intf -> dev , ""missing<s2sv_blank>cdc<s2sv_blank>union<s2sv_blank>descriptor\\n"" ) ; return null ; }","<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> ""Found<S2SV_blank>union<S2SV_blank>header\\n"" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen
",torvalds@linux/ea04efee7635c9120d015dcdeeeb6988130cb67a,CVE-2017-16645,https://github.com/torvalds/linux/commit/ea04efee7635c9120d015dcdeeeb6988130cb67a,2017-11-07T23:29Z,<S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> <S2SV_StartBug> return union_desc ; <S2SV_EndBug>
3287,CWE-399,"static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = null ; struct fileentry * fe ; struct extendedfileentry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = udf_i ( inode ) ; struct udf_sb_info * sbi = udf_sb ( inode -> i_sb ) ; unsigned int link_count ; bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<s2sv_blank>%ld)<s2sv_blank>failed<s2sv_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != tag_ident_fe && ident != tag_ident_efe && ident != tag_ident_use ) { udf_err ( inode -> i_sb , ""(ino<s2sv_blank>%ld)<s2sv_blank>failed<s2sv_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileentry * ) bh -> b_data ; efe = ( struct extendedfileentry * ) bh -> b_data ; if ( fe -> icbtag . strategytype == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == tag_ident_ie && ibh ) { struct buffer_head * nbh = null ; struct kernel_lb_addr loc ; struct indirectentry * ie ; ie = ( struct indirectentry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirecticb . extlocation ) ; if ( ie -> indirecticb . extlength && ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , & ident ) ) ) { if ( ident == tag_ident_fe || ident == tag_ident_efe ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; } brelse ( nbh ) ; } } brelse ( ibh ) ; } else if ( fe -> icbtag . strategytype != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<s2sv_blank>strategy<s2sv_blank>type:<s2sv_blank>%d\\n"" , le16_to_cpu ( fe -> icbtag . strategytype ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbtag . strategytype == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbtag . flags ) & icbtag_flag_ad_mask ; iinfo -> i_unique = 0 ; iinfo -> i_leneattr = 0 ; iinfo -> i_lenextents = 0 ; iinfo -> i_lenalloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> desctag . tagident == cpu_to_le16 ( tag_ident_efe ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedfileentry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedfileentry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedfileentry ) ) ; } else if ( fe -> desctag . tagident == cpu_to_le16 ( tag_ident_fe ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileentry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileentry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileentry ) ) ; } else if ( fe -> desctag . tagident == cpu_to_le16 ( tag_ident_use ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenalloc = le32_to_cpu ( ( ( struct unallocspaceentry * ) bh -> b_data ) -> lengthallocdescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocspaceentry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocspaceentry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocspaceentry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || udf_query_flag ( inode -> i_sb , udf_flag_uid_ignore ) || udf_query_flag ( inode -> i_sb , udf_flag_uid_set ) ) inode -> i_uid = udf_sb ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || udf_query_flag ( inode -> i_sb , udf_flag_gid_ignore ) || udf_query_flag ( inode -> i_sb , udf_flag_gid_set ) ) inode -> i_gid = udf_sb ( inode -> i_sb ) -> s_gid ; if ( fe -> icbtag . filetype != icbtag_file_type_directory && sbi -> s_fmode != udf_invalid_mode ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbtag . filetype == icbtag_file_type_directory && sbi -> s_dmode != udf_invalid_mode ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> filelinkcount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationlength ) ; iinfo -> i_lenextents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalblocksrecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accesstime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationtime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrtime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueid ) ; iinfo -> i_leneattr = le32_to_cpu ( fe -> lengthextendedattr ) ; iinfo -> i_lenalloc = le32_to_cpu ( fe -> lengthallocdescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalblocksrecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accesstime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationtime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createtime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrtime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueid ) ; iinfo -> i_leneattr = le32_to_cpu ( efe -> lengthextendedattr ) ; iinfo -> i_lenalloc = le32_to_cpu ( efe -> lengthallocdescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbtag . filetype ) { case icbtag_file_type_directory : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= s_ifdir ; inc_nlink ( inode ) ; break ; case icbtag_file_type_realtime : case icbtag_file_type_regular : case icbtag_file_type_undef : case icbtag_file_type_vat20 : if ( iinfo -> i_alloc_type == icbtag_flag_ad_in_icb ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= s_ifreg ; break ; case icbtag_file_type_block : inode -> i_mode |= s_ifblk ; break ; case icbtag_file_type_char : inode -> i_mode |= s_ifchr ; break ; case icbtag_file_type_fifo : init_special_inode ( inode , inode -> i_mode | s_ififo , 0 ) ; break ; case icbtag_file_type_socket : init_special_inode ( inode , inode -> i_mode | s_ifsock , 0 ) ; break ; case icbtag_file_type_symlink : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = s_iflnk | s_irwxugo ; break ; case icbtag_file_type_main : udf_debug ( ""metadata<s2sv_blank>file-----\\n"" ) ; break ; case icbtag_file_type_mirror : udf_debug ( ""metadata<s2sv_blank>mirror<s2sv_blank>file-----\\n"" ) ; break ; case icbtag_file_type_bitmap : udf_debug ( ""metadata<s2sv_blank>bitmap<s2sv_blank>file-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<s2sv_blank>%ld)<s2sv_blank>failed<s2sv_blank>unknown<s2sv_blank>file<s2sv_blank>type=%d\\n"" , inode -> i_ino , fe -> icbtag . filetype ) ; make_bad_inode ( inode ) ; return ; } if ( s_ischr ( inode -> i_mode ) || s_isblk ( inode -> i_mode ) ) { struct devicespec * dsea = ( struct devicespec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , mkdev ( le32_to_cpu ( dsea -> majordeviceident ) , le32_to_cpu ( dsea -> minordeviceident ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }","<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
",torvalds@linux/c03aa9f6e1f938618e6db2e23afef0574efeeb65,CVE-2014-6410,https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65,2014-09-28T10:55Z,"<S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug>"
3858,CWE-264,"static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = null ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = null ; struct futex_hash_bucket * hb ; union futex_key key2 = futex_key_init ; struct futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - einval ; if ( ! bitset ) return - einval ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & flags_clockrt ) ? clock_realtime : clock_monotonic , hrtimer_mode_abs ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rb_clear_node ( & rt_waiter . pi_tree_entry ) ; rb_clear_node ( & rt_waiter . tree_entry ) ; rt_waiter . task = null ; ret = get_futex_key ( uaddr2 , flags & flags_shared , & key2 , verify_write ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { warn_on ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - efault ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - eintr ) { ret = - ewouldblock ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }","<S2SV_ModStart> goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
",torvalds@linux/e9c243a5a6de0be8e584c604d353412584b592f8,CVE-2014-3153,https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8,2014-06-07T14:55Z,"<S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug>"
7770,CWE-125,"stmt_ty assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int end_lineno , int end_col_offset , pyarena * arena ) { stmt_ty p ; if ( ! value ) { pyerr_setstring ( pyexc_valueerror , ""field<s2sv_blank>value<s2sv_blank>is<s2sv_blank>required<s2sv_blank>for<s2sv_blank>assign"" ) ; return null ; } p = ( stmt_ty ) pyarena_malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return null ; p -> kind = assign_kind ; p -> v . assign . targets = targets ; p -> v . assign . value = value ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug>"
6230,CWE-000,"static int crossorigindirective ( mastate * state , cchar * key , cchar * value ) { httproute * route ; char * option , * ovalue , * tok ; route = state -> route ; tok = sclone ( value ) ; while ( ( option = magetnextarg ( tok , & tok ) ) != 0 ) { option = stok ( option , ""<s2sv_blank>=\\t,"" , & ovalue ) ; ovalue = strim ( ovalue , ""\\""\'"" , mpr_trim_both ) ; if ( scaselessmatch ( option , ""origin"" ) ) { route -> corsorigin = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , ""credentials"" ) ) { route -> corscredentials = httpgetbooltoken ( ovalue ) ; } else if ( scaselessmatch ( option , ""headers"" ) ) { route -> corsheaders = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , ""age"" ) ) { route -> corsage = atoi ( ovalue ) ; } else { mprlog ( ""error<s2sv_blank>appweb<s2sv_blank>config"" , 0 , ""unknown<s2sv_blank>crossorigin<s2sv_blank>option<s2sv_blank>%s"" , option ) ; return mpr_err_bad_syntax ; } } # if keep if ( smatch ( route -> corsorigin , ""*"" ) && route -> corscredentials ) { mprlog ( ""error<s2sv_blank>appweb<s2sv_blank>config"" , 0 , ""crossorigin:<s2sv_blank>cannot<s2sv_blank>use<s2sv_blank>wildcard<s2sv_blank>origin<s2sv_blank>if<s2sv_blank>allowing<s2sv_blank>credentials"" ) ; return mpr_err_bad_state ; } # endif httpaddroutemethods ( route , ""options"" ) ; route -> flags |= http_route_cors ; return 0 ; }","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug>"
6128,CWE-401,"static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = null , * iter ; unsigned int tos_off ; u8 mask , val ; int err ; if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) goto err_delete ; tos_off = proto == htons ( eth_p_ip ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { nl_set_err_msg_mod ( extack , ""conflict<s2sv_blank>with<s2sv_blank>already<s2sv_blank>offloaded<s2sv_blank>filter"" ) ; goto err_delete ; } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , gfp_kernel ) ; if ( ! match ) return - enomem ; list_add ( & match -> list , & alink -> dscp_map ) ; } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ; return - eopnotsupp ; }","<S2SV_ModStart> extack ) ) { err = - EOPNOTSUPP ; <S2SV_ModStart> goto err_delete ; } <S2SV_ModStart> ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ; err = - EOPNOTSUPP ; <S2SV_ModStart> ! match ) { err = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto err_delete ; } <S2SV_ModStart> ) ; return err <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/78beef629fd95be4ed853b2d37b832f766bd96ca,CVE-2019-19076,https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca,2019-11-18T06:15Z,"<S2SV_StartBug> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> list_add ( & match -> list , & alink -> dscp_map ) ; <S2SV_EndBug> <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug>"
228,CWE-17,"static struct fileidentdesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileidentdesc * cfi ) { struct fileidentdesc * fi = null ; loff_t f_pos ; int block , flen ; unsigned char * fname = null ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = udf_i ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = null ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != icbtag_flag_ad_in_icb ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( ext_recorded_allocated >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == icbtag_flag_ad_short ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == icbtag_flag_ad_long ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fibh -> sbh ) goto out_err ; } fname = kmalloc ( udf_name_len , gfp_nofs ) ; if ( ! fname ) goto out_err ; while ( f_pos < size ) { fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out_err ; liu = le16_to_cpu ( cfi -> lengthofimpuse ) ; lfi = cfi -> lengthfileident ; if ( fibh -> sbh == fibh -> ebh ) { nameptr = fi -> fileident + liu ; } else { int poffset ; poffset = fibh -> soffset + sizeof ( struct fileidentdesc ) + liu + lfi ; if ( poffset >= lfi ) nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + poffset - lfi ) ; else { nameptr = fname ; memcpy ( nameptr , fi -> fileident + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh -> ebh -> b_data , poffset ) ; } } if ( ( cfi -> filecharacteristics & fid_file_char_deleted ) != 0 ) { if ( ! udf_query_flag ( dir -> i_sb , udf_flag_undelete ) ) continue ; } if ( ( cfi -> filecharacteristics & fid_file_char_hidden ) != 0 ) { if ( ! udf_query_flag ( dir -> i_sb , udf_flag_unhide ) ) continue ; } if ( ( cfi -> filecharacteristics & fid_file_char_parent ) && isdotdot ) goto out_ok ; if ( ! lfi ) continue ; flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ; } out_err : fi = null ; if ( fibh -> sbh != fibh -> ebh ) brelse ( fibh -> ebh ) ; brelse ( fibh -> sbh ) ; out_ok : brelse ( epos . bh ) ; kfree ( fname ) ; return fi ; }","<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug>"
4877,CWE-362,"static int mptctl_mpt_command ( unsigned long arg ) { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_command karg ; mpt_adapter * ioc ; int iocnum ; int rc ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( kern_err mynam ""%s@%d::mptctl_mpt_command<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>read<s2sv_blank>in<s2sv_blank>mpt_ioctl_command<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , __file__ , __line__ , uarg ) ; return - efault ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == null ) ) { printk ( kern_debug mynam ""%s::mptctl_mpt_command()<s2sv_blank>@%d<s2sv_blank>-<s2sv_blank>ioc%d<s2sv_blank>not<s2sv_blank>found!\\n"" , __file__ , __line__ , iocnum ) ; return - enodev ; } rc = mptctl_do_mpt_command ( karg , & uarg -> mf ) ; return rc ; }","<S2SV_ModStart> int mptctl_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_command karg <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> rc = mptctl_do_mpt_command <S2SV_ModStart> = mptctl_do_mpt_command ( ioc ,
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_mpt_command ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_command karg ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <S2SV_EndBug>"
736,CWE-362,static void queue_delete ( struct snd_seq_queue * q ) { snd_seq_timer_stop ( q -> timer ) ; snd_seq_timer_close ( q ) ; snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; },"<S2SV_ModStart> q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
",torvalds@linux/3567eb6af614dac436c4b16a8d426f9faed639b3,CVE-2016-2544,https://github.com/torvalds/linux/commit/3567eb6af614dac436c4b16a8d426f9faed639b3,2016-04-27T17:59Z,<S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug>
4747,CWE-416,static void nodedestruct ( struct savenode * node ) { if ( node -> v == & node -> sorted ) { tr_free ( node -> sorted . val . l . vals ) ; } },"<S2SV_ModStart> node ) { TR_ASSERT ( node != NULL ) ; <S2SV_ModStart> ( node -> sorted != NULL <S2SV_ModEnd> ) { tr_free <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> vals ) ; tr_free ( node -> sorted ) ;
",transmission@transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e,CVE-2018-10756,https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e,2020-05-15T16:15Z,<S2SV_StartBug> if ( node -> v == & node -> sorted ) <S2SV_EndBug> <S2SV_StartBug> tr_free ( node -> sorted . val . l . vals ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
4871,CWE-362,"static int mptctl_eventreport ( unsigned long arg ) { struct mpt_ioctl_eventreport __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_eventreport karg ; mpt_adapter * ioc ; int iocnum ; int numbytes , maxevents , max ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_eventreport ) ) ) { printk ( kern_err mynam ""%s@%d::mptctl_eventreport<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>read<s2sv_blank>in<s2sv_blank>mpt_ioctl_eventreport<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , __file__ , __line__ , uarg ) ; return - efault ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == null ) ) { printk ( kern_debug mynam ""%s::mptctl_eventreport()<s2sv_blank>@%d<s2sv_blank>-<s2sv_blank>ioc%d<s2sv_blank>not<s2sv_blank>found!\\n"" , __file__ , __line__ , iocnum ) ; return - enodev ; } dctlprintk ( ioc , printk ( myioc_s_debug_fmt ""mptctl_eventreport<s2sv_blank>called.\\n"" , ioc -> name ) ) ; numbytes = karg . hdr . maxdatasize - sizeof ( mpt_ioctl_header ) ; maxevents = numbytes / sizeof ( mpt_ioctl_events ) ; max = mptctl_event_log_size < maxevents ? mptctl_event_log_size : maxevents ; if ( ( max < 1 ) || ! ioc -> events ) return - enodata ; ioc -> aen_event_read_flag = 0 ; numbytes = max * sizeof ( mpt_ioctl_events ) ; if ( copy_to_user ( uarg -> eventdata , ioc -> events , numbytes ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_eventreport<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>out<s2sv_blank>mpt_ioctl_eventreport<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , ioc -> events ) ; return - efault ; } return 0 ; }","<S2SV_ModStart> int mptctl_eventreport ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_eventreport karg ; <S2SV_ModEnd> int numBytes , <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,<S2SV_StartBug> mptctl_eventreport ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug>
4128,CWE-20,"long kvm_arch_vcpu_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) { struct kvm_vcpu * vcpu = filp -> private_data ; void __user * argp = ( void __user * ) arg ; int r ; union { struct kvm_lapic_state * lapic ; struct kvm_xsave * xsave ; struct kvm_xcrs * xcrs ; void * buffer ; } u ; u . buffer = null ; switch ( ioctl ) { case kvm_get_lapic : { r = - einval ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = kzalloc ( sizeof ( struct kvm_lapic_state ) , gfp_kernel ) ; r = - enomem ; if ( ! u . lapic ) goto out ; r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ; if ( r ) goto out ; r = - efault ; if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ; r = 0 ; break ; } case kvm_set_lapic : { r = - einval ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ; if ( is_err ( u . lapic ) ) return ptr_err ( u . lapic ) ; r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ; break ; } case kvm_interrupt : { struct kvm_interrupt irq ; r = - efault ; if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ; r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ; break ; } case kvm_nmi : { r = kvm_vcpu_ioctl_nmi ( vcpu ) ; break ; } case kvm_set_cpuid : { struct kvm_cpuid __user * cpuid_arg = argp ; struct kvm_cpuid cpuid ; r = - efault ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case kvm_set_cpuid2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - efault ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case kvm_get_cpuid2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - efault ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; if ( r ) goto out ; r = - efault ; if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ; r = 0 ; break ; } case kvm_get_msrs : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ; break ; case kvm_set_msrs : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ; break ; case kvm_tpr_access_reporting : { struct kvm_tpr_access_ctl tac ; r = - efault ; if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ; r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ; if ( r ) goto out ; r = - efault ; if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ; r = 0 ; break ; } ; case kvm_set_vapic_addr : { struct kvm_vapic_addr va ; r = - einval ; if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ; r = - efault ; if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ; r = 0 ; kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ; break ; } case kvm_x86_setup_mce : { u64 mcg_cap ; r = - efault ; if ( copy_from_user ( & mcg_cap , argp , sizeof mcg_cap ) ) goto out ; r = kvm_vcpu_ioctl_x86_setup_mce ( vcpu , mcg_cap ) ; break ; } case kvm_x86_set_mce : { struct kvm_x86_mce mce ; r = - efault ; if ( copy_from_user ( & mce , argp , sizeof mce ) ) goto out ; r = kvm_vcpu_ioctl_x86_set_mce ( vcpu , & mce ) ; break ; } case kvm_get_vcpu_events : { struct kvm_vcpu_events events ; kvm_vcpu_ioctl_x86_get_vcpu_events ( vcpu , & events ) ; r = - efault ; if ( copy_to_user ( argp , & events , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = 0 ; break ; } case kvm_set_vcpu_events : { struct kvm_vcpu_events events ; r = - efault ; if ( copy_from_user ( & events , argp , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_vcpu_events ( vcpu , & events ) ; break ; } case kvm_get_debugregs : { struct kvm_debugregs dbgregs ; kvm_vcpu_ioctl_x86_get_debugregs ( vcpu , & dbgregs ) ; r = - efault ; if ( copy_to_user ( argp , & dbgregs , sizeof ( struct kvm_debugregs ) ) ) break ; r = 0 ; break ; } case kvm_set_debugregs : { struct kvm_debugregs dbgregs ; r = - efault ; if ( copy_from_user ( & dbgregs , argp , sizeof ( struct kvm_debugregs ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_debugregs ( vcpu , & dbgregs ) ; break ; } case kvm_get_xsave : { u . xsave = kzalloc ( sizeof ( struct kvm_xsave ) , gfp_kernel ) ; r = - enomem ; if ( ! u . xsave ) break ; kvm_vcpu_ioctl_x86_get_xsave ( vcpu , u . xsave ) ; r = - efault ; if ( copy_to_user ( argp , u . xsave , sizeof ( struct kvm_xsave ) ) ) break ; r = 0 ; break ; } case kvm_set_xsave : { u . xsave = memdup_user ( argp , sizeof ( * u . xsave ) ) ; if ( is_err ( u . xsave ) ) return ptr_err ( u . xsave ) ; r = kvm_vcpu_ioctl_x86_set_xsave ( vcpu , u . xsave ) ; break ; } case kvm_get_xcrs : { u . xcrs = kzalloc ( sizeof ( struct kvm_xcrs ) , gfp_kernel ) ; r = - enomem ; if ( ! u . xcrs ) break ; kvm_vcpu_ioctl_x86_get_xcrs ( vcpu , u . xcrs ) ; r = - efault ; if ( copy_to_user ( argp , u . xcrs , sizeof ( struct kvm_xcrs ) ) ) break ; r = 0 ; break ; } case kvm_set_xcrs : { u . xcrs = memdup_user ( argp , sizeof ( * u . xcrs ) ) ; if ( is_err ( u . xcrs ) ) return ptr_err ( u . xcrs ) ; r = kvm_vcpu_ioctl_x86_set_xcrs ( vcpu , u . xcrs ) ; break ; } case kvm_set_tsc_khz : { u32 user_tsc_khz ; r = - einval ; user_tsc_khz = ( u32 ) arg ; if ( user_tsc_khz >= kvm_max_guest_tsc_khz ) goto out ; if ( user_tsc_khz == 0 ) user_tsc_khz = tsc_khz ; kvm_set_tsc_khz ( vcpu , user_tsc_khz ) ; r = 0 ; goto out ; } case kvm_get_tsc_khz : { r = vcpu -> arch . virtual_tsc_khz ; goto out ; } case kvm_kvmclock_ctrl : { r = kvm_set_guest_paused ( vcpu ) ; goto out ; } default : r = - einval ; } out : kfree ( u . buffer ) ; return r ; }","<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z,<S2SV_StartBug> r = 0 ; <S2SV_EndBug>
8120,CWE-295,"void options_defaults ( ) { service_options * service ; memset ( & new_global_options , 0 , sizeof ( global_options ) ) ; memset ( & new_service_options , 0 , sizeof ( service_options ) ) ; new_service_options . next = null ; parse_global_option ( cmd_set_defaults , null , null ) ; service = & new_service_options ; parse_service_option ( cmd_set_defaults , & service , null , null ) ; }","<S2SV_ModStart> ( CMD_SET_DEFAULTS , & new_global_options ,
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug>"
3714,CWE-362,"static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { struct desc_struct * desc ; unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1l ; if ( ! sel ) return 0 ; desc = get_desc ( sel ) ; if ( ! desc ) return 0 ; limit = get_desc_limit ( desc ) ; if ( desc -> g ) limit = ( limit << 12 ) + 0xfff ; return limit ; }","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = get_desc_limit ( & <S2SV_ModStart> if ( desc . <S2SV_ModEnd> g ) limit
",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug>
4930,CWE-617,"int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; assert ( idx >= 0 && idx <= pci_barmax ) ; if ( ( size & ( size - 1 ) ) != 0 ) size = 1ul << flsl ( size ) ; if ( type == pcibar_io ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case pcibar_none : baseptr = null ; addr = mask = lobits = 0 ; break ; case pcibar_io : baseptr = & pci_emul_iobase ; limit = pci_emul_iolimit ; mask = pcim_bar_io_base ; lobits = pcim_bar_io_space ; break ; case pcibar_mem64 : if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = pci_emul_memlimit32 ; mask = pcim_bar_mem_base ; lobits = pcim_bar_mem_space | pcim_bar_mem_64 ; break ; } if ( size == 0x100000000ul ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = pci_emul_memlimit64 ; mask = pcim_bar_mem_base ; lobits = pcim_bar_mem_space | pcim_bar_mem_64 | pcim_bar_mem_prefetch ; break ; case pcibar_mem32 : baseptr = & pci_emul_membase32 ; limit = pci_emul_memlimit32 ; mask = pcim_bar_mem_base ; lobits = pcim_bar_mem_space | pcim_bar_mem_32 ; break ; default : printf ( ""%s:<s2sv_blank>invalid<s2sv_blank>bar<s2sv_blank>type<s2sv_blank>%d\\n"" , __func__ , type ) ; assert ( 0 ) ; } if ( baseptr != null ) { error = pci_emul_alloc_resource ( baseptr , limit , size , & addr ) ; if ( error != 0 ) return error ; } pdi -> bar [ idx ] . type = type ; pdi -> bar [ idx ] . addr = addr ; pdi -> bar [ idx ] . size = size ; bar = ( addr & mask ) | lobits ; pci_set_cfgdata32 ( pdi , pcir_bar ( idx ) , bar ) ; if ( type == pcibar_mem64 ) { assert ( idx + 1 <= pci_barmax ) ; pdi -> bar [ idx + 1 ] . type = pcibar_memhi64 ; pci_set_cfgdata32 ( pdi , pcir_bar ( idx + 1 ) , bar >> 32 ) ; } register_bar ( pdi , idx ) ; return 0 ; }","<S2SV_ModStart> , bar ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\n"" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> ; default : pr_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , <S2SV_ModStart> type ) ; return - 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> PCIBAR_MEM64 ) { <S2SV_ModEnd> pdi -> bar
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,"<S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug>"
6918,CWE-400,"asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( insn ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""unsupported<s2sv_blank>unaligned<s2sv_blank>load/store<s2sv_blank>trap<s2sv_blank>for<s2sv_blank>kernel<s2sv_blank>at<s2sv_blank><%08lx>.\\n"" , regs -> pc ) ; unaligned_panic ( ""wheee.<s2sv_blank>kernel<s2sv_blank>does<s2sv_blank>fpu/atomic<s2sv_blank>unaligned<s2sv_blank>load/store."" ) ; } else { unsigned long addr = compute_effective_address ( regs , insn ) ; int err ; perf_sw_event ( perf_count_sw_alignment_faults , 1 , 0 , regs , addr ) ; switch ( dir ) { case load : err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) , size , ( unsigned long * ) addr , decode_signedness ( insn ) ) ; break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs ) ; break ; default : panic ( ""impossible<s2sv_blank>kernel<s2sv_blank>unaligned<s2sv_blank>trap."" ) ; } if ( err ) kernel_mna_trap_fault ( regs , insn ) ; else advance ( regs ) ; } }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug>"
7790,CWE-125,"static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = null , kwarg = null ; arg_ty arg ; node * ch ; if ( type ( n ) == parameters ) { if ( nch ( n ) == 2 ) return arguments ( null , null , null , null , null , null , c -> c_arena ) ; n = child ( n , 1 ) ; } assert ( type ( n ) == typedargslist || type ( n ) == varargslist ) ; for ( i = 0 ; i < nch ( n ) ; i ++ ) { ch = child ( n , i ) ; if ( type ( ch ) == star ) { i ++ ; if ( i < nch ( n ) && ( type ( child ( n , i ) ) == tfpdef || type ( child ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( type ( ch ) == doublestar ) break ; if ( type ( ch ) == vfpdef || type ( ch ) == tfpdef ) nposargs ++ ; if ( type ( ch ) == equal ) nposdefaults ++ ; } for ( ; i < nch ( n ) ; ++ i ) { ch = child ( n , i ) ; if ( type ( ch ) == doublestar ) break ; if ( type ( ch ) == tfpdef || type ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _py_asdl_seq_new ( nposargs , c -> c_arena ) : null ) ; if ( ! posargs && nposargs ) return null ; kwonlyargs = ( nkwonlyargs ? _py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : null ) ; if ( ! kwonlyargs && nkwonlyargs ) return null ; posdefaults = ( nposdefaults ? _py_asdl_seq_new ( nposdefaults , c -> c_arena ) : null ) ; if ( ! posdefaults && nposdefaults ) return null ; kwdefaults = ( nkwonlyargs ? _py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : null ) ; if ( ! kwdefaults && nkwonlyargs ) return null ; i = 0 ; j = 0 ; k = 0 ; while ( i < nch ( n ) ) { ch = child ( n , i ) ; switch ( type ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < nch ( n ) && type ( child ( n , i + 1 ) ) == equal ) { expr_ty expression = ast_for_expr ( c , child ( n , i + 2 ) ) ; if ( ! expression ) return null ; assert ( posdefaults != null ) ; asdl_seq_set ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<s2sv_blank>argument<s2sv_blank>follows<s2sv_blank>default<s2sv_blank>argument"" ) ; return null ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return null ; asdl_seq_set ( posargs , k ++ , arg ) ; i += 2 ; break ; case star : if ( i + 1 >= nch ( n ) || ( i + 2 == nch ( n ) && type ( child ( n , i + 1 ) ) == comma ) ) { ast_error ( c , child ( n , i ) , ""named<s2sv_blank>arguments<s2sv_blank>must<s2sv_blank>follow<s2sv_blank>bare<s2sv_blank>*"" ) ; return null ; } ch = child ( n , i + 1 ) ; if ( type ( ch ) == comma ) { int res = 0 ; i += 2 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return null ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return null ; i += 3 ; if ( i < nch ( n ) && ( type ( child ( n , i ) ) == tfpdef || type ( child ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return null ; i = res ; } } break ; case doublestar : ch = child ( n , i + 1 ) ; assert ( type ( ch ) == tfpdef || type ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return null ; i += 3 ; break ; default : pyerr_format ( pyexc_systemerror , ""unexpected<s2sv_blank>node<s2sv_blank>in<s2sv_blank>varargslist:<s2sv_blank>%d<s2sv_blank>@<s2sv_blank>%d"" , type ( ch ) , i ) ; return null ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }","<S2SV_ModStart> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> n ) && ( <S2SV_ModStart> ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <S2SV_ModStart> += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } <S2SV_ModStart> ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <S2SV_ModEnd> if ( i <S2SV_ModStart> ; i += 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <S2SV_ModEnd> ; break ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> i += 2 ; <S2SV_EndBug> <S2SV_StartBug> ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) { <S2SV_EndBug> <S2SV_StartBug> res = handle_keywordonly_args ( c , n , i , <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug>"
7795,CWE-125,"static asdl_seq * ast_for_suite ( struct compiling * c , const node * n ) { asdl_seq * seq ; stmt_ty s ; int i , total , num , end , pos = 0 ; node * ch ; req ( n , suite ) ; total = num_stmts ( n ) ; seq = _py_asdl_seq_new ( total , c -> c_arena ) ; if ( ! seq ) return null ; if ( type ( child ( n , 0 ) ) == simple_stmt ) { n = child ( n , 0 ) ; end = nch ( n ) - 1 ; if ( type ( child ( n , end - 1 ) ) == semi ) end -- ; for ( i = 0 ; i < end ; i += 2 ) { ch = child ( n , i ) ; s = ast_for_stmt ( c , ch ) ; if ( ! s ) return null ; asdl_seq_set ( seq , pos ++ , s ) ; } } else { for ( i = 2 ; i < ( nch ( n ) - 1 ) ; i ++ ) { ch = child ( n , i ) ; req ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( c , ch ) ; if ( ! s ) return null ; asdl_seq_set ( seq , pos ++ , s ) ; } else { int j ; ch = child ( ch , 0 ) ; req ( ch , simple_stmt ) ; for ( j = 0 ; j < nch ( ch ) ; j += 2 ) { if ( nch ( child ( ch , j ) ) == 0 ) { assert ( ( j + 1 ) == nch ( ch ) ) ; break ; } s = ast_for_stmt ( c , child ( ch , j ) ) ; if ( ! s ) return null ; asdl_seq_set ( seq , pos ++ , s ) ; } } } } assert ( pos == seq -> size ) ; return seq ; }","<S2SV_ModStart> * ch ; if ( TYPE ( n ) != func_body_suite ) { <S2SV_ModStart> suite ) ; } <S2SV_ModStart> } else { i = 2 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) { i += 2 ; REQ ( CHILD ( n , 2 ) , NEWLINE ) ; } for ( <S2SV_ModEnd> ; i <
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> REQ ( n , suite ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) { <S2SV_EndBug>"
7605,CWE-190,"static inline ulong encode_twos_comp ( long n , int prec ) { ulong result ; assert ( prec >= 2 ) ; jas_eprintf ( ""warning:<s2sv_blank>support<s2sv_blank>for<s2sv_blank>signed<s2sv_blank>data<s2sv_blank>is<s2sv_blank>untested\\n"" ) ; if ( n < 0 ) { result = - n ; result = ( result ^ 0xfffffffful ) + 1 ; result &= ( 1 << prec ) - 1 ; } else { result = n ; } return result ; }","<S2SV_ModStart> <S2SV_null> static inline jas_ulong <S2SV_ModEnd> encode_twos_comp ( long <S2SV_ModStart> prec ) { jas_ulong <S2SV_ModEnd> result ; assert
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> static inline ulong encode_twos_comp ( long n , int prec ) <S2SV_EndBug> <S2SV_StartBug> ulong result ; <S2SV_EndBug>"
7892,CWE-20,"error_t httpclientseturi ( httpclientcontext * context , const char_t * uri ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == null || uri == null ) return error_invalid_parameter ; if ( uri [ 0 ] == '\\0' ) return error_invalid_parameter ; if ( context -> requeststate != http_req_state_format_header ) return error_wrong_state ; if ( context -> bufferlen > http_client_buffer_size ) return error_invalid_syntax ; context -> buffer [ context -> bufferlen ] = '\\0' ; p = strchr ( context -> buffer , '<s2sv_blank>' ) ; if ( p == null ) return error_invalid_syntax ; p ++ ; q = strpbrk ( p , ""<s2sv_blank>?"" ) ; if ( q == null ) return error_invalid_syntax ; m = q - p ; n = osstrlen ( uri ) ; if ( ( context -> bufferlen + n - m ) > http_client_buffer_size ) return error_buffer_overflow ; osmemmove ( p + n , q , context -> buffer + context -> bufferlen + 1 - q ) ; osstrncpy ( p , uri , n ) ; context -> bufferlen = context -> bufferlen + n - m ; return no_error ; }","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug>"
7893,CWE-20,"error_t httpclientformatauthorizationfield ( httpclientcontext * context ) { size_t n ; char_t * p ; httpclientauthparams * authparams ; if ( context -> bufferlen < 2 || context -> bufferlen > http_client_buffer_size ) return error_invalid_syntax ; authparams = & context -> authparams ; # if ( http_client_basic_auth_support == enabled ) if ( authparams -> mode == http_auth_mode_basic ) { size_t k ; size_t m ; n = osstrlen ( authparams -> username ) + osstrlen ( authparams -> password ) ; if ( ( context -> bufferlen + n + 22 ) > http_client_buffer_size ) return error_buffer_overflow ; p = context -> buffer + context -> bufferlen - 2 ; n = ossprintf ( p , ""authorization:<s2sv_blank>basic<s2sv_blank>"" ) ; m = ossprintf ( p + n , ""%s:%s"" , authparams -> username , authparams -> password ) ; base64encode ( p + n , m , null , & k ) ; if ( ( context -> bufferlen + n + k ) > http_client_buffer_size ) return error_buffer_overflow ; base64encode ( p + n , m , p + n , & k ) ; n += k ; if ( ( context -> bufferlen + n + 2 ) > http_client_buffer_size ) return error_buffer_overflow ; ossprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferlen = context -> bufferlen + n + 2 ; } else # endif # if ( http_client_digest_auth_support == enabled ) if ( authparams -> mode == http_auth_mode_digest ) { error_t error ; const char_t * q ; const char_t * uri ; size_t urilen ; char_t response [ http_client_max_response_len + 1 ] ; context -> buffer [ context -> bufferlen ] = '\\0' ; q = strchr ( context -> buffer , '<s2sv_blank>' ) ; if ( q == null ) return error_invalid_syntax ; uri = q + 1 ; q = strchr ( uri , '<s2sv_blank>' ) ; if ( q == null ) return error_invalid_syntax ; urilen = q - uri ; if ( authparams -> qop == http_auth_qop_auth || authparams -> qop == http_auth_qop_auth_int ) { if ( context -> randcallback == null ) return error_prng_not_ready ; error = context -> randcallback ( authparams -> cnonce , http_client_cnonce_size ) ; if ( error ) return error ; httpencodehexstring ( authparams -> cnonce , http_client_cnonce_size , authparams -> cnonce ) ; authparams -> nc ++ ; } error = httpclientcomputedigest ( authparams , context -> method , osstrlen ( context -> method ) , uri , urilen , response ) ; if ( error ) return error ; n = osstrlen ( authparams -> username ) + osstrlen ( authparams -> realm ) + urilen + osstrlen ( authparams -> nonce ) + osstrlen ( authparams -> cnonce ) + osstrlen ( response ) + osstrlen ( authparams -> opaque ) ; if ( ( context -> bufferlen + n + 121 ) > http_client_buffer_size ) return error_buffer_overflow ; p = context -> buffer + context -> bufferlen - 2 ; n = ossprintf ( p , ""authorization:<s2sv_blank>digest<s2sv_blank>"" ) ; n += ossprintf ( p + n , ""username=\\""%s\\"",<s2sv_blank>"" , authparams -> username ) ; n += ossprintf ( p + n , ""realm=\\""%s\\"",<s2sv_blank>"" , authparams -> realm ) ; n += ossprintf ( p + n , ""uri=\\"""" ) ; osstrncpy ( p + n , uri , urilen ) ; n += urilen ; n += ossprintf ( p + n , ""\\"",<s2sv_blank>"" ) ; n += ossprintf ( p + n , ""nonce=\\""%s\\"",<s2sv_blank>"" , authparams -> nonce ) ; if ( authparams -> qop == http_auth_qop_auth ) { n += ossprintf ( p + n , ""qop=auth,<s2sv_blank>"" ) ; n += ossprintf ( p + n , ""nc=%08x,<s2sv_blank>"" , authparams -> nc ) ; n += ossprintf ( p + n , ""cnonce=\\""%s\\"",<s2sv_blank>"" , authparams -> cnonce ) ; } n += ossprintf ( p + n , ""response=\\""%s\\"""" , response ) ; if ( authparams -> opaque [ 0 ] != '\\0' ) { n += ossprintf ( p + n , "",<s2sv_blank>opaque=\\""%s\\"""" , authparams -> opaque ) ; } ossprintf ( p + n , ""\\r\\n\\r\\n"" ) ; context -> bufferlen = context -> bufferlen + n + 2 ; } else # endif { } return no_error ; }","<S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( uri ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug>"
2603,CWE-416,"static int packet_set_ring ( struct sock * sk , union tpacket_req_u * req_u , int closing , int tx_ring ) { struct pgv * pg_vec = null ; struct packet_sock * po = pkt_sk ( sk ) ; int was_running , order = 0 ; struct packet_ring_buffer * rb ; struct sk_buff_head * rb_queue ; __be16 num ; int err = - einval ; struct tpacket_req * req = & req_u -> req ; if ( ! closing && tx_ring && ( po -> tp_version > tpacket_v2 ) ) { net_warn_ratelimited ( ""tx-ring<s2sv_blank>is<s2sv_blank>not<s2sv_blank>supported.\\n"" ) ; goto out ; } rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ; rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ; err = - ebusy ; if ( ! closing ) { if ( atomic_read ( & po -> mapped ) ) goto out ; if ( packet_read_pending ( rb ) ) goto out ; } if ( req -> tp_block_nr ) { err = - ebusy ; if ( unlikely ( rb -> pg_vec ) ) goto out ; switch ( po -> tp_version ) { case tpacket_v1 : po -> tp_hdrlen = tpacket_hdrlen ; break ; case tpacket_v2 : po -> tp_hdrlen = tpacket2_hdrlen ; break ; case tpacket_v3 : po -> tp_hdrlen = tpacket3_hdrlen ; break ; } err = - einval ; if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ; if ( unlikely ( ! page_aligned ( req -> tp_block_size ) ) ) goto out ; if ( po -> tp_version >= tpacket_v3 && ( int ) ( req -> tp_block_size - blk_plus_priv ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ; if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ; if ( unlikely ( req -> tp_frame_size & ( tpacket_alignment - 1 ) ) ) goto out ; rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ; if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ; if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ; err = - enomem ; order = get_order ( req -> tp_block_size ) ; pg_vec = alloc_pg_vec ( req , order ) ; if ( unlikely ( ! pg_vec ) ) goto out ; switch ( po -> tp_version ) { case tpacket_v3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ; break ; default : break ; } } else { err = - einval ; if ( unlikely ( req -> tp_frame_nr ) ) goto out ; } lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; was_running = po -> running ; num = po -> num ; if ( was_running ) { po -> num = 0 ; __unregister_prot_hook ( sk , false ) ; } spin_unlock ( & po -> bind_lock ) ; synchronize_net ( ) ; err = - ebusy ; mutex_lock ( & po -> pg_vec_lock ) ; if ( closing || atomic_read ( & po -> mapped ) == 0 ) { err = 0 ; spin_lock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec , pg_vec ) ; rb -> frame_max = ( req -> tp_frame_nr - 1 ) ; rb -> head = 0 ; rb -> frame_size = req -> tp_frame_size ; spin_unlock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec_order , order ) ; swap ( rb -> pg_vec_len , req -> tp_block_nr ) ; rb -> pg_vec_pages = req -> tp_block_size / page_size ; po -> prot_hook . func = ( po -> rx_ring . pg_vec ) ? tpacket_rcv : packet_rcv ; skb_queue_purge ( rb_queue ) ; if ( atomic_read ( & po -> mapped ) ) pr_err ( ""packet_mmap:<s2sv_blank>vma<s2sv_blank>is<s2sv_blank>busy:<s2sv_blank>%d\\n"" , atomic_read ( & po -> mapped ) ) ; } mutex_unlock ( & po -> pg_vec_lock ) ; spin_lock ( & po -> bind_lock ) ; if ( was_running ) { po -> num = num ; register_prot_hook ( sk ) ; } spin_unlock ( & po -> bind_lock ) ; if ( closing && ( po -> tp_version > tpacket_v2 ) ) { if ( ! tx_ring ) prb_shutdown_retire_blk_timer ( po , rb_queue ) ; } release_sock ( sk ) ; if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : return err ; }","<S2SV_ModStart> req_u -> req ; lock_sock ( sk ) <S2SV_ModStart> out ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ; } if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart> sk ) ; <S2SV_ModEnd> return err ;
",torvalds@linux/84ac7260236a49c79eede91617700174c2c19b0c,CVE-2016-8655,https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c,2016-12-08T08:59Z,<S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug>
2262,CWE-20,"static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ; if ( check_stack_guard_page ( vma , address ) < 0 ) return vm_fault_sigsegv ; if ( ! ( flags & fault_flag_write ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , gfp_kernel , & memcg ) ) goto oom_free_page ; __setpageuptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & vm_write ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , mm_anonpages ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache_add_active_or_unevictable ( page , vma ) ; setpte : set_pte_at ( mm , address , page_table , entry ) ; update_mmu_cache ( vma , address , page_table ) ; unlock : pte_unmap_unlock ( page_table , ptl ) ; return 0 ; release : mem_cgroup_cancel_charge ( page , memcg ) ; page_cache_release ( page ) ; goto unlock ; oom_free_page : page_cache_release ( page ) ; oom : return vm_fault_oom ; }","<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z,"<S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug>"
6566,CWE-119,"cjson * iperf_json_printf ( const char * format , ... ) { cjson * o ; va_list argp ; const char * cp ; char name [ 100 ] ; char * np ; cjson * j ; o = cjson_createobject ( ) ; if ( o == null ) return null ; va_start ( argp , format ) ; np = name ; for ( cp = format ; * cp != '\\0' ; ++ cp ) { switch ( * cp ) { case '<s2sv_blank>' : break ; case ':' : * np = '\\0' ; break ; case '%' : ++ cp ; switch ( * cp ) { case 'b' : j = cjson_createbool ( va_arg ( argp , int ) ) ; break ; case 'd' : j = cjson_createint ( va_arg ( argp , int64_t ) ) ; break ; case 'f' : j = cjson_createfloat ( va_arg ( argp , double ) ) ; break ; case 's' : j = cjson_createstring ( va_arg ( argp , char * ) ) ; break ; default : return null ; } if ( j == null ) return null ; cjson_additemtoobject ( o , name , j ) ; np = name ; break ; default : * np ++ = * cp ; break ; } } va_end ( argp ) ; return o ; }","<S2SV_ModStart> : j = cJSON_CreateNumber <S2SV_ModEnd> ( va_arg ( <S2SV_ModStart> : j = cJSON_CreateNumber <S2SV_ModEnd> ( va_arg (
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ; <S2SV_EndBug>"
3087,CWE-264,"static int command_write ( struct pci_dev * dev , int offset , u16 value , void * data ) { struct xen_pcibk_dev_data * dev_data ; int err ; dev_data = pci_get_drvdata ( dev ) ; if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( kern_debug drv_name "":<s2sv_blank>%s:<s2sv_blank>enable\\n"" , pci_name ( dev ) ) ; err = pci_enable_device ( dev ) ; if ( err ) return err ; if ( dev_data ) dev_data -> enable_intx = 1 ; } else if ( pci_is_enabled ( dev ) && ! is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( kern_debug drv_name "":<s2sv_blank>%s:<s2sv_blank>disable\\n"" , pci_name ( dev ) ) ; pci_disable_device ( dev ) ; if ( dev_data ) dev_data -> enable_intx = 0 ; } if ( ! dev -> is_busmaster && is_master_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( kern_debug drv_name "":<s2sv_blank>%s:<s2sv_blank>set<s2sv_blank>bus<s2sv_blank>master\\n"" , pci_name ( dev ) ) ; pci_set_master ( dev ) ; } if ( value & pci_command_invalidate ) { if ( unlikely ( verbose_request ) ) printk ( kern_debug drv_name "":<s2sv_blank>%s:<s2sv_blank>enable<s2sv_blank>memory-write-invalidate\\n"" , pci_name ( dev ) ) ; err = pci_set_mwi ( dev ) ; if ( err ) { pr_warn ( ""%s:<s2sv_blank>cannot<s2sv_blank>enable<s2sv_blank>memory-write-invalidate<s2sv_blank>(%d)\\n"" , pci_name ( dev ) , err ) ; value &= ~ pci_command_invalidate ; } } return pci_write_config_word ( dev , offset , value ) ; }","<S2SV_ModStart> int err ; u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;
",torvalds@linux/af6fc858a35b90e89ea7a7ee58e66628c55c776b,CVE-2015-2150,https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b,2015-03-12T14:59Z,"<S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug>"
3505,CWE-264,"static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - eperm ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { rcu_read_unlock ( ) ; return - eperm ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }","<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
",torvalds@linux/d049f74f2dbe71354d43d393ac3a188947811348,CVE-2013-2929,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,2013-12-09T18:55Z,"<S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug>"
404,CWE-362,"void ieee80211_sta_ps_deliver_wakeup ( struct sta_info * sta ) { struct ieee80211_sub_if_data * sdata = sta -> sdata ; struct ieee80211_local * local = sdata -> local ; struct sk_buff_head pending ; int filtered = 0 , buffered = 0 , ac ; unsigned long flags ; clear_sta_flag ( sta , wlan_sta_sp ) ; build_bug_on ( bits_to_longs ( ieee80211_num_tids ) > 1 ) ; sta -> driver_buffered_tids = 0 ; if ( ! ( local -> hw . flags & ieee80211_hw_ap_link_ps ) ) drv_sta_notify ( local , sdata , sta_notify_awake , & sta -> sta ) ; skb_queue_head_init ( & pending ) ; for ( ac = 0 ; ac < ieee80211_num_acs ; ac ++ ) { int count = skb_queue_len ( & pending ) , tmp ; spin_lock_irqsave ( & sta -> tx_filtered [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> tx_filtered [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> tx_filtered [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; filtered += tmp - count ; count = tmp ; spin_lock_irqsave ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> ps_tx_buf [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; buffered += tmp - count ; } ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) { ht_dbg ( sdata , ""%pm<s2sv_blank>just<s2sv_blank>woke<s2sv_blank>up<s2sv_blank>and<s2sv_blank>mimo<s2sv_blank>capable<s2sv_blank>-<s2sv_blank>update<s2sv_blank>smps\\n"" , sta -> sta . addr ) ; ieee80211_send_smps_action ( sdata , sdata -> bss -> req_smps , sta -> sta . addr , sdata -> vif . bss_conf . bssid ) ; } local -> total_ps_buffered -= buffered ; sta_info_recalc_tim ( sta ) ; ps_dbg ( sdata , ""sta<s2sv_blank>%pm<s2sv_blank>aid<s2sv_blank>%d<s2sv_blank>sending<s2sv_blank>%d<s2sv_blank>filtered/%d<s2sv_blank>ps<s2sv_blank>frames<s2sv_blank>since<s2sv_blank>sta<s2sv_blank>not<s2sv_blank>sleeping<s2sv_blank>anymore\\n"" , sta -> sta . addr , sta -> sta . aid , filtered , buffered ) ; }","<S2SV_ModStart> pending ) ; spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> clear_sta_ps_flags , sta ) ; spin_unlock ( & sta -> ps_lock
",torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z,"<S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug>"
5379,CWE-476,"static int pb0100_start ( struct sd * sd ) { int err , packet_size , max_packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; struct cam * cam = & sd -> gspca_dev . cam ; u32 mode = cam -> cam_mode [ sd -> gspca_dev . curr_mode ] . priv ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) return - enodev ; packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wmaxpacketsize ) ; max_packet_size = sd -> sensor -> max_packet_size [ sd -> gspca_dev . curr_mode ] ; if ( packet_size < max_packet_size ) stv06xx_write_sensor ( sd , pb_rowspeed , bit ( 4 ) | bit ( 3 ) | bit ( 1 ) ) ; else stv06xx_write_sensor ( sd , pb_rowspeed , bit ( 5 ) | bit ( 3 ) | bit ( 1 ) ) ; if ( mode & pb0100_crop_to_vga ) { stv06xx_write_sensor ( sd , pb_rstart , 30 ) ; stv06xx_write_sensor ( sd , pb_cstart , 20 ) ; stv06xx_write_sensor ( sd , pb_rwsize , 240 - 1 ) ; stv06xx_write_sensor ( sd , pb_cwsize , 320 - 1 ) ; } else { stv06xx_write_sensor ( sd , pb_rstart , 8 ) ; stv06xx_write_sensor ( sd , pb_cstart , 4 ) ; stv06xx_write_sensor ( sd , pb_rwsize , 288 - 1 ) ; stv06xx_write_sensor ( sd , pb_cwsize , 352 - 1 ) ; } if ( mode & pb0100_subsample ) { stv06xx_write_bridge ( sd , stv_y_ctrl , 0x02 ) ; stv06xx_write_bridge ( sd , stv_x_ctrl , 0x06 ) ; stv06xx_write_bridge ( sd , stv_scan_rate , 0x10 ) ; } else { stv06xx_write_bridge ( sd , stv_y_ctrl , 0x01 ) ; stv06xx_write_bridge ( sd , stv_x_ctrl , 0x0a ) ; stv06xx_write_bridge ( sd , stv_scan_rate , 0x20 ) ; } err = stv06xx_write_sensor ( sd , pb_control , bit ( 5 ) | bit ( 3 ) | bit ( 1 ) ) ; gspca_dbg ( gspca_dev , d_stream , ""started<s2sv_blank>stream,<s2sv_blank>status:<s2sv_blank>%d\\n"" , err ) ; return ( err < 0 ) ? err : 0 ; }","<S2SV_ModStart> ( ! alt ) return - ENODEV ; if ( alt -> desc . bNumEndpoints < 1
",torvalds@linux/485b06aadb933190f4bc44e006076bc27a23f205,CVE-2020-11609,https://github.com/torvalds/linux/commit/485b06aadb933190f4bc44e006076bc27a23f205,2020-04-07T17:15Z,<S2SV_StartBug> if ( ! alt ) <S2SV_EndBug>
8143,CWE-416,"static void win_enter_ext ( win_t * wp , int undo_sync , int curwin_invalid , int trigger_new_autocmds , int trigger_enter_autocmds , int trigger_leave_autocmds ) { int other_buffer = false ; if ( wp == curwin && ! curwin_invalid ) return ; # ifdef feat_job_channel if ( ! curwin_invalid ) leaving_window ( curwin ) ; # endif if ( ! curwin_invalid && trigger_leave_autocmds ) { if ( wp -> w_buffer != curbuf ) { apply_autocmds ( event_bufleave , null , null , false , curbuf ) ; other_buffer = true ; if ( ! win_valid ( wp ) ) return ; } apply_autocmds ( event_winleave , null , null , false , curbuf ) ; if ( ! win_valid ( wp ) ) return ; # ifdef feat_eval if ( aborting ( ) ) return ; # endif } if ( undo_sync && curbuf != wp -> w_buffer ) u_sync ( false ) ; update_topline ( ) ; if ( wp -> w_buffer != curbuf ) buf_copy_options ( wp -> w_buffer , bco_enter | bco_nohelp ) ; if ( ! curwin_invalid ) { prevwin = curwin ; curwin -> w_redr_status = true ; } curwin = wp ; curbuf = wp -> w_buffer ; check_cursor ( ) ; if ( ! virtual_active ( ) ) curwin -> w_cursor . coladd = 0 ; changed_line_abv_curs ( ) ; if ( curwin -> w_localdir != null || curtab -> tp_localdir != null ) { char_u * dirname ; if ( globaldir == null ) { char_u cwd [ maxpathl ] ; if ( mch_dirname ( cwd , maxpathl ) == ok ) globaldir = vim_strsave ( cwd ) ; } if ( curwin -> w_localdir != null ) dirname = curwin -> w_localdir ; else dirname = curtab -> tp_localdir ; if ( mch_chdir ( ( char * ) dirname ) == 0 ) shorten_fnames ( true ) ; } else if ( globaldir != null ) { vim_ignored = mch_chdir ( ( char * ) globaldir ) ; vim_clear ( globaldir ) ; shorten_fnames ( true ) ; } # ifdef feat_job_channel entering_window ( curwin ) ; # endif if ( trigger_new_autocmds ) apply_autocmds ( event_winnew , null , null , false , curbuf ) ; if ( trigger_enter_autocmds ) { apply_autocmds ( event_winenter , null , null , false , curbuf ) ; if ( other_buffer ) apply_autocmds ( event_bufenter , null , null , false , curbuf ) ; } # ifdef feat_title maketitle ( ) ; # endif curwin -> w_redr_status = true ; # ifdef feat_terminal if ( bt_terminal ( wp -> w_buffer ) ) redraw_mode = true ; # endif redraw_tabline = true ; if ( restart_edit ) redraw_later ( valid ) ; if ( curwin -> w_height < p_wh && ! curwin -> w_p_wfh # ifdef feat_text_prop && ! popup_is_popup ( curwin ) # endif ) win_setheight ( ( int ) p_wh ) ; else if ( curwin -> w_height == 0 ) win_setheight ( 1 ) ; if ( curwin -> w_width < p_wiw && ! curwin -> w_p_wfw ) win_setwidth ( ( int ) p_wiw ) ; setmouse ( ) ; do_autochdir ; }","<S2SV_ModStart> ( bt_terminal ( curwin <S2SV_ModEnd> -> w_buffer )
",vim@vim/ec66c41d84e574baf8009dbc0bd088d2bc5b2421,CVE-2019-20079,https://github.com/vim/vim/commit/ec66c41d84e574baf8009dbc0bd088d2bc5b2421,2019-12-30T01:15Z,<S2SV_StartBug> if ( bt_terminal ( wp -> w_buffer ) ) <S2SV_EndBug>
5598,CWE-674,"static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = null , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = null ; * count_out = 0 ; while ( len > 0 ) { ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = asn1_bad_id ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == null ) { ret = enomem ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }","<S2SV_ModStart> , & len , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug>"
3236,CWE-200,"static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - eopnotsupp ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & msg_oob ) goto out ; if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & msg_errqueue ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= msg_trunc ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = af_inet ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & msg_trunc ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }","<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
",torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2179,CWE-415,"struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = tcp_syn_recv ; newicsk -> icsk_bind_hash = null ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , sock_rcu_free ) ; newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }","<S2SV_ModStart> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
",torvalds@linux/657831ffc38e30092a2d5f03d385d710eb88b09a,CVE-2017-8890,https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a,2017-05-10T16:29Z,<S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug>
3580,CWE-189,"static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = bpf_op ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; if ( env -> allow_ptr_leaks || bpf_src ( insn -> code ) == bpf_k ) return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? bpf_alu_neg_value : 0 ; alu_state |= ptr_is_dst_reg ? bpf_alu_sanitize_src : bpf_alu_sanitize_dst ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; if ( aux -> alu_state && ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) return - eacces ; aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - efault : 0 ; }","<S2SV_ModStart> ; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :
",torvalds@linux/d3bd7413e0ca40b60cf60d4003246d067cafdeda,CVE-2019-7308,https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda,2019-02-01T22:29Z,<S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> <S2SV_StartBug> return - EACCES ; <S2SV_EndBug>
3985,CWE-20,"static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= msg_trunc ; msg -> msg_namelen = 0 ; lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , null , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }","<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
678,CWE-119,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { struct common_audit_data sa ; struct apparmor_audit_data aad = { 0 , } ; char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - einval ; if ( args [ size - 1 ] != '\\0' ) { if ( size == page_size ) return - einval ; args [ size ] = '\\0' ; } if ( current != task ) return - eacces ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<s2sv_blank>"" ) ; if ( ! args ) return - einval ; args = skip_spaces ( args ) ; if ( ! * args ) return - einval ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! aa_do_test ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , aa_do_test ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! aa_onexec , ! aa_do_test ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! aa_onexec , aa_do_test ) ; } else goto fail ; } else if ( strcmp ( name , ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , aa_onexec , ! aa_do_test ) ; else goto fail ; } else return - einval ; if ( ! error ) error = size ; return error ; fail : sa . type = lsm_audit_data_none ; sa . aad = & aad ; aad . profile = aa_current_profile ( ) ; aad . op = op_setprocattr ; aad . info = name ; aad . error = - einval ; aa_audit_msg ( audit_apparmor_denied , & sa , null ) ; return - einval ; }","<S2SV_ModStart> command , * largs = NULL , * <S2SV_ModStart> return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> EINVAL ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ( name , ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> , ! AA_DO_TEST <S2SV_ModStart> AA_DO_TEST ) ; <S2SV_ModEnd> else goto fail <S2SV_ModStart> ; } else <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error <S2SV_ModStart> . error = error = <S2SV_ModStart> NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/30a46a4647fd1df9cf52e43bf467f0d9265096ca,CVE-2016-6187,https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca,2016-08-06T20:59Z,"<S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>"
6202,CWE-190,"static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { u_int16_t offset = 22 , buf_out_len = 0 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; # ifdef ssh_debug printf ( ""[ssh]<s2sv_blank>%s\\n"" , buf ) ; # endif return ( buf_out_len ) ; invalid_payload : # ifdef ssh_debug printf ( ""[ssh]<s2sv_blank>invalid<s2sv_blank>packet<s2sv_blank>payload\\n"" ) ; # endif return ( 0 ) ; }","<S2SV_ModStart> client_hash ) { u_int32_t <S2SV_ModEnd> offset = 22 <S2SV_ModStart> ] ) ; if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ; <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; #
",ntop@nDPI/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202,CVE-2020-11939,https://github.com/ntop/nDPI/commit/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202,2020-04-23T15:15Z,"<S2SV_StartBug> u_int16_t offset = 22 , buf_out_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug>"
6833,CWE-190,"static int _unpickler_memoput ( unpicklerobject * self , py_ssize_t idx , pyobject * value ) { pyobject * old_item ; if ( idx >= self -> memo_size ) { if ( _unpickler_resizememolist ( self , idx * 2 ) < 0 ) return - 1 ; assert ( idx < self -> memo_size ) ; } py_incref ( value ) ; old_item = self -> memo [ idx ] ; self -> memo [ idx ] = value ; if ( old_item != null ) { py_decref ( old_item ) ; } else { self -> memo_len ++ ; } return 0 ; }","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx , PyObject
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,"<S2SV_StartBug> _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value ) <S2SV_EndBug>"
1120,CWE-119,"static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info ( hdev , ""fixing<s2sv_blank>up<s2sv_blank>petalynx<s2sv_blank>maxter<s2sv_blank>remote<s2sv_blank>report<s2sv_blank>descriptor\\n"" ) ; rdesc [ 60 ] = 0xfa ; rdesc [ 40 ] = 0xfa ; } return rdesc ; }","<S2SV_ModStart> * rsize >= 62 <S2SV_ModEnd> && rdesc [
",torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z,<S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug>
7734,CWE-000,"static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) { struct nfs4_exception exception = { } ; struct nfs4_state * res ; int status ; do { status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; if ( status == 0 ) break ; if ( status == - nfs4err_bad_seqid ) { printk ( kern_warning ""nfs:<s2sv_blank>v4<s2sv_blank>server<s2sv_blank>%s<s2sv_blank>"" ""<s2sv_blank>returned<s2sv_blank>a<s2sv_blank>bad<s2sv_blank>sequence-id<s2sv_blank>error!\\n"" , nfs_server ( dir ) -> nfs_client -> cl_hostname ) ; exception . retry = 1 ; continue ; } if ( status == - nfs4err_bad_stateid ) { exception . retry = 1 ; continue ; } if ( status == - eagain ) { exception . retry = 1 ; continue ; } res = err_ptr ( nfs4_handle_exception ( nfs_server ( dir ) , status , & exception ) ) ; } while ( exception . retry ) ; return res ; }","<S2SV_ModStart> path * path , fmode_t fmode <S2SV_ModStart> dir , path , fmode
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) <S2SV_EndBug> <S2SV_StartBug> status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; <S2SV_EndBug>"
5156,CWE-674,"static int renamecolumnselectcb ( walker * pwalker , select * p ) { renamewalkwith ( pwalker , p ) ; return wrc_continue ; }","<S2SV_ModStart> p ) { if ( p -> selFlags & SF_View ) return WRC_Prune ;
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,"<S2SV_StartBug> static int renameColumnSelectCb ( Walker * pWalker , Select * p ) { <S2SV_EndBug>"
2386,CWE-000,"static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_i ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<s2sv_blank>inode<s2sv_blank>%lu,<s2sv_blank>logical"" ""block<s2sv_blank>%llu,<s2sv_blank>max_blocks<s2sv_blank>%u,<s2sv_blank>flags<s2sv_blank>%d,<s2sv_blank>allocated<s2sv_blank>%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; if ( flags == ext4_get_blocks_pre_io ) { ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = ext4_io_unwritten ; else ext4_set_inode_state ( inode , ext4_state_dio_unwritten ) ; goto out ; } if ( flags == ext4_get_blocks_convert ) { ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & ext4_get_blocks_uninit_ext ) goto map_out ; if ( ( flags & ext4_get_blocks_create ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & ext4_get_blocks_delalloc_reserve ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }","<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,"<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug>"
101,CWE-119,unsigned int x509v3_addr_get_afi ( const ipaddressfamily * f ) { return ( ( f != null && f -> addressfamily != null && f -> addressfamily -> data != null ) ? ( ( f -> addressfamily -> data [ 0 ] << 8 ) | ( f -> addressfamily -> data [ 1 ] ) ) : 0 ) ; },"<S2SV_ModStart> f ) { if ( f == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> f -> addressFamily == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> addressFamily -> data == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> ( f -> <S2SV_ModStart> 8 ) | <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; } <S2SV_null>
",openssl@openssl/068b963bb7afc57f5bdd723de0dd15e7795d5822,CVE-2017-3735,https://github.com/openssl/openssl/commit/068b963bb7afc57f5bdd723de0dd15e7795d5822,2017-08-28T19:29Z,<S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug>
5506,CWE-190,"static image * readtxtimage ( const imageinfo * image_info , exceptioninfo * exception ) { char colorspace [ magickpathextent ] , text [ magickpathextent ] ; image * image ; long x_offset , y_offset ; pixelinfo pixel ; magickbooleantype status ; quantumany range ; register ssize_t i , x ; register quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; if ( image_info -> debug != magickfalse ) ( void ) logmagickevent ( traceevent , getmagickmodule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } ( void ) resetmagickmemory ( text , 0 , sizeof ( text ) ) ; ( void ) readblobstring ( image , text ) ; if ( localencompare ( ( char * ) text , magickid , strlen ( magickid ) ) != 0 ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( getquantumrange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; localelower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = undefinedpixeltrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = blendpixeltrait ; } type = parsecommandoption ( magickcolorspaceoptions , magickfalse , colorspace ) ; if ( type < 0 ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; ( void ) setimagebackgroundcolor ( image , exception ) ; ( void ) setimagecolorspace ( image , ( colorspacetype ) type , exception ) ; getpixelinfo ( image , & pixel ) ; range = getquantumrange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( readblobstring ( image , text ) == ( char * ) null ) break ; switch ( image -> colorspace ) { case graycolorspace : { if ( image -> alpha_trait != undefinedpixeltrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<s2sv_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<s2sv_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case cmykcolorspace : { if ( image -> alpha_trait != undefinedpixeltrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<s2sv_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<s2sv_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != undefinedpixeltrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<s2sv_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<s2sv_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) null ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == labcolorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( magickrealtype ) scaleanytoquantum ( ( quantumany ) ( red + 0.5 ) , range ) ; pixel . green = ( magickrealtype ) scaleanytoquantum ( ( quantumany ) ( green + 0.5 ) , range ) ; pixel . blue = ( magickrealtype ) scaleanytoquantum ( ( quantumany ) ( blue + 0.5 ) , range ) ; pixel . black = ( magickrealtype ) scaleanytoquantum ( ( quantumany ) ( black + 0.5 ) , range ) ; pixel . alpha = ( magickrealtype ) scaleanytoquantum ( ( quantumany ) ( alpha + 0.5 ) , range ) ; q = getauthenticpixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( quantum * ) null ) continue ; setpixelviapixelinfo ( image , & pixel , q ) ; if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; } } if ( eofblob ( image ) != magickfalse ) { throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; break ; } ( void ) readblobstring ( image , text ) ; if ( localencompare ( ( char * ) text , magickid , strlen ( magickid ) ) == 0 ) { acquirenextimage ( image_info , image , exception ) ; if ( getnextimageinlist ( image ) == ( image * ) null ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } image = syncnextimageinlist ( image ) ; status = setimageprogress ( image , loadimagestag , tellblob ( image ) , getblobsize ( image ) ) ; if ( status == magickfalse ) break ; } } while ( localencompare ( ( char * ) text , magickid , strlen ( magickid ) ) == 0 ) ; ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; }","<S2SV_ModStart> depth ++ ) if ( depth >= 64 ) break
",ImageMagick@ImageMagick/50f54462076648ac2e36c3f58f4dadd4babbf1c9,CVE-2017-14173,https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9,2017-09-07T06:29Z,<S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; <S2SV_EndBug>
2737,CWE-399,static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = hugetlbfs_sb ( sb ) ; if ( sbi ) { sb -> s_fs_info = null ; kfree ( sbi ) ; } },"<S2SV_ModStart> = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,<S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug>
2480,CWE-120,"void mwifiex_set_uap_rates ( struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { struct ieee_types_header * rate_ie ; int var_offset = offsetof ( struct ieee80211_mgmt , u . beacon . variable ) ; const u8 * var_pos = params -> beacon . head + var_offset ; int len = params -> beacon . head_len - var_offset ; u8 rate_len = 0 ; rate_ie = ( void * ) cfg80211_find_ie ( wlan_eid_supp_rates , var_pos , len ) ; if ( rate_ie ) { memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; rate_len = rate_ie -> len ; } rate_ie = ( void * ) cfg80211_find_ie ( wlan_eid_ext_supp_rates , params -> beacon . tail , params -> beacon . tail_len ) ; if ( rate_ie ) memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; return ; }","<S2SV_ModStart> rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> len ) ; }
",torvalds@linux/7caac62ed598a196d6ddf8d9c121e12e082cac3a,CVE-2019-14814,https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a,2019-09-20T19:15Z,"<S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug>"
6028,CWE-401,"int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & ah_unplugged ) return 0 ; skb = alloc_skb ( headroom + cmd_len , gfp_atomic ) ; if ( ! skb ) return - enomem ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != null ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - eproto ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , wmi , ""timeout<s2sv_blank>waiting<s2sv_blank>for<s2sv_blank>wmi<s2sv_blank>command:<s2sv_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; return - etimedout ; } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , wmi , ""wmi<s2sv_blank>failure<s2sv_blank>for:<s2sv_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; kfree_skb ( skb ) ; return ret ; }","<S2SV_ModStart> op_mutex ) ; kfree_skb ( skb ) ;
",torvalds@linux/728c1e2a05e4b5fc52fab3421dce772a806612a2,CVE-2019-19074,https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2,2019-11-18T06:15Z,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug>
5365,CWE-125,"void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ inet6_addrstrlen ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( ip_v ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = null ; ch = '\\0' ; if ( ! nd_ttest ( pgm -> pgm_dport ) ) { if ( ip6 ) { nd_print ( ( ndo , ""%s<s2sv_blank>><s2sv_blank>%s:<s2sv_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { nd_print ( ( ndo , ""%s<s2sv_blank>><s2sv_blank>%s:<s2sv_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = extract_16bits ( & pgm -> pgm_sport ) ; dport = extract_16bits ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == ipproto_pgm ) { nd_print ( ( ndo , ""%s.%s<s2sv_blank>><s2sv_blank>%s.%s:<s2sv_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { nd_print ( ( ndo , ""%s<s2sv_blank>><s2sv_blank>%s:<s2sv_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == ipproto_pgm ) { nd_print ( ( ndo , ""%s.%s<s2sv_blank>><s2sv_blank>%s.%s:<s2sv_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { nd_print ( ( ndo , ""%s<s2sv_blank>><s2sv_blank>%s:<s2sv_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } nd_tcheck ( * pgm ) ; nd_print ( ( ndo , ""pgm,<s2sv_blank>length<s2sv_blank>%u"" , extract_16bits ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; nd_print ( ( ndo , ""<s2sv_blank>0x%02x%02x%02x%02x%02x%02x<s2sv_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case pgm_spm : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; nd_tcheck ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( extract_16bits ( & spm -> pgms_nla_afi ) ) { case afnum_inet : nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case afnum_inet6 : nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } nd_print ( ( ndo , ""spm<s2sv_blank>seq<s2sv_blank>%u<s2sv_blank>trail<s2sv_blank>%u<s2sv_blank>lead<s2sv_blank>%u<s2sv_blank>nla<s2sv_blank>%s"" , extract_32bits ( & spm -> pgms_seq ) , extract_32bits ( & spm -> pgms_trailseq ) , extract_32bits ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case pgm_poll : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; nd_tcheck ( * poll_msg ) ; nd_print ( ( ndo , ""poll<s2sv_blank>seq<s2sv_blank>%u<s2sv_blank>round<s2sv_blank>%u"" , extract_32bits ( & poll_msg -> pgmp_seq ) , extract_16bits ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case pgm_polr : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; nd_tcheck ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( extract_16bits ( & polr -> pgmp_nla_afi ) ) { case afnum_inet : nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case afnum_inet6 : nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } nd_tcheck2 ( * bp , sizeof ( uint32_t ) ) ; ivl = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_tcheck2 ( * bp , sizeof ( uint32_t ) ) ; rnd = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_tcheck2 ( * bp , sizeof ( uint32_t ) ) ; mask = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""polr<s2sv_blank>seq<s2sv_blank>%u<s2sv_blank>round<s2sv_blank>%u<s2sv_blank>nla<s2sv_blank>%s<s2sv_blank>ivl<s2sv_blank>%u<s2sv_blank>rnd<s2sv_blank>0x%08x<s2sv_blank>"" ""mask<s2sv_blank>0x%08x"" , extract_32bits ( & polr -> pgmp_seq ) , extract_16bits ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case pgm_odata : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; nd_tcheck ( * odata ) ; nd_print ( ( ndo , ""odata<s2sv_blank>trail<s2sv_blank>%u<s2sv_blank>seq<s2sv_blank>%u"" , extract_32bits ( & odata -> pgmd_trailseq ) , extract_32bits ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case pgm_rdata : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; nd_tcheck ( * rdata ) ; nd_print ( ( ndo , ""rdata<s2sv_blank>trail<s2sv_blank>%u<s2sv_blank>seq<s2sv_blank>%u"" , extract_32bits ( & rdata -> pgmd_trailseq ) , extract_32bits ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case pgm_nak : case pgm_nullnak : case pgm_ncf : { const struct pgm_nak * nak ; char source_buf [ inet6_addrstrlen ] , group_buf [ inet6_addrstrlen ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; nd_tcheck ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( extract_16bits ( & nak -> pgmn_source_afi ) ) { case afnum_inet : nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case afnum_inet6 : nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( extract_16bits ( bp ) ) { case afnum_inet : nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case afnum_inet6 : nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case pgm_nak : nd_print ( ( ndo , ""nak<s2sv_blank>"" ) ) ; break ; case pgm_nullnak : nd_print ( ( ndo , ""nnak<s2sv_blank>"" ) ) ; break ; case pgm_ncf : nd_print ( ( ndo , ""ncf<s2sv_blank>"" ) ) ; break ; default : break ; } nd_print ( ( ndo , ""(%s<s2sv_blank>-><s2sv_blank>%s),<s2sv_blank>seq<s2sv_blank>%u"" , source_buf , group_buf , extract_32bits ( & nak -> pgmn_seq ) ) ) ; break ; } case pgm_ack : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; nd_tcheck ( * ack ) ; nd_print ( ( ndo , ""ack<s2sv_blank>seq<s2sv_blank>%u"" , extract_32bits ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case pgm_spmr : nd_print ( ( ndo , ""spmr"" ) ) ; break ; default : nd_print ( ( ndo , ""unknown<s2sv_blank>type<s2sv_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & pgm_opt_bit_present ) { if ( ! nd_ttest2 ( * bp , pgm_min_opt_len ) ) { nd_print ( ( ndo , ""[|opt]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & pgm_opt_mask ) != pgm_opt_length ) { nd_print ( ( ndo , ""[first<s2sv_blank>option<s2sv_blank>bad,<s2sv_blank>should<s2sv_blank>be<s2sv_blank>pgm_opt_length,<s2sv_blank>is<s2sv_blank>%u]"" , opt_type & pgm_opt_mask ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_length<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } opts_len = extract_16bits ( bp ) ; if ( opts_len < 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>total<s2sv_blank>option<s2sv_blank>length<s2sv_blank>%u<s2sv_blank><<s2sv_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; nd_print ( ( ndo , ""<s2sv_blank>opts<s2sv_blank>len<s2sv_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < pgm_min_opt_len ) { nd_print ( ( ndo , ""[total<s2sv_blank>option<s2sv_blank>length<s2sv_blank>leaves<s2sv_blank>no<s2sv_blank>room<s2sv_blank>for<s2sv_blank>final<s2sv_blank>option]"" ) ) ; return ; } if ( ! nd_ttest2 ( * bp , 2 ) ) { nd_print ( ( ndo , ""<s2sv_blank>[|opt]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < pgm_min_opt_len ) { nd_print ( ( ndo , ""[bad<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank><<s2sv_blank>%u]"" , opt_len , pgm_min_opt_len ) ) ; break ; } if ( opts_len < opt_len ) { nd_print ( ( ndo , ""[total<s2sv_blank>option<s2sv_blank>length<s2sv_blank>leaves<s2sv_blank>no<s2sv_blank>room<s2sv_blank>for<s2sv_blank>final<s2sv_blank>option]"" ) ) ; return ; } if ( ! nd_ttest2 ( * bp , opt_len - 2 ) ) { nd_print ( ( ndo , ""<s2sv_blank>[|opt]"" ) ) ; return ; } switch ( opt_type & pgm_opt_mask ) { case pgm_opt_length : if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_length<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } nd_print ( ( ndo , ""<s2sv_blank>opts<s2sv_blank>len<s2sv_blank>(extra?)<s2sv_blank>%d"" , extract_16bits ( bp ) ) ) ; bp += sizeof ( uint16_t ) ; opts_len -= 4 ; break ; case pgm_opt_fragment : if ( opt_len != 16 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_fragment<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>16]"" , opt_len ) ) ; return ; } bp += 2 ; seq = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; offset = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; len = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>frag<s2sv_blank>seq<s2sv_blank>%u<s2sv_blank>off<s2sv_blank>%u<s2sv_blank>len<s2sv_blank>%u"" , seq , offset , len ) ) ; opts_len -= 16 ; break ; case pgm_opt_nak_list : bp += 2 ; opt_len -= sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>nak<s2sv_blank>list"" ) ) ; while ( opt_len ) { if ( opt_len < sizeof ( uint32_t ) ) { nd_print ( ( ndo , ""[option<s2sv_blank>length<s2sv_blank>not<s2sv_blank>a<s2sv_blank>multiple<s2sv_blank>of<s2sv_blank>4]"" ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( uint32_t ) ) ; nd_print ( ( ndo , ""<s2sv_blank>%u"" , extract_32bits ( bp ) ) ) ; bp += sizeof ( uint32_t ) ; opt_len -= sizeof ( uint32_t ) ; opts_len -= sizeof ( uint32_t ) ; } break ; case pgm_opt_join : if ( opt_len != 8 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_join<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; seq = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>join<s2sv_blank>%u"" , seq ) ) ; opts_len -= 8 ; break ; case pgm_opt_nak_bo_ivl : if ( opt_len != 12 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_nak_bo_ivl<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>12]"" , opt_len ) ) ; return ; } bp += 2 ; offset = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; seq = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>backoff<s2sv_blank>ivl<s2sv_blank>%u<s2sv_blank>ivlseq<s2sv_blank>%u"" , offset , seq ) ) ; opts_len -= 12 ; break ; case pgm_opt_nak_bo_rng : if ( opt_len != 12 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_nak_bo_rng<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>12]"" , opt_len ) ) ; return ; } bp += 2 ; offset = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; seq = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>backoff<s2sv_blank>max<s2sv_blank>%u<s2sv_blank>min<s2sv_blank>%u"" , offset , seq ) ) ; opts_len -= 12 ; break ; case pgm_opt_redirect : bp += 2 ; nla_afnum = extract_16bits ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case afnum_inet : if ( opt_len != 4 + sizeof ( struct in_addr ) ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_redirect<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4<s2sv_blank>+<s2sv_blank>address<s2sv_blank>size]"" , opt_len ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 4 + sizeof ( struct in_addr ) ; break ; case afnum_inet6 : if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_redirect<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4<s2sv_blank>+<s2sv_blank>address<s2sv_blank>size]"" , opt_len ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 4 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } nd_print ( ( ndo , ""<s2sv_blank>redirect<s2sv_blank>%s"" , nla_buf ) ) ; break ; case pgm_opt_parity_prm : if ( opt_len != 8 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_parity_prm<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; len = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>parity<s2sv_blank>maxtgs<s2sv_blank>%u"" , len ) ) ; opts_len -= 8 ; break ; case pgm_opt_parity_grp : if ( opt_len != 8 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_parity_grp<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; seq = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>parity<s2sv_blank>group<s2sv_blank>%u"" , seq ) ) ; opts_len -= 8 ; break ; case pgm_opt_curr_tgsize : if ( opt_len != 8 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_curr_tgsize<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>8]"" , opt_len ) ) ; return ; } bp += 2 ; len = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nd_print ( ( ndo , ""<s2sv_blank>parity<s2sv_blank>atgs<s2sv_blank>%u"" , len ) ) ; opts_len -= 8 ; break ; case pgm_opt_nbr_unreach : if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_nbr_unreach<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; nd_print ( ( ndo , ""<s2sv_blank>nbr_unreach"" ) ) ; opts_len -= 4 ; break ; case pgm_opt_path_nla : nd_print ( ( ndo , ""<s2sv_blank>path_nla<s2sv_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case pgm_opt_syn : if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_syn<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; nd_print ( ( ndo , ""<s2sv_blank>syn"" ) ) ; opts_len -= 4 ; break ; case pgm_opt_fin : if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_fin<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; nd_print ( ( ndo , ""<s2sv_blank>fin"" ) ) ; opts_len -= 4 ; break ; case pgm_opt_rst : if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_rst<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; nd_print ( ( ndo , ""<s2sv_blank>rst"" ) ) ; opts_len -= 4 ; break ; case pgm_opt_cr : nd_print ( ( ndo , ""<s2sv_blank>cr"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case pgm_opt_crqst : if ( opt_len != 4 ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_crqst<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>4]"" , opt_len ) ) ; return ; } bp += 2 ; nd_print ( ( ndo , ""<s2sv_blank>crqst"" ) ) ; opts_len -= 4 ; break ; case pgm_opt_pgmcc_data : bp += 2 ; offset = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = extract_16bits ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case afnum_inet : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_pgmcc_data<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>12<s2sv_blank>+<s2sv_blank>address<s2sv_blank>size]"" , opt_len ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case afnum_inet6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_pgmcc_data<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>12<s2sv_blank>+<s2sv_blank>address<s2sv_blank>size]"" , opt_len ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } nd_print ( ( ndo , ""<s2sv_blank>pgmcc<s2sv_blank>data<s2sv_blank>%u<s2sv_blank>%s"" , offset , nla_buf ) ) ; break ; case pgm_opt_pgmcc_feedback : bp += 2 ; offset = extract_32bits ( bp ) ; bp += sizeof ( uint32_t ) ; nla_afnum = extract_16bits ( bp ) ; bp += ( 2 * sizeof ( uint16_t ) ) ; switch ( nla_afnum ) { case afnum_inet : if ( opt_len != 12 + sizeof ( struct in_addr ) ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_pgmcc_data<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>12<s2sv_blank>+<s2sv_blank>address<s2sv_blank>size]"" , opt_len ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= 12 + sizeof ( struct in_addr ) ; break ; case afnum_inet6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { nd_print ( ( ndo , ""[bad<s2sv_blank>opt_pgmcc_data<s2sv_blank>option,<s2sv_blank>length<s2sv_blank>%u<s2sv_blank>!=<s2sv_blank>12<s2sv_blank>+<s2sv_blank>address<s2sv_blank>size]"" , opt_len ) ) ; return ; } nd_tcheck2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= 12 + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } nd_print ( ( ndo , ""<s2sv_blank>pgmcc<s2sv_blank>feedback<s2sv_blank>%u<s2sv_blank>%s"" , offset , nla_buf ) ) ; break ; default : nd_print ( ( ndo , ""<s2sv_blank>opt_%02x<s2sv_blank>[%d]<s2sv_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & pgm_opt_end ) break ; } } nd_print ( ( ndo , ""<s2sv_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == pt_pgm_zmtp1 && ( pgm -> pgm_type == pgm_odata || pgm -> pgm_type == pgm_rdata ) ) zmtp1_print_datagram ( ndo , bp , extract_16bits ( & pgm -> pgm_length ) ) ; return ; trunc : nd_print ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) nd_print ( ( ndo , "">"" ) ) ; }","<S2SV_ModStart> case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <S2SV_ModStart> ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <S2SV_ModEnd> ; opts_len -= <S2SV_ModStart> -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; offset = <S2SV_ModEnd> EXTRACT_32BITS ( bp <S2SV_ModStart> ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset <S2SV_ModEnd> , seq ) <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> , opt_len ) <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <S2SV_ModEnd> + sizeof ( <S2SV_ModStart> ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset <S2SV_ModEnd> , nla_buf ) <S2SV_ModStart> break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> + sizeof (
",the-tcpdump-group@tcpdump/4601c685e7fd19c3724d5e499c69b8d3ec49933e,CVE-2017-13019,https://github.com/the-tcpdump-group/tcpdump/commit/4601c685e7fd19c3724d5e499c69b8d3ec49933e,2017-09-14T06:29Z,"<S2SV_StartBug> if ( opt_len != 4 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 16 ) { <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len < sizeof ( uint32_t ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> seq = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in_addr ) ) { <S2SV_EndBug> <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in_addr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { <S2SV_EndBug> <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in6_addr ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; <S2SV_EndBug> <S2SV_StartBug> case PGM_OPT_PARITY_PRM : <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug>"
4399,CWE-000,"void print_arrays_for ( char * set ) { file * f ; sprintf ( buf , ""%s.conf"" , set ) ; if ( ( f = fopen ( buf , ""r"" ) ) == null ) { fprintf ( stderr , ""%s:<s2sv_blank>can\'t<s2sv_blank>read<s2sv_blank>conf<s2sv_blank>file<s2sv_blank>for<s2sv_blank>charset<s2sv_blank>%s\\n"" , prog , set ) ; exit ( exit_failure ) ; } printf ( ""\\\n<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>\\n\\n"" , set , prog ) ; print_array ( f , set , ""ctype"" , ctype_table_size ) ; print_array ( f , set , ""to_lower"" , to_lower_table_size ) ; print_array ( f , set , ""to_upper"" , to_upper_table_size ) ; print_array ( f , set , ""sort_order"" , sort_order_table_size ) ; printf ( ""\\n"" ) ; fclose ( f ) ; return ; }","<S2SV_ModStart> * f ; snprintf ( buf , sizeof ( buf ) <S2SV_ModEnd> , ""%s.conf"" , <S2SV_ModStart> } printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" <S2SV_ModEnd> , set ,
",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z,"<S2SV_StartBug> sprintf ( buf , ""%s.conf"" , set ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" , <S2SV_EndBug>"
2428,CWE-190,"static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }","<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
",torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76,CVE-2018-12896,https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76,2018-07-02T17:29Z,"<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug>"
3554,CWE-200,"static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & msg_dontwait ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( ""%p<s2sv_blank>%zu\\n"" , sk , len ) ; lock_sock ( sk ) ; if ( sk -> sk_state == llcp_closed && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( msg_oob ) ) return - eopnotsupp ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""recv<s2sv_blank>datagram<s2sv_blank>failed<s2sv_blank>state<s2sv_blank>%d<s2sv_blank>%d<s2sv_blank>%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & rcv_shutdown ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & msg_peek ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - efault ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == sock_dgram && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""datagram<s2sv_blank>socket<s2sv_blank>%d<s2sv_blank>%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ; sockaddr -> sa_family = af_nfc ; sockaddr -> nfc_protocol = nfc_proto_nfc_dep ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & msg_peek ) ) { if ( sk -> sk_type == sock_stream || sk -> sk_type == sock_dgram || sk -> sk_type == sock_raw ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == sock_seqpacket && ( flags & msg_trunc ) ) copied = rlen ; return copied ; }","<S2SV_ModStart> , len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;
",torvalds@linux/d26d6504f23e803824e8ebd14e52d4fc0a0b09cb,CVE-2013-3233,https://github.com/torvalds/linux/commit/d26d6504f23e803824e8ebd14e52d4fc0a0b09cb,2013-04-22T11:41Z,"<S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug>"
7471,CWE-476,"static int resize ( int new_rows , int new_cols , vtermpos * delta , void * user ) { vtermscreen * screen = user ; int is_altscreen = ( screen -> buffers [ 1 ] && screen -> buffer == screen -> buffers [ 1 ] ) ; int old_rows = screen -> rows ; int old_cols = screen -> cols ; int first_blank_row ; if ( ! is_altscreen && new_rows < old_rows ) { vtermpos pos = { 0 , 0 } ; vtermpos cursor = screen -> state -> pos ; for ( pos . row = old_rows - 1 ; pos . row >= new_rows ; pos . row -- ) if ( ! vterm_screen_is_eol ( screen , pos ) || cursor . row == pos . row ) break ; first_blank_row = pos . row + 1 ; if ( first_blank_row > new_rows ) { vtermrect rect = { 0 , 0 , 0 , 0 } ; rect . end_row = old_rows ; rect . end_col = old_cols ; scrollrect ( rect , first_blank_row - new_rows , 0 , user ) ; vterm_screen_flush_damage ( screen ) ; delta -> row -= first_blank_row - new_rows ; } } screen -> buffers [ 0 ] = realloc_buffer ( screen , screen -> buffers [ 0 ] , new_rows , new_cols ) ; if ( screen -> buffers [ 1 ] ) screen -> buffers [ 1 ] = realloc_buffer ( screen , screen -> buffers [ 1 ] , new_rows , new_cols ) ; screen -> buffer = is_altscreen ? screen -> buffers [ 1 ] : screen -> buffers [ 0 ] ; screen -> rows = new_rows ; screen -> cols = new_cols ; if ( screen -> sb_buffer ) vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( vtermscreencell ) * new_cols ) ; if ( new_cols > old_cols ) { vtermrect rect ; rect . start_row = 0 ; rect . end_row = old_rows ; rect . start_col = old_cols ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } if ( new_rows > old_rows ) { if ( ! is_altscreen && screen -> callbacks && screen -> callbacks -> sb_popline ) { int rows = new_rows - old_rows ; while ( rows ) { vtermrect rect = { 0 , 0 , 0 , 0 } ; vtermpos pos = { 0 , 0 } ; if ( ! ( screen -> callbacks -> sb_popline ( screen -> cols , screen -> sb_buffer , screen -> cbdata ) ) ) break ; rect . end_row = screen -> rows ; rect . end_col = screen -> cols ; scrollrect ( rect , - 1 , 0 , user ) ; for ( pos . col = 0 ; pos . col < screen -> cols ; pos . col += screen -> sb_buffer [ pos . col ] . width ) vterm_screen_set_cell ( screen , pos , screen -> sb_buffer + pos . col ) ; rect . end_row = 1 ; damagerect ( screen , rect ) ; vterm_screen_flush_damage ( screen ) ; rows -- ; delta -> row ++ ; } } { vtermrect rect ; rect . start_row = old_rows ; rect . end_row = new_rows ; rect . start_col = 0 ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } } if ( screen -> callbacks && screen -> callbacks -> resize ) return ( * screen -> callbacks -> resize ) ( new_rows , new_cols , screen -> cbdata ) ; return 1 ; }","<S2SV_ModStart> = new_cols ; <S2SV_ModEnd> vterm_allocator_free ( screen
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,<S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug>
7725,CWE-000,"static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != null ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( nfs_delegated_state , & state -> flags ) ; } if ( open_stateid != null ) nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; update_open_stateflags ( state , open_flags ) ; spin_unlock ( & state -> owner -> so_lock ) ; }","<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug>"
4803,CWE-444,"agoocon agoo_con_create ( agooerr err , int sock , uint64_t id , agoobind b ) { agoocon c ; if ( null == ( c = ( agoocon ) agoo_calloc ( 1 , sizeof ( struct _agoocon ) ) ) ) { agoo_err_mem ( err , ""connection"" ) ; } else { c -> sock = sock ; c -> id = id ; c -> timeout = dtime ( ) + con_timeout ; c -> bind = b ; c -> loop = null ; pthread_mutex_init ( & c -> res_lock , 0 ) ; } return c ; }","<S2SV_ModStart> } else { struct sockaddr_storage addr ; socklen_t len = sizeof ( addr ) ; getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( addr . ss_family == AF_INET ) { struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ; inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ; } else { struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ; inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ; }
",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z,<S2SV_StartBug> c -> sock = sock ; <S2SV_EndBug>
7736,CWE-000,"static void nfs4_open_confirm_release ( void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state * state = null ; if ( data -> cancelled == 0 ) goto out_free ; if ( ! data -> rpc_done ) goto out_free ; state = nfs4_opendata_to_nfs4_state ( data ) ; if ( ! is_err ( state ) ) nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; out_free : nfs4_opendata_put ( data ) ; }","<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug>"
3771,CWE-20,"long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - einval ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { if ( shmflg & shm_rnd ) addr &= ~ ( shmlba - 1 ) ; else # ifndef __arch_force_shmlba if ( addr & ~ page_mask ) # endif goto out ; } flags = map_shared | map_fixed ; } else { if ( ( shmflg & shm_remap ) ) goto out ; flags = map_shared ; } if ( shmflg & shm_rdonly ) { prot = prot_read ; acc_mode = s_irugo ; f_mode = fmode_read ; } else { prot = prot_read | prot_write ; acc_mode = s_irugo | s_iwugo ; f_mode = fmode_read | fmode_write ; } if ( shmflg & shm_exec ) { prot |= prot_exec ; acc_mode |= s_ixugo ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( is_err ( shp ) ) { err = ptr_err ( shp ) ; goto out_unlock ; } err = - eacces ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - eidrm ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - enomem ; sfd = kzalloc ( sizeof ( * sfd ) , gfp_kernel ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = ptr_err ( file ) ; if ( is_err ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = null ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - eintr ; goto out_fput ; } if ( addr && ! ( shmflg & shm_remap ) ) { err = - einval ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , null ) ; * raddr = addr ; err = 0 ; if ( is_err_value ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }","<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba
",torvalds@linux/e1d35d4dc7f089e6c9c080d556feedf9c706f0c7,CVE-2017-5669,https://github.com/torvalds/linux/commit/e1d35d4dc7f089e6c9c080d556feedf9c706f0c7,2017-02-24T15:59Z,<S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug>
530,CWE-416,"static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; if ( len < tcp_hdrlen ) return - 1 ; if ( info -> mss == xt_tcpmss_clamp_pmtu ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknown<s2sv_blank>or<s2sv_blank>invalid<s2sv_blank>path-mtu<s2sv_blank>(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - tcpolen_mss ; i += optlen ( opt , i ) ) { if ( opt [ i ] == tcpopt_mss && opt [ i + 1 ] == tcpolen_mss ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ; if ( skb_tailroom ( skb ) < tcpolen_mss ) { if ( pskb_expand_head ( skb , 0 , tcpolen_mss - skb_tailroom ( skb ) , gfp_atomic ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , tcpolen_mss ) ; if ( xt_family ( par ) == nfproto_ipv4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + tcpolen_mss , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + tcpolen_mss ) , true ) ; opt [ 0 ] = tcpopt_mss ; opt [ 1 ] = tcpolen_mss ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += tcpolen_mss / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return tcpolen_mss ; }","<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
",torvalds@linux/2638fd0f92d4397884fd991d8f4925cb3f081901,CVE-2017-18017,https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901,2018-01-03T06:29Z,<S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug>
7843,CWE-20,"error_t tcpsendresetsegment ( netinterface * interface , ippseudoheader * pseudoheader , tcpheader * segment , size_t length ) { error_t error ; size_t offset ; uint8_t flags ; uint32_t seqnum ; uint32_t acknum ; netbuffer * buffer ; tcpheader * segment2 ; ippseudoheader pseudoheader2 ; nettxancillary ancillary ; if ( segment -> flags & tcp_flag_ack ) { flags = tcp_flag_rst ; seqnum = segment -> acknum ; acknum = 0 ; } else { flags = tcp_flag_rst | tcp_flag_ack ; seqnum = 0 ; acknum = segment -> seqnum + length ; if ( segment -> flags & tcp_flag_syn ) acknum ++ ; if ( segment -> flags & tcp_flag_fin ) acknum ++ ; } buffer = ipallocbuffer ( sizeof ( tcpheader ) , & offset ) ; if ( buffer == null ) return error_out_of_memory ; segment2 = netbufferat ( buffer , offset ) ; segment2 -> srcport = htons ( segment -> destport ) ; segment2 -> destport = htons ( segment -> srcport ) ; segment2 -> seqnum = htonl ( seqnum ) ; segment2 -> acknum = htonl ( acknum ) ; segment2 -> reserved1 = 0 ; segment2 -> dataoffset = 5 ; segment2 -> flags = flags ; segment2 -> reserved2 = 0 ; segment2 -> window = 0 ; segment2 -> checksum = 0 ; segment2 -> urgentpointer = 0 ; # if ( ipv4_support == enabled ) if ( pseudoheader -> length == sizeof ( ipv4pseudoheader ) ) { pseudoheader2 . length = sizeof ( ipv4pseudoheader ) ; pseudoheader2 . ipv4data . srcaddr = pseudoheader -> ipv4data . destaddr ; pseudoheader2 . ipv4data . destaddr = pseudoheader -> ipv4data . srcaddr ; pseudoheader2 . ipv4data . reserved = 0 ; pseudoheader2 . ipv4data . protocol = ipv4_protocol_tcp ; pseudoheader2 . ipv4data . length = htons ( sizeof ( tcpheader ) ) ; segment2 -> checksum = ipcalcupperlayerchecksumex ( & pseudoheader2 . ipv4data , sizeof ( ipv4pseudoheader ) , buffer , offset , sizeof ( tcpheader ) ) ; } else # endif # if ( ipv6_support == enabled ) if ( pseudoheader -> length == sizeof ( ipv6pseudoheader ) ) { pseudoheader2 . length = sizeof ( ipv6pseudoheader ) ; pseudoheader2 . ipv6data . srcaddr = pseudoheader -> ipv6data . destaddr ; pseudoheader2 . ipv6data . destaddr = pseudoheader -> ipv6data . srcaddr ; pseudoheader2 . ipv6data . length = htonl ( sizeof ( tcpheader ) ) ; pseudoheader2 . ipv6data . reserved [ 0 ] = 0 ; pseudoheader2 . ipv6data . reserved [ 1 ] = 0 ; pseudoheader2 . ipv6data . reserved [ 2 ] = 0 ; pseudoheader2 . ipv6data . nextheader = ipv6_tcp_header ; segment2 -> checksum = ipcalcupperlayerchecksumex ( & pseudoheader2 . ipv6data , sizeof ( ipv6pseudoheader ) , buffer , offset , sizeof ( tcpheader ) ) ; } else # endif { netbufferfree ( buffer ) ; return error_invalid_address ; } mib2_inc_counter32 ( tcpgroup . tcpoutsegs , 1 ) ; tcp_mib_inc_counter32 ( tcpoutsegs , 1 ) ; tcp_mib_inc_counter64 ( tcphcoutsegs , 1 ) ; mib2_inc_counter32 ( tcpgroup . tcpoutrsts , 1 ) ; tcp_mib_inc_counter32 ( tcpoutrsts , 1 ) ; trace_debug ( ""%s:<s2sv_blank>sending<s2sv_blank>tcp<s2sv_blank>reset<s2sv_blank>segment...\\r\\n"" , formatsystemtime ( osgetsystemtime ( ) , null ) ) ; tcpdumpheader ( segment2 , length , 0 , 0 ) ; ancillary = net_default_tx_ancillary ; error = ipsenddatagram ( interface , & pseudoheader2 , buffer , offset , & ancillary ) ; netbufferfree ( buffer ) ; return error ; }","<S2SV_ModStart> & TCP_FLAG_SYN ) { <S2SV_ModStart> ackNum ++ ; } <S2SV_ModStart> & TCP_FLAG_FIN ) { <S2SV_ModStart> ackNum ++ ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug>
6247,CWE-189,"void * chk_malloc ( size_t bytes ) { char * buffer = ( char * ) dlmalloc ( bytes + chk_overhead_size ) ; if ( buffer ) { memset ( buffer , chk_sentinel_value , bytes + chk_overhead_size ) ; size_t offset = dlmalloc_usable_size ( buffer ) - sizeof ( size_t ) ; * ( size_t * ) ( buffer + offset ) = bytes ; buffer += chk_sentinel_head_size ; } return buffer ; }","<S2SV_ModStart> bytes ) { size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> * buffer = <S2SV_ModStart> buffer = ( uint8_t <S2SV_ModEnd> * ) dlmalloc <S2SV_ModStart> ) dlmalloc ( size <S2SV_ModEnd> ) ; if
",android@platform_bionic/7f5aa4f35e23fd37425b3a5041737cdf58f87385,CVE-2012-2674,https://github.com/android/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385,2012-07-25T19:55Z,<S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug>
115,CWE-285,"int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = null ; size_t size = 0 ; int error ; switch ( type ) { case acl_type_access : name_index = ext2_xattr_index_posix_acl_access ; if ( acl ) { error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( error < 0 ) return error ; else { inode -> i_ctime = current_time_sec ; mark_inode_dirty ( inode ) ; if ( error == 0 ) acl = null ; } } break ; case acl_type_default : name_index = ext2_xattr_index_posix_acl_default ; if ( ! s_isdir ( inode -> i_mode ) ) return acl ? - eacces : 0 ; break ; default : return - einval ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( is_err ( value ) ) return ( int ) ptr_err ( value ) ; } error = ext2_xattr_set ( inode , name_index , """" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug>"
7231,CWE-19,"static int ext2_xattr_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = null ; struct ext2_xattr_entry * entry ; char * end ; size_t rest = buffer_size ; int error ; ea_idebug ( inode , ""buffer=%p,<s2sv_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; down_read ( & ext2_i ( inode ) -> xattr_sem ) ; error = 0 ; if ( ! ext2_i ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<s2sv_blank>block<s2sv_blank>%d"" , ext2_i ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , ext2_i ( inode ) -> i_file_acl ) ; error = - eio ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<s2sv_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( hdr ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( hdr ( bh ) -> h_magic != cpu_to_le32 ( ext2_xattr_magic ) || hdr ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_list"" , ""inode<s2sv_blank>%ld:<s2sv_blank>bad<s2sv_blank>block<s2sv_blank>%d"" , inode -> i_ino , ext2_i ( inode ) -> i_file_acl ) ; error = - eio ; goto cleanup ; } entry = first_entry ( bh ) ; while ( ! is_last_entry ( entry ) ) { struct ext2_xattr_entry * next = ext2_xattr_next ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; entry = next ; } if ( ext2_xattr_cache_insert ( bh ) ) ea_idebug ( inode , ""cache<s2sv_blank>insert<s2sv_blank>failed"" ) ; for ( entry = first_entry ( bh ) ; ! is_last_entry ( entry ) ; entry = ext2_xattr_next ( entry ) ) { const struct xattr_handler * handler = ext2_xattr_handler ( entry -> e_name_index ) ; if ( handler && ( ! handler -> list || handler -> list ( dentry ) ) ) { const char * prefix = handler -> prefix ? : handler -> name ; size_t prefix_len = strlen ( prefix ) ; size_t size = prefix_len + entry -> e_name_len + 1 ; if ( buffer ) { if ( size > rest ) { error = - erange ; goto cleanup ; } memcpy ( buffer , prefix , prefix_len ) ; buffer += prefix_len ; memcpy ( buffer , entry -> e_name , entry -> e_name_len ) ; buffer += entry -> e_name_len ; * buffer ++ = 0 ; } rest -= size ; } } error = buffer_size - rest ; cleanup : brelse ( bh ) ; up_read ( & ext2_i ( inode ) -> xattr_sem ) ; return error ; }","<S2SV_ModStart> ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug>
2472,CWE-754,"static int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & attr_replace ) && ( retval == - enoattr ) ) { return retval ; } else if ( retval == - eexist ) { if ( args -> flags & attr_create ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; assert ( retval == 0 ) ; } if ( args -> namelen >= xfs_attr_sf_entsize_max || args -> valuelen >= xfs_attr_sf_entsize_max ) return - enospc ; newsize = xfs_attr_sf_totsize ( args -> dp ) ; newsize += xfs_attr_sf_entsize_byname ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - enospc ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }","<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
",torvalds@linux/7b38460dc8e4eafba06c78f8e37099d3b34d473c,CVE-2018-18690,https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c,2018-10-26T18:29Z,<S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug>
8298,CWE-20,"static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; define_wait ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; msg -> msg_namelen = 0 ; lock_sock ( sk ) ; if ( sk -> sk_state != ss_connected ) { if ( sock_flag ( sk , sock_done ) ) err = 0 ; else err = - enotconn ; goto out ; } if ( flags & msg_oob ) { err = - eopnotsupp ; goto out ; } if ( sk -> sk_shutdown & rcv_shutdown ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & msg_waitall , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - enomem ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & msg_dontwait ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , task_interruptible ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - enomem ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - enomem ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & msg_peek ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & msg_peek ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & rcv_shutdown ) || ( vsk -> peer_shutdown & send_shutdown ) ) { break ; } if ( timeout == 0 ) { err = - eagain ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - eagain ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , task_interruptible ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & rcv_shutdown ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & msg_peek ) ) { if ( vsk -> peer_shutdown & send_shutdown ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = ss_unconnected ; sock_set_flag ( sk , sock_done ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
5680,CWE-119,"static int search_impl ( i_ctx_t * i_ctx_p , bool forward ) { os_ptr op = osp ; os_ptr op1 = op - 1 ; uint size = r_size ( op ) ; uint count ; byte * pat ; byte * ptr ; byte ch ; int incr = forward ? 1 : - 1 ; check_read_type ( * op1 , t_string ) ; check_read_type ( * op , t_string ) ; if ( size > r_size ( op1 ) ) { make_false ( op ) ; return 0 ; } count = r_size ( op1 ) - size ; ptr = op1 -> value . bytes ; if ( size == 0 ) goto found ; if ( ! forward ) ptr += count ; pat = op -> value . bytes ; ch = pat [ 0 ] ; do { if ( * ptr == ch && ( size == 1 || ! memcmp ( ptr , pat , size ) ) ) goto found ; ptr += incr ; } while ( count -- ) ; make_false ( op ) ; return 0 ; found : op -> tas . type_attrs = op1 -> tas . type_attrs ; op -> value . bytes = ptr ; r_set_size ( op , size ) ; push ( 2 ) ; op [ - 1 ] = * op1 ; r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; op1 -> value . bytes = ptr + size ; r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; make_true ( op ) ; return 0 ; }","<S2SV_ModStart> = ptr ; op -> tas . rsize = size <S2SV_ModEnd> ; push ( <S2SV_ModStart> * op1 ; op [ - 3 ] . <S2SV_ModEnd> value . bytes <S2SV_ModStart> + size ; if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> make_true ( op
",ArtifexSoftware@ghostpdl/5d499272b95a6b890a1397e11d20937de000d31b,CVE-2020-15900,https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b,2020-07-28T16:15Z,"<S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug>"
8081,CWE-400,"static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) { struct evtchn_fifo_control_block * control_block ; unsigned long ready ; unsigned q ; control_block = per_cpu ( cpu_control_block , cpu ) ; ready = xchg ( & control_block -> ready , 0 ) ; while ( ready ) { q = find_first_bit ( & ready , evtchn_fifo_max_queues ) ; consume_one_event ( cpu , control_block , q , & ready , drop ) ; ready |= xchg ( & control_block -> ready , 0 ) ; } }","<S2SV_ModStart> unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModEnd> ) { struct <S2SV_ModStart> ( cpu , ctrl , <S2SV_ModStart> , & ready <S2SV_ModEnd> ) ; ready
",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z,"<S2SV_StartBug> static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) <S2SV_EndBug> <S2SV_StartBug> consume_one_event ( cpu , control_block , q , & ready , drop ) ; <S2SV_EndBug>"
6816,CWE-772,"static image * readdcmimage ( const imageinfo * image_info , exceptioninfo * exception ) { # define throwdcmexception ( exception , message ) { if ( data != ( unsigned char * ) null ) data = ( unsigned char * ) relinquishmagickmemory ( data ) ; if ( stream_info != ( dcmstreaminfo * ) null ) stream_info = ( dcmstreaminfo * ) relinquishmagickmemory ( stream_info ) ; throwreaderexception ( ( exception ) , ( message ) ) ; } char explicit_vr [ magickpathextent ] , implicit_vr [ magickpathextent ] , magick [ magickpathextent ] , photometric [ magickpathextent ] ; dcminfo info ; dcmstreaminfo * stream_info ; image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; magickbooleantype explicit_file , explicit_retry , sequence , use_explicit ; magickoffsettype offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; if ( image_info -> debug != magickfalse ) ( void ) logmagickevent ( traceevent , getmagickmodule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } image -> depth = 8ul ; image -> endian = lsbendian ; data = ( unsigned char * ) null ; stream_info = ( dcmstreaminfo * ) acquiremagickmemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( dcmstreaminfo * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; ( void ) resetmagickmemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = readblob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; count = readblob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( localencompare ( magick , ""dicm"" , 4 ) != 0 ) ) { offset = seekblob ( image , 0l , seek_set ) ; if ( offset < 0 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; } ( void ) copymagickstring ( photometric , ""monochrome1<s2sv_blank>"" , magickpathextent ) ; info . polarity = magickfalse ; info . scale = ( quantum * ) null ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255ul ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0ul ) ; info . significant_bits = 0 ; info . rescale = magickfalse ; info . rescale_intercept = 0.0 ; info . rescale_slope = 1.0 ; info . window_center = 0.0 ; info . window_width = 0.0 ; data = ( unsigned char * ) null ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = magickfalse ; colors = 0 ; redmap = ( int * ) null ; greenmap = ( int * ) null ; bluemap = ( int * ) null ; graymap = ( int * ) null ; height = 0 ; number_scenes = 1 ; sequence = magickfalse ; use_explicit = magickfalse ; explicit_retry = magickfalse ; width = 0 ; for ( group = 0 ; ( group != 0x7fe0 ) || ( element != 0x0010 ) || ( sequence != magickfalse ) ; ) { image -> offset = ( ssize_t ) tellblob ( image ) ; group = readbloblsbshort ( image ) ; element = readbloblsbshort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == msbendian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xff ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xff ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) copymagickstring ( implicit_vr , dicom_info [ i ] . vr , magickpathextent ) ; count = readblob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; if ( ( explicit_file == magickfalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != magickfalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != magickfalse ) ? magicktrue : magickfalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == magickfalse ) ) || ( explicit_file != magickfalse ) ? magicktrue : magickfalse ; if ( ( use_explicit != magickfalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) copymagickstring ( implicit_vr , explicit_vr , magickpathextent ) ; if ( ( use_explicit == magickfalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = seekblob ( image , ( magickoffsettype ) - 2 , seek_cur ) ; if ( offset < 0 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""ob"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""un"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""ow"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""sq"" , 2 ) == 0 ) ) { ( void ) readbloblsbshort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = readbloblsbsignedlong ( image ) ; else datum = readblobsignedlong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = readbloblsbsignedshort ( image ) ; else datum = readblobsignedshort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""ss"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""us"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""ul"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""sl"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""fl"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""fd"" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != magickfalse ) { if ( use_explicit == magickfalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) null ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) formatlocalefile ( stdout , ""0x%04lx<s2sv_blank>%4ld<s2sv_blank>%s-%s<s2sv_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) null ) ( void ) formatlocalefile ( stdout , ""<s2sv_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) formatlocalefile ( stdout , "":<s2sv_blank>"" ) ; } if ( ( sequence == magickfalse ) && ( group == 0x7fe0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != magickfalse ) ( void ) formatlocalefile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) null ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = readblobbyte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = readbloblsbsignedshort ( image ) ; else datum = readblobsignedshort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = readbloblsbsignedlong ( image ) ; else datum = readblobsignedlong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > getblobsize ( image ) ) throwreaderexception ( corruptimageerror , ""insufficientimagedatainfile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) acquirequantummemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; count = readblob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != magickfalse ) ( void ) formatlocalefile ( stdout , ""count=%d<s2sv_blank>quantum=%d<s2sv_blank>"" ""length=%d<s2sv_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; throwdcmexception ( corruptimageerror , ""insufficientimagedatainfile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xffffffffu ) { sequence = magicktrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xfffee0dd ) { if ( data != ( unsigned char * ) null ) data = ( unsigned char * ) relinquishmagickmemory ( data ) ; sequence = magickfalse ; continue ; } if ( sequence != magickfalse ) { if ( data != ( unsigned char * ) null ) data = ( unsigned char * ) relinquishmagickmemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ magickpathextent ] ; if ( ( datum == 0 ) && ( explicit_retry == magickfalse ) ) { explicit_retry = magicktrue ; ( void ) seekblob ( image , ( magickoffsettype ) 0 , seek_set ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != magickfalse ) ( void ) formatlocalefile ( stdout , ""corrupted<s2sv_blank>image<s2sv_blank>-<s2sv_blank>trying<s2sv_blank>explicit<s2sv_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) null ) ( void ) copymagickstring ( transfer_syntax , ( char * ) data , magickpathextent ) ; if ( image_info -> verbose != magickfalse ) ( void ) formatlocalefile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; } switch ( type ) { case 1 : { image -> endian = lsbendian ; break ; } case 2 : { image -> endian = msbendian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = jpegcompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = jpeg2000compression ; else image -> compression = jpegcompression ; break ; } case 5 : { image -> compression = rlecompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) null ) break ; for ( i = 0 ; i < ( ssize_t ) magickmin ( length , magickpathextent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = localecompare ( photometric , ""monochrome1<s2sv_blank>"" ) == 0 ? magicktrue : magickfalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = planeinterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) null ) break ; number_scenes = stringtounsignedlong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( info . depth > 32 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; info . max_value = ( 1ul << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( info . depth > 32 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; info . max_value = ( 1ul << info . significant_bits ) - 1 ; info . mask = ( size_t ) getquantumrange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) null ) info . window_center = stringtodouble ( ( char * ) data , ( char * * ) null ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) null ) info . window_width = stringtodouble ( ( char * ) data , ( char * * ) null ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) null ) info . rescale_intercept = stringtodouble ( ( char * ) data , ( char * * ) null ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) null ) info . rescale_slope = stringtodouble ( ( char * ) data , ( char * * ) null ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) null ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) acquirequantummemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) null ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) acquirequantummemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == msbendian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) null ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) acquirequantummemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == msbendian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) null ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) acquirequantummemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == msbendian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) null ) && ( strncmp ( ( char * ) data , ""inverse"" , 7 ) == 0 ) ) info . polarity = magicktrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) null ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) null ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) null ) { attribute = acquirestring ( ""dcm:"" ) ; ( void ) concatenatestring ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) magickmax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == magickfalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) substitutestring ( & attribute , ""<s2sv_blank>"" , """" ) ; ( void ) setimageproperty ( image , attribute , ( char * ) data , exception ) ; } attribute = destroystring ( attribute ) ; } } if ( image_info -> verbose != magickfalse ) { if ( data == ( unsigned char * ) null ) ( void ) formatlocalefile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) magickmax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == magickfalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) formatlocalefile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != magickfalse ) ( void ) formatlocalefile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) formatlocalefile ( stdout , ""%c"" , '.' ) ; ( void ) formatlocalefile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) null ) data = ( unsigned char * ) relinquishmagickmemory ( data ) ; if ( eofblob ( image ) != magickfalse ) { throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == jpegcompression ) || ( image -> compression == jpeg2000compression ) ) { image * images ; imageinfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) readblobbyte ( image ) ; ( void ) ( ( readbloblsbshort ( image ) << 16 ) | readbloblsbshort ( image ) ) ; length = ( size_t ) readbloblsblong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) acquirequantummemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) readbloblsbsignedlong ( image ) ; offset = tellblob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = cloneimageinfo ( image_info ) ; setimageinfoblob ( read_info , ( void * ) null , 0 ) ; images = newimagelist ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ magickpathextent ] ; const char * property ; file * file ; image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( readbloblsbshort ( image ) << 16 ) | readbloblsbshort ( image ) ; length = ( size_t ) readbloblsblong ( image ) ; if ( tag == 0xfffee0dd ) break ; if ( tag != 0xfffee000 ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; file = ( file * ) null ; unique_file = acquireuniquefileresource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( file * ) null ) { ( void ) relinquishuniquefileresource ( filename ) ; throwfileexception ( exception , fileopenerror , ""unabletocreatetemporaryfile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = readblobbyte ( image ) ; if ( c == eof ) { throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) formatlocalestring ( read_info -> filename , magickpathextent , ""jpeg:%s"" , filename ) ; if ( image -> compression == jpeg2000compression ) ( void ) formatlocalestring ( read_info -> filename , magickpathextent , ""j2k:%s"" , filename ) ; jpeg_image = readimage ( read_info , exception ) ; if ( jpeg_image != ( image * ) null ) { resetimagepropertyiterator ( image ) ; property = getnextimageproperty ( image ) ; while ( property != ( const char * ) null ) { ( void ) setimageproperty ( jpeg_image , property , getimageproperty ( image , property , exception ) , exception ) ; property = getnextimageproperty ( image ) ; } appendimagetolist ( & images , jpeg_image ) ; } ( void ) relinquishuniquefileresource ( filename ) ; } read_info = destroyimageinfo ( read_info ) ; image = destroyimage ( image ) ; return ( getfirstimageinlist ( images ) ) ; } if ( info . depth != ( 1ul * magickcore_quantum_depth ) ) { quantumany range ; length = ( size_t ) ( getquantumrange ( info . depth ) + 1 ) ; info . scale = ( quantum * ) acquirequantummemory ( length , sizeof ( * info . scale ) ) ; if ( info . scale == ( quantum * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; range = getquantumrange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) getquantumrange ( info . depth ) ; i ++ ) info . scale [ i ] = scaleanytoquantum ( ( size_t ) i , range ) ; } if ( image -> compression == rlecompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) readblobbyte ( image ) ; tag = ( readbloblsbshort ( image ) << 16 ) | readbloblsbshort ( image ) ; ( void ) tag ; length = ( size_t ) readbloblsblong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) acquirequantummemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) null ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) readbloblsbsignedlong ( image ) ; offset = tellblob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != magickfalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) break ; image -> colorspace = rgbcolorspace ; if ( ( image -> colormap == ( pixelinfo * ) null ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( acquireimagecolormap ( image , colors , exception ) == magickfalse ) throwdcmexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; if ( redmap != ( int * ) null ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( quantum * ) null ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( magickrealtype ) index ; } if ( greenmap != ( int * ) null ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( quantum * ) null ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( magickrealtype ) index ; } if ( bluemap != ( int * ) null ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( quantum * ) null ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( magickrealtype ) index ; } if ( graymap != ( int * ) null ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( quantum * ) null ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( magickrealtype ) index ; image -> colormap [ i ] . green = ( magickrealtype ) index ; image -> colormap [ i ] . blue = ( magickrealtype ) index ; } } if ( image -> compression == rlecompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) readblobbyte ( image ) ; tag = ( readbloblsbshort ( image ) << 16 ) | readbloblsbshort ( image ) ; stream_info -> remaining = ( size_t ) readbloblsblong ( image ) ; if ( ( tag != 0xfffee000 ) || ( stream_info -> remaining <= 64 ) || ( eofblob ( image ) != magickfalse ) ) throwdcmexception ( corruptimageerror , ""improperimageheader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = readbloblsblong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) readbloblsbsignedlong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) seekblob ( image , ( magickoffsettype ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , seek_set ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == planeinterlace ) ) { register ssize_t x ; register quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = getauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { setpixelred ( image , scalechartoquantum ( ( unsigned char ) readdcmbyte ( stream_info , image ) ) , q ) ; break ; } case 1 : { setpixelgreen ( image , scalechartoquantum ( ( unsigned char ) readdcmbyte ( stream_info , image ) ) , q ) ; break ; } case 2 : { setpixelblue ( image , scalechartoquantum ( ( unsigned char ) readdcmbyte ( stream_info , image ) ) , q ) ; break ; } case 3 : { setpixelalpha ( image , scalechartoquantum ( ( unsigned char ) readdcmbyte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; if ( image -> previous == ( image * ) null ) { status = setimageprogress ( image , loadimagetag , ( magickoffsettype ) y , image -> rows ) ; if ( status == magickfalse ) break ; } } } } else { const char * option ; option = getimageoption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) null ) { if ( localecompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = getimageoption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) null ) { geometryinfo geometry_info ; magickstatustype flags ; flags = parsegeometry ( option , & geometry_info ) ; if ( flags & rhovalue ) info . window_center = geometry_info . rho ; if ( flags & sigmavalue ) info . window_width = geometry_info . sigma ; info . rescale = magicktrue ; } option = getimageoption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) null ) info . rescale = isstringtrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = readdcmpixels ( image , & info , stream_info , magicktrue , exception ) ; if ( ( status != magickfalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) seekblob ( image , ( magickoffsettype ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , seek_set ) ; ( void ) readdcmpixels ( image , & info , stream_info , magickfalse , exception ) ; } } if ( setimagegray ( image , exception ) != magickfalse ) ( void ) setimagecolorspace ( image , graycolorspace , exception ) ; if ( eofblob ( image ) != magickfalse ) { throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { acquirenextimage ( image_info , image , exception ) ; if ( getnextimageinlist ( image ) == ( image * ) null ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } image = syncnextimageinlist ( image ) ; status = setimageprogress ( image , loadimagestag , tellblob ( image ) , getblobsize ( image ) ) ; if ( status == magickfalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) null ) stream_info -> offsets = ( ssize_t * ) relinquishmagickmemory ( stream_info -> offsets ) ; stream_info = ( dcmstreaminfo * ) relinquishmagickmemory ( stream_info ) ; if ( info . scale != ( quantum * ) null ) info . scale = ( quantum * ) relinquishmagickmemory ( info . scale ) ; if ( graymap != ( int * ) null ) graymap = ( int * ) relinquishmagickmemory ( graymap ) ; if ( bluemap != ( int * ) null ) bluemap = ( int * ) relinquishmagickmemory ( bluemap ) ; if ( greenmap != ( int * ) null ) greenmap = ( int * ) relinquishmagickmemory ( greenmap ) ; if ( redmap != ( int * ) null ) redmap = ( int * ) relinquishmagickmemory ( redmap ) ; ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; }","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,
",ImageMagick@ImageMagick/a33f7498f9052b50e8fe8c8422a11ba84474cb42,CVE-2017-12644,https://github.com/ImageMagick/ImageMagick/commit/a33f7498f9052b50e8fe8c8422a11ba84474cb42,2017-08-07T15:29Z,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug>"
5398,CWE-787,"static pyobject * patch ( pyobject * self , pyobject * args ) { char * origdata , * newdata , * diffblock , * extrablock , * diffptr , * extraptr ; py_ssize_t origdatalength , newdatalength , diffblocklength , extrablocklength ; pyobject * controltuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numtuples ; if ( ! pyarg_parsetuple ( args , ""s#no!s#s#"" , & origdata , & origdatalength , & newdatalength , & pylist_type , & controltuples , & diffblock , & diffblocklength , & extrablock , & extrablocklength ) ) return null ; newdata = pymem_malloc ( newdatalength + 1 ) ; if ( ! newdata ) return pyerr_nomemory ( ) ; oldpos = 0 ; newpos = 0 ; diffptr = diffblock ; extraptr = extrablock ; numtuples = pylist_get_size ( controltuples ) ; for ( i = 0 ; i < numtuples ; i ++ ) { tuple = pylist_get_item ( controltuples , i ) ; if ( ! pytuple_check ( tuple ) ) { pymem_free ( newdata ) ; pyerr_setstring ( pyexc_typeerror , ""expecting<s2sv_blank>tuple"" ) ; return null ; } if ( pytuple_get_size ( tuple ) != 3 ) { pymem_free ( newdata ) ; pyerr_setstring ( pyexc_typeerror , ""expecting<s2sv_blank>tuple<s2sv_blank>of<s2sv_blank>size<s2sv_blank>3"" ) ; return null ; } x = pylong_aslong ( pytuple_get_item ( tuple , 0 ) ) ; y = pylong_aslong ( pytuple_get_item ( tuple , 1 ) ) ; z = pylong_aslong ( pytuple_get_item ( tuple , 2 ) ) ; if ( newpos + x > newdatalength || diffptr + x > diffblock + diffblocklength || extraptr + y > extrablock + extrablocklength ) { pymem_free ( newdata ) ; pyerr_setstring ( pyexc_valueerror , ""corrupt<s2sv_blank>patch<s2sv_blank>(overflow)"" ) ; return null ; } memcpy ( newdata + newpos , diffptr , x ) ; diffptr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origdatalength ) ) newdata [ newpos + j ] += origdata [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newdata + newpos , extraptr , y ) ; extraptr += y ; newpos += y ; oldpos += z ; } if ( newpos != newdatalength || diffptr != diffblock + diffblocklength || extraptr != extrablock + extrablocklength ) { pymem_free ( newdata ) ; pyerr_setstring ( pyexc_valueerror , ""corrupt<s2sv_blank>patch<s2sv_blank>(underflow)"" ) ; return null ; } results = pybytes_fromstringandsize ( newdata , newdatalength ) ; pymem_free ( newdata ) ; return results ; }","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z,"<S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug>"
7793,CWE-125,"static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? child ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = null ; int name_i = 1 ; int end_lineno , end_col_offset ; req ( n , funcdef ) ; name = new_identifier ( child ( n , name_i ) ) ; if ( ! name ) return null ; if ( forbidden_name ( c , name , child ( n , name_i ) , 0 ) ) return null ; args = ast_for_arguments ( c , child ( n , name_i + 1 ) ) ; if ( ! args ) return null ; if ( type ( child ( n , name_i + 2 ) ) == rarrow ) { returns = ast_for_expr ( c , child ( n , name_i + 3 ) ) ; if ( ! returns ) return null ; name_i += 2 ; } body = ast_for_suite ( c , child ( n , name_i + 3 ) ) ; if ( ! body ) return null ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; if ( is_async ) return asyncfunctiondef ( name , args , body , decorator_seq , returns , lineno ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else return functiondef ( name , args , body , decorator_seq , returns , lineno ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }","<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug>"
4772,CWE-119,"void l2tp_packet_print ( const struct l2tp_packet_t * pack , void ( * print ) ( const char * fmt , ... ) ) { const struct l2tp_attr_t * attr ; const struct l2tp_dict_value_t * val ; if ( pack -> hdr . ver == 2 ) { print ( ""[l2tp<s2sv_blank>tid=%u<s2sv_blank>sid=%u"" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ; log_ppp_debug ( ""<s2sv_blank>ns=%u<s2sv_blank>nr=%u"" , ntohs ( pack -> hdr . ns ) , ntohs ( pack -> hdr . nr ) ) ; } else { print ( ""[l2tp<s2sv_blank>cid=%u"" , pack -> hdr . cid ) ; log_ppp_debug ( ""<s2sv_blank>ns=%u<s2sv_blank>nr=%u"" , ntohs ( pack -> hdr . ns ) , ntohs ( pack -> hdr . nr ) ) ; } list_for_each_entry ( attr , & pack -> attrs , entry ) { print ( ""<s2sv_blank><%s"" , attr -> attr -> name ) ; val = l2tp_dict_find_value ( attr -> attr , attr -> val ) ; if ( val ) print ( ""<s2sv_blank>%s"" , val -> name ) ; else if ( attr -> h ) print ( ""<s2sv_blank>(hidden,<s2sv_blank>%hu<s2sv_blank>bytes)"" , attr -> length ) ; else { switch ( attr -> attr -> type ) { case attr_type_int16 : print ( ""<s2sv_blank>%i"" , attr -> val . int16 ) ; break ; case attr_type_int32 : print ( ""<s2sv_blank>%i"" , attr -> val . int32 ) ; break ; case attr_type_string : print ( ""<s2sv_blank>%s"" , attr -> val . string ) ; break ; } } print ( "">"" ) ; } print ( ""]\\n"" ) ; }","<S2SV_ModStart> * val ; switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <S2SV_ModEnd> print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" <S2SV_ModStart> ) ) ; break ; case 3 : <S2SV_ModEnd> print ( ""[L2TP<S2SV_blank>cid=%u"" <S2SV_ModStart> Nr ) ) ; break ; default : print ( ""[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\n"" ) ; return
",accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,CVE-2020-15173,https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,2020-09-09T23:15Z,"<S2SV_StartBug> if ( pack -> hdr . ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <S2SV_EndBug>"
2167,CWE-119,"static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = gfs2_i ( inode ) ; struct buffer_head * dibh ; int error ; u64 start = offset >> page_cache_shift ; unsigned int start_offset = offset & ~ page_cache_mask ; u64 end = ( offset + len - 1 ) >> page_cache_shift ; pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ page_cache_mask ; unsigned int from , to ; if ( ! end_offset ) end_offset = page_cache_size ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , null ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << page_cache_shift ; from = start_offset ; to = page_cache_size ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , aop_flag_nofs ) ; if ( unlikely ( ! page ) ) { error = - enomem ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size && ! ( mode & falloc_fl_keep_size ) ) { i_size_write ( inode , offset + to ) ; } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += page_cache_size ; from = 0 ; } mark_inode_dirty ( inode ) ; brelse ( dibh ) ; out : return error ; }","<S2SV_ModStart> int error ; unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> = offset >> <S2SV_ModStart> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> ( offset + <S2SV_ModStart> offset + len <S2SV_ModEnd> > inode -> <S2SV_ModStart> FALLOC_FL_KEEP_SIZE ) ) <S2SV_ModEnd> i_size_write ( inode <S2SV_ModStart> , offset + len ) ; <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> mark_inode_dirty ( inode <S2SV_ModEnd> ) ; out <S2SV_ModStart> ; out : brelse ( dibh ) ;
",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z,"<S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> return error ; <S2SV_EndBug>"
3608,CWE-264,"static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - einval ; if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , cap_sys_admin ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( cap_setuid ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( cap_setgid ) ) ) { return 0 ; } return - eperm ; }","<S2SV_ModStart> || ns_capable ( task_active_pid_ns ( current ) <S2SV_ModEnd> -> user_ns ,
",torvalds@linux/d661684cf6820331feae71146c35da83d794467e,CVE-2013-4300,https://github.com/torvalds/linux/commit/d661684cf6820331feae71146c35da83d794467e,2013-09-25T10:31Z,"<S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug>"
2877,CWE-310,"static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ) ; memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , crypto_max_alg_name ) ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , cryptocfga_priority_val , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & crypto_alg_larval ) { struct crypto_report_larval rl ; snprintf ( rl . type , crypto_max_alg_name , ""%s"" , ""larval"" ) ; if ( nla_put ( skb , cryptocfga_report_larval , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( crypto_alg_type_mask | crypto_alg_larval ) ) { case crypto_alg_type_cipher : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case crypto_alg_type_compress : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - emsgsize ; }","<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if
",torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,CVE-2013-2548,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,2013-03-15T20:55Z,"<S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug>"
2210,CWE-200,"static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & msg_dontwait ; if ( flags & msg_oob || flags & msg_errqueue ) return - eopnotsupp ; err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - eagain ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - einval ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= msg_trunc ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; msg -> msg_namelen = 0 ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }","<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( msg
",torvalds@linux/680d04e0ba7e926233e3b9cee59125ce181f66ba,CVE-2013-3236,https://github.com/torvalds/linux/commit/680d04e0ba7e926233e3b9cee59125ce181f66ba,2013-04-22T11:41Z,<S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
3946,CWE-476,"static int tls_construct_cke_ecdhe ( ssl * s , unsigned char * * p , int * len , int * al ) { # ifndef openssl_no_ec unsigned char * encodedpoint = null ; int encoded_pt_len = 0 ; evp_pkey * ckey = null , * skey = null ; skey = s -> s3 -> peer_tmp ; if ( skey == null ) { sslerr ( ssl_f_tls_construct_cke_ecdhe , err_r_internal_error ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; if ( ssl_derive ( s , ckey , skey ) == 0 ) { sslerr ( ssl_f_tls_construct_cke_ecdhe , err_r_evp_lib ) ; goto err ; } encoded_pt_len = evp_pkey_get1_tls_encodedpoint ( ckey , & encodedpoint ) ; if ( encoded_pt_len == 0 ) { sslerr ( ssl_f_tls_construct_cke_ecdhe , err_r_ec_lib ) ; goto err ; } evp_pkey_free ( ckey ) ; ckey = null ; * len = encoded_pt_len ; * * p = * len ; * p += 1 ; memcpy ( * p , encodedpoint , * len ) ; * len += 1 ; openssl_free ( encodedpoint ) ; return 1 ; err : evp_pkey_free ( ckey ) ; return 0 ; # else sslerr ( ssl_f_tls_construct_cke_ecdhe , err_r_internal_error ) ; * al = ssl_ad_internal_error ; return 0 ; # endif }","<S2SV_ModStart> ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if (
",openssl@openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa,CVE-2017-3730,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,2017-05-04T19:29Z,"<S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug>"
6577,CWE-20,"void cleanupoutput ( char * str ) { char * s , * t ; int period = 0 ; s = t = str ; while ( * s && * s != '}' ) { if ( * s == '\\n' ) * s = '<s2sv_blank>' ; if ( ( * s == '<s2sv_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<s2sv_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; else * t ++ = * s ++ ; } while ( * s ) * t ++ = * s ++ ; * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<s2sv_blank>' ) { s ++ ; } else if ( * s <= '9' && * s >= '0' ) { * t ++ = * s ++ ; } else if ( * s == '\\n' && ( t > str && t [ - 1 ] == '\\n' ) ) { s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) t -- ; if ( t > str && t [ - 1 ] == '.' ) t -- ; while ( * s == '<s2sv_blank>' && s [ 1 ] == '<s2sv_blank>' ) s ++ ; period = 0 ; * t ++ = * s ++ ; } else if ( * s == '<s2sv_blank>' && s [ 1 ] == '<s2sv_blank>' ) s ++ ; else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<s2sv_blank>' ) { s ++ ; } else * t ++ = * s ++ ; } * t = 0 ; }","<S2SV_ModStart> ( * s <S2SV_ModEnd> ) { if <S2SV_ModStart> == '\\n' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] <S2SV_ModEnd> == '<S2SV_blank>' || <S2SV_ModStart> == '<S2SV_blank>' || s [ 1 ] == '\\n' || s [ 1 ] == 0 ) ) { s ++ ; } else { * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( isdigit ( * s ) ) { * t ++ = * s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) { t -- ; } if ( t > str && t [ - 1 ] == '.' ) { t -- ; if ( t > str && ! isdigit ( t [ - 1 ] ) ) { * t ++ = '0' ; } } period = 0 ; * t ++ = * s ++ ; } else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 <S2SV_ModEnd> ] == '<S2SV_blank>' <S2SV_ModStart> ] == '<S2SV_blank>' <S2SV_ModEnd> ) { s
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,<S2SV_StartBug> while ( * s && * s != '}' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == '\\n' ) * s = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> if ( ( * s == '<S2SV_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; <S2SV_EndBug>
3397,CWE-404,"int nfs3svc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ~ 0 ; args -> count = ntohl ( * p ++ ) ; args -> count = min_t ( u32 , args -> count , page_size ) ; args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; return xdr_argsize_check ( rqstp , p ) ; }","<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,"<S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug>"
7474,CWE-476,"internal void vterm_allocator_free ( vterm * vt , void * ptr ) { ( * vt -> allocator -> free ) ( ptr , vt -> allocdata ) ; }","<S2SV_ModStart> ptr ) { if ( ptr )
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,<S2SV_StartBug> { <S2SV_EndBug>
2893,CWE-119,"static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case mic_virtio_add_device : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - efault ; if ( mic_aligned_desc_size ( & dd ) > mic_max_desc_blk_size || dd . num_vq > mic_max_vrings ) return - einval ; dd_config = kzalloc ( mic_desc_size ( & dd ) , gfp_kernel ) ; if ( ! dd_config ) return - enomem ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - efault ; goto free_ret ; } mutex_lock ( & vdev -> vdev_mutex ) ; mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case mic_virtio_copy_desc : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - efault ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - efault ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case mic_virtio_config_change : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , gfp_kernel ) ; if ( ! buf ) { ret = - enomem ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - efault ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - enoioctlcmd ; } ; return 0 ; }","<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }
",torvalds@linux/9bf292bfca94694a721449e3fd752493856710f6,CVE-2016-5728,https://github.com/torvalds/linux/commit/9bf292bfca94694a721449e3fd752493856710f6,2016-06-27T10:59Z,<S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug>
1323,CWE-119,"static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; unsigned long tpgt ; int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return err_ptr ( - einval ) ; if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > uint_max ) return err_ptr ( - einval ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , gfp_kernel ) ; if ( ! tpg ) { pr_err ( ""unable<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>struct<s2sv_blank>vhost_scsi_tpg"" ) ; return err_ptr ( - enomem ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; init_list_head ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , transport_tpg_type_normal ) ; if ( ret < 0 ) { kfree ( tpg ) ; return null ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }","<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
",torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c,CVE-2015-4036,https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c,2015-08-31T20:59Z,"<S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug>"
8107,CWE-416,"void luat_getvarargs ( lua_state * l , callinfo * ci , stkid where , int wanted ) { int i ; int nextra = ci -> u . l . nextraargs ; if ( wanted < 0 ) { wanted = nextra ; checkstackp ( l , nextra , where ) ; l -> top = where + nextra ; } for ( i = 0 ; i < wanted && i < nextra ; i ++ ) setobjs2s ( l , where + i , ci -> func - nextra + i ) ; for ( ; i < wanted ; i ++ ) setnilvalue ( s2v ( where + i ) ) ; }","<S2SV_ModStart> = nextra ; checkstackGCp <S2SV_ModEnd> ( L ,
",lua@lua/eb41999461b6f428186c55abd95f4ce1a76217d5,CVE-2020-15888,https://github.com/lua/lua/commit/eb41999461b6f428186c55abd95f4ce1a76217d5,2020-07-21T22:15Z,"<S2SV_StartBug> checkstackp ( L , nextra , where ) ; <S2SV_EndBug>"
885,CWE-200,"static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; bt_dbg ( ""sock<s2sv_blank>%p<s2sv_blank>sk<s2sv_blank>%p"" , sock , sk ) ; if ( ! hdev ) return - ebadfd ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = af_bluetooth ; haddr -> hci_dev = hdev -> id ; release_sock ( sk ) ; return 0 ; }","<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
",torvalds@linux/3f68ba07b1da811bf383b4b701b129bfcb2e4988,CVE-2012-6544,https://github.com/torvalds/linux/commit/3f68ba07b1da811bf383b4b701b129bfcb2e4988,2013-03-15T20:55Z,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug>
6873,CWE-763,"static void atomic2gen ( lua_state * l , global_state * g ) { sweep2old ( l , & g -> allgc ) ; g -> reallyold = g -> old = g -> survival = g -> allgc ; sweep2old ( l , & g -> finobj ) ; g -> finobjrold = g -> finobjold = g -> finobjsur = g -> finobj ; sweep2old ( l , & g -> tobefnz ) ; g -> gckind = kgc_gen ; g -> lastatomic = 0 ; g -> gcestimate = gettotalbytes ( g ) ; finishgencycle ( l , g ) ; }","<S2SV_ModStart> g ) { g -> gcstate = GCSswpallgc ;
",lua@lua/a6da1472c0c5e05ff249325f979531ad51533110,CVE-2020-24371,https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110,2020-08-17T17:15Z,"<S2SV_StartBug> static void atomic2gen ( lua_State * L , global_State * g ) { <S2SV_EndBug>"
5763,CWE-295,"static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ sha256len ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ sha256strlen ] , * subject , * issuer ; char * line ; int i ; x509_name * subj ; ssl_set_verify ( tunnel -> ssl_handle , ssl_verify_peer , null ) ; x509 * cert = ssl_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == null ) { log_error ( ""unable<s2sv_blank>to<s2sv_blank>get<s2sv_blank>gateway<s2sv_blank>certificate.\\n"" ) ; return 1 ; } subj = x509_get_subject_name ( cert ) ; # ifdef have_x509_check_host if ( x509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , null ) == 1 ) cert_valid = 1 ; # else char common_name [ field_size + 1 ] ; if ( subj && x509_name_get_text_by_nid ( subj , nid_commonname , common_name , field_size ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , field_size ) == 0 ) cert_valid = 1 ; # endif if ( cert_valid && ssl_get_verify_result ( tunnel -> ssl_handle ) == x509_v_ok ) { log_debug ( ""gateway<s2sv_blank>certificate<s2sv_blank>validation<s2sv_blank>succeeded.\\n"" ) ; ret = 0 ; goto free_cert ; } log_debug ( ""gateway<s2sv_blank>certificate<s2sv_blank>validation<s2sv_blank>failed.\\n"" ) ; if ( x509_digest ( cert , evp_sha256 ( ) , digest , & len ) <= 0 || len != sha256len ) { log_error ( ""could<s2sv_blank>not<s2sv_blank>compute<s2sv_blank>certificate<s2sv_blank>sha256<s2sv_blank>digest.\\n"" ) ; goto free_cert ; } for ( i = 0 ; i < sha256len ; i ++ ) sprintf ( & digest_str [ 2 * i ] , ""%02x"" , digest [ i ] ) ; digest_str [ sha256strlen - 1 ] = '\\0' ; for ( elem = tunnel -> config -> cert_whitelist ; elem != null ; elem = elem -> next ) if ( memcmp ( digest_str , elem -> data , sha256strlen - 1 ) == 0 ) break ; if ( elem != null ) { log_debug ( ""gateway<s2sv_blank>certificate<s2sv_blank>digest<s2sv_blank>found<s2sv_blank>in<s2sv_blank>white<s2sv_blank>list.\\n"" ) ; ret = 0 ; goto free_cert ; } subject = x509_name_oneline ( subj , null , 0 ) ; issuer = x509_name_oneline ( x509_get_issuer_name ( cert ) , null , 0 ) ; log_error ( ""gateway<s2sv_blank>certificate<s2sv_blank>validation<s2sv_blank>failed,<s2sv_blank>and<s2sv_blank>the<s2sv_blank>certificate<s2sv_blank>digest<s2sv_blank>in<s2sv_blank>not<s2sv_blank>in<s2sv_blank>the<s2sv_blank>local<s2sv_blank>whitelist.<s2sv_blank>if<s2sv_blank>you<s2sv_blank>trust<s2sv_blank>it,<s2sv_blank>rerun<s2sv_blank>with:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>--trusted-cert<s2sv_blank>%s\\n"" , digest_str ) ; log_error ( ""or<s2sv_blank>add<s2sv_blank>this<s2sv_blank>line<s2sv_blank>to<s2sv_blank>your<s2sv_blank>config<s2sv_blank>file:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>trusted-cert<s2sv_blank>=<s2sv_blank>%s\\n"" , digest_str ) ; log_error ( ""gateway<s2sv_blank>certificate:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>subject:\\n"" ) ; for ( line = strtok ( subject , ""/"" ) ; line != null ; line = strtok ( null , ""/"" ) ) log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" , line ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>issuer:\\n"" ) ; for ( line = strtok ( issuer , ""/"" ) ; line != null ; line = strtok ( null , ""/"" ) ) log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" , line ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>sha256<s2sv_blank>digest:\\n"" ) ; log_error ( ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" , digest_str ) ; free_cert : x509_free ( cert ) ; return ret ; }","<S2SV_ModStart> ; # else if ( validate_hostname ( <S2SV_ModEnd> tunnel -> config <S2SV_ModStart> -> gateway_host , cert ) == MatchFound <S2SV_ModEnd> ) cert_valid =
",adrienverge@openfortivpn/6328a070ddaab16faaf008cb9a8a62439c30f2a8,CVE-2020-7043,https://github.com/adrienverge/openfortivpn/commit/6328a070ddaab16faaf008cb9a8a62439c30f2a8,2020-02-27T18:15Z,<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> FIELD_SIZE ) == 0 ) <S2SV_EndBug>
2794,CWE-476,static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) { struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; },"<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;
",torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,CVE-2017-15116,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,2017-11-30T18:29Z,<S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug>
889,CWE-416,"int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - enodev ; io -> io_cleanup = mem_cleanup ; switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""invalid<s2sv_blank>register<s2sv_blank>size:<s2sv_blank>%d\\n"" , io -> regsize ) ; return - einval ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , device_name ) == null ) { mem_region_cleanup ( io , idx ) ; return - eio ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == null ) { mem_region_cleanup ( io , io -> io_size ) ; return - eio ; } return 0 ; }","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
",torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z,<S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
5761,CWE-369,"void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , ""additional<s2sv_blank>pixmap<s2sv_blank>header<s2sv_blank>fields,<s2sv_blank>at<s2sv_blank>%d"" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , ""pixmap<s2sv_blank>version:<s2sv_blank>%d"" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , ""packing<s2sv_blank>type:<s2sv_blank>%d"" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , ""pixel<s2sv_blank>data<s2sv_blank>length:<s2sv_blank>%d"" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , ""dpi:<s2sv_blank>%.2f"" de_char_times ""%.2f"" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , ""pixel<s2sv_blank>type=%d,<s2sv_blank>bits/pixel=%d,<s2sv_blank>components/pixel=%d,<s2sv_blank>bits/comp=%d"" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; if ( bi -> pdwidth < bi -> npwidth ) { bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , ""plane<s2sv_blank>bytes:<s2sv_blank>%d"" , ( int ) plane_bytes ) ; bi -> pmtable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , ""pmtable:<s2sv_blank>0x%08x"" , ( unsigned int ) bi -> pmtable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , ""pmreserved:<s2sv_blank>0x%08x"" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }","<S2SV_ModStart> cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }
",jsummers@deark/62acb7753b0e3c0d3ab3c15057b0a65222313334,CVE-2021-28856,https://github.com/jsummers/deark/commit/62acb7753b0e3c0d3ab3c15057b0a65222313334,2021-04-14T17:15Z,<S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug>
1245,CWE-119,"static bool check_underflow ( const struct arpt_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; if ( ! unconditional ( & e -> arp ) ) return false ; t = arpt_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , xt_standard_target ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == nf_drop || verdict == nf_accept ; }","<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,<S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug>
7794,CWE-125,"static stmt_ty ast_for_import_stmt ( struct compiling * c , const node * n ) { int lineno ; int col_offset ; int i ; asdl_seq * aliases ; req ( n , import_stmt ) ; lineno = lineno ( n ) ; col_offset = n -> n_col_offset ; n = child ( n , 0 ) ; if ( type ( n ) == import_name ) { n = child ( n , 1 ) ; req ( n , dotted_as_names ) ; aliases = _py_asdl_seq_new ( ( nch ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return null ; for ( i = 0 ; i < nch ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , child ( n , i ) , 1 ) ; if ( ! import_alias ) return null ; asdl_seq_set ( aliases , i / 2 , import_alias ) ; } return import ( aliases , lineno , col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( type ( n ) == import_from ) { int n_children ; int idx , ndots = 0 ; const node * n_copy = n ; alias_ty mod = null ; identifier modname = null ; for ( idx = 1 ; idx < nch ( n ) ; idx ++ ) { if ( type ( child ( n , idx ) ) == dotted_name ) { mod = alias_for_import_name ( c , child ( n , idx ) , 0 ) ; if ( ! mod ) return null ; idx ++ ; break ; } else if ( type ( child ( n , idx ) ) == ellipsis ) { ndots += 3 ; continue ; } else if ( type ( child ( n , idx ) ) != dot ) { break ; } ndots ++ ; } idx ++ ; switch ( type ( child ( n , idx ) ) ) { case star : n = child ( n , idx ) ; n_children = 1 ; break ; case lpar : n = child ( n , idx + 1 ) ; n_children = nch ( n ) ; break ; case import_as_names : n = child ( n , idx ) ; n_children = nch ( n ) ; if ( n_children % 2 == 0 ) { ast_error ( c , n , ""trailing<s2sv_blank>comma<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>without"" ""<s2sv_blank>surrounding<s2sv_blank>parentheses"" ) ; return null ; } break ; default : ast_error ( c , n , ""unexpected<s2sv_blank>node-type<s2sv_blank>in<s2sv_blank>from-import"" ) ; return null ; } aliases = _py_asdl_seq_new ( ( n_children + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return null ; if ( type ( n ) == star ) { alias_ty import_alias = alias_for_import_name ( c , n , 1 ) ; if ( ! import_alias ) return null ; asdl_seq_set ( aliases , 0 , import_alias ) ; } else { for ( i = 0 ; i < nch ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , child ( n , i ) , 1 ) ; if ( ! import_alias ) return null ; asdl_seq_set ( aliases , i / 2 , import_alias ) ; } } if ( mod != null ) modname = mod -> name ; return importfrom ( modname , aliases , ndots , lineno , col_offset , n_copy -> n_end_lineno , n_copy -> n_end_col_offset , c -> c_arena ) ; } pyerr_format ( pyexc_systemerror , ""unknown<s2sv_blank>import<s2sv_blank>statement:<s2sv_blank>starts<s2sv_blank>with<s2sv_blank>command<s2sv_blank>\'%s\'"" , str ( child ( n , 0 ) ) ) ; return null ; }","
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,
634,CWE-362,"static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; struct sctp_bind_hashbucket * head ; struct list_head tmplist ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; if ( oldsp -> do_auto_asconf ) { memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; inet_sk_copy_descendant ( newsk , oldsk ) ; memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; } else inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = null ; head = & sctp_port_hashtable [ sctp_phashfn ( sock_net ( oldsk ) , inet_sk ( oldsk ) -> inet_num ) ] ; local_bh_disable ( ) ; spin_lock ( & head -> lock ) ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> inet_num = inet_sk ( oldsk ) -> inet_num ; spin_unlock ( & head -> lock ) ; local_bh_enable ( ) ; sctp_bind_addr_dup ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , gfp_kernel ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } skb_queue_head_init ( & newsp -> pd_lobby ) ; atomic_set ( & sctp_sk ( newsk ) -> pd_mode , assoc -> ulpq . pd_mode ) ; if ( atomic_read ( & sctp_sk ( oldsk ) -> pd_mode ) ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk , null ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; newsp -> type = type ; lock_sock_nested ( newsk , single_depth_nesting ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , closed ) && sctp_style ( newsk , tcp ) ) newsk -> sk_shutdown |= rcv_shutdown ; newsk -> sk_state = sctp_ss_established ; release_sock ( newsk ) ; }","<S2SV_ModStart> * head ; <S2SV_ModEnd> newsk -> sk_sndbuf <S2SV_ModStart> -> sk_rcvbuf ; sctp_copy_descendant <S2SV_ModEnd> ( newsk ,
",torvalds@linux/2d45a02d0166caf2627fe91897c6ffc3b19514c4,CVE-2015-3212,https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4,2015-08-31T10:59Z,<S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug>
5742,CWE-269,"static_ovl void escapes ( cp , tp ) const char * cp ; char * tp ; { while ( * cp ) { int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mm"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xxoo"" , cp [ 1 ] ) && cp [ 2 ] ) { neardata const char hex [ ] = ""00112233445566778899aabbccddeeff"" ; const char * dp ; int dcount = 0 ; cp ++ ; if ( * cp == 'x' || * cp == 'x' ) for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ; else if ( * cp == 'o' || * cp == 'o' ) for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; else for ( ; * cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 10 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; } cp ++ ; } else if ( * cp == '^' && cp [ 1 ] ) { cval = ( * ++ cp & 0x1f ) ; cp ++ ; } else cval = * cp ++ ; if ( meta ) cval |= 0x80 ; * tp ++ = cval ; } * tp = '\\0' ; }","<S2SV_ModStart> tp ; { static <S2SV_ModEnd> NEARDATA const char <S2SV_ModStart> NEARDATA const char oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , <S2SV_ModStart> dp ; int cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> == 'x' || <S2SV_ModStart> == 'x' || cp [ 1 ] <S2SV_ModEnd> == 'X' ) <S2SV_ModStart> == 'X' ) && cp [ 2 ] <S2SV_ModEnd> && ( dp <S2SV_ModStart> ( hex , cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> cval = ( <S2SV_ModStart> 2 ) ; } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> { switch ( <S2SV_ModStart> cp ; } ++ cp ; } <S2SV_ModEnd> if ( meta <S2SV_ModStart> tp ++ = ( char )
",NetHack@NetHack/612755bfb5c412079795c68ba392df5d93874ed8,CVE-2020-5253,https://github.com/NetHack/NetHack/commit/612755bfb5c412079795c68ba392df5d93874ed8,2020-03-10T17:15Z,"<S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug>"
140,CWE-362,"static int snd_ctl_elem_user_put ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int change ; struct user_element * ue = kcontrol -> private_data ; change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ; if ( change ) memcpy ( ue -> elem_data , & ucontrol -> value , ue -> elem_data_size ) ; return change ; }","<S2SV_ModStart> kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
",torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,CVE-2014-4652,https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,2014-07-03T04:22Z,<S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> <S2SV_StartBug> return change ; <S2SV_EndBug>
4131,CWE-000,"static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , pf_inet6 , gfp_kernel , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( null , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , sock_zapped ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; rcu_init_pointer ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = null ; } out : return newsk ; }","<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
",torvalds@linux/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8,CVE-2017-9075,https://github.com/torvalds/linux/commit/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8,2017-05-19T07:29Z,"<S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug>"
1274,CWE-119,"static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) { int ret ; ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , pegasus_req_set_reg , pegasus_reqt_write , data , indx , & data , 1 , 1000 ) ; if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<s2sv_blank>returned<s2sv_blank>%d\\n"" , __func__ , ret ) ; return ret ; }","<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , 1 , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
6540,CWE-119,"static cjson * cjson_new_item ( void ) { cjson * node = ( cjson * ) cjson_malloc ( sizeof ( cjson ) ) ; if ( node ) memset ( node , 0 , sizeof ( cjson ) ) ; return node ; }","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
3195,CWE-189,"static u32 apic_get_tmcct ( struct kvm_lapic * apic ) { ktime_t remaining ; s64 ns ; u32 tmcct ; assert ( apic != null ) ; if ( kvm_apic_get_reg ( apic , apic_tmict ) == 0 ) return 0 ; remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ; if ( ktime_to_ns ( remaining ) < 0 ) remaining = ktime_set ( 0 , 0 ) ; ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ) ; tmcct = div64_u64 ( ns , ( apic_bus_cycle_ns * apic -> divide_count ) ) ; return tmcct ; }","<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period
",torvalds@linux/b963a22e6d1a266a67e9eecc88134713fd54775c,CVE-2013-6367,https://github.com/torvalds/linux/commit/b963a22e6d1a266a67e9eecc88134713fd54775c,2013-12-14T18:08Z,"<S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug>"
5056,CWE-189,"datum varbit_in ( pg_function_args ) { char * input_string = pg_getarg_cstring ( 0 ) ; # ifdef not_used oid typelem = pg_getarg_oid ( 1 ) ; # endif int32 atttypmod = pg_getarg_int32 ( 2 ) ; varbit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'b' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'x' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else bitlen = slen * 4 ; if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen > atttypmod ) ereport ( error , ( errcode ( errcode_string_data_right_truncation ) , errmsg ( ""bit<s2sv_blank>string<s2sv_blank>too<s2sv_blank>long<s2sv_blank>for<s2sv_blank>type<s2sv_blank>bit<s2sv_blank>varying(%d)"" , atttypmod ) ) ) ; len = varbittotallen ( bitlen ) ; result = ( varbit * ) palloc0 ( len ) ; set_varsize ( result , len ) ; varbitlen ( result ) = min ( bitlen , atttypmod ) ; r = varbits ( result ) ; if ( bit_not_hex ) { x = highbit ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( error , ( errcode ( errcode_invalid_text_representation ) , errmsg ( ""\\""%c\\""<s2sv_blank>is<s2sv_blank>not<s2sv_blank>a<s2sv_blank>valid<s2sv_blank>binary<s2sv_blank>digit"" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = highbit ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( error , ( errcode ( errcode_invalid_text_representation ) , errmsg ( ""\\""%c\\""<s2sv_blank>is<s2sv_blank>not<s2sv_blank>a<s2sv_blank>valid<s2sv_blank>hexadecimal<s2sv_blank>digit"" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x << 4 ; bc = 1 ; } } } pg_return_varbit_p ( result ) ; }","<S2SV_ModStart> slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug>
3141,CWE-20,"static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= sndrv_timer_iflg_running ; if ( timeri -> master ) list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ; spin_unlock_irqrestore ( & slave_active_lock , flags ) ; return 1 ; }","<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,"<S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug>"
2155,CWE-362,"void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; struct net * net = sock_net ( asoc -> base . sk ) ; bh_lock_sock ( asoc -> base . sk ) ; if ( sock_owned_by_user ( asoc -> base . sk ) ) { pr_debug ( ""%s:<s2sv_blank>sock<s2sv_blank>is<s2sv_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( hz / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , sctp_event_t_timeout , sctp_st_timeout ( sctp_event_timeout_heartbeat ) , asoc -> state , asoc -> ep , asoc , transport , gfp_atomic ) ; if ( error ) asoc -> base . sk -> sk_err = - error ; out_unlock : bh_unlock_sock ( asoc -> base . sk ) ; sctp_transport_put ( transport ) ; }","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug>
4921,CWE-617,"void deinit_pci ( struct vmctx * ctx ) { struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; int bus , slot , func ; size_t lowmem ; struct mem_range mr ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""pci<s2sv_blank>ecfg"" ; mr . base = pci_emul_ecfg_base ; mr . size = pci_emul_ecfg_size ; unregister_mem ( & mr ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""pci<s2sv_blank>hole<s2sv_blank>(32-bit)"" ; mr . base = lowmem ; mr . size = ( 4ull * 1024 * 1024 * 1024 ) - lowmem ; unregister_mem_fallback ( & mr ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = ""pci<s2sv_blank>hole<s2sv_blank>(64-bit)"" ; mr . base = pci_emul_membase64 ; mr . size = pci_emul_memlimit64 - pci_emul_membase64 ; unregister_mem_fallback ( & mr ) ; for ( bus = 0 ; bus < maxbuses ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == null ) continue ; for ( slot = 0 ; slot < maxslots ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < maxfuncs ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == null ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ; assert ( ops != null ) ; pr_notice ( ""pci<s2sv_blank>deinit<s2sv_blank>%s\\n"" , fi -> fi_name ) ; pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ; } } } }","<S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\n""
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug>
6149,CWE-125,"int dbd_st_prepare ( sv * sth , imp_sth_t * imp_sth , char * statement , sv * attribs ) { int i ; sv * * svp ; dthx ; # if mysql_version_id >= server_prepare_version # if mysql_version_id < call_placeholder_version char * str_ptr , * str_last_ptr ; # if mysql_version_id < limit_placeholder_version int limit_flag = 0 ; # endif # endif int col_type , prepare_retval ; mysql_bind * bind , * bind_end ; imp_sth_phb_t * fbind ; # endif d_imp_xxh ( sth ) ; d_imp_dbh_from_sth ; if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t-><s2sv_blank>dbd_st_prepare<s2sv_blank>mysql_version_id<s2sv_blank>%d,<s2sv_blank>sql<s2sv_blank>statement:<s2sv_blank>%s\\n"" , mysql_version_id , statement ) ; # if mysql_version_id >= server_prepare_version imp_sth -> use_server_side_prepare = imp_dbh -> use_server_side_prepare ; if ( attribs ) { svp = dbd_attrib_get_svp ( attribs , ""mysql_server_prepare"" , 20 ) ; imp_sth -> use_server_side_prepare = ( svp ) ? svtrue ( * svp ) : imp_dbh -> use_server_side_prepare ; svp = dbd_attrib_get_svp ( attribs , ""async"" , 5 ) ; if ( svp && svtrue ( * svp ) ) { # if mysql_async imp_sth -> is_async = true ; imp_sth -> use_server_side_prepare = false ; # else do_error ( sth , 2000 , ""async<s2sv_blank>support<s2sv_blank>was<s2sv_blank>not<s2sv_blank>built<s2sv_blank>into<s2sv_blank>this<s2sv_blank>version<s2sv_blank>of<s2sv_blank>dbd::mysql"" , ""hy000"" ) ; return 0 ; # endif } } imp_sth -> fetch_done = 0 ; # endif imp_sth -> done_desc = 0 ; imp_sth -> result = null ; imp_sth -> currow = 0 ; svp = dbd_attrib_get_svp ( attribs , ""mysql_use_result"" , 16 ) ; imp_sth -> use_mysql_use_result = svp ? svtrue ( * svp ) : imp_dbh -> use_mysql_use_result ; for ( i = 0 ; i < av_attrib_last ; i ++ ) imp_sth -> av_attr [ i ] = nullav ; mysql_st_free_result_sets ( sth , imp_sth ) ; # if mysql_version_id >= server_prepare_version && mysql_version_id < call_placeholder_version if ( imp_sth -> use_server_side_prepare ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<s2sv_blank>set,<s2sv_blank>check<s2sv_blank>restrictions\\n"" ) ; if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , # if mysql_version_id < limit_placeholder_version ""\\t\\tneed<s2sv_blank>to<s2sv_blank>test<s2sv_blank>for<s2sv_blank>limit<s2sv_blank>&<s2sv_blank>call\\n"" ) ; # else ""\\t\\tneed<s2sv_blank>to<s2sv_blank>test<s2sv_blank>for<s2sv_blank>restrictions\\n"" ) ; # endif str_last_ptr = statement + strlen ( statement ) ; for ( str_ptr = statement ; str_ptr < str_last_ptr ; str_ptr ++ ) { # if mysql_version_id < limit_placeholder_version if ( limit_flag ) { if ( * str_ptr == '?' ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tlimit<s2sv_blank>and<s2sv_blank>?<s2sv_blank>found,<s2sv_blank>set<s2sv_blank>to<s2sv_blank>use_server_side_prepare=0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } else if ( str_ptr < str_last_ptr - 6 && isspace ( * ( str_ptr + 0 ) ) && tolower ( * ( str_ptr + 1 ) ) == 'l' && tolower ( * ( str_ptr + 2 ) ) == 'i' && tolower ( * ( str_ptr + 3 ) ) == 'm' && tolower ( * ( str_ptr + 4 ) ) == 'i' && tolower ( * ( str_ptr + 5 ) ) == 't' && isspace ( * ( str_ptr + 6 ) ) ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""limit<s2sv_blank>set<s2sv_blank>limit<s2sv_blank>flag<s2sv_blank>to<s2sv_blank>1\\n"" ) ; limit_flag = 1 ; } # endif if ( str_ptr < str_last_ptr - 4 && tolower ( * ( str_ptr + 0 ) ) == 'c' && tolower ( * ( str_ptr + 1 ) ) == 'a' && tolower ( * ( str_ptr + 2 ) ) == 'l' && tolower ( * ( str_ptr + 3 ) ) == 'l' && isspace ( * ( str_ptr + 4 ) ) ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""disable<s2sv_blank>ps<s2sv_blank>mode<s2sv_blank>for<s2sv_blank>call()\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } } # endif # if mysql_version_id >= server_prepare_version if ( imp_sth -> use_server_side_prepare ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<s2sv_blank>set\\n"" ) ; if ( imp_sth -> stmt ) fprintf ( stderr , ""error:<s2sv_blank>trying<s2sv_blank>to<s2sv_blank>prepare<s2sv_blank>new<s2sv_blank>stmt<s2sv_blank>while<s2sv_blank>we<s2sv_blank>have<s2sv_blank>\\\n<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>already<s2sv_blank>not<s2sv_blank>closed<s2sv_blank>one<s2sv_blank>\\n"" ) ; imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ; if ( ! imp_sth -> stmt ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\terror:<s2sv_blank>unable<s2sv_blank>to<s2sv_blank>return<s2sv_blank>mysql_stmt<s2sv_blank>structure<s2sv_blank>\\\n<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>from<s2sv_blank>mysql_stmt_init():<s2sv_blank>error<s2sv_blank>no:<s2sv_blank>%d<s2sv_blank>error<s2sv_blank>msg:%s\\n"" , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) ) ; } prepare_retval = mysql_stmt_prepare ( imp_sth -> stmt , statement , strlen ( statement ) ) ; if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<s2sv_blank>returned<s2sv_blank>%d\\n"" , prepare_retval ) ; if ( prepare_retval ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<s2sv_blank>%d<s2sv_blank>%s\\n"" , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) ) ; if ( mysql_stmt_errno ( imp_sth -> stmt ) == er_unsupported_ps ) { if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tsetting<s2sv_blank>imp_sth->use_server_side_prepare<s2sv_blank>to<s2sv_blank>0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; } else { do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; mysql_stmt_close ( imp_sth -> stmt ) ; imp_sth -> stmt = null ; return false ; } } else { dbic_num_params ( imp_sth ) = mysql_stmt_param_count ( imp_sth -> stmt ) ; if ( dbic_num_params ( imp_sth ) > 0 ) { int has_statement_fields = imp_sth -> stmt -> fields != 0 ; imp_sth -> bind = alloc_bind ( dbic_num_params ( imp_sth ) ) ; imp_sth -> fbind = alloc_fbind ( dbic_num_params ( imp_sth ) ) ; imp_sth -> has_been_bound = 0 ; for ( i = 0 , bind = imp_sth -> bind , fbind = imp_sth -> fbind , bind_end = bind + dbic_num_params ( imp_sth ) ; bind < bind_end ; bind ++ , fbind ++ , i ++ ) { col_type = ( has_statement_fields ? imp_sth -> stmt -> fields [ i ] . type : mysql_type_string ) ; bind -> buffer_type = mysql_to_perl_type ( col_type ) ; if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t\\tmysql_to_perl_type<s2sv_blank>returned<s2sv_blank>%d\\n"" , col_type ) ; bind -> buffer = null ; bind -> length = & ( fbind -> length ) ; bind -> is_null = ( char * ) & ( fbind -> is_null ) ; fbind -> is_null = 1 ; fbind -> length = 0 ; } } } } # endif # if mysql_version_id >= server_prepare_version if ( imp_sth -> use_server_side_prepare == 0 ) dbic_num_params ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , athx_ statement , imp_dbh -> bind_comment_placeholders ) ; # else dbic_num_params ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , athx_ statement , imp_dbh -> bind_comment_placeholders ) ; # endif imp_sth -> params = alloc_param ( dbic_num_params ( imp_sth ) ) ; dbic_impset_on ( imp_sth ) ; if ( dbic_trace_level ( imp_xxh ) >= 2 ) perlio_printf ( dbic_logpio ( imp_xxh ) , ""\\t<-<s2sv_blank>dbd_st_prepare\\n"" ) ; return 1 ; }","<S2SV_ModStart> # endif int <S2SV_ModEnd> prepare_retval ; MYSQL_BIND <S2SV_ModStart> ( stderr , ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> ) ; imp_sth <S2SV_ModStart> imp_xxh ) , ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> , mysql_errno ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> imp_sth -> bind <S2SV_ModStart> ++ ) { bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ; bind ->
",perl5-dbi@DBD-mysql/793b72b1a0baa5070adacaac0e12fd995a6fbabe,CVE-2016-1249,https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe,2017-02-17T02:59Z,"<S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug>"
2351,CWE-20,"int bnep_add_connection ( struct bnep_connadd_req * req , struct socket * sock ) { struct net_device * dev ; struct bnep_session * s , * ss ; u8 dst [ eth_alen ] , src [ eth_alen ] ; int err ; bt_dbg ( """" ) ; baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ; dev = alloc_netdev ( sizeof ( struct bnep_session ) , ( * req -> device ) ? req -> device : ""bnep%d"" , net_name_unknown , bnep_net_setup ) ; if ( ! dev ) return - enomem ; down_write ( & bnep_session_sem ) ; ss = __bnep_get_session ( dst ) ; if ( ss && ss -> state == bt_connected ) { err = - eexist ; goto failed ; } s = netdev_priv ( dev ) ; memcpy ( s -> eh . h_dest , & src , eth_alen ) ; memcpy ( s -> eh . h_source , & dst , eth_alen ) ; memcpy ( dev -> dev_addr , s -> eh . h_dest , eth_alen ) ; s -> dev = dev ; s -> sock = sock ; s -> role = req -> role ; s -> state = bt_connected ; s -> msg . msg_flags = msg_nosignal ; # ifdef config_bt_bnep_mc_filter set_bit ( bnep_mc_hash ( dev -> broadcast ) , ( ulong * ) & s -> mc_filter ) ; # endif # ifdef config_bt_bnep_proto_filter bnep_set_default_proto_filter ( s ) ; # endif set_netdev_dev ( dev , bnep_get_device ( s ) ) ; set_netdev_devtype ( dev , & bnep_type ) ; err = register_netdev ( dev ) ; if ( err ) goto failed ; __bnep_link_session ( s ) ; __module_get ( this_module ) ; s -> task = kthread_run ( bnep_session , s , ""kbnepd<s2sv_blank>%s"" , dev -> name ) ; if ( is_err ( s -> task ) ) { module_put ( this_module ) ; unregister_netdev ( dev ) ; __bnep_unlink_session ( s ) ; err = ptr_err ( s -> task ) ; goto failed ; } up_write ( & bnep_session_sem ) ; strcpy ( req -> device , dev -> name ) ; return 0 ; failed : up_write ( & bnep_session_sem ) ; free_netdev ( dev ) ; return err ; }","<S2SV_ModStart> """" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
",torvalds@linux/71bb99a02b32b4cc4265118e85f6035ca72923f0,CVE-2017-15868,https://github.com/torvalds/linux/commit/71bb99a02b32b4cc4265118e85f6035ca72923f0,2017-12-05T23:29Z,"<S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug>"
641,CWE-362,"static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; define_wait ( wait ) ; pr_debug ( ""%s:<s2sv_blank>asoc:%p,<s2sv_blank>timeo:%ld,<s2sv_blank>msg_len:%zu\\n"" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , task_interruptible ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= sctp_state_shutdown_pending || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; bug_on ( sk != asoc -> base . sk ) ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - epipe ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - eagain ; goto out ; }","<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
",torvalds@linux/2dcab598484185dea7ec22219c76dcdd59e3cb90,CVE-2017-5986,https://github.com/torvalds/linux/commit/2dcab598484185dea7ec22219c76dcdd59e3cb90,2017-02-18T21:59Z,<S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug>
2680,CWE-20,"static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = llc_sap_ev_type_pdu ; ev -> reason = 0 ; skb -> sk = sk ; llc_sap_state_process ( sap , skb ) ; }","<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
",torvalds@linux/8b74d439e1697110c5e5c600643e823eb1dd0762,CVE-2017-6345,https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762,2017-03-01T20:59Z,<S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug>
1102,CWE-772,"int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( rpel_req_size ) ; if ( ! req ) return - enomem ; resp = alloc_smp_resp ( rpel_resp_size ) ; if ( ! resp ) { kfree ( req ) ; return - enomem ; } req [ 1 ] = smp_report_phy_err_log ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , rpel_req_size , resp , rpel_resp_size ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : kfree ( resp ) ; return res ; }","<S2SV_ModStart> : kfree ( req ) ; kfree (
",torvalds@linux/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4,CVE-2018-7757,https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4,2018-03-08T14:29Z,<S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug>
2211,CWE-119,"static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>command_info<s2sv_blank>is<s2sv_blank>null,<s2sv_blank>exiting.\\n"" , __func__ ) ; return ; } if ( status ) { dev_dbg ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>nonzero<s2sv_blank>urb<s2sv_blank>status:<s2sv_blank>%d\\n"" , __func__ , status ) ; if ( status != - enoent ) command_info -> command_finished = whiteheat_cmd_failure ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == whiteheat_cmd_complete ) { command_info -> command_finished = whiteheat_cmd_complete ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == whiteheat_cmd_failure ) { command_info -> command_finished = whiteheat_cmd_failure ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == whiteheat_event ) { dev_dbg ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>event<s2sv_blank>received\\n"" , __func__ ) ; } else if ( data [ 0 ] == whiteheat_get_dtr_rts ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ; command_info -> command_finished = whiteheat_cmd_complete ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>bad<s2sv_blank>reply<s2sv_blank>from<s2sv_blank>firmware\\n"" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , gfp_atomic ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , ""%s<s2sv_blank>-<s2sv_blank>failed<s2sv_blank>resubmitting<s2sv_blank>read<s2sv_blank>urb,<s2sv_blank>error<s2sv_blank>%d\\n"" , __func__ , result ) ; }","<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1
",torvalds@linux/6817ae225cd650fb1c3295d769298c38b1eba818,CVE-2014-3185,https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818,2014-09-28T10:55Z,<S2SV_StartBug> if ( status ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug>
4644,CWE-190,"static int bson_string_is_db_ref ( const unsigned char * string , const int length ) { int result = 0 ; if ( length >= 4 ) { if ( string [ 1 ] == 'r' && string [ 2 ] == 'e' && string [ 3 ] == 'f' ) result = 1 ; } else if ( length >= 3 ) { if ( string [ 1 ] == 'i' && string [ 2 ] == 'd' ) result = 1 ; else if ( string [ 1 ] == 'd' && string [ 2 ] == 'b' ) result = 1 ; } return result ; }","<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,"<S2SV_StartBug> static int bson_string_is_db_ref ( const unsigned char * string , const int length ) { <S2SV_EndBug>"
7907,CWE-20,"error_t mqttsnclientsendunsubscribe ( mqttsnclientcontext * context , const char_t * topicname ) { error_t error ; systime_t time ; uint16_t topicid ; mqttsnflags flags ; error = no_error ; flags . all = 0 ; topicid = mqttsnclientfindpredeftopicname ( context , topicname ) ; if ( topicid != mqtt_sn_invalid_topic_id ) { flags . topicidtype = mqtt_sn_predefined_topic_id ; } else { if ( osstrlen ( topicname ) == 2 && strchr ( topicname , '#' ) == null && strchr ( topicname , '+' ) == null ) { flags . topicidtype = mqtt_sn_short_topic_name ; } else { flags . topicidtype = mqtt_sn_normal_topic_name ; } error = mqttsnformatunsubscribe ( & context -> message , flags , context -> msgid , topicid , topicname ) ; } if ( ! error ) { trace_info ( ""sending<s2sv_blank>unsubscribe<s2sv_blank>message<s2sv_blank>(%"" priusize ""<s2sv_blank>bytes)...\\r\\n"" , context -> message . length ) ; mqttsndumpmessage ( context -> message . buffer , context -> message . length ) ; error = mqttsnclientsenddatagram ( context , context -> message . buffer , context -> message . length ) ; time = osgetsystemtime ( ) ; context -> retransmitstarttime = time ; context -> keepalivetimestamp = time ; context -> state = mqtt_sn_client_state_sending_req ; context -> msgtype = mqtt_sn_msg_type_unsubscribe ; } return error ; }","<S2SV_ModStart> == 2 && osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug>"
6063,CWE-000,"static void ext4_invalidatepage ( struct page * page , unsigned long offset ) { journal_t * journal = ext4_journal ( page -> mapping -> host ) ; if ( offset == 0 ) clearpagechecked ( page ) ; if ( journal ) jbd2_journal_invalidatepage ( journal , page , offset ) ; else block_invalidatepage ( page , offset ) ; }","<S2SV_ModStart> mapping -> host ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,<S2SV_StartBug> journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; <S2SV_EndBug>
2701,CWE-000,"static int aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct usb_endpoint_descriptor * endpoint ; struct aiptek * aiptek ; struct input_dev * inputdev ; int i ; int speeds [ ] = { 0 , aiptek_programmable_delay_50 , aiptek_programmable_delay_400 , aiptek_programmable_delay_25 , aiptek_programmable_delay_100 , aiptek_programmable_delay_200 , aiptek_programmable_delay_300 } ; int err = - enomem ; speeds [ 0 ] = programmabledelay ; aiptek = kzalloc ( sizeof ( struct aiptek ) , gfp_kernel ) ; inputdev = input_allocate_device ( ) ; if ( ! aiptek || ! inputdev ) { dev_warn ( & intf -> dev , ""cannot<s2sv_blank>allocate<s2sv_blank>memory<s2sv_blank>or<s2sv_blank>input<s2sv_blank>device\\n"" ) ; goto fail1 ; } aiptek -> data = usb_alloc_coherent ( usbdev , aiptek_packet_length , gfp_atomic , & aiptek -> data_dma ) ; if ( ! aiptek -> data ) { dev_warn ( & intf -> dev , ""cannot<s2sv_blank>allocate<s2sv_blank>usb<s2sv_blank>buffer\\n"" ) ; goto fail1 ; } aiptek -> urb = usb_alloc_urb ( 0 , gfp_kernel ) ; if ( ! aiptek -> urb ) { dev_warn ( & intf -> dev , ""cannot<s2sv_blank>allocate<s2sv_blank>urb\\n"" ) ; goto fail2 ; } aiptek -> inputdev = inputdev ; aiptek -> usbdev = usbdev ; aiptek -> intf = intf ; aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . binterfacenumber ; aiptek -> indelay = 0 ; aiptek -> enddelay = 0 ; aiptek -> previousjitterable = 0 ; aiptek -> lastmacro = - 1 ; aiptek -> cursetting . pointermode = aiptek_pointer_either_mode ; aiptek -> cursetting . coordinatemode = aiptek_coordinate_absolute_mode ; aiptek -> cursetting . toolmode = aiptek_tool_button_pen_mode ; aiptek -> cursetting . xtilt = aiptek_tilt_disable ; aiptek -> cursetting . ytilt = aiptek_tilt_disable ; aiptek -> cursetting . mousebuttonleft = aiptek_mouse_left_button ; aiptek -> cursetting . mousebuttonmiddle = aiptek_mouse_middle_button ; aiptek -> cursetting . mousebuttonright = aiptek_mouse_right_button ; aiptek -> cursetting . stylusbuttonupper = aiptek_stylus_upper_button ; aiptek -> cursetting . stylusbuttonlower = aiptek_stylus_lower_button ; aiptek -> cursetting . jitterdelay = jitterdelay ; aiptek -> cursetting . programmabledelay = programmabledelay ; aiptek -> newsetting = aiptek -> cursetting ; usb_make_path ( usbdev , aiptek -> features . usbpath , sizeof ( aiptek -> features . usbpath ) ) ; strlcat ( aiptek -> features . usbpath , ""/input0"" , sizeof ( aiptek -> features . usbpath ) ) ; inputdev -> name = ""aiptek"" ; inputdev -> phys = aiptek -> features . usbpath ; usb_to_input_id ( usbdev , & inputdev -> id ) ; inputdev -> dev . parent = & intf -> dev ; input_set_drvdata ( inputdev , aiptek ) ; inputdev -> open = aiptek_open ; inputdev -> close = aiptek_close ; for ( i = 0 ; i < array_size ( eventtypes ) ; ++ i ) __set_bit ( eventtypes [ i ] , inputdev -> evbit ) ; for ( i = 0 ; i < array_size ( absevents ) ; ++ i ) __set_bit ( absevents [ i ] , inputdev -> absbit ) ; for ( i = 0 ; i < array_size ( relevents ) ; ++ i ) __set_bit ( relevents [ i ] , inputdev -> relbit ) ; __set_bit ( msc_serial , inputdev -> mscbit ) ; for ( i = 0 ; i < array_size ( buttonevents ) ; ++ i ) __set_bit ( buttonevents [ i ] , inputdev -> keybit ) ; for ( i = 0 ; i < array_size ( macrokeyevents ) ; ++ i ) __set_bit ( macrokeyevents [ i ] , inputdev -> keybit ) ; input_set_abs_params ( inputdev , abs_x , 0 , 2999 , 0 , 0 ) ; input_set_abs_params ( inputdev , abs_y , 0 , 2249 , 0 , 0 ) ; input_set_abs_params ( inputdev , abs_pressure , 0 , 511 , 0 , 0 ) ; input_set_abs_params ( inputdev , abs_tilt_x , aiptek_tilt_min , aiptek_tilt_max , 0 , 0 ) ; input_set_abs_params ( inputdev , abs_tilt_y , aiptek_tilt_min , aiptek_tilt_max , 0 , 0 ) ; input_set_abs_params ( inputdev , abs_wheel , aiptek_wheel_min , aiptek_wheel_max - 1 , 0 , 0 ) ; endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bendpointaddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> binterval ) ; aiptek -> urb -> transfer_dma = aiptek -> data_dma ; aiptek -> urb -> transfer_flags |= urb_no_transfer_dma_map ; for ( i = 0 ; i < array_size ( speeds ) ; ++ i ) { aiptek -> cursetting . programmabledelay = speeds [ i ] ; ( void ) aiptek_program_tablet ( aiptek ) ; if ( input_abs_get_max ( aiptek -> inputdev , abs_x ) > 0 ) { dev_info ( & intf -> dev , ""aiptek<s2sv_blank>using<s2sv_blank>%d<s2sv_blank>ms<s2sv_blank>programming<s2sv_blank>speed\\n"" , aiptek -> cursetting . programmabledelay ) ; break ; } } if ( i == array_size ( speeds ) ) { dev_info ( & intf -> dev , ""aiptek<s2sv_blank>tried<s2sv_blank>all<s2sv_blank>speeds,<s2sv_blank>no<s2sv_blank>sane<s2sv_blank>response\\n"" ) ; goto fail3 ; } usb_set_intfdata ( intf , aiptek ) ; err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; if ( err ) { dev_warn ( & intf -> dev , ""cannot<s2sv_blank>create<s2sv_blank>sysfs<s2sv_blank>group<s2sv_blank>err:<s2sv_blank>%d\\n"" , err ) ; goto fail3 ; } err = input_register_device ( aiptek -> inputdev ) ; if ( err ) { dev_warn ( & intf -> dev , ""input_register_device<s2sv_blank>returned<s2sv_blank>err:<s2sv_blank>%d\\n"" , err ) ; goto fail4 ; } return 0 ; fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; fail3 : usb_free_urb ( aiptek -> urb ) ; fail2 : usb_free_coherent ( usbdev , aiptek_packet_length , aiptek -> data , aiptek -> data_dma ) ; fail1 : usb_set_intfdata ( intf , null ) ; input_free_device ( inputdev ) ; kfree ( aiptek ) ; return err ; }","<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> ""Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n"" ) ; err = - EINVAL ;
",torvalds@linux/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96,CVE-2015-7515,https://github.com/torvalds/linux/commit/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96,2016-04-27T17:59Z,<S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug>
7788,CWE-125,"mod_ty pyast_fromnodeobject ( const node * n , pycompilerflags * flags , pyobject * filename , pyarena * arena ) { int i , j , k , num ; asdl_seq * stmts = null ; stmt_ty s ; node * ch ; struct compiling c ; mod_ty res = null ; c . c_arena = arena ; c . c_filename = filename ; c . c_normalize = null ; if ( type ( n ) == encoding_decl ) n = child ( n , 0 ) ; k = 0 ; switch ( type ( n ) ) { case file_input : stmts = _py_asdl_seq_new ( num_stmts ( n ) , arena ) ; if ( ! stmts ) goto out ; for ( i = 0 ; i < nch ( n ) - 1 ; i ++ ) { ch = child ( n , i ) ; if ( type ( ch ) == newline ) continue ; req ( ch , stmt ) ; num = num_stmts ( ch ) ; if ( num == 1 ) { s = ast_for_stmt ( & c , ch ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , k ++ , s ) ; } else { ch = child ( ch , 0 ) ; req ( ch , simple_stmt ) ; for ( j = 0 ; j < num ; j ++ ) { s = ast_for_stmt ( & c , child ( ch , j * 2 ) ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , k ++ , s ) ; } } } res = module ( stmts , arena ) ; break ; case eval_input : { expr_ty testlist_ast ; testlist_ast = ast_for_testlist ( & c , child ( n , 0 ) ) ; if ( ! testlist_ast ) goto out ; res = expression ( testlist_ast , arena ) ; break ; } case single_input : if ( type ( child ( n , 0 ) ) == newline ) { stmts = _py_asdl_seq_new ( 1 , arena ) ; if ( ! stmts ) goto out ; asdl_seq_set ( stmts , 0 , pass ( n -> n_lineno , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , arena ) ) ; if ( ! asdl_seq_get ( stmts , 0 ) ) goto out ; res = interactive ( stmts , arena ) ; } else { n = child ( n , 0 ) ; num = num_stmts ( n ) ; stmts = _py_asdl_seq_new ( num , arena ) ; if ( ! stmts ) goto out ; if ( num == 1 ) { s = ast_for_stmt ( & c , n ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , 0 , s ) ; } else { req ( n , simple_stmt ) ; for ( i = 0 ; i < nch ( n ) ; i += 2 ) { if ( type ( child ( n , i ) ) == newline ) break ; s = ast_for_stmt ( & c , child ( n , i ) ) ; if ( ! s ) goto out ; asdl_seq_set ( stmts , i / 2 , s ) ; } } res = interactive ( stmts , arena ) ; } break ; default : pyerr_format ( pyexc_systemerror , ""invalid<s2sv_blank>node<s2sv_blank>%d<s2sv_blank>for<s2sv_blank>pyast_fromnode"" , type ( n ) ) ; goto out ; } out : if ( c . c_normalize ) { py_decref ( c . c_normalize ) ; } return res ; }","<S2SV_ModStart> = NULL ; asdl_seq * type_ignores = NULL ; <S2SV_ModStart> res = NULL ; asdl_seq * argtypes = NULL ; expr_ty ret , arg <S2SV_ModStart> } } } ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Py_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } <S2SV_ModStart> Module ( stmts , type_ignores <S2SV_ModStart> } break ; case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { num ++ ; } } argtypes = _Py_asdl_seq_new ( num , arena ) ; if ( ! argtypes ) goto out ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else { argtypes = _Py_asdl_seq_new ( 0 , arena ) ; if ( ! argtypes ) goto out ; } ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> stmt_ty s ; <S2SV_EndBug> <S2SV_StartBug> mod_ty res = NULL ; <S2SV_EndBug> <S2SV_StartBug> res = Module ( stmts , arena ) ; <S2SV_EndBug> <S2SV_StartBug> default : <S2SV_EndBug>"
6482,CWE-310,"static void read_conf ( file * conffile ) { char * buffer , * line , * val ; buffer = loadfile ( conffile ) ; for ( line = strtok ( buffer , ""\\r\\n"" ) ; line ; line = strtok ( null , ""\\r\\n"" ) ) { if ( ! strncmp ( line , ""export<s2sv_blank>"" , 7 ) ) continue ; val = strchr ( line , '=' ) ; if ( ! val ) { printf ( ""invalid<s2sv_blank>configuration<s2sv_blank>line\\n"" ) ; break ; } * val ++ = '\\0' ; if ( ! strcmp ( line , ""json_indent"" ) ) conf . indent = atoi ( val ) ; if ( ! strcmp ( line , ""json_compact"" ) ) conf . compact = atoi ( val ) ; if ( ! strcmp ( line , ""json_ensure_ascii"" ) ) conf . ensure_ascii = atoi ( val ) ; if ( ! strcmp ( line , ""json_preserve_order"" ) ) conf . preserve_order = atoi ( val ) ; if ( ! strcmp ( line , ""json_sort_keys"" ) ) conf . sort_keys = atoi ( val ) ; if ( ! strcmp ( line , ""strip"" ) ) conf . strip = atoi ( val ) ; } free ( buffer ) ; }","<S2SV_ModStart> val ) ; if ( ! strcmp ( line , ""HASHSEED"" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; }
",akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z,<S2SV_StartBug> } <S2SV_EndBug>
2298,CWE-119,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { duprintf ( ""bad<s2sv_blank>offset<s2sv_blank>%p\\n"" , e ) ; return - einval ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<s2sv_blank>element<s2sv_blank>%p<s2sv_blank>size<s2sv_blank>%u\\n"" , e , e -> next_offset ) ; return - einval ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < nf_arp_numhooks ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""underflows<s2sv_blank>must<s2sv_blank>be<s2sv_blank>unconditional<s2sv_blank>and<s2sv_blank>"" ""use<s2sv_blank>the<s2sv_blank>standard<s2sv_blank>target<s2sv_blank>with<s2sv_blank>"" ""accept/drop\\n"" ) ; return - einval ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }","<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
",torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,CVE-2016-4998,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,2016-07-03T21:59Z,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug>
7642,CWE-190,"int ras_validate ( jas_stream_t * in ) { uchar buf [ ras_magiclen ] ; int i ; int n ; uint_fast32_t magic ; assert ( jas_stream_maxputback >= ras_magiclen ) ; if ( ( n = jas_stream_read ( in , buf , ras_magiclen ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == eof ) { return - 1 ; } } if ( n < ras_magiclen ) { return - 1 ; } magic = ( jas_cast ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( jas_cast ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( jas_cast ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != ras_magic ) { return - 1 ; } return 0 ; }","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ RAS_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug>
6345,CWE-772,"generic_ret * modify_policy_2_svc ( mpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; gss_buffer_desc client_name , service_name ; om_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = null ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } prime_arg = arg -> rec . policy ; if ( changepw_service ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , acl_modify , null , null ) ) { log_unauth ( ""kadm5_modify_policy"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = kadm5_auth_modify ; } else { ret . code = kadm5_modify_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_policy"" , ( ( prime_arg == null ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != null ) krb5_free_error_message ( handle -> context , errmsg ) ; } gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
5878,CWE-400,"static void exif_data_load_data_content ( exifdata * data , exififd ifd , const unsigned char * d , unsigned int ds , unsigned int offset , unsigned int recursion_depth ) { exiflong o , thumbnail_offset = 0 , thumbnail_length = 0 ; exifshort n ; exifentry * entry ; unsigned int i ; exiftag tag ; if ( ! data || ! data -> priv ) return ; if ( ( ( ( int ) ifd ) < 0 ) || ( ( ( int ) ifd ) >= exif_ifd_count ) ) return ; if ( recursion_depth > 12 ) { exif_log ( data -> priv -> log , exif_log_code_corrupt_data , ""exifdata"" , ""deep<s2sv_blank>recursion<s2sv_blank>detected!"" ) ; return ; } if ( ( offset + 2 < offset ) || ( offset + 2 < 2 ) || ( offset + 2 > ds ) ) { exif_log ( data -> priv -> log , exif_log_code_corrupt_data , ""exifdata"" , ""tag<s2sv_blank>data<s2sv_blank>past<s2sv_blank>end<s2sv_blank>of<s2sv_blank>buffer<s2sv_blank>(%u<s2sv_blank>><s2sv_blank>%u)"" , offset + 2 , ds ) ; return ; } n = exif_get_short ( d + offset , data -> priv -> order ) ; exif_log ( data -> priv -> log , exif_log_code_debug , ""exifdata"" , ""loading<s2sv_blank>%hu<s2sv_blank>entries..."" , n ) ; offset += 2 ; if ( offset + 12 * n > ds ) { n = ( ds - offset ) / 12 ; exif_log ( data -> priv -> log , exif_log_code_debug , ""exifdata"" , ""short<s2sv_blank>data;<s2sv_blank>only<s2sv_blank>loading<s2sv_blank>%hu<s2sv_blank>entries..."" , n ) ; } for ( i = 0 ; i < n ; i ++ ) { tag = exif_get_short ( d + offset + 12 * i , data -> priv -> order ) ; switch ( tag ) { case exif_tag_exif_ifd_pointer : case exif_tag_gps_info_ifd_pointer : case exif_tag_interoperability_ifd_pointer : case exif_tag_jpeg_interchange_format_length : case exif_tag_jpeg_interchange_format : o = exif_get_long ( d + offset + 12 * i + 8 , data -> priv -> order ) ; exif_log ( data -> priv -> log , exif_log_code_debug , ""exifdata"" , ""sub-ifd<s2sv_blank>entry<s2sv_blank>0x%x<s2sv_blank>(\'%s\')<s2sv_blank>at<s2sv_blank>%u."" , tag , exif_tag_get_name ( tag ) , o ) ; switch ( tag ) { case exif_tag_exif_ifd_pointer : check_rec ( exif_ifd_exif ) ; exif_data_load_data_content ( data , exif_ifd_exif , d , ds , o , recursion_depth + 1 ) ; break ; case exif_tag_gps_info_ifd_pointer : check_rec ( exif_ifd_gps ) ; exif_data_load_data_content ( data , exif_ifd_gps , d , ds , o , recursion_depth + 1 ) ; break ; case exif_tag_interoperability_ifd_pointer : check_rec ( exif_ifd_interoperability ) ; exif_data_load_data_content ( data , exif_ifd_interoperability , d , ds , o , recursion_depth + 1 ) ; break ; case exif_tag_jpeg_interchange_format : thumbnail_offset = o ; if ( thumbnail_offset && thumbnail_length ) exif_data_load_data_thumbnail ( data , d , ds , thumbnail_offset , thumbnail_length ) ; break ; case exif_tag_jpeg_interchange_format_length : thumbnail_length = o ; if ( thumbnail_offset && thumbnail_length ) exif_data_load_data_thumbnail ( data , d , ds , thumbnail_offset , thumbnail_length ) ; break ; default : return ; } break ; default : if ( ! exif_tag_get_name_in_ifd ( tag , ifd ) ) { if ( ! memcmp ( d + offset + 12 * i , ""\\0\\0\\0\\0"" , 4 ) ) { exif_log ( data -> priv -> log , exif_log_code_debug , ""exifdata"" , ""skipping<s2sv_blank>empty<s2sv_blank>entry<s2sv_blank>at<s2sv_blank>position<s2sv_blank>%u<s2sv_blank>in<s2sv_blank>\'%s\'."" , i , exif_ifd_get_name ( ifd ) ) ; break ; } exif_log ( data -> priv -> log , exif_log_code_debug , ""exifdata"" , ""unknown<s2sv_blank>tag<s2sv_blank>0x%04x<s2sv_blank>(entry<s2sv_blank>%u<s2sv_blank>in<s2sv_blank>\'%s\').<s2sv_blank>please<s2sv_blank>report<s2sv_blank>this<s2sv_blank>tag<s2sv_blank>"" ""to<s2sv_blank><libexif-devel@lists.sourceforge.net>."" , tag , i , exif_ifd_get_name ( ifd ) ) ; if ( data -> priv -> options & exif_data_option_ignore_unknown_tags ) break ; } entry = exif_entry_new_mem ( data -> priv -> mem ) ; if ( ! entry ) { exif_log ( data -> priv -> log , exif_log_code_no_memory , ""exifdata"" , ""could<s2sv_blank>not<s2sv_blank>allocate<s2sv_blank>memory"" ) ; return ; } if ( exif_data_load_data_entry ( data , entry , d , ds , offset + 12 * i ) ) exif_content_add_entry ( data -> ifd [ ifd ] , entry ) ; exif_entry_unref ( entry ) ; break ; } } }","<S2SV_ModStart> , unsigned int recursion_cost <S2SV_ModEnd> ) { ExifLong <S2SV_ModStart> ; if ( recursion_cost > 170 <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifData"" , ""Deep/expensive<S2SV_blank>recursion<S2SV_blank>detected!"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break
",libexif@libexif/6aa11df549114ebda520dde4cdaea2f9357b2c89,CVE-2018-20030,https://github.com/libexif/libexif/commit/6aa11df549114ebda520dde4cdaea2f9357b2c89,2019-02-20T17:29Z,"<S2SV_StartBug> unsigned int ds , unsigned int offset , unsigned int recursion_depth ) <S2SV_EndBug> <S2SV_StartBug> if ( recursion_depth > 12 ) { <S2SV_EndBug> <S2SV_StartBug> ""Deep<S2SV_blank>recursion<S2SV_blank>detected!"" ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug>"
6303,CWE-000,"static void salttextaway ( xtermwidget xw , int which , cell * cellc , cell * cell ) { tscreen * screen = tscreenof ( xw ) ; selectedcells * scp ; int i ; int eol ; int need = 0 ; char * line ; char * lp ; cell first = * cellc ; cell last = * cell ; if ( which < 0 || which >= max_selections ) { trace ( ( ""salttextaway<s2sv_blank>-<s2sv_blank>which<s2sv_blank>selection?\\n"" ) ) ; return ; } scp = & ( screen -> selected_cells [ which ] ) ; trace ( ( ""salttextaway<s2sv_blank>which=%d,<s2sv_blank>first=%d,%d,<s2sv_blank>last=%d,%d\\n"" , which , first . row , first . col , last . row , last . col ) ) ; if ( issamerow ( & first , & last ) && first . col > last . col ) { int tmp ; exchange ( first . col , last . col , tmp ) ; } -- last . col ; if ( issamerow ( & last , & first ) ) { need = length ( screen , first . row , first . col , last . col ) ; } else { need += length ( screen , first . row , first . col , screen -> max_col ) + 1 ; for ( i = first . row + 1 ; i < last . row ; i ++ ) need += length ( screen , i , 0 , screen -> max_col ) + 1 ; if ( last . col >= 0 ) need += length ( screen , last . row , 0 , last . col ) ; } if_opt_wide_chars ( screen , { need *= 4 ; } ) ; if ( need < 0 ) return ; if ( scp -> data_limit <= ( unsigned ) need ) { if ( ( line = ( char * ) malloc ( ( size_t ) need + 1 ) ) == 0 ) syserror ( error_bmalloc2 ) ; free ( scp -> data_buffer ) ; scp -> data_buffer = line ; scp -> data_limit = ( size_t ) ( need + 1 ) ; } else { line = scp -> data_buffer ; } if ( line == 0 ) return ; line [ need ] = '\\0' ; lp = line ; if ( issamerow ( & last , & first ) ) { lp = savetext ( screen , last . row , first . col , last . col , lp , & eol ) ; } else { lp = savetext ( screen , first . row , first . col , screen -> max_col , lp , & eol ) ; if ( eol ) * lp ++ = '\\n' ; for ( i = first . row + 1 ; i < last . row ; i ++ ) { lp = savetext ( screen , i , 0 , screen -> max_col , lp , & eol ) ; if ( eol ) * lp ++ = '\\n' ; } if ( last . col >= 0 ) lp = savetext ( screen , last . row , 0 , last . col , lp , & eol ) ; } * lp = '\\0' ; trace ( ( ""salted<s2sv_blank>text:%u:%s\\n"" , ( unsigned ) ( lp - line ) , visiblechars ( line , ( unsigned ) ( lp - line ) ) ) ) ; scp -> data_length = ( size_t ) ( lp - line ) ; }","<S2SV_ModStart> ; int need = 0 ; size_t have <S2SV_ModStart> screen , { if ( need > 0 ) { if ( screen -> max_combining > 0 ) need += screen -> max_combining ; need *= 6 ; } <S2SV_ModEnd> } ) ; <S2SV_ModStart> = '\\0' ; have = ( size_t ) ( lp - line ) ; if ( ( have * 2 ) < ( size_t ) need ) { scp -> data_limit = have + 1 ; line = realloc ( line , scp -> data_limit ) ; } <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> , visibleChars ( <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> data_length = have <S2SV_ModEnd> ; } <S2SV_null>
",ThomasDickey@xterm-snapshots/82ba55b8f994ab30ff561a347b82ea340ba7075c,CVE-2021-27135,https://github.com/ThomasDickey/xterm-snapshots/commit/82ba55b8f994ab30ff561a347b82ea340ba7075c,2021-02-10T16:15Z,"<S2SV_StartBug> int need = 0 ; <S2SV_EndBug> <S2SV_StartBug> need *= 4 ; <S2SV_EndBug> <S2SV_StartBug> TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\n"" , ( unsigned ) ( lp - line ) , <S2SV_EndBug> <S2SV_StartBug> visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> scp -> data_length = ( size_t ) ( lp - line ) ; <S2SV_EndBug>"
5447,CWE-787,"void process_bitmap_updates ( stream s ) { uint16 num_updates ; uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; logger ( protocol , debug , ""%s()"" , __func__ ) ; in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { in_uint16_le ( s , left ) ; in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( graphics , debug , ""process_bitmap_updates(),<s2sv_blank>[%d,%d,%d,%d],<s2sv_blank>[%d,%d],<s2sv_blank>bpp=%d,<s2sv_blank>compression=%d"" , left , top , right , bottom , width , height , bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * bpp ) ] , width * bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( graphics , warning , ""process_bitmap_updates(),<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>decompress<s2sv_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }","<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,"<S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug>"
5885,CWE-125,"static uint drive_process_irp_write ( drive_device * drive , irp * irp ) { drive_file * file ; uint32 length ; uint64 offset ; if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> complete ) return error_invalid_parameter ; if ( stream_getremaininglength ( irp -> input ) < 32 ) return error_invalid_data ; stream_read_uint32 ( irp -> input , length ) ; stream_read_uint64 ( irp -> input , offset ) ; stream_seek ( irp -> input , 20 ) ; file = drive_get_file_by_id ( drive , irp -> fileid ) ; if ( ! file ) { irp -> iostatus = status_unsuccessful ; length = 0 ; } else if ( ! drive_file_seek ( file , offset ) ) { irp -> iostatus = drive_map_windows_err ( getlasterror ( ) ) ; length = 0 ; } else if ( ! drive_file_write ( file , stream_pointer ( irp -> input ) , length ) ) { irp -> iostatus = drive_map_windows_err ( getlasterror ( ) ) ; length = 0 ; } stream_write_uint32 ( irp -> output , length ) ; stream_write_uint8 ( irp -> output , 0 ) ; return irp -> complete ( irp ) ; }","<S2SV_ModStart> UINT64 Offset ; void * ptr ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( file , ptr <S2SV_ModEnd> , Length )
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,"<S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug>"
580,CWE-399,"static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * ieee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx ; int err ; if ( nla_put_string ( skb , dcb_attr_ifname , netdev -> name ) ) return - emsgsize ; ieee = nla_nest_start ( skb , dcb_attr_ieee ) ; if ( ! ieee ) return - emsgsize ; if ( ops -> ieee_getets ) { struct ieee_ets ets ; err = ops -> ieee_getets ( netdev , & ets ) ; if ( ! err && nla_put ( skb , dcb_attr_ieee_ets , sizeof ( ets ) , & ets ) ) return - emsgsize ; } if ( ops -> ieee_getmaxrate ) { struct ieee_maxrate maxrate ; err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; if ( ! err ) { err = nla_put ( skb , dcb_attr_ieee_maxrate , sizeof ( maxrate ) , & maxrate ) ; if ( err ) return - emsgsize ; } } if ( ops -> ieee_getpfc ) { struct ieee_pfc pfc ; err = ops -> ieee_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , dcb_attr_ieee_pfc , sizeof ( pfc ) , & pfc ) ) return - emsgsize ; } app = nla_nest_start ( skb , dcb_attr_ieee_app_table ) ; if ( ! app ) return - emsgsize ; spin_lock ( & dcb_lock ) ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { err = nla_put ( skb , dcb_attr_ieee_app , sizeof ( itr -> app ) , & itr -> app ) ; if ( err ) { spin_unlock ( & dcb_lock ) ; return - emsgsize ; } } } if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - eopnotsupp ; spin_unlock ( & dcb_lock ) ; nla_nest_end ( skb , app ) ; if ( ops -> ieee_peer_getets ) { struct ieee_ets ets ; err = ops -> ieee_peer_getets ( netdev , & ets ) ; if ( ! err && nla_put ( skb , dcb_attr_ieee_peer_ets , sizeof ( ets ) , & ets ) ) return - emsgsize ; } if ( ops -> ieee_peer_getpfc ) { struct ieee_pfc pfc ; err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , dcb_attr_ieee_peer_pfc , sizeof ( pfc ) , & pfc ) ) return - emsgsize ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , dcb_attr_ieee_peer_app , dcb_attr_ieee_app_unspec , dcb_attr_ieee_app ) ; if ( err ) return - emsgsize ; } nla_nest_end ( skb , ieee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , dcb_attr_dcbx , dcbx ) ; if ( err ) return - emsgsize ; } return 0 ; }","<S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
",torvalds@linux/29cd8ae0e1a39e239a3a7b67da1986add1199fc0,CVE-2013-2634,https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0,2013-03-22T11:59Z,"<S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug>"
4125,CWE-20,"void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { u32 data ; void * vapic ; if ( test_bit ( kvm_apic_pv_eoi_pending , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( kvm_apic_check_vapic , & vcpu -> arch . apic_attention ) ) return ; vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }","<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z,<S2SV_StartBug> u32 data ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug>
4250,CWE-401,"struct clock_source * dcn20_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , gfp_kernel ) ; if ( ! clk_src ) return null ; if ( dcn20_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } break_to_debugger ( ) ; return null ; }","<S2SV_ModStart> base ; } kfree ( clk_src ) ;
",torvalds@linux/055e547478a11a6360c7ce05e2afc3e366968a12,CVE-2019-19083,https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12,2019-11-18T06:15Z,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug>
121,CWE-285,"static int __jfs_set_acl ( tid_t tid , struct inode * inode , int type , struct posix_acl * acl ) { char * ea_name ; int rc ; int size = 0 ; char * value = null ; switch ( type ) { case acl_type_access : ea_name = xattr_name_posix_acl_access ; if ( acl ) { rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; if ( rc < 0 ) return rc ; inode -> i_ctime = current_time ; mark_inode_dirty ( inode ) ; if ( rc == 0 ) acl = null ; } break ; case acl_type_default : ea_name = xattr_name_posix_acl_default ; break ; default : return - einval ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , gfp_kernel ) ; if ( ! value ) return - enomem ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( rc < 0 ) goto out ; } rc = __jfs_setxattr ( tid , inode , ea_name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }","<S2SV_ModStart> { rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart> < 0 ) <S2SV_ModEnd> goto out ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug>"
5076,CWE-400,"static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return nghttp2_err_proto ; } if ( settings_payloadlen % nghttp2_frame_settings_entry_length ) { return nghttp2_err_invalid_argument ; } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , nghttp2_settings , nghttp2_flag_none , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , nghttp2_flag_none , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , nghttp2_stream_flag_none , & pri_spec , nghttp2_stream_opening , session -> server ? null : stream_user_data ) ; if ( stream == null ) { return nghttp2_err_nomem ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , nghttp2_shut_rd ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , nghttp2_shut_wr ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }","<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS
",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z,<S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug>
3300,CWE-125,"void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; struct va_format vaf ; char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<s2sv_blank>%pv"" , dev_name ( & qedi -> pdev -> dev ) , nfunc , line , qedi -> host_no , & vaf ) ; else pr_info ( ""[0000:00:00.0]:[%s:%d]:<s2sv_blank>%pv"" , nfunc , line , & vaf ) ; ret : va_end ( va ) ; }","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug>"
1164,CWE-264,"syscall_define6 ( sendto , int , fd , void __user * , buff , size_t , len , unsigned int , flags , struct sockaddr __user * , addr , int , addr_len ) { struct socket * sock ; struct sockaddr_storage address ; int err ; struct msghdr msg ; struct iovec iov ; int fput_needed ; if ( len > int_max ) len = int_max ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; iov . iov_base = buff ; iov . iov_len = len ; msg . msg_name = null ; iov_iter_init ( & msg . msg_iter , write , & iov , 1 , len ) ; msg . msg_control = null ; msg . msg_controllen = 0 ; msg . msg_namelen = 0 ; if ( addr ) { err = move_addr_to_kernel ( addr , addr_len , & address ) ; if ( err < 0 ) goto out_put ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = addr_len ; } if ( sock -> file -> f_flags & o_nonblock ) flags |= msg_dontwait ; msg . msg_flags = flags ; err = sock_sendmsg ( sock , & msg , len ) ; out_put : fput_light ( sock -> file , fput_needed ) ; out : return err ; }","<S2SV_ModStart> len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
",torvalds@linux/4de930efc23b92ddf88ce91c405ee645fe6e27ea,CVE-2015-2686,https://github.com/torvalds/linux/commit/4de930efc23b92ddf88ce91c405ee645fe6e27ea,2016-05-02T10:59Z,<S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug>
3121,CWE-119,"int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == usbip_stub ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ; ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<s2sv_blank>xbuf,<s2sv_blank>%d\\n"" , ret ) ; if ( ud -> side == usbip_stub ) { usbip_event_add ( ud , sdev_event_error_tcp ) ; } else { usbip_event_add ( ud , vdev_event_error_tcp ) ; return - epipe ; } } return ret ; }","<S2SV_ModStart> return 0 ; if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> if ( ud <S2SV_ModStart> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <S2SV_ModStart> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }
",torvalds@linux/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb,CVE-2016-3955,https://github.com/torvalds/linux/commit/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb,2016-07-03T21:59Z,"<S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug>"
4083,CWE-189,"static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; when = timespec_to_ns ( new_setting -> it_value ) ; period = timespec_to_ns ( new_setting -> it_interval ) ; if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , gfp_kernel ) ; if ( base == null ) return - enomem ; if ( flags & timer_abstime ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; now = timespec_to_ns ( n ) ; if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = timer_set ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , comparator ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }","<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
",torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z,<S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug>
4109,CWE-399,"long video_ioctl2 ( struct file * file , unsigned int cmd , unsigned long arg ) { char sbuf [ 128 ] ; void * mbuf = null ; void * parg = ( void * ) arg ; long err = - einval ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = null ; void * * kernel_ptr = null ; if ( _ioc_dir ( cmd ) != _ioc_none ) { if ( _ioc_size ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _ioc_size ( cmd ) , gfp_kernel ) ; if ( null == mbuf ) return - enomem ; parg = mbuf ; } err = - efault ; if ( _ioc_dir ( cmd ) & _ioc_write ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _ioc_size ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _ioc_size ( cmd ) - n ) ; } else { memset ( parg , 0 , _ioc_size ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , gfp_kernel ) ; err = - enomem ; if ( null == mbuf ) goto out_array_args ; err = - efault ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = __video_do_ioctl ( file , cmd , parg ) ; if ( err == - enoioctlcmd ) err = - einval ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - efault ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : switch ( _ioc_dir ( cmd ) ) { case _ioc_read : case ( _ioc_write | _ioc_read ) : if ( copy_to_user ( ( void __user * ) arg , parg , _ioc_size ( cmd ) ) ) err = - efault ; break ; } out : kfree ( mbuf ) ; return err ; }","<S2SV_ModStart> arg ) { return video_usercopy <S2SV_ModEnd> ( file , <S2SV_ModStart> , cmd , arg , __video_do_ioctl ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e,CVE-2010-5329,https://github.com/torvalds/linux/commit/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e,2017-04-24T06:59Z,"<S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug>"
7053,CWE-476,"void av1_rewriteesdescriptorex ( gf_mpegvisualsampleentrybox * av1 , gf_mediabox * mdia ) { gf_bitratebox * btrt = gf_isom_sample_entry_get_bitrate ( ( gf_sampleentrybox * ) av1 , gf_false ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( gf_descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderconfig -> streamtype = gf_stream_visual ; av1 -> emul_esd -> decoderconfig -> objecttypeindication = gf_codecid_av1 ; if ( btrt ) { av1 -> emul_esd -> decoderconfig -> buffersizedb = btrt -> buffersizedb ; av1 -> emul_esd -> decoderconfig -> avgbitrate = btrt -> avgbitrate ; av1 -> emul_esd -> decoderconfig -> maxbitrate = btrt -> maxbitrate ; } if ( av1 -> av1_config ) { gf_av1config * av1_cfg = av1_duplicateconfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderconfig -> decoderspecificinfo -> data , & av1 -> emul_esd -> decoderconfig -> decoderspecificinfo -> datalength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }","<S2SV_ModStart> av1 -> av1_config && av1 -> av1_config -> config
",gpac@gpac/b2eab95e07cb5819375a50358d4806a8813b6e50,CVE-2021-31262,https://github.com/gpac/gpac/commit/b2eab95e07cb5819375a50358d4806a8813b6e50,2021-04-19T19:15Z,<S2SV_StartBug> if ( av1 -> av1_config ) { <S2SV_EndBug>
910,CWE-399,"static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - etoomanyrefs ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > max_recursion_level ) ) return - etoomanyrefs ; unixcb ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! unixcb ( skb ) . fp ) return - enomem ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ; return max_level ; }","<S2SV_ModStart> -> fp -> user , scm -> fp ->
",torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z,<S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug>
595,CWE-20,"static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( kvm_reg_size ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - enoent ; if ( validate_core_offset ( reg ) ) return - einval ; if ( kvm_reg_size ( reg -> id ) > sizeof ( tmp ) ) return - einval ; if ( copy_from_user ( valp , uaddr , kvm_reg_size ( reg -> id ) ) ) { err = - efault ; goto out ; } if ( off == kvm_reg_arm_core_reg ( regs . pstate ) ) { u32 mode = ( * ( u32 * ) valp ) & psr_aa32_mode_mask ; switch ( mode ) { case psr_aa32_mode_usr : case psr_aa32_mode_fiq : case psr_aa32_mode_irq : case psr_aa32_mode_svc : case psr_aa32_mode_abt : case psr_aa32_mode_und : case psr_mode_el0t : case psr_mode_el1t : case psr_mode_el1h : break ; default : err = - einval ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , kvm_reg_size ( reg -> id ) ) ; out : return err ; }","<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
",torvalds@linux/2a3f93459d689d990b3ecfbe782fec89b97d3279,CVE-2018-18021,https://github.com/torvalds/linux/commit/2a3f93459d689d990b3ecfbe782fec89b97d3279,2018-10-07T06:29Z,<S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug>
2905,CWE-399,"static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; vcpu = kvm_arch_vcpu_create ( kvm , id ) ; if ( is_err ( vcpu ) ) return ptr_err ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; if ( atomic_read ( & kvm -> online_vcpus ) == kvm_max_vcpus ) { r = - einval ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - eexist ; goto unlock_vcpu_destroy ; } bug_on ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }","<S2SV_ModStart> ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if (
",torvalds@linux/9c895160d25a76c21b65bad141b08e8d4f99afef,CVE-2012-1601,https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef,2012-05-17T11:00Z,<S2SV_StartBug> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { <S2SV_EndBug>
2903,CWE-000,"static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( intf ) ; struct usb_host_interface * interface ; struct usb_endpoint_descriptor * endpoint ; struct powermate_device * pm ; struct input_dev * input_dev ; int pipe , maxp ; int error = - enomem ; interface = intf -> cur_altsetting ; endpoint = & interface -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_int_in ( endpoint ) ) return - eio ; usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0a , usb_type_class | usb_recip_interface , 0 , interface -> desc . binterfacenumber , null , 0 , usb_ctrl_set_timeout ) ; pm = kzalloc ( sizeof ( struct powermate_device ) , gfp_kernel ) ; input_dev = input_allocate_device ( ) ; if ( ! pm || ! input_dev ) goto fail1 ; if ( powermate_alloc_buffers ( udev , pm ) ) goto fail2 ; pm -> irq = usb_alloc_urb ( 0 , gfp_kernel ) ; if ( ! pm -> irq ) goto fail2 ; pm -> config = usb_alloc_urb ( 0 , gfp_kernel ) ; if ( ! pm -> config ) goto fail3 ; pm -> udev = udev ; pm -> intf = intf ; pm -> input = input_dev ; usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; strlcat ( pm -> phys , ""/input0"" , sizeof ( pm -> phys ) ) ; spin_lock_init ( & pm -> lock ) ; switch ( le16_to_cpu ( udev -> descriptor . idproduct ) ) { case powermate_product_new : input_dev -> name = pm_name_powermate ; break ; case powermate_product_old : input_dev -> name = pm_name_soundknob ; break ; default : input_dev -> name = pm_name_soundknob ; printk ( kern_warning ""powermate:<s2sv_blank>unknown<s2sv_blank>product<s2sv_blank>id<s2sv_blank>%04x\\n"" , le16_to_cpu ( udev -> descriptor . idproduct ) ) ; } input_dev -> phys = pm -> phys ; usb_to_input_id ( udev , & input_dev -> id ) ; input_dev -> dev . parent = & intf -> dev ; input_set_drvdata ( input_dev , pm ) ; input_dev -> event = powermate_input_event ; input_dev -> evbit [ 0 ] = bit_mask ( ev_key ) | bit_mask ( ev_rel ) | bit_mask ( ev_msc ) ; input_dev -> keybit [ bit_word ( btn_0 ) ] = bit_mask ( btn_0 ) ; input_dev -> relbit [ bit_word ( rel_dial ) ] = bit_mask ( rel_dial ) ; input_dev -> mscbit [ bit_word ( msc_pulseled ) ] = bit_mask ( msc_pulseled ) ; pipe = usb_rcvintpipe ( udev , endpoint -> bendpointaddress ) ; maxp = usb_maxpacket ( udev , pipe , usb_pipeout ( pipe ) ) ; if ( maxp < powermate_payload_size_min || maxp > powermate_payload_size_max ) { printk ( kern_warning ""powermate:<s2sv_blank>expected<s2sv_blank>payload<s2sv_blank>of<s2sv_blank>%d--%d<s2sv_blank>bytes,<s2sv_blank>found<s2sv_blank>%d<s2sv_blank>bytes!\\n"" , powermate_payload_size_min , powermate_payload_size_max , maxp ) ; maxp = powermate_payload_size_max ; } usb_fill_int_urb ( pm -> irq , udev , pipe , pm -> data , maxp , powermate_irq , pm , endpoint -> binterval ) ; pm -> irq -> transfer_dma = pm -> data_dma ; pm -> irq -> transfer_flags |= urb_no_transfer_dma_map ; if ( usb_submit_urb ( pm -> irq , gfp_kernel ) ) { error = - eio ; goto fail4 ; } error = input_register_device ( pm -> input ) ; if ( error ) goto fail5 ; pm -> requires_update = update_pulse_asleep | update_pulse_awake | update_pulse_mode | update_static_brightness ; powermate_pulse_led ( pm , 0x80 , 255 , 0 , 1 , 0 ) ; usb_set_intfdata ( intf , pm ) ; return 0 ; fail5 : usb_kill_urb ( pm -> irq ) ; fail4 : usb_free_urb ( pm -> config ) ; fail3 : usb_free_urb ( pm -> irq ) ; fail2 : powermate_free_buffers ( udev , pm ) ; fail1 : input_free_device ( input_dev ) ; kfree ( pm ) ; return error ; }","<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
",torvalds@linux/9c6ba456711687b794dcf285856fc14e2c76074f,CVE-2016-2186,https://github.com/torvalds/linux/commit/9c6ba456711687b794dcf285856fc14e2c76074f,2016-05-02T10:59Z,<S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug>
5103,CWE-119,"hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = null ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == null ) goto error ; h -> msglvl = flags & hivex_open_msglvl_mask ; const char * debug = getenv ( ""hivex_debug"" ) ; if ( debug && streq ( debug , ""1"" ) ) h -> msglvl = 2 ; debug ( 2 , ""created<s2sv_blank>handle<s2sv_blank>%p"" , h ) ; h -> writable = ! ! ( flags & hivex_open_write ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == null ) goto error ; # ifdef o_cloexec h -> fd = open ( filename , o_rdonly | o_cloexec | o_binary ) ; # else h -> fd = open ( filename , o_rdonly | o_binary ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef o_cloexec fcntl ( h -> fd , f_setfd , fd_cloexec ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( ! h -> writable ) { h -> addr = mmap ( null , h -> size , prot_read , map_shared , h -> fd , 0 ) ; if ( h -> addr == map_failed ) goto error ; debug ( 2 , ""mapped<s2sv_blank>file<s2sv_blank>at<s2sv_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == null ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { set_errno ( enotsup , ""%s:<s2sv_blank>not<s2sv_blank>a<s2sv_blank>windows<s2sv_blank>nt<s2sv_blank>registry<s2sv_blank>hive<s2sv_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { set_errno ( enotsup , ""%s:<s2sv_blank>hive<s2sv_blank>file<s2sv_blank>major<s2sv_blank>version<s2sv_blank>%"" priu32 ""<s2sv_blank>(expected<s2sv_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == null ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { set_errno ( einval , ""%s:<s2sv_blank>bad<s2sv_blank>checksum<s2sv_blank>in<s2sv_blank>hive<s2sv_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<s2sv_blank>header<s2sv_blank>fields:\\n"" ""<s2sv_blank><s2sv_blank>file<s2sv_blank>version<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%"" priu32 "".%"" priu32 ""\\n"" ""<s2sv_blank><s2sv_blank>sequence<s2sv_blank>nos<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%"" priu32 ""<s2sv_blank>%"" priu32 ""\\n"" ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(sequences<s2sv_blank>nos<s2sv_blank>should<s2sv_blank>match<s2sv_blank>if<s2sv_blank>hive<s2sv_blank>was<s2sv_blank>synched<s2sv_blank>at<s2sv_blank>shutdown)\\n"" ""<s2sv_blank><s2sv_blank>last<s2sv_blank>modified<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%"" priu64 ""\\n"" ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(windows<s2sv_blank>filetime,<s2sv_blank>x<s2sv_blank>100<s2sv_blank>ns<s2sv_blank>since<s2sv_blank>1601-01-01)\\n"" ""<s2sv_blank><s2sv_blank>original<s2sv_blank>file<s2sv_blank>name<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(only<s2sv_blank>32<s2sv_blank>chars<s2sv_blank>are<s2sv_blank>stored,<s2sv_blank>name<s2sv_blank>is<s2sv_blank>probably<s2sv_blank>truncated)\\n"" ""<s2sv_blank><s2sv_blank>root<s2sv_blank>offset<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>0x%x<s2sv_blank>+<s2sv_blank>0x1000\\n"" ""<s2sv_blank><s2sv_blank>end<s2sv_blank>of<s2sv_blank>last<s2sv_blank>page<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>0x%x<s2sv_blank>+<s2sv_blank>0x1000<s2sv_blank>(total<s2sv_blank>file<s2sv_blank>size<s2sv_blank>0x%zx)\\n"" ""<s2sv_blank><s2sv_blank>checksum<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>0x%x<s2sv_blank>(calculated<s2sv_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<s2sv_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; debug ( 2 , ""root<s2sv_blank>offset<s2sv_blank>=<s2sv_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = size_max , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = size_max , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { set_errno ( enotsup , ""%s:<s2sv_blank>trailing<s2sv_blank>garbage<s2sv_blank>at<s2sv_blank>end<s2sv_blank>of<s2sv_blank>file<s2sv_blank>"" ""(at<s2sv_blank>0x%zx,<s2sv_blank>after<s2sv_blank>%zu<s2sv_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; debug ( 2 , ""page<s2sv_blank>at<s2sv_blank>0x%zx,<s2sv_blank>size<s2sv_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { set_errno ( enotsup , ""%s:<s2sv_blank>page<s2sv_blank>size<s2sv_blank>%zu<s2sv_blank>at<s2sv_blank>0x%zx,<s2sv_blank>bad<s2sv_blank>registry"" , filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { set_errno ( enotsup , ""%s:<s2sv_blank>block<s2sv_blank>size<s2sv_blank>%"" priu32 ""<s2sv_blank>at<s2sv_blank>0x%zx,<s2sv_blank>bad<s2sv_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<s2sv_blank>%s:<s2sv_blank>"" ""%s<s2sv_blank>block<s2sv_blank>id<s2sv_blank>%d,%d<s2sv_blank>(%c%c)<s2sv_blank>at<s2sv_blank>0x%zx<s2sv_blank>size<s2sv_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<s2sv_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; bitmap_set ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { set_errno ( enotsup , ""%s:<s2sv_blank>no<s2sv_blank>root<s2sv_blank>block<s2sv_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { set_errno ( enotsup , ""%s:<s2sv_blank>bad<s2sv_blank>root<s2sv_blank>block<s2sv_blank>(free<s2sv_blank>or<s2sv_blank>not<s2sv_blank>nk)"" , filename ) ; goto error ; } debug ( 1 , ""successfully<s2sv_blank>read<s2sv_blank>windows<s2sv_blank>registry<s2sv_blank>hive<s2sv_blank>file:\\n"" ""<s2sv_blank><s2sv_blank>pages:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu<s2sv_blank>[sml:<s2sv_blank>%zu,<s2sv_blank>lge:<s2sv_blank>%zu]\\n"" ""<s2sv_blank><s2sv_blank>blocks:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu<s2sv_blank>[sml:<s2sv_blank>%zu,<s2sv_blank>avg:<s2sv_blank>%zu,<s2sv_blank>lge:<s2sv_blank>%zu]\\n"" ""<s2sv_blank><s2sv_blank>blocks<s2sv_blank>used:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu\\n"" ""<s2sv_blank><s2sv_blank>bytes<s2sv_blank>used:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != map_failed ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return null ; }","<S2SV_ModStart> . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; }
",libguestfs@hivex/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,2014-12-08T16:59Z,<S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug>
3720,CWE-362,"static int ext4_split_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_map_blocks * map , int split_flag , int flags ) { ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len , depth ; int err = 0 ; int uninitialized ; int split_flag1 , flags1 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; uninitialized = ext4_ext_is_uninitialized ( ex ) ; if ( map -> m_lblk + map -> m_len < ee_block + ee_len ) { split_flag1 = split_flag & ext4_ext_may_zeroout ? ext4_ext_may_zeroout : 0 ; flags1 = flags | ext4_get_blocks_pre_io ; if ( uninitialized ) split_flag1 |= ext4_ext_mark_uninit1 | ext4_ext_mark_uninit2 ; err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ; if ( err ) goto out ; } ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( is_err ( path ) ) return ptr_err ( path ) ; if ( map -> m_lblk >= ee_block ) { split_flag1 = split_flag & ext4_ext_may_zeroout ? ext4_ext_may_zeroout : 0 ; if ( uninitialized ) split_flag1 |= ext4_ext_mark_uninit1 ; if ( split_flag & ext4_ext_mark_uninit2 ) split_flag1 |= ext4_ext_mark_uninit2 ; err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk , split_flag1 , flags ) ; if ( err ) goto out ; } ext4_ext_show_leaf ( inode , path ) ; out : return err ? err : map -> m_len ; }","<S2SV_ModStart> split_flag & EXT4_EXT_MAY_ZEROOUT <S2SV_ModEnd> ; flags1 = <S2SV_ModStart> | EXT4_EXT_MARK_UNINIT2 ; if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> ; if (
",torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531,CVE-2012-4508,https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531,2012-12-21T11:47Z,"<S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug>"
284,CWE-416,"static ssize_t bsg_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct bsg_device * bd = file -> private_data ; ssize_t bytes_written ; int ret ; dprintk ( ""%s:<s2sv_blank>write<s2sv_blank>%zd<s2sv_blank>bytes\\n"" , bd -> name , count ) ; bsg_set_block ( bd , file ) ; bytes_written = 0 ; ret = __bsg_write ( bd , buf , count , & bytes_written , file -> f_mode & fmode_write ) ; * ppos = bytes_written ; if ( ! bytes_written || err_block_err ( ret ) ) bytes_written = ret ; dprintk ( ""%s:<s2sv_blank>returning<s2sv_blank>%zd\\n"" , bd -> name , bytes_written ) ; return bytes_written ; }","<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
",torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835,CVE-2016-10088,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,2016-12-30T18:59Z,"<S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug>"
1257,CWE-264,"static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; init_list_head ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= iff_master | iff_multicast ; bond_dev -> priv_flags |= iff_bonding ; bond_dev -> priv_flags &= ~ iff_xmit_dst_release ; bond_dev -> features |= netif_f_vlan_challenged ; bond_dev -> features |= netif_f_lltx ; bond_dev -> hw_features = bond_vlan_features | netif_f_hw_vlan_tx | netif_f_hw_vlan_rx | netif_f_hw_vlan_filter ; bond_dev -> hw_features &= ~ ( netif_f_all_csum & ~ netif_f_no_csum ) ; bond_dev -> features |= bond_dev -> hw_features ; }","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; bond_dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug>
6530,CWE-119,cjson * cjson_createtrue ( void ) { cjson * item = cjson_new_item ( ) ; if ( item ) item -> type = cjson_true ; return item ; },"
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
118,CWE-285,"int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > gfs2_acl_max_entries ( gfs2_sb ( inode ) ) ) return - e2big ; if ( type == acl_type_access ) { umode_t mode = inode -> i_mode ; error = posix_acl_equiv_mode ( acl , & mode ) ; if ( error < 0 ) return error ; if ( error == 0 ) acl = null ; if ( mode != inode -> i_mode ) { inode -> i_mode = mode ; mark_inode_dirty ( inode ) ; } } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , null , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , gfp_nofs ) ; if ( data == null ) return - enomem ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = null ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , gfs2_eatype_sys ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }","<S2SV_ModStart> ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } if (
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
2961,CWE-399,"int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = x86emul_continue ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = op_none ; ctxt -> memopp = null ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != x86emul_continue ) return rc ; } switch ( mode ) { case x86emul_mode_real : case x86emul_mode_vm86 : case x86emul_mode_prot16 : def_op_bytes = def_ad_bytes = 2 ; break ; case x86emul_mode_prot32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef config_x86_64 case x86emul_mode_prot64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return emulation_failed ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == x86emul_mode_prot64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != x86emul_mode_prot64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & modrm ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == x86emul_mode_prot64 || ( mode >= x86emul_mode_prot16 && ( ctxt -> modrm & 0x80 ) ) ) ) { ctxt -> d = notimpl ; } while ( ctxt -> d & groupmask ) { switch ( ctxt -> d & groupmask ) { case group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case groupdual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case rmext : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case prefix : if ( ctxt -> rep_prefix && op_prefix ) return emulation_failed ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; default : return emulation_failed ; } ctxt -> d &= ~ ( u64 ) groupmask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return emulation_failed ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & emulateonud ) ) ) return emulation_failed ; if ( unlikely ( ctxt -> d & ( notimpl | stack | op3264 | sse | mmx | intercept | checkperm ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & notimpl ) return emulation_failed ; if ( mode == x86emul_mode_prot64 && ( ctxt -> d & stack ) ) ctxt -> op_bytes = 8 ; if ( ctxt -> d & op3264 ) { if ( mode == x86emul_mode_prot64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ctxt -> d & sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & modrm ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & memabs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != x86emul_continue ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = vcpu_sreg_ds ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> srcshift ) & opmask ) ; if ( rc != x86emul_continue ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> src2shift ) & opmask ) ; if ( rc != x86emul_continue ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> dstshift ) & opmask ) ; done : if ( ctxt -> rip_relative ) ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; return ( rc != x86emul_continue ) ? emulation_failed : emulation_ok ; }","<S2SV_ModStart> OpMask ) ; <S2SV_ModEnd> if ( ctxt <S2SV_ModStart> -> _eip ; done :
",torvalds@linux/a430c9166312e1aa3d80bce32374233bdbfeba32,CVE-2014-8481,https://github.com/torvalds/linux/commit/a430c9166312e1aa3d80bce32374233bdbfeba32,2014-11-10T11:55Z,<S2SV_StartBug> done : <S2SV_EndBug> <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug>
4004,CWE-20,"static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - einval ; if ( flags & ~ ( msg_peek | msg_dontwait | msg_trunc | msg_cmsg_compat ) ) goto out ; msg -> msg_namelen = 0 ; skb = skb_recv_datagram ( sk , flags , flags & msg_dontwait , & err ) ; if ( skb == null ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= msg_trunc ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & msg_trunc ) ? skb -> len : copied ; if ( pfk -> dump . dump != null && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }","<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug>
509,CWE-125,"int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { u16 offset = sizeof ( struct ipv6hdr ) ; struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset + 1 <= packet_len ) { switch ( * * nexthdr ) { case nexthdr_hop : break ; case nexthdr_routing : found_rhdr = 1 ; break ; case nexthdr_dest : # if is_enabled ( config_ipv6_mip6 ) if ( ipv6_find_tlv ( skb , offset , ipv6_tlv_hao ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } offset += ipv6_optlen ( exthdr ) ; * nexthdr = & exthdr -> nexthdr ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; } return offset ; }","<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug>
6940,CWE-400,"static void perf_event_read_event ( struct perf_event * event , struct task_struct * task ) { struct perf_output_handle handle ; struct perf_sample_data sample ; struct perf_read_event read_event = { . header = { . type = perf_record_read , . misc = 0 , . size = sizeof ( read_event ) + event -> read_size , } , . pid = perf_event_pid ( event , task ) , . tid = perf_event_tid ( event , task ) , } ; int ret ; perf_event_header__init_id ( & read_event . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; if ( ret ) return ; perf_output_put ( & handle , read_event ) ; perf_output_read ( & handle , event ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; }","<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <S2SV_EndBug>"
3756,CWE-200,"static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { list_head ( tmp_list ) ; struct mount * p ; if ( how & umount_propagate ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= mnt_umount ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & umount_propagate ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { bool disconnect ; p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = null ; if ( how & umount_sync ) p -> mnt . mnt_flags |= mnt_sync_umount ; disconnect = ! is_mnt_locked_and_lazy ( p ) ; pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : null ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , ms_private ) ; } }","<S2SV_ModStart> disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
",torvalds@linux/e0c9c0afd2fc958ffa34b697972721d81df8a56f,CVE-2015-4176,https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f,2016-05-02T10:59Z,<S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug>
7382,CWE-401,"static int mlx5_fw_fatal_reporter_dump ( struct devlink_health_reporter * reporter , struct devlink_fmsg * fmsg , void * priv_ctx ) { struct mlx5_core_dev * dev = devlink_health_reporter_priv ( reporter ) ; u32 crdump_size = dev -> priv . health . crdump_size ; u32 * cr_data ; u32 data_size ; u32 offset ; int err ; if ( ! mlx5_core_is_pf ( dev ) ) return - eperm ; cr_data = kvmalloc ( crdump_size , gfp_kernel ) ; if ( ! cr_data ) return - enomem ; err = mlx5_crdump_collect ( dev , cr_data ) ; if ( err ) return err ; if ( priv_ctx ) { struct mlx5_fw_reporter_ctx * fw_reporter_ctx = priv_ctx ; err = mlx5_fw_reporter_ctx_pairs_put ( fmsg , fw_reporter_ctx ) ; if ( err ) goto free_data ; } err = devlink_fmsg_arr_pair_nest_start ( fmsg , ""crdump_data"" ) ; if ( err ) goto free_data ; for ( offset = 0 ; offset < crdump_size ; offset += data_size ) { if ( crdump_size - offset < mlx5_cr_dump_chunk_size ) data_size = crdump_size - offset ; else data_size = mlx5_cr_dump_chunk_size ; err = devlink_fmsg_binary_put ( fmsg , ( char * ) cr_data + offset , data_size ) ; if ( err ) goto free_data ; } err = devlink_fmsg_arr_pair_nest_end ( fmsg ) ; free_data : kvfree ( cr_data ) ; return err ; }","<S2SV_ModStart> ( err ) goto free_data <S2SV_ModEnd> ; if (
",torvalds@linux/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471,CVE-2019-19047,https://github.com/torvalds/linux/commit/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471,2019-11-18T06:15Z,<S2SV_StartBug> return err ; <S2SV_EndBug>
3137,CWE-119,"static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & o_nonblock ) && ( socket_client -> queue_len == 0 ) ) return - eagain ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - einval ; if ( ! access_ok ( verify_write , buf , count ) ) return - efault ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; error = copy_to_user ( buf , & socket_packet -> icmp_packet , socket_packet -> icmp_len ) ; packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - efault ; return packet_len ; }","<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree (
",torvalds@linux/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c,CVE-2011-4604,https://github.com/torvalds/linux/commit/b5a1eeef04cc7859f34dec9b72ea1b28e4aba07c,2013-06-07T14:03Z,"<S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug>"
5873,CWE-125,"int imagingpcxdecode ( imaging im , imagingcodecstate state , uint8 * buf , py_ssize_t bytes ) { uint8 n ; uint8 * ptr ; if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) { state -> errcode = imaging_codec_overrun ; return - 1 ; } else if ( strcmp ( im -> mode , ""p"" ) == 0 && state -> xsize > state -> bytes ) { state -> errcode = imaging_codec_overrun ; return - 1 ; } ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xc0 ) == 0xc0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3f ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = imaging_codec_overrun ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( uint8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { return - 1 ; } } } }","<S2SV_ModStart> ; if ( ( state -> xsize * state -> bits + 7 ) / 8 <S2SV_ModEnd> > state -> <S2SV_ModStart> state -> bytes <S2SV_ModEnd> ) { state <S2SV_ModStart> 1 ; } ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } <S2SV_ModEnd> } } }
",python-pillow@Pillow/6a83e4324738bb0452fbe8074a995b1c73f08de7,CVE-2020-10378,https://github.com/python-pillow/Pillow/commit/6a83e4324738bb0452fbe8074a995b1c73f08de7,2020-06-25T19:15Z,"<S2SV_StartBug> if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( im -> mode , ""P"" ) == 0 && state -> xsize > state -> bytes ) { <S2SV_EndBug> <S2SV_StartBug> ptr = buf ; <S2SV_EndBug>"
611,CWE-416,"static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = null ; mm -> mm_rb = rb_root ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; init_list_head ( & mm -> mmlist ) ; mm -> core_state = null ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; mmu_notifier_mm_init ( mm ) ; init_tlb_flush_pending ( mm ) ; # if defined ( config_transparent_hugepage ) && ! use_split_pmd_ptlocks mm -> pmd_huge_pte = null ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & mmf_init_mask ; mm -> def_flags = current -> mm -> def_flags & vm_init_def_mask ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return null ; }","<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
",torvalds@linux/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,CVE-2017-17052,https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,2017-11-29T03:29Z,<S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug>
285,CWE-416,"static ssize_t sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) { int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; sg_device * sdp ; sg_fd * sfp ; sg_request * srp ; struct sg_header old_hdr ; sg_io_hdr_t * hp ; unsigned char cmnd [ sg_max_cdb_size ] ; if ( ( ! ( sfp = ( sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - enxio ; scsi_log_timeout ( 3 , sg_printk ( kern_info , sdp , ""sg_write:<s2sv_blank>count=%d\\n"" , ( int ) count ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; if ( ! ( ( filp -> f_flags & o_nonblock ) || scsi_block_when_processing_errors ( sdp -> device ) ) ) return - enxio ; if ( ! access_ok ( verify_read , buf , count ) ) return - efault ; if ( count < sz_sg_header ) return - eio ; if ( __copy_from_user ( & old_hdr , buf , sz_sg_header ) ) return - efault ; blocking = ! ( filp -> f_flags & o_nonblock ) ; if ( old_hdr . reply_len < 0 ) return sg_new_write ( sfp , filp , buf , count , blocking , 0 , 0 , null ) ; if ( count < ( sz_sg_header + 6 ) ) return - eio ; if ( ! ( srp = sg_add_request ( sfp ) ) ) { scsi_log_timeout ( 1 , sg_printk ( kern_info , sdp , ""sg_write:<s2sv_blank>queue<s2sv_blank>full\\n"" ) ) ; return - edom ; } buf += sz_sg_header ; __get_user ( opcode , buf ) ; if ( sfp -> next_cmd_len > 0 ) { cmd_size = sfp -> next_cmd_len ; sfp -> next_cmd_len = 0 ; } else { cmd_size = command_size ( opcode ) ; if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) cmd_size = 12 ; } scsi_log_timeout ( 4 , sg_printk ( kern_info , sdp , ""sg_write:<s2sv_blank><s2sv_blank><s2sv_blank>scsi<s2sv_blank>opcode=0x%02x,<s2sv_blank>cmd_size=%d\\n"" , ( int ) opcode , cmd_size ) ) ; input_size = count - cmd_size ; mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; mxsize -= sz_sg_header ; input_size -= sz_sg_header ; if ( input_size < 0 ) { sg_remove_request ( sfp , srp ) ; return - eio ; } hp = & srp -> header ; hp -> interface_id = '\\0' ; hp -> cmd_len = ( unsigned char ) cmd_size ; hp -> iovec_count = 0 ; hp -> mx_sb_len = 0 ; if ( input_size > 0 ) hp -> dxfer_direction = ( old_hdr . reply_len > sz_sg_header ) ? sg_dxfer_to_from_dev : sg_dxfer_to_dev ; else hp -> dxfer_direction = ( mxsize > 0 ) ? sg_dxfer_from_dev : sg_dxfer_none ; hp -> dxfer_len = mxsize ; if ( ( hp -> dxfer_direction == sg_dxfer_to_dev ) || ( hp -> dxfer_direction == sg_dxfer_to_from_dev ) ) hp -> dxferp = ( char __user * ) buf + cmd_size ; else hp -> dxferp = null ; hp -> sbp = null ; hp -> timeout = old_hdr . reply_len ; hp -> flags = input_size ; hp -> pack_id = old_hdr . pack_id ; hp -> usr_ptr = null ; if ( __copy_from_user ( cmnd , buf , cmd_size ) ) return - efault ; if ( hp -> dxfer_direction == sg_dxfer_to_from_dev ) { static char cmd [ task_comm_len ] ; if ( strcmp ( current -> comm , cmd ) ) { printk_ratelimited ( kern_warning ""sg_write:<s2sv_blank>data<s2sv_blank>in/out<s2sv_blank>%d/%d<s2sv_blank>bytes<s2sv_blank>"" ""for<s2sv_blank>scsi<s2sv_blank>command<s2sv_blank>0x%x--<s2sv_blank>guessing<s2sv_blank>"" ""data<s2sv_blank>in;\\n<s2sv_blank><s2sv_blank><s2sv_blank>program<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>setting<s2sv_blank>"" ""count<s2sv_blank>and/or<s2sv_blank>reply_len<s2sv_blank>properly\\n"" , old_hdr . reply_len - ( int ) sz_sg_header , input_size , ( unsigned int ) cmnd [ 0 ] , current -> comm ) ; strcpy ( cmd , current -> comm ) ; } } k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; return ( k < 0 ) ? k : count ; }","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (
",torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835,CVE-2016-10088,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,2016-12-30T18:59Z,<S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug>
2439,CWE-399,"long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = null ; struct eventfd_ctx * ctx = null ; u64 p ; long r ; int i , fd ; if ( ioctl == vhost_set_owner ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case vhost_set_mem_table : r = vhost_set_memory ( d , argp ) ; break ; case vhost_set_log_base : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - efault ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - efault ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - efault ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case vhost_set_log_fd : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? null : eventfd_fget ( fd ) ; if ( is_err ( eventfp ) ) { r = ptr_err ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ; ctx = d -> log_ctx ; d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : null ; } else filep = eventfp ; for ( i = 0 ; i < d -> nvqs ; ++ i ) { mutex_lock ( & d -> vqs [ i ] -> mutex ) ; d -> vqs [ i ] -> log_ctx = d -> log_ctx ; mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; } if ( ctx ) eventfd_ctx_put ( ctx ) ; if ( filep ) fput ( filep ) ; break ; default : r = - enoioctlcmd ; break ; } done : return r ; }","<S2SV_ModStart> -> log_file ; d -> log_file = eventfp ;
",torvalds@linux/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5,CVE-2015-6252,https://github.com/torvalds/linux/commit/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5,2015-10-19T10:59Z,<S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug>
7616,CWE-190,"jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; size_t size ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { goto error ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { goto error ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; }","<S2SV_ModStart> * jas_matrix_create ( jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> numcols ) { <S2SV_ModStart> * matrix ; jas_matind_t <S2SV_ModEnd> i ; size_t
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug>"
5334,CWE-401,"static int sof_set_get_large_ctrl_data ( struct snd_sof_dev * sdev , struct sof_ipc_ctrl_data * cdata , struct sof_ipc_ctrl_data_params * sparams , bool send ) { struct sof_ipc_ctrl_data * partdata ; size_t send_bytes ; size_t offset = 0 ; size_t msg_bytes ; size_t pl_size ; int err ; int i ; partdata = kzalloc ( sof_ipc_msg_max_size , gfp_kernel ) ; if ( ! partdata ) return - enomem ; if ( send ) err = sof_get_ctrl_copy_params ( cdata -> type , cdata , partdata , sparams ) ; else err = sof_get_ctrl_copy_params ( cdata -> type , partdata , cdata , sparams ) ; if ( err < 0 ) return err ; msg_bytes = sparams -> msg_bytes ; pl_size = sparams -> pl_size ; memcpy ( partdata , cdata , sparams -> hdr_bytes ) ; mutex_lock ( & sdev -> ipc -> tx_mutex ) ; for ( i = 0 ; i < sparams -> num_msg ; i ++ ) { send_bytes = min ( msg_bytes , pl_size ) ; partdata -> num_elems = send_bytes ; partdata -> rhdr . hdr . size = sparams -> hdr_bytes + send_bytes ; partdata -> msg_index = i ; msg_bytes -= send_bytes ; partdata -> elems_remaining = msg_bytes ; if ( send ) memcpy ( sparams -> dst , sparams -> src + offset , send_bytes ) ; err = sof_ipc_tx_message_unlocked ( sdev -> ipc , partdata -> rhdr . hdr . cmd , partdata , partdata -> rhdr . hdr . size , partdata , partdata -> rhdr . hdr . size ) ; if ( err < 0 ) break ; if ( ! send ) memcpy ( sparams -> dst + offset , sparams -> src , send_bytes ) ; offset += pl_size ; } mutex_unlock ( & sdev -> ipc -> tx_mutex ) ; kfree ( partdata ) ; return err ; }","<S2SV_ModStart> < 0 ) { kfree ( partdata ) ; <S2SV_ModStart> return err ; }
",torvalds@linux/45c1380358b12bf2d1db20a5874e9544f56b34ab,CVE-2019-18811,https://github.com/torvalds/linux/commit/45c1380358b12bf2d1db20a5874e9544f56b34ab,2019-11-07T16:15Z,<S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug>
3027,CWE-399,"int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , regs , 0 ) ; if ( ! ( task_thread_info ( tsk ) -> status & ts_usedfpu ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= ts_usedfpu ; } return fpu_emulate ( inst , fpu , regs ) ; }","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
8325,CWE-125,"static bool autodetect_recv_bandwidth_measure_results ( rdprdp * rdp , wstream * s , autodetect_rsp_pdu * autodetectrsppdu ) { bool success = true ; if ( autodetectrsppdu -> headerlength != 0x0e ) return false ; wlog_vrb ( autodetect_tag , ""received<s2sv_blank>bandwidth<s2sv_blank>measure<s2sv_blank>results<s2sv_blank>pdu"" ) ; stream_read_uint32 ( s , rdp -> autodetect -> bandwidthmeasuretimedelta ) ; stream_read_uint32 ( s , rdp -> autodetect -> bandwidthmeasurebytecount ) ; if ( rdp -> autodetect -> bandwidthmeasuretimedelta > 0 ) rdp -> autodetect -> netcharbandwidth = rdp -> autodetect -> bandwidthmeasurebytecount * 8 / rdp -> autodetect -> bandwidthmeasuretimedelta ; else rdp -> autodetect -> netcharbandwidth = 0 ; ifcallret ( rdp -> autodetect -> bandwidthmeasureresults , success , rdp -> context , autodetectrsppdu -> sequencenumber ) ; return success ; }","<S2SV_ModStart> , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1
",FreeRDP@FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65,CVE-2020-11047,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,2020-05-07T20:15Z,"<S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug>"
761,CWE-20,"static int __key_instantiate_and_link ( struct key * key , struct key_preparsed_payload * prep , struct key * keyring , struct key * authkey , struct assoc_array_edit * * _edit ) { int ret , awaken ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - ebusy ; mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( key_flag_instantiated , & key -> flags ) ) { ret = key -> type -> instantiate ( key , prep ) ; if ( ret == 0 ) { atomic_inc ( & key -> user -> nikeys ) ; set_bit ( key_flag_instantiated , & key -> flags ) ; if ( test_and_clear_bit ( key_flag_user_construct , & key -> flags ) ) awaken = 1 ; if ( keyring ) { if ( test_bit ( key_flag_keep , & keyring -> flags ) ) set_bit ( key_flag_keep , & key -> flags ) ; __key_link ( key , _edit ) ; } if ( authkey ) key_revoke ( authkey ) ; if ( prep -> expiry != time_t_max ) { key -> expiry = prep -> expiry ; key_schedule_gc ( prep -> expiry + key_gc_delay ) ; } } } mutex_unlock ( & key_construction_mutex ) ; if ( awaken ) wake_up_bit ( & key -> flags , key_flag_user_construct ) ; return ret ; }","<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug>"
2358,CWE-000,"static int handle_vmon ( struct kvm_vcpu * vcpu ) { int ret ; gpa_t vmptr ; struct page * page ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; const u64 vmxon_needed_features = feature_control_locked | feature_control_vmxon_enabled_outside_smx ; if ( ! kvm_read_cr4_bits ( vcpu , x86_cr4_vmxe ) ) { kvm_queue_exception ( vcpu , ud_vector ) ; return 1 ; } if ( vmx -> nested . vmxon ) { nested_vmx_failvalid ( vcpu , vmxerr_vmxon_in_vmx_root_operation ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( ( vmx -> msr_ia32_feature_control & vmxon_needed_features ) != vmxon_needed_features ) { kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } if ( nested_vmx_get_vmptr ( vcpu , & vmptr ) ) return 1 ; if ( ! page_aligned ( vmptr ) || ( vmptr >> cpuid_maxphyaddr ( vcpu ) ) ) { nested_vmx_failinvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } page = kvm_vcpu_gpa_to_page ( vcpu , vmptr ) ; if ( is_error_page ( page ) ) { nested_vmx_failinvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( * ( u32 * ) kmap ( page ) != vmcs12_revision ) { kunmap ( page ) ; kvm_release_page_clean ( page ) ; nested_vmx_failinvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } kunmap ( page ) ; kvm_release_page_clean ( page ) ; vmx -> nested . vmxon_ptr = vmptr ; ret = enter_vmx_operation ( vcpu ) ; if ( ret ) return ret ; nested_vmx_succeed ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; }","<S2SV_ModStart> vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
",torvalds@linux/727ba748e110b4de50d142edca9d6a9b7e6111d8,CVE-2018-12904,https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8,2018-06-27T11:29Z,"<S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug>"
4533,CWE-125,"pyobject * ast2obj_type_ignore ( void * _o ) { type_ignore_ty o = ( type_ignore_ty ) _o ; pyobject * result = null , * value = null ; if ( ! o ) { py_incref ( py_none ) ; return py_none ; } switch ( o -> kind ) { case typeignore_kind : result = pytype_genericnew ( typeignore_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_int ( o -> v . typeignore . lineno ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_lineno , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; } return result ; failed : py_xdecref ( value ) ; py_xdecref ( result ) ; return null ; }","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
870,CWE-200,"static void sg_fill_request_table ( sg_fd * sfp , sg_req_info_t * rinfo ) { sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > sg_max_queue ) break ; memset ( & rinfo [ val ] , 0 , sz_sg_req_info ) ; rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }","<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
",torvalds@linux/3e0097499839e0fe3af380410eababe5a47c4cf9,CVE-2017-14991,https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9,2017-10-04T01:29Z,"<S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug>"
6706,CWE-787,"static int xdp_umem_reg ( struct xdp_umem * umem , struct xdp_umem_reg * mr ) { bool unaligned_chunks = mr -> flags & xdp_umem_unaligned_chunk_flag ; u32 chunk_size = mr -> chunk_size , headroom = mr -> headroom ; unsigned int chunks , chunks_per_page ; u64 addr = mr -> addr , size = mr -> len ; int size_chk , err ; if ( chunk_size < xdp_umem_min_chunk_size || chunk_size > page_size ) { return - einval ; } if ( mr -> flags & ~ ( xdp_umem_unaligned_chunk_flag | xdp_umem_uses_need_wakeup ) ) return - einval ; if ( ! unaligned_chunks && ! is_power_of_2 ( chunk_size ) ) return - einval ; if ( ! page_aligned ( addr ) ) { return - einval ; } if ( ( addr + size ) < addr ) return - einval ; chunks = ( unsigned int ) div_u64 ( size , chunk_size ) ; if ( chunks == 0 ) return - einval ; if ( ! unaligned_chunks ) { chunks_per_page = page_size / chunk_size ; if ( chunks < chunks_per_page || chunks % chunks_per_page ) return - einval ; } size_chk = chunk_size - headroom - xdp_packet_headroom ; if ( size_chk < 0 ) return - einval ; umem -> address = ( unsigned long ) addr ; umem -> chunk_mask = unaligned_chunks ? xsk_unaligned_buf_addr_mask : ~ ( ( u64 ) chunk_size - 1 ) ; umem -> size = size ; umem -> headroom = headroom ; umem -> chunk_size_nohr = chunk_size - headroom ; umem -> npgs = size / page_size ; umem -> pgs = null ; umem -> user = null ; umem -> flags = mr -> flags ; init_list_head ( & umem -> xsk_list ) ; spin_lock_init ( & umem -> xsk_list_lock ) ; refcount_set ( & umem -> users , 1 ) ; err = xdp_umem_account_pages ( umem ) ; if ( err ) return err ; err = xdp_umem_pin_pages ( umem ) ; if ( err ) goto out_account ; umem -> pages = kvcalloc ( umem -> npgs , sizeof ( * umem -> pages ) , gfp_kernel_account ) ; if ( ! umem -> pages ) { err = - enomem ; goto out_pin ; } err = xdp_umem_map_pages ( umem ) ; if ( ! err ) return 0 ; kvfree ( umem -> pages ) ; out_pin : xdp_umem_unpin_pages ( umem ) ; out_account : xdp_umem_unaccount_pages ( umem ) ; return err ; }","<S2SV_ModStart> len ; int <S2SV_ModEnd> err ; if <S2SV_ModStart> EINVAL ; } if ( headroom >= chunk_size - XDP_PACKET_HEADROOM <S2SV_ModEnd> ) return -
",torvalds@linux/99e3a236dd43d06c65af0a2ef9cb44306aef6e02,CVE-2020-12659,https://github.com/torvalds/linux/commit/99e3a236dd43d06c65af0a2ef9cb44306aef6e02,2020-05-05T07:15Z,"<S2SV_StartBug> int size_chk , err ; <S2SV_EndBug> <S2SV_StartBug> size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ; <S2SV_EndBug>"
106,CWE-264,"int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , o_wronly | o_creat | o_cloexec | o_noctty , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ; if ( mode != mode_invalid ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != uid_invalid || gid != gid_invalid ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != usec_infinity ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , null ) ; if ( r < 0 ) return - errno ; return 0 ; }","<S2SV_ModStart> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> ) ; if
",systemd@systemd/06eeacb6fe029804f296b065b3ce91e796e1cd0e,CVE-2016-10156,https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e,2017-01-23T07:59Z,"<S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug>"
7171,CWE-552,"static ssize_t _consolefs_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = null ; size_t buf_size = 0 ; if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > oe_iov_max ) oe_raise_errno ( oe_einval ) ; if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) oe_raise_errno ( oe_enomem ) ; if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != oe_ok ) { oe_raise_errno ( oe_einval ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>"
5467,CWE-362,"int my_redel ( const char * org_name , const char * tmp_name , myf myflags ) { int error = 1 ; dbug_enter ( ""my_redel"" ) ; dbug_print ( ""my"" , ( ""org_name:<s2sv_blank>\'%s\'<s2sv_blank>tmp_name:<s2sv_blank>\'%s\'<s2sv_blank><s2sv_blank>myflags:<s2sv_blank>%d"" , org_name , tmp_name , myflags ) ) ; if ( my_copystat ( org_name , tmp_name , myflags ) < 0 ) goto end ; if ( myflags & my_redel_make_backup ) { char name_buff [ fn_reflen + 20 ] ; char ext [ 20 ] ; ext [ 0 ] = '-' ; get_date ( ext + 1 , 2 + 4 , ( time_t ) 0 ) ; strmov ( strend ( ext ) , redel_ext ) ; if ( my_rename ( org_name , fn_format ( name_buff , org_name , """" , ext , 2 ) , myflags ) ) goto end ; } else if ( my_delete_allow_opened ( org_name , myflags ) ) goto end ; if ( my_rename ( tmp_name , org_name , myflags ) ) goto end ; error = 0 ; end : dbug_return ( error ) ; }","<S2SV_ModStart> ; if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> goto end ; }
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,"<S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug>"
7228,CWE-19,"static int ext2_xattr_cache_insert ( struct buffer_head * bh ) { __u32 hash = le32_to_cpu ( hdr ( bh ) -> h_hash ) ; struct mb_cache_entry * ce ; int error ; ce = mb_cache_entry_alloc ( ext2_xattr_cache , gfp_nofs ) ; if ( ! ce ) return - enomem ; error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; if ( error ) { mb_cache_entry_free ( ce ) ; if ( error == - ebusy ) { ea_bdebug ( bh , ""already<s2sv_blank>in<s2sv_blank>cache<s2sv_blank>(%d<s2sv_blank>cache<s2sv_blank>entries)"" , atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; error = 0 ; } } else { ea_bdebug ( bh , ""inserting<s2sv_blank>[%x]<s2sv_blank>(%d<s2sv_blank>cache<s2sv_blank>entries)"" , ( int ) hash , atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; mb_cache_entry_release ( ce ) ; } return error ; }","<S2SV_ModStart> int ext2_xattr_cache_insert ( struct mb2_cache * cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <S2SV_ModEnd> , bh -> <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> } } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> ( bh , ""inserting<S2SV_blank>[%x]"" <S2SV_ModEnd> , ( int <S2SV_ModStart> int ) hash ) ; <S2SV_ModEnd> return error ;
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,"<S2SV_StartBug> ext2_xattr_cache_insert ( struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash , <S2SV_EndBug>"
295,CWE-264,"int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , struct mount * source_mnt , struct list_head * tree_list ) { struct mount * m , * child ; int ret = 0 ; struct mount * prev_dest_mnt = dest_mnt ; struct mount * prev_src_mnt = source_mnt ; list_head ( tmp_list ) ; list_head ( umount_list ) ; for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; m = propagation_next ( m , dest_mnt ) ) { int type ; struct mount * source ; if ( is_mnt_new ( m ) ) continue ; source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; child = copy_tree ( source , source -> mnt . mnt_root , type ) ; if ( is_err ( child ) ) { ret = ptr_err ( child ) ; list_splice ( tree_list , tmp_list . prev ) ; goto out ; } if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { mnt_set_mountpoint ( m , dest_dentry , child ) ; list_add_tail ( & child -> mnt_hash , tree_list ) ; } else { list_add_tail ( & child -> mnt_hash , & tmp_list ) ; } prev_dest_mnt = m ; prev_src_mnt = child ; } out : br_write_lock ( & vfsmount_lock ) ; while ( ! list_empty ( & tmp_list ) ) { child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; umount_tree ( child , 0 , & umount_list ) ; } br_write_unlock ( & vfsmount_lock ) ; release_mounts ( & umount_list ) ; return ret ; }","<S2SV_ModStart> ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
",torvalds@linux/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,CVE-2013-1957,https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,2013-04-24T19:55Z,"<S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug>"
8402,CWE-125,"static ssize_t parse8bim ( image * ifile , image * ofile ) { char brkused , quoted , * line , * token , * newstr , * name ; int state , next ; unsigned char dataset ; unsigned int recnum ; int inputlen = magickpathextent ; magickoffsettype savedpos , currentpos ; ssize_t savedolen = 0l , outputlen = 0l ; tokeninfo * token_info ; dataset = 0 ; recnum = 0 ; line = ( char * ) acquirequantummemory ( ( size_t ) inputlen , sizeof ( * line ) ) ; if ( line == ( char * ) null ) return ( - 1 ) ; newstr = name = token = ( char * ) null ; savedpos = 0 ; token_info = acquiretokeninfo ( ) ; while ( super_fgets ( & line , & inputlen , ifile ) != null ) { state = 0 ; next = 0 ; token = ( char * ) acquirequantummemory ( ( size_t ) inputlen , sizeof ( * token ) ) ; if ( token == ( char * ) null ) break ; newstr = ( char * ) acquirequantummemory ( ( size_t ) inputlen , sizeof ( * newstr ) ) ; if ( newstr == ( char * ) null ) break ; while ( tokenizer ( token_info , 0 , token , ( size_t ) inputlen , line , """" , ""="" , ""\\"""" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( state == 0 ) { int state , next ; char brkused , quoted ; state = 0 ; next = 0 ; while ( tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""#"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { switch ( state ) { case 0 : if ( strcmp ( newstr , ""8bim"" ) == 0 ) dataset = 255 ; else dataset = ( unsigned char ) stringtolong ( newstr ) ; break ; case 1 : recnum = ( unsigned int ) stringtounsignedlong ( newstr ) ; break ; case 2 : name = ( char * ) acquirequantummemory ( strlen ( newstr ) + magickpathextent , sizeof ( * name ) ) ; if ( name ) ( void ) strcpy ( name , newstr ) ; break ; } state ++ ; } } else if ( state == 1 ) { int next ; ssize_t len ; char brkused , quoted ; next = 0 ; len = ( ssize_t ) strlen ( token ) ; while ( tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""&"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( brkused && next > 0 ) { char * s = & token [ next - 1 ] ; len -= ( ssize_t ) converthtmlcodes ( s , ( int ) strlen ( s ) ) ; } } if ( dataset == 255 ) { unsigned char nlen = 0 ; int i ; if ( savedolen > 0 ) { magickoffsettype offset ; ssize_t diff = outputlen - savedolen ; currentpos = tellblob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = seekblob ( ofile , savedpos , seek_set ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) writeblobmsblong ( ofile , ( unsigned int ) diff ) ; offset = seekblob ( ofile , currentpos , seek_set ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0l ; } if ( outputlen & 1 ) { ( void ) writeblobbyte ( ofile , 0x00 ) ; outputlen ++ ; } ( void ) writeblobstring ( ofile , ""8bim"" ) ; ( void ) writeblobmsbshort ( ofile , ( unsigned short ) recnum ) ; outputlen += 6 ; if ( name ) nlen = ( unsigned char ) strlen ( name ) ; ( void ) writeblobbyte ( ofile , nlen ) ; outputlen ++ ; for ( i = 0 ; i < nlen ; i ++ ) ( void ) writeblobbyte ( ofile , ( unsigned char ) name [ i ] ) ; outputlen += nlen ; if ( ( nlen & 0x01 ) == 0 ) { ( void ) writeblobbyte ( ofile , 0x00 ) ; outputlen ++ ; } if ( recnum != iptc_id ) { ( void ) writeblobmsblong ( ofile , ( unsigned int ) len ) ; outputlen += 4 ; next = 0 ; outputlen += len ; while ( len -- ) ( void ) writeblobbyte ( ofile , ( unsigned char ) token [ next ++ ] ) ; if ( outputlen & 1 ) { ( void ) writeblobbyte ( ofile , 0x00 ) ; outputlen ++ ; } } else { savedpos = tellblob ( ofile ) ; if ( savedpos < 0 ) return ( - 1 ) ; ( void ) writeblobmsblong ( ofile , 0xffffffffu ) ; outputlen += 4 ; savedolen = outputlen ; } } else { if ( len <= 0x7fff ) { ( void ) writeblobbyte ( ofile , 0x1c ) ; ( void ) writeblobbyte ( ofile , ( unsigned char ) dataset ) ; ( void ) writeblobbyte ( ofile , ( unsigned char ) ( recnum & 0xff ) ) ; ( void ) writeblobmsbshort ( ofile , ( unsigned short ) len ) ; outputlen += 5 ; next = 0 ; outputlen += len ; while ( len -- ) ( void ) writeblobbyte ( ofile , ( unsigned char ) token [ next ++ ] ) ; } } } state ++ ; } if ( token != ( char * ) null ) token = destroystring ( token ) ; if ( newstr != ( char * ) null ) newstr = destroystring ( newstr ) ; if ( name != ( char * ) null ) name = destroystring ( name ) ; } token_info = destroytokeninfo ( token_info ) ; if ( token != ( char * ) null ) token = destroystring ( token ) ; if ( newstr != ( char * ) null ) newstr = destroystring ( newstr ) ; if ( name != ( char * ) null ) name = destroystring ( name ) ; line = destroystring ( line ) ; if ( savedolen > 0 ) { magickoffsettype offset ; ssize_t diff = outputlen - savedolen ; currentpos = tellblob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = seekblob ( ofile , savedpos , seek_set ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) writeblobmsblong ( ofile , ( unsigned int ) diff ) ; offset = seekblob ( ofile , currentpos , seek_set ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0l ; } return outputlen ; }","<S2SV_ModStart> ( len -- > 0 <S2SV_ModStart> ( len -- > 0
",ImageMagick@ImageMagick/f8c318d462270b03e77f082e2a3a32867cacd3c6,CVE-2016-7524,https://github.com/ImageMagick/ImageMagick/commit/f8c318d462270b03e77f082e2a3a32867cacd3c6,2020-02-06T14:15Z,<S2SV_StartBug> while ( len -- ) <S2SV_EndBug> <S2SV_StartBug> while ( len -- ) <S2SV_EndBug>
6254,CWE-863,"static int do_misc_fixups ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; bool expect_blinding = bpf_jit_blinding_enabled ( prog ) ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , ret , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( bpf_alu64 | bpf_mod | bpf_x ) || insn -> code == ( bpf_alu64 | bpf_div | bpf_x ) || insn -> code == ( bpf_alu | bpf_mod | bpf_x ) || insn -> code == ( bpf_alu | bpf_div | bpf_x ) ) { bool is64 = bpf_class ( insn -> code ) == bpf_alu64 ; bool isdiv = bpf_op ( insn -> code ) == bpf_div ; struct bpf_insn * patchlet ; struct bpf_insn chk_and_div [ ] = { bpf_raw_insn ( ( is64 ? bpf_jmp : bpf_jmp32 ) | bpf_jne | bpf_k , insn -> src_reg , 0 , 2 , 0 ) , bpf_alu32_reg ( bpf_xor , insn -> dst_reg , insn -> dst_reg ) , bpf_jmp_imm ( bpf_ja , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn chk_and_mod [ ] = { bpf_raw_insn ( ( is64 ? bpf_jmp : bpf_jmp32 ) | bpf_jeq | bpf_k , insn -> src_reg , 0 , 1 + ( is64 ? 0 : 1 ) , 0 ) , * insn , bpf_jmp_imm ( bpf_ja , 0 , 0 , 1 ) , bpf_mov32_reg ( insn -> dst_reg , insn -> dst_reg ) , } ; patchlet = isdiv ? chk_and_div : chk_and_mod ; cnt = isdiv ? array_size ( chk_and_div ) : array_size ( chk_and_mod ) - ( is64 ? 2 : 0 ) ; new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ; if ( ! new_prog ) return - enomem ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( bpf_class ( insn -> code ) == bpf_ld && ( bpf_mode ( insn -> code ) == bpf_abs || bpf_mode ( insn -> code ) == bpf_ind ) ) { cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ; if ( cnt == 0 || cnt >= array_size ( insn_buf ) ) { verbose ( env , ""bpf<s2sv_blank>verifier<s2sv_blank>is<s2sv_blank>misconfigured\\n"" ) ; return - einval ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - enomem ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( insn -> code == ( bpf_alu64 | bpf_add | bpf_x ) || insn -> code == ( bpf_alu64 | bpf_sub | bpf_x ) ) { const u8 code_add = bpf_alu64 | bpf_add | bpf_x ; const u8 code_sub = bpf_alu64 | bpf_sub | bpf_x ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg ; aux = & env -> insn_aux_data [ i + delta ] ; if ( ! aux -> alu_state || aux -> alu_state == bpf_alu_non_pointer ) continue ; isneg = aux -> alu_state & bpf_alu_neg_value ; issrc = ( aux -> alu_state & bpf_alu_sanitize ) == bpf_alu_sanitize_src ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = bpf_alu64_imm ( bpf_mul , off_reg , - 1 ) ; * patch ++ = bpf_mov32_imm ( bpf_reg_ax , aux -> alu_limit ) ; * patch ++ = bpf_alu64_reg ( bpf_sub , bpf_reg_ax , off_reg ) ; * patch ++ = bpf_alu64_reg ( bpf_or , bpf_reg_ax , off_reg ) ; * patch ++ = bpf_alu64_imm ( bpf_neg , bpf_reg_ax , 0 ) ; * patch ++ = bpf_alu64_imm ( bpf_arsh , bpf_reg_ax , 63 ) ; * patch ++ = bpf_alu64_reg ( bpf_and , bpf_reg_ax , off_reg ) ; if ( ! issrc ) * patch ++ = bpf_mov64_reg ( insn -> dst_reg , insn -> src_reg ) ; insn -> src_reg = bpf_reg_ax ; if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = bpf_alu64_imm ( bpf_mul , off_reg , - 1 ) ; cnt = patch - insn_buf ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - enomem ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( insn -> code != ( bpf_jmp | bpf_call ) ) continue ; if ( insn -> src_reg == bpf_pseudo_call ) continue ; if ( insn -> src_reg == bpf_pseudo_kfunc_call ) { ret = fixup_kfunc_call ( env , insn ) ; if ( ret ) return ret ; continue ; } if ( insn -> imm == bpf_func_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == bpf_func_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == bpf_func_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == bpf_func_tail_call ) { prog -> cb_access = 1 ; if ( ! allow_tail_call_in_subprogs ( env ) ) prog -> aux -> stack_depth = max_bpf_stack ; prog -> aux -> max_pkt_offset = max_packet_off ; insn -> imm = 0 ; insn -> code = bpf_jmp | bpf_tail_call ; aux = & env -> insn_aux_data [ i + delta ] ; if ( env -> bpf_capable && ! expect_blinding && prog -> jit_requested && ! bpf_map_key_poisoned ( aux ) && ! bpf_map_ptr_poisoned ( aux ) && ! bpf_map_ptr_unpriv ( aux ) ) { struct bpf_jit_poke_descriptor desc = { . reason = bpf_poke_reason_tail_call , . tail_call . map = bpf_map_ptr ( aux -> map_ptr_state ) , . tail_call . key = bpf_map_key_immediate ( aux ) , . insn_idx = i + delta , } ; ret = bpf_jit_add_poke_descriptor ( prog , & desc ) ; if ( ret < 0 ) { verbose ( env , ""adding<s2sv_blank>tail<s2sv_blank>call<s2sv_blank>poke<s2sv_blank>descriptor<s2sv_blank>failed\\n"" ) ; return ret ; } insn -> imm = ret + 1 ; continue ; } if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( bpf_map_ptr_poisoned ( aux ) ) { verbose ( env , ""tail_call<s2sv_blank>abusing<s2sv_blank>map_ptr\\n"" ) ; return - einval ; } map_ptr = bpf_map_ptr ( aux -> map_ptr_state ) ; insn_buf [ 0 ] = bpf_jmp_imm ( bpf_jge , bpf_reg_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = bpf_alu32_imm ( bpf_and , bpf_reg_3 , container_of ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - enomem ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( prog -> jit_requested && bits_per_long == 64 && ( insn -> imm == bpf_func_map_lookup_elem || insn -> imm == bpf_func_map_update_elem || insn -> imm == bpf_func_map_delete_elem || insn -> imm == bpf_func_map_push_elem || insn -> imm == bpf_func_map_pop_elem || insn -> imm == bpf_func_map_peek_elem || insn -> imm == bpf_func_redirect_map ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = bpf_map_ptr ( aux -> map_ptr_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == bpf_func_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == - eopnotsupp ) goto patch_map_ops_generic ; if ( cnt <= 0 || cnt >= array_size ( insn_buf ) ) { verbose ( env , ""bpf<s2sv_blank>verifier<s2sv_blank>is<s2sv_blank>misconfigured\\n"" ) ; return - einval ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - enomem ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } build_bug_on ( ! __same_type ( ops -> map_lookup_elem , ( void * ( * ) ( struct bpf_map * map , void * key ) ) null ) ) ; build_bug_on ( ! __same_type ( ops -> map_delete_elem , ( int ( * ) ( struct bpf_map * map , void * key ) ) null ) ) ; build_bug_on ( ! __same_type ( ops -> map_update_elem , ( int ( * ) ( struct bpf_map * map , void * key , void * value , u64 flags ) ) null ) ) ; build_bug_on ( ! __same_type ( ops -> map_push_elem , ( int ( * ) ( struct bpf_map * map , void * value , u64 flags ) ) null ) ) ; build_bug_on ( ! __same_type ( ops -> map_pop_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) null ) ) ; build_bug_on ( ! __same_type ( ops -> map_peek_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) null ) ) ; build_bug_on ( ! __same_type ( ops -> map_redirect , ( int ( * ) ( struct bpf_map * map , u32 ifindex , u64 flags ) ) null ) ) ; patch_map_ops_generic : switch ( insn -> imm ) { case bpf_func_map_lookup_elem : insn -> imm = bpf_cast_call ( ops -> map_lookup_elem ) - __bpf_call_base ; continue ; case bpf_func_map_update_elem : insn -> imm = bpf_cast_call ( ops -> map_update_elem ) - __bpf_call_base ; continue ; case bpf_func_map_delete_elem : insn -> imm = bpf_cast_call ( ops -> map_delete_elem ) - __bpf_call_base ; continue ; case bpf_func_map_push_elem : insn -> imm = bpf_cast_call ( ops -> map_push_elem ) - __bpf_call_base ; continue ; case bpf_func_map_pop_elem : insn -> imm = bpf_cast_call ( ops -> map_pop_elem ) - __bpf_call_base ; continue ; case bpf_func_map_peek_elem : insn -> imm = bpf_cast_call ( ops -> map_peek_elem ) - __bpf_call_base ; continue ; case bpf_func_redirect_map : insn -> imm = bpf_cast_call ( ops -> map_redirect ) - __bpf_call_base ; continue ; } goto patch_call_imm ; } if ( prog -> jit_requested && bits_per_long == 64 && insn -> imm == bpf_func_jiffies64 ) { struct bpf_insn ld_jiffies_addr [ 2 ] = { bpf_ld_imm64 ( bpf_reg_0 , ( unsigned long ) & jiffies ) , } ; insn_buf [ 0 ] = ld_jiffies_addr [ 0 ] ; insn_buf [ 1 ] = ld_jiffies_addr [ 1 ] ; insn_buf [ 2 ] = bpf_ldx_mem ( bpf_dw , bpf_reg_0 , bpf_reg_0 , 0 ) ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - enomem ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } patch_call_imm : fn = env -> ops -> get_func_proto ( insn -> imm , env -> prog ) ; if ( ! fn -> func ) { verbose ( env , ""kernel<s2sv_blank>subsystem<s2sv_blank>misconfigured<s2sv_blank>func<s2sv_blank>%s#%d\\n"" , func_id_name ( insn -> imm ) , insn -> imm ) ; return - efault ; } insn -> imm = fn -> func - __bpf_call_base ; } for ( i = 0 ; i < prog -> aux -> size_poke_tab ; i ++ ) { map_ptr = prog -> aux -> poke_tab [ i ] . tail_call . map ; if ( ! map_ptr -> ops -> map_poke_track || ! map_ptr -> ops -> map_poke_untrack || ! map_ptr -> ops -> map_poke_run ) { verbose ( env , ""bpf<s2sv_blank>verifier<s2sv_blank>is<s2sv_blank>misconfigured\\n"" ) ; return - einval ; } ret = map_ptr -> ops -> map_poke_track ( map_ptr , prog -> aux ) ; if ( ret < 0 ) { verbose ( env , ""tracking<s2sv_blank>tail<s2sv_blank>call<s2sv_blank>prog<s2sv_blank>failed\\n"" ) ; return ret ; } } sort_kfunc_descs_by_imm ( env -> prog ) ; return 0 ; }","<S2SV_ModStart> issrc , isneg , isimm <S2SV_ModStart> == BPF_ALU_SANITIZE_SRC ; isimm = aux -> alu_state & BPF_ALU_IMMEDIATE ; <S2SV_ModStart> ; if ( isimm ) { <S2SV_ModEnd> * patch ++ <S2SV_ModStart> patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; } else { if ( isneg ) <S2SV_ModEnd> * patch ++ <S2SV_ModStart> patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 <S2SV_ModEnd> ) ; * <S2SV_ModStart> patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit <S2SV_ModEnd> ) ; * <S2SV_ModStart> = BPF_ALU64_REG ( BPF_SUB <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> patch ++ = BPF_ALU64_REG ( BPF_OR <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> , BPF_REG_AX , off_reg <S2SV_ModEnd> ) ; * <S2SV_ModStart> = BPF_ALU64_IMM ( BPF_NEG <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> , BPF_REG_AX , 0 <S2SV_ModEnd> ) ; * <S2SV_ModStart> patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; * patch ++ = <S2SV_ModStart> off_reg ) ; } <S2SV_ModStart> issrc && isneg && ! isimm
",torvalds@linux/801c6058d14a82179a7ee17a4b532cac6fad067f,CVE-2021-31829,https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f,2021-05-06T16:15Z,"<S2SV_StartBug> bool issrc , isneg ; <S2SV_EndBug> <S2SV_StartBug> off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; <S2SV_EndBug> <S2SV_StartBug> if ( isneg ) <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( issrc && isneg ) <S2SV_EndBug>"
5847,CWE-59,"int mingw_rmdir ( const char * pathname ) { int ret , tries = 0 ; wchar_t wpathname [ max_path ] ; if ( xutftowcs_path ( wpathname , pathname ) < 0 ) return - 1 ; while ( ( ret = _wrmdir ( wpathname ) ) == - 1 && tries < array_size ( delay ) ) { if ( ! is_file_in_use_error ( getlasterror ( ) ) ) errno = err_win_to_posix ( getlasterror ( ) ) ; if ( errno != eacces ) break ; if ( ! is_dir_empty ( wpathname ) ) { errno = enotempty ; break ; } sleep ( delay [ tries ] ) ; tries ++ ; } while ( ret == - 1 && errno == eacces && is_file_in_use_error ( getlasterror ( ) ) && ask_yes_no_if_possible ( ""deletion<s2sv_blank>of<s2sv_blank>directory<s2sv_blank>\'%s\'<s2sv_blank>failed.<s2sv_blank>"" ""should<s2sv_blank>i<s2sv_blank>try<s2sv_blank>again?"" , pathname ) ) ret = _wrmdir ( wpathname ) ; return ret ; }","<S2SV_ModStart> wpathname ) ; if ( ! ret ) invalidate_lstat_cache ( ) ;
",git@git/684dd4c2b414bcf648505e74498a608f28de4592,CVE-2021-21300,https://github.com/git/git/commit/684dd4c2b414bcf648505e74498a608f28de4592,2021-03-09T20:15Z,<S2SV_StartBug> return ret ; <S2SV_EndBug>
7308,CWE-125,"static void parse_sec_attr_44 ( sc_file_t * file , const u8 * buf , size_t len ) { const int df_idx [ 8 ] = { sc_ac_op_delete , sc_ac_op_create , sc_ac_op_create , sc_ac_op_invalidate , sc_ac_op_rehabilitate , sc_ac_op_lock , sc_ac_op_delete , - 1 } ; const int ef_idx [ 8 ] = { sc_ac_op_read , sc_ac_op_update , sc_ac_op_write , sc_ac_op_invalidate , sc_ac_op_rehabilitate , - 1 , sc_ac_op_erase , - 1 } ; const int efi_idx [ 8 ] = { sc_ac_op_read , sc_ac_op_erase , sc_ac_op_update , sc_ac_op_invalidate , sc_ac_op_rehabilitate , - 1 , sc_ac_op_erase , - 1 } ; u8 bvalue ; int i ; int ikeyref = 0 ; int imethod ; int ipincount ; int ioffset = 0 ; int ioperation ; const int * p_idx ; while ( len > 1 ) { size_t iaclen = buf [ ioffset ] & 0x0f ; if ( iaclen > len ) break ; imethod = sc_ac_none ; if ( buf [ ioffset ] & 0x80 ) { size_t iparmlen = 1 ; size_t ikeylen = 0 ; if ( buf [ ioffset ] & 0x20 ) ikeylen ++ ; if ( buf [ ioffset + 1 ] & 0x40 ) iparmlen ++ ; if ( buf [ ioffset + 1 ] & 0x20 ) iparmlen ++ ; if ( buf [ ioffset + 1 ] & 0x10 ) iparmlen ++ ; if ( buf [ ioffset + 1 ] & 0x08 ) iparmlen ++ ; if ( ikeylen ) { int isc ; if ( len < 1 + ( size_t ) iaclen ) break ; isc = buf [ ioffset + iaclen ] ; switch ( ( isc >> 5 ) & 0x03 ) { case 0 : imethod = sc_ac_term ; break ; case 1 : imethod = sc_ac_aut ; break ; case 2 : case 3 : imethod = sc_ac_pro ; break ; } ikeyref = isc & 0x1f ; } if ( iaclen > ( 1 + iparmlen + ikeylen ) ) { if ( len < 1 + 1 + 1 + ( size_t ) iparmlen ) break ; ikeyref = buf [ ioffset + 1 + 1 + iparmlen ] ; imethod = sc_ac_chv ; } if ( len < 1 + 2 ) break ; switch ( buf [ ioffset + 2 ] ) { case 0x2a : ioperation = sc_ac_op_crypto ; break ; case 0x46 : ioperation = sc_ac_op_update ; break ; default : ioperation = sc_ac_op_select ; break ; } sc_file_add_acl_entry ( file , ioperation , imethod , ikeyref ) ; } else { switch ( file -> type ) { case sc_file_type_df : p_idx = df_idx ; break ; case sc_file_type_internal_ef : p_idx = efi_idx ; break ; default : p_idx = ef_idx ; break ; } ipincount = iaclen - 1 ; if ( buf [ ioffset ] & 0x20 ) { int isc ; if ( len < 1 + ( size_t ) iaclen ) break ; isc = buf [ ioffset + iaclen ] ; switch ( ( isc >> 5 ) & 0x03 ) { case 0 : imethod = sc_ac_term ; break ; case 1 : imethod = sc_ac_aut ; break ; case 2 : case 3 : imethod = sc_ac_pro ; break ; } ikeyref = isc & 0x1f ; ipincount -- ; } if ( ipincount > 0 ) { if ( len < 1 + 2 ) break ; ikeyref = buf [ ioffset + 2 ] ; imethod = sc_ac_chv ; } bvalue = buf [ ioffset + 1 ] ; for ( i = 0 ; i < 8 ; i ++ ) { if ( ( bvalue & 1 ) && ( p_idx [ i ] >= 0 ) ) sc_file_add_acl_entry ( file , p_idx [ i ] , imethod , ikeyref ) ; bvalue >>= 1 ; } } ioffset += iaclen + 1 ; len -= iaclen + 1 ; } }","<S2SV_ModStart> iPinCount = iACLen > 0 ? iACLen - 1 : 0 <S2SV_ModEnd> ; if (
",OpenSC@OpenSC/c3f23b836e5a1766c36617fe1da30d22f7b63de2,CVE-2019-19479,https://github.com/OpenSC/OpenSC/commit/c3f23b836e5a1766c36617fe1da30d22f7b63de2,2019-12-01T23:15Z,<S2SV_StartBug> iPinCount = iACLen - 1 ; <S2SV_EndBug>
7829,CWE-20,"error_t coapclientsettxblocksize ( coapclientrequest * request , uint_t blocksize ) { if ( request == null ) return error_invalid_parameter ; osacquiremutex ( & request -> context -> mutex ) ; if ( blocksize == 16 ) request -> txblockszx = coap_block_size_16 ; else if ( blocksize == 32 ) request -> txblockszx = coap_block_size_32 ; else if ( blocksize == 64 ) request -> txblockszx = coap_block_size_64 ; else if ( blocksize == 128 ) request -> txblockszx = coap_block_size_128 ; else if ( blocksize == 256 ) request -> txblockszx = coap_block_size_256 ; else if ( blocksize == 512 ) request -> txblockszx = coap_block_size_512 ; else request -> txblockszx = coap_block_size_1024 ; if ( request -> txblockszx > coapclientgetmaxblocksize ( ) ) request -> txblockszx = coapclientgetmaxblocksize ( ) ; osreleasemutex ( & request -> context -> mutex ) ; return no_error ; }","<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> txBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug>
6636,CWE-119,"int commonio_sort ( struct commonio_db * db , int ( * cmp ) ( const void * , const void * ) ) { struct commonio_entry * * entries , * ptr ; size_t n = 0 , i ; # if keep_nis_at_end struct commonio_entry * nis = null ; # endif for ( ptr = db -> head ; ( null != ptr ) # if keep_nis_at_end && ( null != ptr -> line ) && ( ( '+' != ptr -> line [ 0 ] ) && ( '-' != ptr -> line [ 0 ] ) ) # endif ; ptr = ptr -> next ) { n ++ ; } # if keep_nis_at_end if ( ( null != ptr ) && ( null != ptr -> line ) ) { nis = ptr ; } # endif if ( n <= 1 ) { return 0 ; } entries = malloc ( n * sizeof ( struct commonio_entry * ) ) ; if ( entries == null ) { return - 1 ; } n = 0 ; for ( ptr = db -> head ; # if keep_nis_at_end nis != ptr ; # else null != ptr ; # endif ptr = ptr -> next ) { entries [ n ] = ptr ; n ++ ; } qsort ( entries , n , sizeof ( struct commonio_entry * ) , cmp ) ; db -> head = entries [ 0 ] ; n -- ; # if keep_nis_at_end if ( null == nis ) # endif { db -> tail = entries [ n ] ; } db -> head -> prev = null ; db -> head -> next = entries [ 1 ] ; entries [ n ] -> prev = entries [ n - 1 ] ; # if keep_nis_at_end entries [ n ] -> next = nis ; # else entries [ n ] -> next = null ; # endif for ( i = 1 ; i < n ; i ++ ) { entries [ i ] -> prev = entries [ i - 1 ] ; entries [ i ] -> next = entries [ i + 1 ] ; } free ( entries ) ; db -> changed = true ; return 0 ; }","<S2SV_ModStart> KEEP_NIS_AT_END && ( ( NULL == <S2SV_ModEnd> ptr -> line <S2SV_ModStart> -> line ) || ( ( '+' != ptr -> line [ 0 ] ) && ( '-' <S2SV_ModEnd> != ptr -> <S2SV_ModStart> 0 ] ) <S2SV_ModEnd> ) ) # <S2SV_ModStart> KEEP_NIS_AT_END if ( NULL != ptr <S2SV_ModEnd> ) { nis
",shadow-maint@shadow/954e3d2e7113e9ac06632aee3c69b8d818cc8952,CVE-2017-12424,https://github.com/shadow-maint/shadow/commit/954e3d2e7113e9ac06632aee3c69b8d818cc8952,2017-08-04T09:29Z,<S2SV_StartBug> && ( NULL != ptr -> line ) <S2SV_EndBug> <S2SV_StartBug> && ( ( '+' != ptr -> line [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> && ( '-' != ptr -> line [ 0 ] ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) { <S2SV_EndBug>
5415,CWE-401,"static int __ipmi_bmc_register ( struct ipmi_smi * intf , struct ipmi_device_id * id , bool guid_set , guid_t * guid , int intf_num ) { int rv ; struct bmc_device * bmc ; struct bmc_device * old_bmc ; intf -> in_bmc_register = true ; mutex_unlock ( & intf -> bmc_reg_mutex ) ; mutex_lock ( & ipmidriver_mutex ) ; if ( guid_set ) old_bmc = ipmi_find_bmc_guid ( & ipmidriver . driver , guid ) ; else old_bmc = ipmi_find_bmc_prod_dev_id ( & ipmidriver . driver , id -> product_id , id -> device_id ) ; if ( old_bmc ) { bmc = old_bmc ; intf -> bmc = old_bmc ; mutex_lock ( & bmc -> dyn_mutex ) ; list_add_tail ( & intf -> bmc_link , & bmc -> intfs ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; dev_info ( intf -> si_dev , ""interfacing<s2sv_blank>existing<s2sv_blank>bmc<s2sv_blank>(man_id:<s2sv_blank>0x%6.6x,<s2sv_blank>prod_id:<s2sv_blank>0x%4.4x,<s2sv_blank>dev_id:<s2sv_blank>0x%2.2x)\\n"" , bmc -> id . manufacturer_id , bmc -> id . product_id , bmc -> id . device_id ) ; } else { bmc = kzalloc ( sizeof ( * bmc ) , gfp_kernel ) ; if ( ! bmc ) { rv = - enomem ; goto out ; } init_list_head ( & bmc -> intfs ) ; mutex_init ( & bmc -> dyn_mutex ) ; init_work ( & bmc -> remove_work , cleanup_bmc_work ) ; bmc -> id = * id ; bmc -> dyn_id_set = 1 ; bmc -> dyn_guid_set = guid_set ; bmc -> guid = * guid ; bmc -> dyn_id_expiry = jiffies + ipmi_dyn_dev_id_expiry ; bmc -> pdev . name = ""ipmi_bmc"" ; rv = ida_simple_get ( & ipmi_bmc_ida , 0 , 0 , gfp_kernel ) ; if ( rv < 0 ) goto out ; bmc -> pdev . dev . driver = & ipmidriver . driver ; bmc -> pdev . id = rv ; bmc -> pdev . dev . release = release_bmc_device ; bmc -> pdev . dev . type = & bmc_device_type ; kref_init ( & bmc -> usecount ) ; intf -> bmc = bmc ; mutex_lock ( & bmc -> dyn_mutex ) ; list_add_tail ( & intf -> bmc_link , & bmc -> intfs ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; rv = platform_device_register ( & bmc -> pdev ) ; if ( rv ) { dev_err ( intf -> si_dev , ""unable<s2sv_blank>to<s2sv_blank>register<s2sv_blank>bmc<s2sv_blank>device:<s2sv_blank>%d\\n"" , rv ) ; goto out_list_del ; } dev_info ( intf -> si_dev , ""found<s2sv_blank>new<s2sv_blank>bmc<s2sv_blank>(man_id:<s2sv_blank>0x%6.6x,<s2sv_blank>prod_id:<s2sv_blank>0x%4.4x,<s2sv_blank>dev_id:<s2sv_blank>0x%2.2x)\\n"" , bmc -> id . manufacturer_id , bmc -> id . product_id , bmc -> id . device_id ) ; } rv = sysfs_create_link ( & intf -> si_dev -> kobj , & bmc -> pdev . dev . kobj , ""bmc"" ) ; if ( rv ) { dev_err ( intf -> si_dev , ""unable<s2sv_blank>to<s2sv_blank>create<s2sv_blank>bmc<s2sv_blank>symlink:<s2sv_blank>%d\\n"" , rv ) ; goto out_put_bmc ; } if ( intf_num == - 1 ) intf_num = intf -> intf_num ; intf -> my_dev_name = kasprintf ( gfp_kernel , ""ipmi%d"" , intf_num ) ; if ( ! intf -> my_dev_name ) { rv = - enomem ; dev_err ( intf -> si_dev , ""unable<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>link<s2sv_blank>from<s2sv_blank>bmc:<s2sv_blank>%d\\n"" , rv ) ; goto out_unlink1 ; } rv = sysfs_create_link ( & bmc -> pdev . dev . kobj , & intf -> si_dev -> kobj , intf -> my_dev_name ) ; if ( rv ) { kfree ( intf -> my_dev_name ) ; intf -> my_dev_name = null ; dev_err ( intf -> si_dev , ""unable<s2sv_blank>to<s2sv_blank>create<s2sv_blank>symlink<s2sv_blank>to<s2sv_blank>bmc:<s2sv_blank>%d\\n"" , rv ) ; goto out_free_my_dev_name ; } intf -> bmc_registered = true ; out : mutex_unlock ( & ipmidriver_mutex ) ; mutex_lock ( & intf -> bmc_reg_mutex ) ; intf -> in_bmc_register = false ; return rv ; out_free_my_dev_name : kfree ( intf -> my_dev_name ) ; intf -> my_dev_name = null ; out_unlink1 : sysfs_remove_link ( & intf -> si_dev -> kobj , ""bmc"" ) ; out_put_bmc : mutex_lock ( & bmc -> dyn_mutex ) ; list_del ( & intf -> bmc_link ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; intf -> bmc = & intf -> tmp_bmc ; kref_put ( & bmc -> usecount , cleanup_bmc_device ) ; goto out ; out_list_del : mutex_lock ( & bmc -> dyn_mutex ) ; list_del ( & intf -> bmc_link ) ; mutex_unlock ( & bmc -> dyn_mutex ) ; intf -> bmc = & intf -> tmp_bmc ; put_device ( & bmc -> pdev . dev ) ; goto out ; }","<S2SV_ModStart> < 0 ) { kfree ( bmc ) ; <S2SV_ModStart> goto out ; }
",torvalds@linux/4aa7afb0ee20a97fbf0c5bab3df028d5fb85fdab,CVE-2019-19046,https://github.com/torvalds/linux/commit/4aa7afb0ee20a97fbf0c5bab3df028d5fb85fdab,2019-11-18T06:15Z,<S2SV_StartBug> if ( rv < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug>
3391,CWE-404,"static int lockd ( void * vrqstp ) { int err = 0 ; struct svc_rqst * rqstp = vrqstp ; set_freezable ( ) ; allow_signal ( sigkill ) ; dprintk ( ""nfs<s2sv_blank>locking<s2sv_blank>service<s2sv_blank>started<s2sv_blank>(ver<s2sv_blank>"" lockd_version "").\\n"" ) ; while ( ! kthread_should_stop ( ) ) { long timeout = max_schedule_timeout ; rpc_ifdebug ( char buf [ rpc_max_addrbuflen ] ) ; rqstp -> rq_server -> sv_maxconn = nlm_max_connections ; if ( signalled ( ) ) { flush_signals ( current ) ; restart_grace ( ) ; continue ; } timeout = nlmsvc_retry_blocked ( ) ; err = svc_recv ( rqstp , timeout ) ; if ( err == - eagain || err == - eintr ) continue ; dprintk ( ""lockd:<s2sv_blank>request<s2sv_blank>from<s2sv_blank>%s\\n"" , svc_print_addr ( rqstp , buf , sizeof ( buf ) ) ) ; svc_process ( rqstp ) ; } flush_signals ( current ) ; if ( nlmsvc_ops ) nlmsvc_invalidate_all ( ) ; nlm_shutdown_hosts ( ) ; return 0 ; }","<S2SV_ModStart> rqstp = vrqstp ; struct net * net = & init_net ; struct lockd_net * ln = net_generic ( net , lockd_net_id ) <S2SV_ModStart> ( ) ; cancel_delayed_work_sync ( & ln -> grace_period_end ) ; locks_end_grace ( & ln -> lockd_manager ) ;
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,<S2SV_StartBug> struct svc_rqst * rqstp = vrqstp ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug>
7902,CWE-20,"error_t ssiprocessexeccommand ( httpconnection * connection , const char_t * tag , size_t length ) { char_t * separator ; char_t * attribute ; char_t * value ; if ( connection -> settings -> cgicallback == null ) return error_invalid_tag ; if ( length < 4 || length >= http_server_buffer_size ) return error_invalid_tag ; osmemcpy ( connection -> buffer , tag + 4 , length - 4 ) ; connection -> buffer [ length - 4 ] = '\\0' ; separator = strchr ( connection -> buffer , '=' ) ; if ( ! separator ) return error_invalid_tag ; * separator = '\\0' ; attribute = strtrimwhitespace ( connection -> buffer ) ; value = strtrimwhitespace ( separator + 1 ) ; if ( value [ 0 ] == '\\'' || value [ 0 ] == \'\\""\' ) value ++ ; length = osstrlen ( value ) ; if ( length > 0 ) { if ( value [ length - 1 ] == '\\'' || value [ length - 1 ] == \'\\""\' ) value [ length - 1 ] = '\\0' ; } if ( osstrcasecmp ( attribute , ""cgi"" ) && osstrcasecmp ( attribute , ""cmd"" ) && osstrcasecmp ( attribute , ""cmd_argument"" ) ) return error_invalid_tag ; if ( osstrlen ( value ) > http_server_cgi_param_max_len ) return error_invalid_tag ; osstrcpy ( connection -> cgiparam , value ) ; return connection -> settings -> cgicallback ( connection , connection -> cgiparam ) ; }","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug>"
3297,CWE-399,"static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , nlm_f_multi ) ; if ( ! nlh ) return - emsgsize ; bpm = nlmsg_data ( nlh ) ; bpm -> family = af_bridge ; bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , mdba_mdb ) ; if ( nest == null ) goto cancel ; nest2 = nla_nest_start ( skb , mdba_mdb_entry ) ; if ( nest2 == null ) goto end ; if ( nla_put ( skb , mdba_mdb_entry_info , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - emsgsize ; }","<S2SV_ModStart> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;
",torvalds@linux/c085c49920b2f900ba716b4ca1c1a55ece9872cc,CVE-2013-2636,https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc,2013-03-22T11:59Z,<S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug>
2157,CWE-362,"void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; struct net * net = sock_net ( asoc -> base . sk ) ; bh_lock_sock ( asoc -> base . sk ) ; if ( sock_owned_by_user ( asoc -> base . sk ) ) { pr_debug ( ""%s:<s2sv_blank>sock<s2sv_blank>is<s2sv_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> t3_rtx_timer , jiffies + ( hz / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , sctp_event_t_timeout , sctp_st_timeout ( sctp_event_timeout_t3_rtx ) , asoc -> state , asoc -> ep , asoc , transport , gfp_atomic ) ; if ( error ) asoc -> base . sk -> sk_err = - error ; out_unlock : bh_unlock_sock ( asoc -> base . sk ) ; sctp_transport_put ( transport ) ; }","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug>
944,CWE-264,"static int rd_build_device_space ( struct rd_dev * rd_dev ) { u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; u32 max_sg_per_table = ( rd_max_allocation_size / sizeof ( struct scatterlist ) ) ; struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( rd_dev -> rd_page_count <= 0 ) { pr_err ( ""illegal<s2sv_blank>page<s2sv_blank>count:<s2sv_blank>%u<s2sv_blank>for<s2sv_blank>ramdisk<s2sv_blank>device\\n"" , rd_dev -> rd_page_count ) ; return - einval ; } if ( rd_dev -> rd_flags & rdf_nullio ) return 0 ; total_sg_needed = rd_dev -> rd_page_count ; sg_tables = ( total_sg_needed / max_sg_per_table ) + 1 ; sg_table = kzalloc ( sg_tables * sizeof ( struct rd_dev_sg_table ) , gfp_kernel ) ; if ( ! sg_table ) { pr_err ( ""unable<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>memory<s2sv_blank>for<s2sv_blank>ramdisk"" ""<s2sv_blank>scatterlist<s2sv_blank>tables\\n"" ) ; return - enomem ; } rd_dev -> sg_table_array = sg_table ; rd_dev -> sg_table_count = sg_tables ; while ( total_sg_needed ) { sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ; sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , gfp_kernel ) ; if ( ! sg ) { pr_err ( ""unable<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>scatterlist<s2sv_blank>array"" ""<s2sv_blank>for<s2sv_blank>struct<s2sv_blank>rd_dev\\n"" ) ; return - enomem ; } sg_init_table ( sg , sg_per_table ) ; sg_table [ i ] . sg_table = sg ; sg_table [ i ] . rd_sg_count = sg_per_table ; sg_table [ i ] . page_start_offset = page_offset ; sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = alloc_pages ( gfp_kernel , 0 ) ; if ( ! pg ) { pr_err ( ""unable<s2sv_blank>to<s2sv_blank>allocate<s2sv_blank>scatterlist"" ""<s2sv_blank>pages<s2sv_blank>for<s2sv_blank>struct<s2sv_blank>rd_dev_sg_table\\n"" ) ; return - enomem ; } sg_assign_page ( & sg [ j ] , pg ) ; sg [ j ] . length = page_size ; } page_offset += sg_per_table ; total_sg_needed -= sg_per_table ; } pr_debug ( ""core_rd[%u]<s2sv_blank>-<s2sv_blank>built<s2sv_blank>ramdisk<s2sv_blank>device<s2sv_blank>id:<s2sv_blank>%u<s2sv_blank>space<s2sv_blank>of"" ""<s2sv_blank>%u<s2sv_blank>pages<s2sv_blank>in<s2sv_blank>%u<s2sv_blank>tables\\n"" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , rd_dev -> rd_page_count , rd_dev -> sg_table_count ) ; return 0 ; }","<S2SV_ModStart> rd_dev ) { struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> sg_tables , total_sg_needed <S2SV_ModStart> ) ) ; int rc <S2SV_ModEnd> ; if ( <S2SV_ModStart> = sg_tables ; rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of""
",torvalds@linux/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,CVE-2014-4027,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,2014-06-23T11:21Z,"<S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug>"
5860,CWE-20,"int processcommand ( redisclient * c ) { struct rediscommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addreply ( c , shared . ok ) ; c -> flags |= redis_close_after_reply ; return redis_err ; } cmd = lookupcommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addreplyerrorformat ( c , ""unknown<s2sv_blank>command<s2sv_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return redis_ok ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addreplyerrorformat ( c , ""wrong<s2sv_blank>number<s2sv_blank>of<s2sv_blank>arguments<s2sv_blank>for<s2sv_blank>\'%s\'<s2sv_blank>command"" , cmd -> name ) ; return redis_ok ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authcommand ) { addreplyerror ( c , ""operation<s2sv_blank>not<s2sv_blank>permitted"" ) ; return redis_ok ; } if ( server . maxmemory ) freememoryifneeded ( ) ; if ( server . maxmemory && ( cmd -> flags & redis_cmd_denyoom ) && zmalloc_used_memory ( ) > server . maxmemory ) { addreplyerror ( c , ""command<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>when<s2sv_blank>used<s2sv_blank>memory<s2sv_blank>><s2sv_blank>\'maxmemory\'"" ) ; return redis_ok ; } if ( ( dictsize ( c -> pubsub_channels ) > 0 || listlength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribecommand && cmd -> proc != unsubscribecommand && cmd -> proc != psubscribecommand && cmd -> proc != punsubscribecommand ) { addreplyerror ( c , ""only<s2sv_blank>(p)subscribe<s2sv_blank>/<s2sv_blank>(p)unsubscribe<s2sv_blank>/<s2sv_blank>quit<s2sv_blank>allowed<s2sv_blank>in<s2sv_blank>this<s2sv_blank>context"" ) ; return redis_ok ; } if ( server . masterhost && server . replstate != redis_repl_connected && server . repl_serve_stale_data == 0 && cmd -> proc != infocommand && cmd -> proc != slaveofcommand ) { addreplyerror ( c , ""link<s2sv_blank>with<s2sv_blank>master<s2sv_blank>is<s2sv_blank>down<s2sv_blank>and<s2sv_blank>slave-serve-stale-data<s2sv_blank>is<s2sv_blank>set<s2sv_blank>to<s2sv_blank>no"" ) ; return redis_ok ; } if ( server . loading && cmd -> proc != infocommand ) { addreply ( c , shared . loadingerr ) ; return redis_ok ; } if ( c -> flags & redis_multi && cmd -> proc != execcommand && cmd -> proc != discardcommand && cmd -> proc != multicommand && cmd -> proc != watchcommand ) { queuemulticommand ( c , cmd ) ; addreply ( c , shared . queued ) ; } else { if ( server . vm_enabled && server . vm_max_threads > 0 && blockclientonswappedkeys ( c , cmd ) ) return redis_err ; call ( c , cmd ) ; } return redis_ok ; }","<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,<S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug>
306,CWE-000,"syscall_define4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - efault ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - ebadf ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - eperm ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - einval ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == epoll_ctl_add || op == epoll_ctl_del ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == epoll_ctl_add ) { if ( is_file_epoll ( tfile ) ) { error = - eloop ; if ( ep_loop_check ( ep , tfile ) != 0 ) goto error_tgt_fput ; } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - einval ; switch ( op ) { case epoll_ctl_add : if ( ! epi ) { epds . events |= pollerr | pollhup ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - eexist ; clear_tfile_check_list ( ) ; break ; case epoll_ctl_del : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - enoent ; break ; case epoll_ctl_mod : if ( epi ) { epds . events |= pollerr | pollhup ; error = ep_modify ( ep , epi , & epds ) ; } else error = - enoent ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }","<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }
",torvalds@linux/13d518074a952d33d47c428419693f63389547e9,CVE-2012-3375,https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9,2012-10-03T11:02Z,"<S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug>"
3867,CWE-362,"int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , ext4_inode_extents ) ) return - eopnotsupp ; if ( offset & ( ext4_cluster_size ( sb ) - 1 ) || len & ( ext4_cluster_size ( sb ) - 1 ) ) return - einval ; if ( ! s_isreg ( inode -> i_mode ) ) return - eopnotsupp ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> ext4_block_size_bits ( sb ) ; len_lblk = len >> ext4_block_size_bits ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , page_size ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , llong_max ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , ext4_inode_extents ) ) { ret = - eopnotsupp ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - efbig ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - einval ; goto out_mutex ; } truncate_pagecache ( inode , ioffset ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , ext4_ht_truncate , credits ) ; if ( is_err ( handle ) ) { ret = ptr_err ( handle ) ; goto out_dio ; } inode -> i_size += len ; ext4_i ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & ext4_i ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , null , 0 ) ; if ( is_err ( path ) ) { up_write ( & ext4_i ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = ext4_ext_mark_unwrit1 | ext4_ext_mark_unwrit2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , ext4_ex_nocache | ext4_get_blocks_pre_io | ext4_get_blocks_metadata_nofail ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & ext4_i ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , ext_max_blocks - offset_lblk ) ; if ( ret ) { up_write ( & ext4_i ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , shift_right ) ; up_write ( & ext4_i ( inode ) -> i_data_sem ) ; if ( is_sync ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
",torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug>"
8315,CWE-120,"int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; char * bufp , * commentp , * altp ; mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == '<s2sv_blank>' ) commentp [ - 1 ] = '\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , ""finish"" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = true ; chosen_symset_start = false ; return 1 ; } config_error_add ( ""no<s2sv_blank>\\""finish\\"""" ) ; return 0 ; } ++ bufp ; if ( * bufp == '<s2sv_blank>' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( ""unknown<s2sv_blank>sym<s2sv_blank>keyword"" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == sym_control ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof * tmpsp ) ; tmpsp -> next = ( struct symsetentry * ) 0 ; if ( ! lastsp ) symset_list = tmpsp ; else lastsp -> next = tmpsp ; tmpsp -> idx = symset_count ++ ; tmpsp -> name = dupstr ( bufp ) ; tmpsp -> desc = ( char * ) 0 ; tmpsp -> handling = h_unk ; tmpsp -> nocolor = 0 ; tmpsp -> primary = 0 ; tmpsp -> rogue = 0 ; break ; case 2 : tmpsp = lastsp ; for ( i = 0 ; known_handling [ i ] ; ++ i ) if ( ! strcmpi ( known_handling [ i ] , bufp ) ) { tmpsp -> handling = i ; break ; } break ; case 3 : tmpsp = lastsp ; if ( tmpsp && ! tmpsp -> desc ) tmpsp -> desc = dupstr ( bufp ) ; break ; case 5 : tmpsp = lastsp ; for ( i = 0 ; known_restrictions [ i ] ; ++ i ) { if ( ! strcmpi ( known_restrictions [ i ] , bufp ) ) { switch ( i ) { case 0 : tmpsp -> primary = 1 ; break ; case 1 : tmpsp -> rogue = 1 ; break ; } break ; } } break ; } } return 1 ; } if ( symp -> range ) { if ( symp -> range == sym_control ) { switch ( symp -> idx ) { case 0 : if ( ! strcmpi ( bufp , symset [ which_set ] . name ) ) { chosen_symset_start = true ; if ( which_set == rogueset ) init_rogue_symbols ( ) ; else if ( which_set == primary ) init_primary_symbols ( ) ; } break ; case 1 : if ( chosen_symset_start ) chosen_symset_end = true ; chosen_symset_start = false ; break ; case 2 : if ( chosen_symset_start ) set_symhandling ( bufp , which_set ) ; break ; case 4 : if ( chosen_symset_start ) { if ( bufp ) { if ( ! strcmpi ( bufp , ""true"" ) || ! strcmpi ( bufp , ""yes"" ) || ! strcmpi ( bufp , ""on"" ) ) symset [ which_set ] . nocolor = 0 ; else if ( ! strcmpi ( bufp , ""false"" ) || ! strcmpi ( bufp , ""no"" ) || ! strcmpi ( bufp , ""off"" ) ) symset [ which_set ] . nocolor = 1 ; } } break ; case 5 : if ( chosen_symset_start ) { int n = 0 ; while ( known_restrictions [ n ] ) { if ( ! strcmpi ( known_restrictions [ n ] , bufp ) ) { switch ( n ) { case 0 : symset [ which_set ] . primary = 1 ; break ; case 1 : symset [ which_set ] . rogue = 1 ; break ; } break ; } n ++ ; } } break ; } } else { val = sym_val ( bufp ) ; if ( chosen_symset_start ) { if ( which_set == primary ) { update_primary_symset ( symp , val ) ; } else if ( which_set == rogueset ) { update_rogue_symset ( symp , val ) ; } } } } return 1 ; }","<S2SV_ModStart> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0'
",NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z,"<S2SV_StartBug> char * bufp , * commentp , * altp ; <S2SV_EndBug>"
8250,CWE-787,"static int l2cap_sock_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_l2 la ; int len , err = 0 ; bt_dbg ( ""sk<s2sv_blank>%p"" , sk ) ; if ( ! addr || addr -> sa_family != af_bluetooth ) return - einval ; memset ( & la , 0 , sizeof ( la ) ) ; len = min_t ( unsigned int , sizeof ( la ) , alen ) ; memcpy ( & la , addr , len ) ; if ( la . l2_cid ) return - einval ; lock_sock ( sk ) ; if ( sk -> sk_type == sock_seqpacket && ! la . l2_psm ) { err = - einval ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case l2cap_mode_basic : break ; case l2cap_mode_ertm : if ( enable_ertm ) break ; default : err = - enotsupp ; goto done ; } switch ( sk -> sk_state ) { case bt_connect : case bt_connect2 : case bt_config : goto wait ; case bt_connected : goto done ; case bt_open : case bt_bound : break ; default : err = - ebadfd ; goto done ; } bacpy ( & bt_sk ( sk ) -> dst , & la . l2_bdaddr ) ; l2cap_pi ( sk ) -> psm = la . l2_psm ; err = l2cap_do_connect ( sk ) ; if ( err ) goto done ; wait : err = bt_sock_wait_state ( sk , bt_connected , sock_sndtimeo ( sk , flags & o_nonblock ) ) ; done : release_sock ( sk ) ; return err ; }","<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,<S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug>
7833,CWE-20,"void rawsocketprocessethpacket ( netinterface * interface , ethheader * header , const uint8_t * data , size_t length , netrxancillary * ancillary ) { uint_t i ; socket * socket ; socketqueueitem * queueitem ; netbuffer * p ; for ( i = 0 ; i < socket_max_count ; i ++ ) { socket = sockettable + i ; if ( socket -> type != socket_type_raw_eth ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> protocol == socket_eth_proto_all ) { } else if ( socket -> protocol == socket_eth_proto_llc ) { if ( ntohs ( header -> type ) > eth_mtu ) continue ; } else { if ( ntohs ( header -> type ) != socket -> protocol ) continue ; } break ; } if ( i >= socket_max_count ) return ; if ( socket -> receivequeue == null ) { p = netbufferalloc ( sizeof ( socketqueueitem ) + sizeof ( ethheader ) + length ) ; if ( p != null ) { queueitem = netbufferat ( p , 0 ) ; queueitem -> buffer = p ; socket -> receivequeue = queueitem ; } else { queueitem = null ; } } else { queueitem = socket -> receivequeue ; for ( i = 1 ; queueitem -> next ; i ++ ) { queueitem = queueitem -> next ; } if ( i >= raw_socket_rx_queue_size ) { mib2_inc_counter32 ( ifgroup . iftable [ interface -> index ] . ifindiscards , 1 ) ; if_mib_inc_counter32 ( iftable [ interface -> index ] . ifindiscards , 1 ) ; return ; } p = netbufferalloc ( sizeof ( socketqueueitem ) + sizeof ( ethheader ) + length ) ; if ( p != null ) { queueitem -> next = netbufferat ( p , 0 ) ; queueitem = queueitem -> next ; queueitem -> buffer = p ; } else { queueitem = null ; } } if ( queueitem == null ) { mib2_inc_counter32 ( ifgroup . iftable [ interface -> index ] . ifindiscards , 1 ) ; if_mib_inc_counter32 ( iftable [ interface -> index ] . ifindiscards , 1 ) ; return ; } queueitem -> next = null ; queueitem -> srcport = 0 ; queueitem -> srcipaddr = ip_addr_any ; queueitem -> destipaddr = ip_addr_any ; queueitem -> offset = sizeof ( socketqueueitem ) ; netbufferwrite ( queueitem -> buffer , queueitem -> offset , header , sizeof ( ethheader ) ) ; netbufferwrite ( queueitem -> buffer , queueitem -> offset + sizeof ( ethheader ) , data , length ) ; queueitem -> ancillary = * ancillary ; rawsocketupdateevents ( socket ) ; }","<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug>
4571,CWE-125,"static pyobject * decode_bytes_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { return pybytes_decodeescape ( s , len , null , 0 , null ) ; }","<S2SV_ModStart> len ) { const char * first_invalid_escape ; PyObject * result = _PyBytes_DecodeEscape <S2SV_ModEnd> ( s , <S2SV_ModStart> 0 , NULL , & first_invalid_escape ) ; if ( result == NULL ) return NULL ; if ( first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_DECREF ( result ) ; return NULL ; } } return result <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> return PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL ) ; <S2SV_EndBug>"
6527,CWE-119,cjson * cjson_createobject ( void ) { cjson * item = cjson_new_item ( ) ; if ( item ) item -> type = cjson_object ; return item ; },"
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,
3114,CWE-20,"static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; u8 smac [ eth_alen ] ; u8 alt_smac [ eth_alen ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == rdma_transport_ib ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == ib_link_layer_ethernet ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - einval ; if ( cma_disable_callback ( listen_id , rdma_cm_listen ) ) return - econnaborted ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = rdma_cm_event_connect_request ; if ( ib_event -> event == ib_cm_sidr_req_received ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = ib_cm_sidr_req_private_data_size - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - enomem ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , single_depth_nesting ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ; if ( is_iboe ) { if ( ib_event -> param . req_rcvd . primary_path != null ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , null ) ; else psmac = null ; if ( ib_event -> param . req_rcvd . alternate_path != null ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , null ) ; else palt_smac = null ; } mutex_lock ( & lock ) ; if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , rdma_cm_connect ) && ( conn_id -> id . qp_type != ib_qpt_ud ) ) ib_send_cm_mra ( cm_id , cma_cm_mra_setting , null , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = null ; err2 : cma_exch ( conn_id , rdma_cm_destroying ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }","<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if
",torvalds@linux/b2853fd6c2d0f383dbdf7427e263eb576a633867,CVE-2014-2739,https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867,2014-04-14T23:55Z,<S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug>
2327,CWE-416,"int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( null == bus || null == bus -> name || null == bus -> read || null == bus -> write ) return - einval ; bug_on ( bus -> state != mdiobus_allocated && bus -> state != mdiobus_unregistered ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = null ; dev_set_name ( & bus -> dev , ""%s"" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( ""mii_bus<s2sv_blank>%s<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>register\\n"" , bus -> id ) ; put_device ( & bus -> dev ) ; return - einval ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , ""reset"" , gpiod_out_low ) ; if ( is_err ( gpiod ) ) { dev_err ( & bus -> dev , ""mii_bus<s2sv_blank>%s<s2sv_blank>couldn\'t<s2sv_blank>get<s2sv_blank>reset<s2sv_blank>gpio\\n"" , bus -> id ) ; device_del ( & bus -> dev ) ; return ptr_err ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < phy_max_addr ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( is_err ( phydev ) && ( ptr_err ( phydev ) != - enodev ) ) { err = ptr_err ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = mdiobus_registered ; pr_info ( ""%s:<s2sv_blank>probed\\n"" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }","<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL
",torvalds@linux/6ff7b060535e87c2ae14dd8548512abfdda528fb,CVE-2019-12819,https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb,2019-06-14T02:29Z,<S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug>
3916,CWE-264,"int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , o_wronly | o_creat | o_cloexec | o_noctty , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ; if ( mode > 0 ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != uid_invalid || gid != gid_invalid ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != usec_infinity ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , null ) ; if ( r < 0 ) return - errno ; return 0 ; }","<S2SV_ModStart> if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
",systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z,<S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug>
534,CWE-399,"struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = null ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = null ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = null ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return null ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + word_round ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = null ; if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = null ; return null ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<s2sv_blank>chunk:%p[%s],<s2sv_blank>length:%d,<s2sv_blank>skb->len:%d\\n"" , chunk , sctp_cname ( sctp_st_chunk ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }","<S2SV_ModStart> data ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; }
",torvalds@linux/26b87c7881006311828bb0ab271a551a62dcceb4,CVE-2014-3688,https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4,2014-11-30T01:59Z,<S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug>
4945,CWE-617,"static void update_bar_address ( struct vmctx * ctx , struct pci_vdev * dev , uint64_t addr , int idx , int type , bool ignore_reg_unreg ) { bool decode = false ; uint64_t orig_addr = dev -> bar [ idx ] . addr ; if ( ! ignore_reg_unreg ) { if ( dev -> bar [ idx ] . type == pcibar_io ) decode = porten ( dev ) ; else decode = memen ( dev ) ; } if ( decode ) unregister_bar ( dev , idx ) ; switch ( type ) { case pcibar_io : case pcibar_mem32 : dev -> bar [ idx ] . addr = addr ; break ; case pcibar_mem64 : dev -> bar [ idx ] . addr &= ~ 0xfffffffful ; dev -> bar [ idx ] . addr |= addr ; break ; case pcibar_memhi64 : dev -> bar [ idx ] . addr &= 0xffffffff ; dev -> bar [ idx ] . addr |= addr ; break ; default : assert ( 0 ) ; } if ( decode ) register_bar ( dev , idx ) ; if ( dev -> dev_ops -> vdev_update_bar_map && decode ) dev -> dev_ops -> vdev_update_bar_map ( ctx , dev , idx , orig_addr ) ; }","<S2SV_ModStart> ; default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; return <S2SV_ModEnd> ; } if
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug>
7768,CWE-125,"static int tok_get ( struct tok_state * tok , char * * p_start , char * * p_end ) { int c ; int blankline , nonascii ; * p_start = * p_end = null ; nextline : tok -> start = null ; blankline = 0 ; if ( tok -> atbol ) { int col = 0 ; int altcol = 0 ; tok -> atbol = 0 ; for ( ; ; ) { c = tok_nextc ( tok ) ; if ( c == '<s2sv_blank>' ) { col ++ , altcol ++ ; } else if ( c == '\\t' ) { col = ( col / tok -> tabsize + 1 ) * tok -> tabsize ; altcol = ( altcol / alttabsize + 1 ) * alttabsize ; } else if ( c == '\\014' ) { col = altcol = 0 ; } else { break ; } } tok_backup ( tok , c ) ; if ( c == '#' || c == '\\n' ) { if ( col == 0 && c == '\\n' && tok -> prompt != null ) { blankline = 0 ; } else { blankline = 1 ; } } if ( ! blankline && tok -> level == 0 ) { if ( col == tok -> indstack [ tok -> indent ] ) { if ( altcol != tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } } else if ( col > tok -> indstack [ tok -> indent ] ) { if ( tok -> indent + 1 >= maxindent ) { tok -> done = e_toodeep ; tok -> cur = tok -> inp ; return errortoken ; } if ( altcol <= tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } tok -> pendin ++ ; tok -> indstack [ ++ tok -> indent ] = col ; tok -> altindstack [ tok -> indent ] = altcol ; } else { while ( tok -> indent > 0 && col < tok -> indstack [ tok -> indent ] ) { tok -> pendin -- ; tok -> indent -- ; } if ( col != tok -> indstack [ tok -> indent ] ) { tok -> done = e_dedent ; tok -> cur = tok -> inp ; return errortoken ; } if ( altcol != tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } } } } tok -> start = tok -> cur ; if ( tok -> pendin != 0 ) { if ( tok -> pendin < 0 ) { tok -> pendin ++ ; return dedent ; } else { tok -> pendin -- ; return indent ; } } again : tok -> start = null ; do { c = tok_nextc ( tok ) ; } while ( c == '<s2sv_blank>' || c == '\\t' || c == '\\014' ) ; tok -> start = tok -> cur - 1 ; if ( c == '#' ) { while ( c != eof && c != '\\n' ) { c = tok_nextc ( tok ) ; } } if ( c == eof ) { return tok -> done == e_eof ? endmarker : errortoken ; } nonascii = 0 ; if ( is_potential_identifier_start ( c ) ) { int saw_b = 0 , saw_r = 0 , saw_u = 0 , saw_f = 0 ; while ( 1 ) { if ( ! ( saw_b || saw_u || saw_f ) && ( c == 'b' || c == 'b' ) ) saw_b = 1 ; else if ( ! ( saw_b || saw_u || saw_r || saw_f ) && ( c == 'u' || c == 'u' ) ) { saw_u = 1 ; } else if ( ! ( saw_r || saw_u ) && ( c == 'r' || c == 'r' ) ) { saw_r = 1 ; } else if ( ! ( saw_f || saw_b || saw_u ) && ( c == 'f' || c == 'f' ) ) { saw_f = 1 ; } else { break ; } c = tok_nextc ( tok ) ; if ( c == \'""\' || c == '\\'' ) { goto letter_quote ; } } while ( is_potential_identifier_char ( c ) ) { if ( c >= 128 ) { nonascii = 1 ; } c = tok_nextc ( tok ) ; } tok_backup ( tok , c ) ; if ( nonascii && ! verify_identifier ( tok ) ) { return errortoken ; } * p_start = tok -> start ; * p_end = tok -> cur ; return name ; } if ( c == '\\n' ) { tok -> atbol = 1 ; if ( blankline || tok -> level > 0 ) { goto nextline ; } * p_start = tok -> start ; * p_end = tok -> cur - 1 ; tok -> cont_line = 0 ; return newline ; } if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( isdigit ( c ) ) { goto fraction ; } else if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( c == '.' ) { * p_start = tok -> start ; * p_end = tok -> cur ; return ellipsis ; } else { tok_backup ( tok , c ) ; } tok_backup ( tok , '.' ) ; } else { tok_backup ( tok , c ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return dot ; } if ( isdigit ( c ) ) { if ( c == '0' ) { c = tok_nextc ( tok ) ; if ( c == 'x' || c == 'x' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( ! isxdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<s2sv_blank>hexadecimal<s2sv_blank>literal"" ) ; } do { c = tok_nextc ( tok ) ; } while ( isxdigit ( c ) ) ; } while ( c == '_' ) ; } else if ( c == 'o' || c == 'o' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c < '0' || c >= '8' ) { tok_backup ( tok , c ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<s2sv_blank>digit<s2sv_blank>\'%c\'<s2sv_blank>in<s2sv_blank>octal<s2sv_blank>literal"" , c ) ; } else { return syntaxerror ( tok , ""invalid<s2sv_blank>octal<s2sv_blank>literal"" ) ; } } do { c = tok_nextc ( tok ) ; } while ( '0' <= c && c < '8' ) ; } while ( c == '_' ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<s2sv_blank>digit<s2sv_blank>\'%c\'<s2sv_blank>in<s2sv_blank>octal<s2sv_blank>literal"" , c ) ; } } else if ( c == 'b' || c == 'b' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c != '0' && c != '1' ) { tok_backup ( tok , c ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<s2sv_blank>digit<s2sv_blank>\'%c\'<s2sv_blank>in<s2sv_blank>binary<s2sv_blank>literal"" , c ) ; } else { return syntaxerror ( tok , ""invalid<s2sv_blank>binary<s2sv_blank>literal"" ) ; } } do { c = tok_nextc ( tok ) ; } while ( c == '0' || c == '1' ) ; } while ( c == '_' ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<s2sv_blank>digit<s2sv_blank>\'%c\'<s2sv_blank>in<s2sv_blank>binary<s2sv_blank>literal"" , c ) ; } } else { int nonzero = 0 ; while ( 1 ) { if ( c == '_' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<s2sv_blank>decimal<s2sv_blank>literal"" ) ; } } if ( c != '0' ) { break ; } c = tok_nextc ( tok ) ; } if ( isdigit ( c ) ) { nonzero = 1 ; c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return errortoken ; } } if ( c == '.' ) { c = tok_nextc ( tok ) ; goto fraction ; } else if ( c == 'e' || c == 'e' ) { goto exponent ; } else if ( c == 'j' || c == 'j' ) { goto imaginary ; } else if ( nonzero ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""leading<s2sv_blank>zeros<s2sv_blank>in<s2sv_blank>decimal<s2sv_blank>integer<s2sv_blank>"" ""literals<s2sv_blank>are<s2sv_blank>not<s2sv_blank>permitted;<s2sv_blank>"" ""use<s2sv_blank>an<s2sv_blank>0o<s2sv_blank>prefix<s2sv_blank>for<s2sv_blank>octal<s2sv_blank>integers"" ) ; } } } else { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return errortoken ; } { if ( c == '.' ) { c = tok_nextc ( tok ) ; fraction : if ( isdigit ( c ) ) { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return errortoken ; } } } if ( c == 'e' || c == 'e' ) { int e ; exponent : e = c ; c = tok_nextc ( tok ) ; if ( c == '+' || c == '-' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<s2sv_blank>decimal<s2sv_blank>literal"" ) ; } } else if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; tok_backup ( tok , e ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return number ; } c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return errortoken ; } } if ( c == 'j' || c == 'j' ) { imaginary : c = tok_nextc ( tok ) ; } } } tok_backup ( tok , c ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return number ; } letter_quote : if ( c == '\\'' || c == \'""\' ) { int quote = c ; int quote_size = 1 ; int end_quote_size = 0 ; tok -> first_lineno = tok -> lineno ; tok -> multi_line_start = tok -> line_start ; c = tok_nextc ( tok ) ; if ( c == quote ) { c = tok_nextc ( tok ) ; if ( c == quote ) { quote_size = 3 ; } else { end_quote_size = 1 ; } } if ( c != quote ) { tok_backup ( tok , c ) ; } while ( end_quote_size != quote_size ) { c = tok_nextc ( tok ) ; if ( c == eof ) { if ( quote_size == 3 ) { tok -> done = e_eofs ; } else { tok -> done = e_eols ; } tok -> cur = tok -> inp ; return errortoken ; } if ( quote_size == 1 && c == '\\n' ) { tok -> done = e_eols ; tok -> cur = tok -> inp ; return errortoken ; } if ( c == quote ) { end_quote_size += 1 ; } else { end_quote_size = 0 ; if ( c == '\\\\' ) { tok_nextc ( tok ) ; } } } * p_start = tok -> start ; * p_end = tok -> cur ; return string ; } if ( c == '\\\\' ) { c = tok_nextc ( tok ) ; if ( c != '\\n' ) { tok -> done = e_linecont ; tok -> cur = tok -> inp ; return errortoken ; } tok -> cont_line = 1 ; goto again ; } { int c2 = tok_nextc ( tok ) ; int token = pytoken_twochars ( c , c2 ) ; if ( token != op ) { int c3 = tok_nextc ( tok ) ; int token3 = pytoken_threechars ( c , c2 , c3 ) ; if ( token3 != op ) { token = token3 ; } else { tok_backup ( tok , c3 ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return token ; } tok_backup ( tok , c2 ) ; } switch ( c ) { case '(' : case '[' : case '{' : # ifndef pgen if ( tok -> level >= maxlevel ) { return syntaxerror ( tok , ""too<s2sv_blank>many<s2sv_blank>nested<s2sv_blank>parentheses"" ) ; } tok -> parenstack [ tok -> level ] = c ; tok -> parenlinenostack [ tok -> level ] = tok -> lineno ; # endif tok -> level ++ ; break ; case ')' : case ']' : case '}' : # ifndef pgen if ( ! tok -> level ) { return syntaxerror ( tok , ""unmatched<s2sv_blank>\'%c\'"" , c ) ; } # endif tok -> level -- ; # ifndef pgen int opening = tok -> parenstack [ tok -> level ] ; if ( ! ( ( opening == '(' && c == ')' ) || ( opening == '[' && c == ']' ) || ( opening == '{' && c == '}' ) ) ) { if ( tok -> parenlinenostack [ tok -> level ] != tok -> lineno ) { return syntaxerror ( tok , ""closing<s2sv_blank>parenthesis<s2sv_blank>\'%c\'<s2sv_blank>does<s2sv_blank>not<s2sv_blank>match<s2sv_blank>"" ""opening<s2sv_blank>parenthesis<s2sv_blank>\'%c\'<s2sv_blank>on<s2sv_blank>line<s2sv_blank>%d"" , c , opening , tok -> parenlinenostack [ tok -> level ] ) ; } else { return syntaxerror ( tok , ""closing<s2sv_blank>parenthesis<s2sv_blank>\'%c\'<s2sv_blank>does<s2sv_blank>not<s2sv_blank>match<s2sv_blank>"" ""opening<s2sv_blank>parenthesis<s2sv_blank>\'%c\'"" , c , opening ) ; } } # endif break ; } * p_start = tok -> start ; * p_end = tok -> cur ; return pytoken_onechar ( c ) ; }","<S2SV_ModStart> '#' ) { const char * prefix , * p , * type_start ; <S2SV_ModStart> tok ) ; } if ( tok -> type_comments ) { p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '<S2SV_blank>' ) { while ( * p == '<S2SV_blank>' || * p == '\\t' ) { p ++ ; } } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '<S2SV_blank>' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } }
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,<S2SV_StartBug> while ( c != EOF && c != '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> c = tok_nextc ( tok ) ; <S2SV_EndBug>
3286,CWE-20,"static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( vm_exit_intr_info ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<s2sv_blank>failed<s2sv_blank>vm<s2sv_blank>entry<s2sv_blank>%x\\n"" , __func__ , vmcs_read32 ( vm_instruction_error ) ) ; return 1 ; } switch ( exit_reason ) { case exit_reason_exception_nmi : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & intr_info_vector_mask ) ) ; case exit_reason_external_interrupt : return 0 ; case exit_reason_triple_fault : return 1 ; case exit_reason_pending_interrupt : return nested_cpu_has ( vmcs12 , cpu_based_virtual_intr_pending ) ; case exit_reason_nmi_window : return nested_cpu_has ( vmcs12 , cpu_based_virtual_nmi_pending ) ; case exit_reason_task_switch : return 1 ; case exit_reason_cpuid : return 1 ; case exit_reason_hlt : return nested_cpu_has ( vmcs12 , cpu_based_hlt_exiting ) ; case exit_reason_invd : return 1 ; case exit_reason_invlpg : return nested_cpu_has ( vmcs12 , cpu_based_invlpg_exiting ) ; case exit_reason_rdpmc : return nested_cpu_has ( vmcs12 , cpu_based_rdpmc_exiting ) ; case exit_reason_rdtsc : return nested_cpu_has ( vmcs12 , cpu_based_rdtsc_exiting ) ; case exit_reason_vmcall : case exit_reason_vmclear : case exit_reason_vmlaunch : case exit_reason_vmptrld : case exit_reason_vmptrst : case exit_reason_vmread : case exit_reason_vmresume : case exit_reason_vmwrite : case exit_reason_vmoff : case exit_reason_vmon : return 1 ; case exit_reason_cr_access : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case exit_reason_dr_access : return nested_cpu_has ( vmcs12 , cpu_based_mov_dr_exiting ) ; case exit_reason_io_instruction : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case exit_reason_msr_read : case exit_reason_msr_write : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case exit_reason_invalid_state : return 1 ; case exit_reason_mwait_instruction : return nested_cpu_has ( vmcs12 , cpu_based_mwait_exiting ) ; case exit_reason_monitor_instruction : return nested_cpu_has ( vmcs12 , cpu_based_monitor_exiting ) ; case exit_reason_pause_instruction : return nested_cpu_has ( vmcs12 , cpu_based_pause_exiting ) || nested_cpu_has2 ( vmcs12 , secondary_exec_pause_loop_exiting ) ; case exit_reason_mce_during_vmentry : return 0 ; case exit_reason_tpr_below_threshold : return 1 ; case exit_reason_apic_access : return nested_cpu_has2 ( vmcs12 , secondary_exec_virtualize_apic_accesses ) ; case exit_reason_ept_violation : case exit_reason_ept_misconfig : return 0 ; case exit_reason_preemption_timer : return vmcs12 -> pin_based_vm_exec_control & pin_based_vmx_preemption_timer ; case exit_reason_wbinvd : return nested_cpu_has2 ( vmcs12 , secondary_exec_wbinvd_exiting ) ; case exit_reason_xsetbv : return 1 ; default : return 1 ; } }","<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
",torvalds@linux/bfd0a56b90005f8c8a004baf407ad90045c2b11e,CVE-2014-3645,https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e,2014-11-10T11:55Z,<S2SV_StartBug> return 1 ; <S2SV_EndBug>
8375,CWE-362,"int tcp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ; int err ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - einval ; if ( usin -> sin_family != af_inet ) return - eafnosupport ; nexthop = daddr = usin -> sin_addr . s_addr ; if ( inet -> opt && inet -> opt -> srr ) { if ( ! daddr ) return - einval ; nexthop = inet -> opt -> faddr ; } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , rt_conn_flags ( sk ) , sk -> sk_bound_dev_if , ipproto_tcp , orig_sport , orig_dport , sk , true ) ; if ( is_err ( rt ) ) { err = ptr_err ( rt ) ; if ( err == - enetunreach ) ip_inc_stats_bh ( sock_net ( sk ) , ipstats_mib_outnoroutes ) ; return err ; } if ( rt -> rt_flags & ( rtcf_multicast | rtcf_broadcast ) ) { ip_rt_put ( rt ) ; return - enetunreach ; } if ( ! inet -> opt || ! inet -> opt -> srr ) daddr = rt -> rt_dst ; if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) { tp -> rx_opt . ts_recent = 0 ; tp -> rx_opt . ts_recent_stamp = 0 ; tp -> write_seq = 0 ; } if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) { struct inet_peer * peer = rt_get_peer ( rt ) ; if ( peer ) { inet_peer_refcheck ( peer ) ; if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= tcp_paws_msl ) { tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ; tp -> rx_opt . ts_recent = peer -> tcp_ts ; } } } inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; if ( inet -> opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; tp -> rx_opt . mss_clamp = tcp_mss_default ; tcp_set_state ( sk , tcp_syn_sent ) ; err = inet_hash_connect ( & tcp_death_row , sk ) ; if ( err ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( is_err ( rt ) ) { err = ptr_err ( rt ) ; rt = null ; goto failure ; } sk -> sk_gso_type = skb_gso_tcpv4 ; sk_setup_caps ( sk , & rt -> dst ) ; if ( ! tp -> write_seq ) tp -> write_seq = secure_tcp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , usin -> sin_port ) ; inet -> inet_id = tp -> write_seq ^ jiffies ; err = tcp_connect ( sk ) ; rt = null ; if ( err ) goto failure ; return 0 ; failure : tcp_set_state ( sk , tcp_close ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; return err ; }","<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> if ( ! inet_opt || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; tp
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> opt || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug>
4089,CWE-399,"static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( ipcb ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { ip_inc_stats_bh ( dev_net ( dev ) , ipstats_mib_intruncatedpkts ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { ip_inc_stats_bh ( dev_net ( dev ) , ipstats_mib_indiscards ) ; goto drop ; } if ( iph -> ihl == 5 ) { memset ( ipcb ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; } opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! in_dev_source_route ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : ip_inc_stats_bh ( dev_net ( dev ) , ipstats_mib_inhdrerrors ) ; drop : return - 1 ; }","<S2SV_ModStart> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart> == 5 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> opt -> optlen
",torvalds@linux/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,CVE-2011-4087,https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,2013-06-08T13:05Z,<S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
193,CWE-399,static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { if ( vcpu -> arch . time_page ) { kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = null ; } },"<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1,CVE-2013-1797,https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1,2013-03-22T11:59Z,<S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug>
3396,CWE-404,"int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , page_size ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; return xdr_argsize_check ( rqstp , p ) ; }","<S2SV_ModStart> p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> v ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,"<S2SV_StartBug> args -> count = ntohl ( * p ++ ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug>"
871,CWE-200,"static long sg_ioctl ( struct file * filp , unsigned int cmd_in , unsigned long arg ) { void __user * p = ( void __user * ) arg ; int __user * ip = p ; int result , val , read_only ; sg_device * sdp ; sg_fd * sfp ; sg_request * srp ; unsigned long iflags ; if ( ( ! ( sfp = ( sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - enxio ; scsi_log_timeout ( 3 , sg_printk ( kern_info , sdp , ""sg_ioctl:<s2sv_blank>cmd=0x%x\\n"" , ( int ) cmd_in ) ) ; read_only = ( o_rdwr != ( filp -> f_flags & o_accmode ) ) ; switch ( cmd_in ) { case sg_io : if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; if ( ! scsi_block_when_processing_errors ( sdp -> device ) ) return - enxio ; if ( ! access_ok ( verify_write , p , sz_sg_io_hdr ) ) return - efault ; result = sg_new_write ( sfp , filp , p , sz_sg_io_hdr , 1 , read_only , 1 , & srp ) ; if ( result < 0 ) return result ; result = wait_event_interruptible ( sfp -> read_wait , ( srp_done ( sfp , srp ) || atomic_read ( & sdp -> detaching ) ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; write_lock_irq ( & sfp -> rq_list_lock ) ; if ( srp -> done ) { srp -> done = 2 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; result = sg_new_read ( sfp , p , sz_sg_io_hdr , srp ) ; return ( result < 0 ) ? result : 0 ; } srp -> orphan = 1 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; return result ; case sg_set_timeout : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - eio ; if ( val >= mult_frac ( ( s64 ) int_max , user_hz , hz ) ) val = min_t ( s64 , mult_frac ( ( s64 ) int_max , user_hz , hz ) , int_max ) ; sfp -> timeout_user = val ; sfp -> timeout = mult_frac ( val , hz , user_hz ) ; return 0 ; case sg_get_timeout : return sfp -> timeout_user ; case sg_set_force_low_dma : return 0 ; case sg_get_low_dma : return put_user ( ( int ) sdp -> device -> host -> unchecked_isa_dma , ip ) ; case sg_get_scsi_id : if ( ! access_ok ( verify_write , p , sizeof ( sg_scsi_id_t ) ) ) return - efault ; else { sg_scsi_id_t __user * sg_idp = p ; if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; __put_user ( ( int ) sdp -> device -> host -> host_no , & sg_idp -> host_no ) ; __put_user ( ( int ) sdp -> device -> channel , & sg_idp -> channel ) ; __put_user ( ( int ) sdp -> device -> id , & sg_idp -> scsi_id ) ; __put_user ( ( int ) sdp -> device -> lun , & sg_idp -> lun ) ; __put_user ( ( int ) sdp -> device -> type , & sg_idp -> scsi_type ) ; __put_user ( ( short ) sdp -> device -> host -> cmd_per_lun , & sg_idp -> h_cmd_per_lun ) ; __put_user ( ( short ) sdp -> device -> queue_depth , & sg_idp -> d_queue_depth ) ; __put_user ( 0 , & sg_idp -> unused [ 0 ] ) ; __put_user ( 0 , & sg_idp -> unused [ 1 ] ) ; return 0 ; } case sg_set_force_pack_id : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> force_packid = val ? 1 : 0 ; return 0 ; case sg_get_pack_id : if ( ! access_ok ( verify_write , ip , sizeof ( int ) ) ) return - efault ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) { read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( srp -> header . pack_id , ip ) ; return 0 ; } } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( - 1 , ip ) ; return 0 ; case sg_get_num_waiting : read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) ++ val ; } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; return put_user ( val , ip ) ; case sg_get_sg_tablesize : return put_user ( sdp -> sg_tablesize , ip ) ; case sg_set_reserved_size : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - einval ; val = min_t ( int , val , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; mutex_lock ( & sfp -> f_mutex ) ; if ( val != sfp -> reserve . bufflen ) { if ( sfp -> mmap_called || sfp -> res_in_use ) { mutex_unlock ( & sfp -> f_mutex ) ; return - ebusy ; } sg_remove_scat ( sfp , & sfp -> reserve ) ; sg_build_reserve ( sfp , val ) ; } mutex_unlock ( & sfp -> f_mutex ) ; return 0 ; case sg_get_reserved_size : val = min_t ( int , sfp -> reserve . bufflen , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; return put_user ( val , ip ) ; case sg_set_command_q : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> cmd_q = val ? 1 : 0 ; return 0 ; case sg_get_command_q : return put_user ( ( int ) sfp -> cmd_q , ip ) ; case sg_set_keep_orphan : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> keep_orphan = val ; return 0 ; case sg_get_keep_orphan : return put_user ( ( int ) sfp -> keep_orphan , ip ) ; case sg_next_cmd_len : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val > sg_max_cdb_size ) return - enomem ; sfp -> next_cmd_len = ( val > 0 ) ? val : 0 ; return 0 ; case sg_get_version_num : return put_user ( sg_version_num , ip ) ; case sg_get_access_count : val = ( sdp -> device ? 1 : 0 ) ; return put_user ( val , ip ) ; case sg_get_request_table : if ( ! access_ok ( verify_write , p , sz_sg_req_info * sg_max_queue ) ) return - efault ; else { sg_req_info_t * rinfo ; rinfo = kmalloc ( sz_sg_req_info * sg_max_queue , gfp_kernel ) ; if ( ! rinfo ) return - enomem ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; sg_fill_request_table ( sfp , rinfo ) ; read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; result = __copy_to_user ( p , rinfo , sz_sg_req_info * sg_max_queue ) ; result = result ? - efault : 0 ; kfree ( rinfo ) ; return result ; } case sg_emulated_host : if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; return put_user ( sdp -> device -> host -> hostt -> emulated , ip ) ; case scsi_ioctl_send_command : if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; if ( read_only ) { unsigned char opcode = write_6 ; scsi_ioctl_command __user * siocp = p ; if ( copy_from_user ( & opcode , siocp -> data , 1 ) ) return - efault ; if ( sg_allow_access ( filp , & opcode ) ) return - eperm ; } return sg_scsi_ioctl ( sdp -> device -> request_queue , null , filp -> f_mode , p ) ; case sg_set_debug : result = get_user ( val , ip ) ; if ( result ) return result ; sdp -> sgdebug = ( char ) val ; return 0 ; case blksectget : return put_user ( max_sectors_bytes ( sdp -> device -> request_queue ) , ip ) ; case blktracesetup : return blk_trace_setup ( sdp -> device -> request_queue , sdp -> disk -> disk_name , mkdev ( scsi_generic_major , sdp -> index ) , null , p ) ; case blktracestart : return blk_trace_startstop ( sdp -> device -> request_queue , 1 ) ; case blktracestop : return blk_trace_startstop ( sdp -> device -> request_queue , 0 ) ; case blktraceteardown : return blk_trace_remove ( sdp -> device -> request_queue ) ; case scsi_ioctl_get_idlun : case scsi_ioctl_get_bus_number : case scsi_ioctl_probe_host : case sg_get_transform : case sg_scsi_reset : if ( atomic_read ( & sdp -> detaching ) ) return - enodev ; break ; default : if ( read_only ) return - eperm ; break ; } result = scsi_ioctl_block_when_processing_errors ( sdp -> device , cmd_in , filp -> f_flags & o_ndelay ) ; if ( result ) return result ; return scsi_ioctl ( sdp -> device , cmd_in , p ) ; }","<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
",torvalds@linux/3e0097499839e0fe3af380410eababe5a47c4cf9,CVE-2017-14991,https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9,2017-10-04T01:29Z,"<S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug>"
2440,CWE-000,"static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; if ( ! net_eq ( net , & init_net ) ) return - eafnosupport ; switch ( sock -> type ) { case sock_dgram : if ( protocol == 0 || protocol == pf_ax25 ) protocol = ax25_p_text ; break ; case sock_seqpacket : switch ( protocol ) { case 0 : case pf_ax25 : protocol = ax25_p_text ; break ; case ax25_p_segment : # ifdef config_inet case ax25_p_arp : case ax25_p_ip : # endif # ifdef config_netrom case ax25_p_netrom : # endif # ifdef config_rose case ax25_p_rose : # endif return - esocktnosupport ; # ifdef config_netrom_module case ax25_p_netrom : if ( ax25_protocol_is_registered ( ax25_p_netrom ) ) return - esocktnosupport ; break ; # endif # ifdef config_rose_module case ax25_p_rose : if ( ax25_protocol_is_registered ( ax25_p_rose ) ) return - esocktnosupport ; # endif default : break ; } break ; case sock_raw : break ; default : return - esocktnosupport ; } sk = sk_alloc ( net , pf_ax25 , gfp_atomic , & ax25_proto , kern ) ; if ( sk == null ) return - enomem ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - enomem ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }","<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
",torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z,"<S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug>"
5995,CWE-119,"int psf_binheader_writef ( sf_private * psf , const char * format , ... ) { va_list argptr ; sf_count_t countdata ; unsigned long longdata ; unsigned int data ; float floatdata ; double doubledata ; void * bindata ; size_t size ; char c , * strptr ; int count = 0 , trunc_8to4 ; trunc_8to4 = sf_false ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) { switch ( c ) { case '<s2sv_blank>' : break ; case 'e' : psf -> rwf_endian = sf_endian_little ; break ; case 'e' : psf -> rwf_endian = sf_endian_big ; break ; case 't' : trunc_8to4 = sf_true ; break ; case 't' : trunc_8to4 = sf_false ; break ; case 'm' : data = va_arg ( argptr , unsigned int ) ; header_put_marker ( psf , data ) ; count += 4 ; break ; case '1' : data = va_arg ( argptr , unsigned int ) ; header_put_byte ( psf , data ) ; count += 1 ; break ; case '2' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == sf_endian_big ) { header_put_be_short ( psf , data ) ; } else { header_put_le_short ( psf , data ) ; } ; count += 2 ; break ; case '3' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == sf_endian_big ) { header_put_be_3byte ( psf , data ) ; } else { header_put_le_3byte ( psf , data ) ; } ; count += 3 ; break ; case '4' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == sf_endian_big ) { header_put_be_int ( psf , data ) ; } else { header_put_le_int ( psf , data ) ; } ; count += 4 ; break ; case '8' : countdata = va_arg ( argptr , sf_count_t ) ; if ( psf -> rwf_endian == sf_endian_big && trunc_8to4 == sf_false ) { header_put_be_8byte ( psf , countdata ) ; count += 8 ; } else if ( psf -> rwf_endian == sf_endian_little && trunc_8to4 == sf_false ) { header_put_le_8byte ( psf , countdata ) ; count += 8 ; } else if ( psf -> rwf_endian == sf_endian_big && trunc_8to4 == sf_true ) { longdata = countdata & 0xffffffff ; header_put_be_int ( psf , longdata ) ; count += 4 ; } else if ( psf -> rwf_endian == sf_endian_little && trunc_8to4 == sf_true ) { longdata = countdata & 0xffffffff ; header_put_le_int ( psf , longdata ) ; count += 4 ; } break ; case 'f' : floatdata = ( float ) va_arg ( argptr , double ) ; if ( psf -> rwf_endian == sf_endian_big ) float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; else float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; psf -> headindex += 4 ; count += 4 ; break ; case 'd' : doubledata = va_arg ( argptr , double ) ; if ( psf -> rwf_endian == sf_endian_big ) double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; else double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; psf -> headindex += 8 ; count += 8 ; break ; case 's' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) + 1 ; size += ( size & 1 ) ; if ( psf -> rwf_endian == sf_endian_big ) header_put_be_int ( psf , size ) ; else header_put_le_int ( psf , size ) ; memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; psf -> headindex += size ; psf -> header [ psf -> headindex - 1 ] = 0 ; count += 4 + size ; break ; case 's' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) ; if ( psf -> rwf_endian == sf_endian_big ) header_put_be_int ( psf , size ) ; else header_put_le_int ( psf , size ) ; memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; size += ( size & 1 ) ; psf -> headindex += size ; psf -> header [ psf -> headindex ] = 0 ; count += 4 + size ; break ; case 'p' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) ; size = ( size & 1 ) ? size : size + 1 ; size = ( size > 254 ) ? 254 : size ; header_put_byte ( psf , size ) ; memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; psf -> headindex += size ; count += 1 + size ; break ; case 'b' : bindata = va_arg ( argptr , void * ) ; size = va_arg ( argptr , size_t ) ; if ( psf -> headindex + size < sizeof ( psf -> header ) ) { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; psf -> headindex += size ; count += size ; } ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; count += size ; while ( size ) { psf -> header [ psf -> headindex ] = 0 ; psf -> headindex ++ ; size -- ; } ; break ; case 'h' : bindata = va_arg ( argptr , void * ) ; memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; psf -> headindex += 16 ; count += 16 ; break ; case 'j' : size = va_arg ( argptr , size_t ) ; psf -> headindex += size ; count += size ; break ; case 'o' : size = va_arg ( argptr , size_t ) ; if ( size < sizeof ( psf -> header ) ) { psf -> headindex = size ; count = 0 ; } ; break ; default : psf_log_printf ( psf , ""***<s2sv_blank>invalid<s2sv_blank>format<s2sv_blank>specifier<s2sv_blank>`%c\'\\n"" , c ) ; psf -> error = sfe_internal ; break ; } ; } ; va_end ( argptr ) ; return count ; }","<S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 4 ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 8 ; <S2SV_ModStart> & 1 ) ; if ( psf -> header . indx + ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> - 1 ] <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; if ( psf -> <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] = 0 <S2SV_ModStart> : size ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; memcpy ( & ( psf -> header . ptr [ psf -> header . indx ] ) , bindata , size ) ; psf -> header . indx += size ; count += size ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; count += size ; while ( size ) { psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx ] <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> ++ ; size <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += 16 ; <S2SV_ModStart> size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ; if ( ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx = size <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> size += ( size & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex - 1 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> header_put_byte ( psf , size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + size < sizeof ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex ++ ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += 16 ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( size < sizeof ( psf -> header ) ) <S2SV_EndBug>"
7606,CWE-190,"static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; cmpt = 0 ; if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || ! jas_safe_intfast32_add ( tly , height , 0 ) ) { goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = jas_image_ct_unknown ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( size > 0 ) { if ( size - 1 > long_max ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , seek_set ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == eof || jas_stream_seek ( cmpt -> stream_ , 0 , seek_set ) < 0 ) { goto error ; } } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }","<S2SV_ModStart> size_t size ; JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n"" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> tly , height , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> if ( ! jas_safe_size_mul3 <S2SV_ModEnd> ( cmpt -> <S2SV_ModStart> cmpt -> height_ <S2SV_ModEnd> , cmpt ->
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,"<S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug>"
1266,CWE-264,"void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , eth_alen ) ; dev -> addr_len = eth_alen ; ether_setup ( dev ) ; dev -> netdev_ops = & bnep_netdev_ops ; dev -> watchdog_timeo = hz * 2 ; }","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug>
2741,CWE-399,"int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; if ( vm_flags & vm_noreserve ) return 0 ; if ( ! vma || vma -> vm_flags & vm_mayshare ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - enomem ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , hpage_resv_owner ) ; } if ( chg < 0 ) return chg ; if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) return - enospc ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { hugetlb_put_quota ( inode -> i_mapping , chg ) ; return ret ; } if ( ! vma || vma -> vm_flags & vm_mayshare ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }","<S2SV_ModStart> inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> 0 ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg )
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,"<S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug>"
1182,CWE-125,"void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , sock_rcvtstamp ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , sock_rcvtstampns ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , sol_socket , scm_timestamp , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , sol_socket , scm_timestampns , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & sof_timestamping_software ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & sof_timestamping_raw_hardware ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , sol_socket , scm_timestamping , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && ( sk -> sk_tsflags & sof_timestamping_opt_stats ) ) put_cmsg ( msg , sol_socket , scm_timestamping_opt_stats , skb -> len , skb -> data ) ; } }","<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,<S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug>
3836,CWE-264,"static ssize_t hfi1_file_write ( struct file * fp , const char __user * data , size_t count , loff_t * offset ) { const struct hfi1_cmd __user * ucmd ; struct hfi1_filedata * fd = fp -> private_data ; struct hfi1_ctxtdata * uctxt = fd -> uctxt ; struct hfi1_cmd cmd ; struct hfi1_user_info uinfo ; struct hfi1_tid_info tinfo ; unsigned long addr ; ssize_t consumed = 0 , copy = 0 , ret = 0 ; void * dest = null ; __u64 user_val = 0 ; int uctxt_required = 1 ; int must_be_root = 0 ; if ( count < sizeof ( cmd ) ) { ret = - einval ; goto bail ; } ucmd = ( const struct hfi1_cmd __user * ) data ; if ( copy_from_user ( & cmd , ucmd , sizeof ( cmd ) ) ) { ret = - efault ; goto bail ; } consumed = sizeof ( cmd ) ; switch ( cmd . type ) { case hfi1_cmd_assign_ctxt : uctxt_required = 0 ; copy = sizeof ( uinfo ) ; dest = & uinfo ; break ; case hfi1_cmd_sdma_status_upd : case hfi1_cmd_credit_upd : copy = 0 ; break ; case hfi1_cmd_tid_update : case hfi1_cmd_tid_free : case hfi1_cmd_tid_inval_read : copy = sizeof ( tinfo ) ; dest = & tinfo ; break ; case hfi1_cmd_user_info : case hfi1_cmd_recv_ctrl : case hfi1_cmd_poll_type : case hfi1_cmd_ack_event : case hfi1_cmd_ctxt_info : case hfi1_cmd_set_pkey : case hfi1_cmd_ctxt_reset : copy = 0 ; user_val = cmd . addr ; break ; case hfi1_cmd_ep_info : case hfi1_cmd_ep_erase_chip : case hfi1_cmd_ep_erase_range : case hfi1_cmd_ep_read_range : case hfi1_cmd_ep_write_range : uctxt_required = 0 ; must_be_root = 1 ; copy = 0 ; break ; default : ret = - einval ; goto bail ; } if ( copy ) { if ( copy_from_user ( dest , ( void __user * ) cmd . addr , copy ) ) { ret = - efault ; goto bail ; } consumed += copy ; } if ( uctxt_required && ! uctxt ) { ret = - einval ; goto bail ; } if ( must_be_root && ! capable ( cap_sys_admin ) ) { ret = - eperm ; goto bail ; } switch ( cmd . type ) { case hfi1_cmd_assign_ctxt : ret = assign_ctxt ( fp , & uinfo ) ; if ( ret < 0 ) goto bail ; ret = setup_ctxt ( fp ) ; if ( ret ) goto bail ; ret = user_init ( fp ) ; break ; case hfi1_cmd_ctxt_info : ret = get_ctxt_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case hfi1_cmd_user_info : ret = get_base_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case hfi1_cmd_sdma_status_upd : break ; case hfi1_cmd_credit_upd : if ( uctxt && uctxt -> sc ) sc_return_credits ( uctxt -> sc ) ; break ; case hfi1_cmd_tid_update : ret = hfi1_user_exp_rcv_setup ( fp , & tinfo ) ; if ( ! ret ) { addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) + sizeof ( tinfo . length ) ) ) ret = - efault ; } break ; case hfi1_cmd_tid_inval_read : ret = hfi1_user_exp_rcv_invalid ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - efault ; break ; case hfi1_cmd_tid_free : ret = hfi1_user_exp_rcv_clear ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - efault ; break ; case hfi1_cmd_recv_ctrl : ret = manage_rcvq ( uctxt , fd -> subctxt , ( int ) user_val ) ; break ; case hfi1_cmd_poll_type : uctxt -> poll_type = ( typeof ( uctxt -> poll_type ) ) user_val ; break ; case hfi1_cmd_ack_event : ret = user_event_ack ( uctxt , fd -> subctxt , user_val ) ; break ; case hfi1_cmd_set_pkey : if ( hfi1_cap_is_uset ( pkey_check ) ) ret = set_ctxt_pkey ( uctxt , fd -> subctxt , user_val ) ; else ret = - eperm ; break ; case hfi1_cmd_ctxt_reset : { struct send_context * sc ; struct hfi1_devdata * dd ; if ( ! uctxt || ! uctxt -> dd || ! uctxt -> sc ) { ret = - einval ; break ; } dd = uctxt -> dd ; sc = uctxt -> sc ; wait_event_interruptible_timeout ( sc -> halt_wait , ( sc -> flags & scf_halted ) , msecs_to_jiffies ( send_ctxt_halt_timeout ) ) ; if ( ! ( sc -> flags & scf_halted ) ) { ret = - enolck ; break ; } if ( sc -> flags & scf_frozen ) { wait_event_interruptible_timeout ( dd -> event_queue , ! ( access_once ( dd -> flags ) & hfi1_frozen ) , msecs_to_jiffies ( send_ctxt_halt_timeout ) ) ; if ( dd -> flags & hfi1_frozen ) { ret = - enolck ; break ; } if ( dd -> flags & hfi1_forced_freeze ) { ret = - enodev ; break ; } sc_disable ( sc ) ; ret = sc_enable ( sc ) ; hfi1_rcvctrl ( dd , hfi1_rcvctrl_ctxt_enb , uctxt -> ctxt ) ; } else { ret = sc_restart ( sc ) ; } if ( ! ret ) sc_return_credits ( sc ) ; break ; } case hfi1_cmd_ep_info : case hfi1_cmd_ep_erase_chip : case hfi1_cmd_ep_erase_range : case hfi1_cmd_ep_read_range : case hfi1_cmd_ep_write_range : ret = handle_eprom_command ( fp , & cmd ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
",torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z,<S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug>
7624,CWE-190,"int jas_seq2d_output ( jas_matrix_t * matrix , file * out ) { # define maxlinelen 80 int i ; int j ; jas_seqent_t x ; char buf [ maxlinelen + 1 ] ; char sbuf [ maxlinelen + 1 ] ; int n ; fprintf ( out , ""%"" priifast32 ""<s2sv_blank>%"" priifast32 ""\\n"" , jas_seq2d_xstart ( matrix ) , jas_seq2d_ystart ( matrix ) ) ; fprintf ( out , ""%"" priifast32 ""<s2sv_blank>%"" priifast32 ""\\n"" , jas_matrix_numcols ( matrix ) , jas_matrix_numrows ( matrix ) ) ; buf [ 0 ] = '\\0' ; for ( i = 0 ; i < jas_matrix_numrows ( matrix ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( matrix ) ; ++ j ) { x = jas_matrix_get ( matrix , i , j ) ; sprintf ( sbuf , ""%s%4ld"" , ( strlen ( buf ) > 0 ) ? ""<s2sv_blank>"" : """" , jas_cast ( long , x ) ) ; n = jas_cast ( int , strlen ( buf ) ) ; if ( n + jas_cast ( int , strlen ( sbuf ) ) > maxlinelen ) { fputs ( buf , out ) ; fputs ( ""\\n"" , out ) ; buf [ 0 ] = '\\0' ; } strcat ( buf , sbuf ) ; if ( j == jas_matrix_numcols ( matrix ) - 1 ) { fputs ( buf , out ) ; fputs ( ""\\n"" , out ) ; buf [ 0 ] = '\\0' ; } } } fputs ( buf , out ) ; return 0 ; }","<S2SV_ModStart> define MAXLINELEN 80 jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,<S2SV_StartBug> int i ; <S2SV_EndBug>
7232,CWE-19,"static int ext2_xattr_set2 ( struct inode * inode , struct buffer_head * old_bh , struct ext2_xattr_header * header ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = null ; int error ; if ( header ) { new_bh = ext2_xattr_cache_find ( inode , header ) ; if ( new_bh ) { if ( new_bh == old_bh ) { ea_bdebug ( new_bh , ""keeping<s2sv_blank>this<s2sv_blank>block"" ) ; } else { ea_bdebug ( new_bh , ""reusing<s2sv_blank>block"" ) ; error = dquot_alloc_block ( inode , 1 ) ; if ( error ) { unlock_buffer ( new_bh ) ; goto cleanup ; } le32_add_cpu ( & hdr ( new_bh ) -> h_refcount , 1 ) ; ea_bdebug ( new_bh , ""refcount<s2sv_blank>now=%d"" , le32_to_cpu ( hdr ( new_bh ) -> h_refcount ) ) ; } unlock_buffer ( new_bh ) ; } else if ( old_bh && header == hdr ( old_bh ) ) { new_bh = old_bh ; get_bh ( new_bh ) ; ext2_xattr_cache_insert ( new_bh ) ; } else { ext2_fsblk_t goal = ext2_group_first_block_no ( sb , ext2_i ( inode ) -> i_block_group ) ; int block = ext2_new_block ( inode , goal , & error ) ; if ( error ) goto cleanup ; ea_idebug ( inode , ""creating<s2sv_blank>block<s2sv_blank>%d"" , block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { ext2_free_blocks ( inode , block , 1 ) ; mark_inode_dirty ( inode ) ; error = - enomem ; goto cleanup ; } lock_buffer ( new_bh ) ; memcpy ( new_bh -> b_data , header , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext2_xattr_cache_insert ( new_bh ) ; ext2_xattr_update_super_block ( sb ) ; } mark_buffer_dirty ( new_bh ) ; if ( is_sync ( inode ) ) { sync_dirty_buffer ( new_bh ) ; error = - eio ; if ( buffer_req ( new_bh ) && ! buffer_uptodate ( new_bh ) ) goto cleanup ; } } ext2_i ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; inode -> i_ctime = current_time_sec ; if ( is_sync ( inode ) ) { error = sync_inode_metadata ( inode , 1 ) ; if ( error && error != - enospc ) { if ( new_bh && new_bh != old_bh ) { dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; } goto cleanup ; } } else mark_inode_dirty ( inode ) ; error = 0 ; if ( old_bh && old_bh != new_bh ) { struct mb_cache_entry * ce ; ce = mb_cache_entry_get ( ext2_xattr_cache , old_bh -> b_bdev , old_bh -> b_blocknr ) ; lock_buffer ( old_bh ) ; if ( hdr ( old_bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { if ( ce ) mb_cache_entry_free ( ce ) ; ea_bdebug ( old_bh , ""freeing"" ) ; ext2_free_blocks ( inode , old_bh -> b_blocknr , 1 ) ; mark_inode_dirty ( inode ) ; get_bh ( old_bh ) ; bforget ( old_bh ) ; } else { le32_add_cpu ( & hdr ( old_bh ) -> h_refcount , - 1 ) ; if ( ce ) mb_cache_entry_release ( ce ) ; dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; mark_buffer_dirty ( old_bh ) ; ea_bdebug ( old_bh , ""refcount<s2sv_blank>now=%d"" , le32_to_cpu ( hdr ( old_bh ) -> h_refcount ) ) ; } unlock_buffer ( old_bh ) ; } cleanup : brelse ( new_bh ) ; return error ; }","<S2SV_ModStart> int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ; <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> new_bh ) { <S2SV_ModEnd> lock_buffer ( old_bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( old_bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext2_mb_cache , hash , old_bh -> b_blocknr <S2SV_ModEnd> ) ; ea_bdebug <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> dquot_free_block_nodirty ( inode
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,<S2SV_StartBug> if ( header ) { <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug>
2939,CWE-77,"static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; bt_dbg ( ""cmd<s2sv_blank>%x<s2sv_blank>arg<s2sv_blank>%p"" , cmd , argp ) ; switch ( cmd ) { case hidpconnadd : if ( ! capable ( cap_net_admin ) ) return - eperm ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - efault ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; } err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - efault ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case hidpconndel : if ( ! capable ( cap_net_admin ) ) return - eperm ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - efault ; return hidp_connection_del ( & cd ) ; case hidpgetconnlist : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - efault ; if ( cl . cnum <= 0 ) return - einval ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - efault ; return err ; case hidpgetconninfo : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - efault ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - efault ; return err ; } return - einval ; }","<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
",torvalds@linux/a1616a5ac99ede5d605047a9012481ce7ff18b16,CVE-2019-11884,https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16,2019-05-10T22:29Z,<S2SV_StartBug> } <S2SV_EndBug>
765,CWE-20,"long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = null ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - einval ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , key_lookup_create | key_lookup_partial , key_need_setattr ) ; if ( is_err ( key_ref ) ) { ret = ptr_err ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - eacces ; down_write ( & key -> sem ) ; if ( ! capable ( cap_sys_admin ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - enomem ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( key_flag_in_quota , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , global_root_uid ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , global_root_uid ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ; if ( test_bit ( key_flag_instantiated , & key -> flags ) ) { atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - edquot ; goto error_put ; }","<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug>"
6832,CWE-190,"static pyobject * _unpickler_memoget ( unpicklerobject * self , py_ssize_t idx ) { if ( idx < 0 || idx >= self -> memo_size ) return null ; return self -> memo [ idx ] ; }","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx ) { <S2SV_ModStart> { if ( <S2SV_ModEnd> idx >= self
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,"<S2SV_StartBug> _Unpickler_MemoGet ( UnpicklerObject * self , Py_ssize_t idx ) <S2SV_EndBug> <S2SV_StartBug> if ( idx < 0 || idx >= self -> memo_size ) <S2SV_EndBug>"
2214,CWE-200,"static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == null ) { warn_once ( 1 , ""use<s2sv_blank>an<s2sv_blank>actual<s2sv_blank>device<s2sv_blank>structure<s2sv_blank>for<s2sv_blank>dma<s2sv_blank>allocation\\n"" ) ; return null ; } if ( is_enabled ( config_zone_dma ) && dev -> coherent_dma_mask <= dma_bit_mask ( 32 ) ) flags |= gfp_dma ; if ( is_enabled ( config_dma_cma ) && ( flags & __gfp_wait ) ) { struct page * page ; void * addr ; size = page_align ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> page_shift , get_order ( size ) ) ; if ( ! page ) return null ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ; if ( flags & __gfp_zero ) memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }","<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr
",torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug>
1092,CWE-200,"static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != tcp_established ) return - enotconn ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ msg_dontwait , flags & msg_dontwait , & er ) ) == null ) return er ; qbit = ( skb -> data [ 0 ] & rose_q_bit ) == rose_q_bit ; skb_pull ( skb , rose_min_len ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= msg_trunc ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != null ) { srose -> srose_family = af_rose ; srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }","<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;
",torvalds@linux/4a184233f21645cf0b719366210ed445d1024d72,CVE-2013-3234,https://github.com/torvalds/linux/commit/4a184233f21645cf0b719366210ed445d1024d72,2013-04-22T11:41Z,<S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug>
7853,CWE-20,"uint16_t dm9000readphyreg ( uint8_t address ) { dm9000writereg ( dm9000_reg_epar , 0x40 | address ) ; dm9000writereg ( dm9000_reg_epcr , epcr_epos | epcr_erprr ) ; while ( ( dm9000readreg ( dm9000_reg_epcr ) & epcr_erre ) != 0 ) { } dm9000writereg ( dm9000_reg_epcr , epcr_epos ) ; usleep ( 5 ) ; return ( dm9000readreg ( dm9000_reg_epdrh ) << 8 ) | dm9000readreg ( dm9000_reg_epdrl ) ; }","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug>"
2166,CWE-119,"static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = gfs2_i ( inode ) ; struct gfs2_sbd * sdp = gfs2_sb ( inode ) ; struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; const unsigned end_of_metadata = height - 1 ; int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; bug_on ( sheight < 1 ) ; bug_on ( dibh == null ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; bug_on ( dblks < 1 ) ; state = alloc_data ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = alloc_grow_depth ; } else { state = alloc_grow_height ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != alloc_data || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case alloc_grow_height : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = alloc_grow_depth ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == null ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = null ; } i = branch_start ; } if ( n == 0 ) break ; case alloc_grow_depth : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = alloc_data ; if ( n == 0 ) break ; case alloc_data : bug_on ( n > dblks ) ; bug_on ( mp -> mp_bh [ end_of_metadata ] == null ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ; break ; } } while ( ( state != alloc_data ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }","<S2SV_ModStart> ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> height - 1 ; int ret <S2SV_ModStart> ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } }
",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z,<S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug>
4104,CWE-399,"void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = null ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define local_ok 1 # define brd_ok 2 # define brd0_ok 4 # define brd1_ok 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & ifa_f_secondary ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( ""%s:<s2sv_blank>bug:<s2sv_blank>prim<s2sv_blank>==<s2sv_blank>null\\n"" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( ""%s:<s2sv_blank>bug:<s2sv_blank>iprim<s2sv_blank>!=<s2sv_blank>prim\\n"" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & ifa_f_noprefixroute ) ) fib_magic ( rtm_delroute , dev -> flags & iff_loopback ? rtn_local : rtn_unicast , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & ifa_f_secondary ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= local_ok ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= brd_ok ; if ( brd == ifa1 -> ifa_broadcast ) ok |= brd1_ok ; if ( any == ifa1 -> ifa_broadcast ) ok |= brd0_ok ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= brd_ok ; if ( brd == brd1 || brd == any1 ) ok |= brd1_ok ; if ( any == brd1 || any == any1 ) ok |= brd0_ok ; } } } if ( ! ( ok & brd_ok ) ) fib_magic ( rtm_delroute , rtn_broadcast , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & brd1_ok ) ) fib_magic ( rtm_delroute , rtn_broadcast , brd , 32 , prim ) ; if ( ! ( ok & brd0_ok ) ) fib_magic ( rtm_delroute , rtn_broadcast , any , 32 , prim ) ; } if ( ! ( ok & local_ok ) ) { unsigned int addr_type ; fib_magic ( rtm_delroute , rtn_local , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != rtn_local ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef local_ok # undef brd_ok # undef brd0_ok # undef brd1_ok }","<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :
",torvalds@linux/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,CVE-2016-3156,https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,2016-04-27T17:59Z,<S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
2495,CWE-399,"static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ; struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ; struct xen_netif_tx_request * txp ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ; if ( unlikely ( err ) ) { pending_ring_idx_t index ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , xen_netif_rsp_error ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ; pending_ring_idx_t index ; pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx ) ; continue ; } txp = & netbk -> pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , xen_netif_rsp_error ) ; index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; if ( err ) continue ; pending_idx = * ( ( u16 * ) skb -> data ) ; xen_netbk_idx_release ( netbk , pending_idx ) ; for ( j = start ; j < i ; j ++ ) { pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ; xen_netbk_idx_release ( netbk , pending_idx ) ; } err = newerr ; } * gopp = gop + 1 ; return err ; }","<S2SV_ModStart> ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo <S2SV_ModStart> err ) ) xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( <S2SV_ModStart> , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> continue ; } xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
",torvalds@linux/7d5145d8eb2b9791533ffe4dc003b129b9696c48,CVE-2013-0217,https://github.com/torvalds/linux/commit/7d5145d8eb2b9791533ffe4dc003b129b9696c48,2013-02-18T04:41Z,"<S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug>"
2889,CWE-415,"int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , gfp_kernel ) ; if ( ! new_blkg ) return - enomem ; preloaded = ! radix_tree_preload ( gfp_kernel ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; if ( is_err ( blkg ) ) { blkg_free ( new_blkg ) ; return ptr_err ( blkg ) ; } q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }","<S2SV_ModStart> blkg ) ) <S2SV_ModEnd> return PTR_ERR ( <S2SV_ModStart> blkg ) ; <S2SV_ModEnd> q -> root_blkg
",torvalds@linux/9b54d816e00425c3a517514e0d677bb3cec49258,CVE-2018-7480,https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258,2018-02-25T20:29Z,<S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
7989,CWE-120,"secureelementstatus_t secureelementprocessjoinaccept ( joinreqidentifier_t joinreqtype , uint8_t * joineui , uint16_t devnonce , uint8_t * encjoinaccept , uint8_t encjoinacceptsize , uint8_t * decjoinaccept , uint8_t * versionminor ) { secureelementstatus_t status = secure_element_error ; if ( ( encjoinaccept == null ) || ( decjoinaccept == null ) || ( versionminor == null ) ) { return secure_element_error_npe ; } keyidentifier_t enckeyid = nwk_key ; if ( joinreqtype != join_req ) { enckeyid = j_s_enc_key ; } uint8_t micheader10 [ 1 ] = { 0x20 } ; lr1110_crypto_process_join_accept ( & lr1110 , ( lr1110_crypto_status_t * ) & status , convert_key_id_from_se_to_lr1110 ( enckeyid ) , convert_key_id_from_se_to_lr1110 ( nwk_key ) , ( lr1110_crypto_lorawan_version_t ) 0 , micheader10 , encjoinaccept + 1 , encjoinacceptsize - 1 , decjoinaccept + 1 ) ; if ( status == secure_element_success ) { * versionminor = ( ( decjoinaccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; if ( * versionminor == 0 ) { return secure_element_success ; } } # if ( use_lrwan_1_1_x_crypto == 1 ) uint8_t micheader11 [ join_accept_mic_computation_offset ] = { 0 } ; uint16_t bufitr = 0 ; micheader11 [ bufitr ++ ] = ( uint8_t ) joinreqtype ; memcpyr ( micheader11 + bufitr , joineui , loramac_join_eui_field_size ) ; bufitr += loramac_join_eui_field_size ; micheader11 [ bufitr ++ ] = devnonce & 0xff ; micheader11 [ bufitr ++ ] = ( devnonce >> 8 ) & 0xff ; micheader11 [ bufitr ++ ] = 0x20 ; lr1110_crypto_process_join_accept ( & lr1110 , ( lr1110_crypto_status_t * ) & status , convert_key_id_from_se_to_lr1110 ( enckeyid ) , convert_key_id_from_se_to_lr1110 ( j_s_int_key ) , ( lr1110_crypto_lorawan_version_t ) 1 , micheader11 , encjoinaccept + 1 , encjoinacceptsize - 1 , decjoinaccept + 1 ) ; if ( status == secure_element_success ) { * versionminor = ( ( decjoinaccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; if ( * versionminor == 1 ) { return secure_element_success ; } } # endif return status ; }","<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
",Lora-net@LoRaMac-node/e3063a91daa7ad8a687223efa63079f0c24568e4,CVE-2020-11068,https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4,2020-06-23T17:15Z,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug>
5715,CWE-415,"static struct usmstatereference * usm_malloc_usmstatereference ( void ) { struct usmstatereference * retval = ( struct usmstatereference * ) calloc ( 1 , sizeof ( struct usmstatereference ) ) ; return retval ; }","<S2SV_ModStart> usmStateReference * retval ; retval = <S2SV_ModEnd> calloc ( 1 <S2SV_ModStart> ) ) ; if ( retval ) retval -> refcnt = 1 ;
",net-snmp@net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,CVE-2019-20892,https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,2020-06-25T10:15Z,<S2SV_StartBug> struct usmStateReference * retval = ( struct usmStateReference * ) <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug>
3559,CWE-400,"static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) { struct mnt_namespace * new_ns ; struct ucounts * ucounts ; int ret ; ucounts = inc_mnt_namespaces ( user_ns ) ; if ( ! ucounts ) return err_ptr ( - enospc ) ; new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , gfp_kernel ) ; if ( ! new_ns ) { dec_mnt_namespaces ( ucounts ) ; return err_ptr ( - enomem ) ; } ret = ns_alloc_inum ( & new_ns -> ns ) ; if ( ret ) { kfree ( new_ns ) ; dec_mnt_namespaces ( ucounts ) ; return err_ptr ( ret ) ; } new_ns -> ns . ops = & mntns_operations ; new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; atomic_set ( & new_ns -> count , 1 ) ; new_ns -> root = null ; init_list_head ( & new_ns -> list ) ; init_waitqueue_head ( & new_ns -> poll ) ; new_ns -> event = 0 ; new_ns -> user_ns = get_user_ns ( user_ns ) ; new_ns -> ucounts = ucounts ; return new_ns ; }","<S2SV_ModStart> = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z,<S2SV_StartBug> return new_ns ; <S2SV_EndBug>
405,CWE-362,"struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return null ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( ieee80211_num_tids * sizeof ( struct ieee80211_tx_latency_stat ) , gfp_atomic ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < ieee80211_num_tids ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , gfp_atomic ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; spin_lock_init ( & sta -> lock ) ; init_work ( & sta -> drv_unblock_wk , sta_unblock ) ; init_work ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef config_mac80211_mesh if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = nl80211_mesh_power_active ; # endif memcpy ( sta -> sta . addr , addr , eth_alen ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = ieee80211_sta_none ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < array_size ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < ieee80211_num_tids ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < ieee80211_num_acs ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < ieee80211_num_tids ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( ushrt_max ) ; sta -> sta . smps_mode = ieee80211_smps_off ; if ( sdata -> vif . type == nl80211_iftype_ap || sdata -> vif . type == nl80211_iftype_ap_vlan ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & ieee80211_ht_cap_sm_ps ) >> ieee80211_ht_cap_sm_ps_shift ; switch ( smps ) { case wlan_ht_smps_control_disabled : sta -> known_smps_mode = ieee80211_smps_off ; break ; case wlan_ht_smps_control_static : sta -> known_smps_mode = ieee80211_smps_static ; break ; case wlan_ht_smps_control_dynamic : sta -> known_smps_mode = ieee80211_smps_dynamic ; break ; default : warn_on ( 1 ) ; } } sta_dbg ( sdata , ""allocated<s2sv_blank>sta<s2sv_blank>%pm\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < ieee80211_num_tids ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return null ; }","<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
",torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z,<S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug>
1181,CWE-125,"void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; __skb_complete_tx_timestamp ( skb , sk , scm_tstamp_snd ) ; sock_put ( sk ) ; } }","<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,"<S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug>"
4530,CWE-125,"pyobject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; pyobject * result = null , * value = null ; if ( ! o ) { py_incref ( py_none ) ; return py_none ; } switch ( o -> kind ) { case module_kind : result = pytype_genericnew ( module_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_list ( o -> v . module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_type_ignores , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case interactive_kind : result = pytype_genericnew ( interactive_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case expression_kind : result = pytype_genericnew ( expression_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . expression . body ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case functiontype_kind : result = pytype_genericnew ( functiontype_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . functiontype . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_argtypes , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_expr ( o -> v . functiontype . returns ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_returns , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; case suite_kind : result = pytype_genericnew ( suite_type , null , null ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_body , value ) == - 1 ) goto failed ; py_decref ( value ) ; break ; } return result ; failed : py_xdecref ( value ) ; py_xdecref ( result ) ; return null ; }","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
7021,CWE-787,"static int decode_frame ( avcodeccontext * avctx , void * data , int * got_frame , avpacket * avpkt ) { exrcontext * s = avctx -> priv_data ; threadframe frame = { . f = data } ; avframe * picture = data ; uint8_t * ptr ; int i , y , ret , ymax ; int planes ; int out_line_size ; int nb_blocks ; uint64_t start_offset_table ; uint64_t start_next_scanline ; putbytecontext offset_table_writer ; bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; if ( ( ret = decode_header ( s , picture ) ) < 0 ) return ret ; switch ( s -> pixel_type ) { case exr_float : case exr_half : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = av_pix_fmt_gbrapf32 ; } else { avctx -> pix_fmt = av_pix_fmt_gbrapf32 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = av_pix_fmt_gbrpf32 ; } else { avctx -> pix_fmt = av_pix_fmt_grayf32 ; } } break ; case exr_uint : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = av_pix_fmt_rgba64 ; } else { avctx -> pix_fmt = av_pix_fmt_ya16 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = av_pix_fmt_rgb48 ; } else { avctx -> pix_fmt = av_pix_fmt_gray16 ; } } break ; default : av_log ( avctx , av_log_error , ""missing<s2sv_blank>channel<s2sv_blank>list.\\n"" ) ; return averror_invaliddata ; } if ( s -> apply_trc_type != avcol_trc_unspecified ) avctx -> color_trc = s -> apply_trc_type ; switch ( s -> compression ) { case exr_raw : case exr_rle : case exr_zip1 : s -> scan_lines_per_block = 1 ; break ; case exr_pxr24 : case exr_zip16 : s -> scan_lines_per_block = 16 ; break ; case exr_piz : case exr_b44 : case exr_b44a : s -> scan_lines_per_block = 32 ; break ; default : avpriv_report_missing_feature ( avctx , ""compression<s2sv_blank>%d"" , s -> compression ) ; return averror_patchwelcome ; } if ( s -> xmin > s -> xmax || s -> ymin > s -> ymax || s -> ydelta == 0xffffffff || s -> xdelta == 0xffffffff ) { av_log ( avctx , av_log_error , ""wrong<s2sv_blank>or<s2sv_blank>missing<s2sv_blank>size<s2sv_blank>information.\\n"" ) ; return averror_invaliddata ; } if ( ( ret = ff_set_dimensions ( avctx , s -> w , s -> h ) ) < 0 ) return ret ; s -> desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( ! s -> desc ) return averror_invaliddata ; if ( s -> desc -> flags & av_pix_fmt_flag_float ) { planes = s -> desc -> nb_components ; out_line_size = avctx -> width * 4 ; } else { planes = 1 ; out_line_size = avctx -> width * 2 * s -> desc -> nb_components ; } if ( s -> is_tile ) { nb_blocks = ( ( s -> xdelta + s -> tile_attr . xsize - 1 ) / s -> tile_attr . xsize ) * ( ( s -> ydelta + s -> tile_attr . ysize - 1 ) / s -> tile_attr . ysize ) ; } else { nb_blocks = ( s -> ydelta + s -> scan_lines_per_block - 1 ) / s -> scan_lines_per_block ; } if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) return ret ; if ( bytestream2_get_bytes_left ( & s -> gb ) / 8 < nb_blocks ) return averror_invaliddata ; if ( ! s -> is_tile && bytestream2_peek_le64 ( & s -> gb ) == 0 ) { av_log ( s -> avctx , av_log_debug , ""recreating<s2sv_blank>invalid<s2sv_blank>scanline<s2sv_blank>offset<s2sv_blank>table\\n"" ) ; start_offset_table = bytestream2_tell ( & s -> gb ) ; start_next_scanline = start_offset_table + nb_blocks * 8 ; bytestream2_init_writer ( & offset_table_writer , & avpkt -> data [ start_offset_table ] , nb_blocks * 8 ) ; for ( y = 0 ; y < nb_blocks ; y ++ ) { bytestream2_put_le64 ( & offset_table_writer , start_next_scanline ) ; bytestream2_seek ( & s -> gb , start_next_scanline + 4 , seek_set ) ; start_next_scanline += ( bytestream2_get_le32 ( & s -> gb ) + 8 ) ; } bytestream2_seek ( & s -> gb , start_offset_table , seek_set ) ; } s -> buf = avpkt -> data ; s -> buf_size = avpkt -> size ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] ; for ( y = 0 ; y < ffmin ( s -> ymin , s -> h ) ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } s -> picture = picture ; avctx -> execute2 ( avctx , decode_block , s -> thread_data , null , nb_blocks ) ; ymax = ffmax ( 0 , s -> ymax + 1 ) ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ; for ( y = ymax ; y < avctx -> height ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } picture -> pict_type = av_picture_type_i ; * got_frame = 1 ; return avpkt -> size ; }","<S2SV_ModStart> 1 ) ; if ( ymax < avctx -> height )
",FFmpeg@FFmpeg/b0a8b40294ea212c1938348ff112ef1b9bf16bb3,CVE-2020-35965,https://github.com/FFmpeg/FFmpeg/commit/b0a8b40294ea212c1938348ff112ef1b9bf16bb3,2021-01-04T02:15Z,<S2SV_StartBug> for ( i = 0 ; i < planes ; i ++ ) { <S2SV_EndBug>
2952,CWE-362,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = emulate_done ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; if ( ! is_guest_mode ( vcpu ) ) { vcpu -> run -> exit_reason = kvm_exit_internal_error ; vcpu -> run -> internal . suberror = kvm_internal_error_emulation ; vcpu -> run -> internal . ndata = 0 ; r = emulate_fail ; } kvm_queue_exception ( vcpu , ud_vector ) ; return r ; }","<S2SV_ModStart> ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
",torvalds@linux/a2b9e6c1a35afcc0973acb72e591c714e78885ff,CVE-2014-7842,https://github.com/torvalds/linux/commit/a2b9e6c1a35afcc0973acb72e591c714e78885ff,2014-11-30T01:59Z,<S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug>
4873,CWE-362,"static int mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) { struct mpt_ioctl_iocinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_iocinfo * karg ; mpt_adapter * ioc ; struct pci_dev * pdev ; int iocnum ; unsigned int port ; int cim_rev ; struct scsi_device * sdev ; virtdevice * vdevice ; if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev0 ) ) cim_rev = 0 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev1 ) ) cim_rev = 1 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo ) ) cim_rev = 2 ; else if ( data_size == ( sizeof ( struct mpt_ioctl_iocinfo_rev0 ) + 12 ) ) cim_rev = 0 ; else return - efault ; karg = memdup_user ( uarg , data_size ) ; if ( is_err ( karg ) ) { printk ( kern_err mynam ""%s@%d::mpt_ioctl_iocinfo()<s2sv_blank>-<s2sv_blank>memdup_user<s2sv_blank>returned<s2sv_blank>error<s2sv_blank>[%ld]\\n"" , __file__ , __line__ , ptr_err ( karg ) ) ; return ptr_err ( karg ) ; } if ( ( ( iocnum = mpt_verify_adapter ( karg -> hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == null ) ) { printk ( kern_debug mynam ""%s::mptctl_getiocinfo()<s2sv_blank>@%d<s2sv_blank>-<s2sv_blank>ioc%d<s2sv_blank>not<s2sv_blank>found!\\n"" , __file__ , __line__ , iocnum ) ; kfree ( karg ) ; return - enodev ; } if ( karg -> hdr . maxdatasize != data_size ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_getiocinfo<s2sv_blank>-<s2sv_blank>"" ""structure<s2sv_blank>size<s2sv_blank>mismatch.<s2sv_blank>command<s2sv_blank>not<s2sv_blank>completed.\\n"" , ioc -> name , __file__ , __line__ ) ; kfree ( karg ) ; return - efault ; } dctlprintk ( ioc , printk ( myioc_s_debug_fmt ""mptctl_getiocinfo<s2sv_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> bus_type == sas ) karg -> adaptertype = mpt_ioctl_interface_sas ; else if ( ioc -> bus_type == fc ) karg -> adaptertype = mpt_ioctl_interface_fc ; else karg -> adaptertype = mpt_ioctl_interface_scsi ; if ( karg -> hdr . port > 1 ) { kfree ( karg ) ; return - einval ; } port = karg -> hdr . port ; karg -> port = port ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg -> pciid = pdev -> device ; karg -> hwrev = pdev -> revision ; karg -> subsystemdevice = pdev -> subsystem_device ; karg -> subsystemvendor = pdev -> subsystem_vendor ; if ( cim_rev == 1 ) { karg -> pciinfo . u . bits . busnumber = pdev -> bus -> number ; karg -> pciinfo . u . bits . devicenumber = pci_slot ( pdev -> devfn ) ; karg -> pciinfo . u . bits . functionnumber = pci_func ( pdev -> devfn ) ; } else if ( cim_rev == 2 ) { karg -> pciinfo . u . bits . busnumber = pdev -> bus -> number ; karg -> pciinfo . u . bits . devicenumber = pci_slot ( pdev -> devfn ) ; karg -> pciinfo . u . bits . functionnumber = pci_func ( pdev -> devfn ) ; karg -> pciinfo . segmentid = pci_domain_nr ( pdev -> bus ) ; } karg -> numdevices = 0 ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { vdevice = sdev -> hostdata ; if ( vdevice == null || vdevice -> vtarget == null ) continue ; if ( vdevice -> vtarget -> tflags & mpt_target_flags_raid_component ) continue ; karg -> numdevices ++ ; } } karg -> fwversion = ioc -> facts . fwversion . word ; karg -> biosversion = ioc -> biosversion ; strncpy ( karg -> driverversion , mpt_linux_package_name , mpt_ioctl_version_length ) ; karg -> driverversion [ mpt_ioctl_version_length - 1 ] = '\\0' ; karg -> buschangeevent = 0 ; karg -> hostid = ioc -> pfacts [ port ] . portscsiid ; karg -> rsvd [ 0 ] = karg -> rsvd [ 1 ] = 0 ; if ( copy_to_user ( ( char __user * ) arg , karg , data_size ) ) { printk ( myioc_s_err_fmt ""%s@%d::mptctl_getiocinfo<s2sv_blank>-<s2sv_blank>"" ""unable<s2sv_blank>to<s2sv_blank>write<s2sv_blank>out<s2sv_blank>mpt_ioctl_iocinfo<s2sv_blank>struct<s2sv_blank>@<s2sv_blank>%p\\n"" , ioc -> name , __file__ , __line__ , uarg ) ; kfree ( karg ) ; return - efault ; } kfree ( karg ) ; return 0 ; }","<S2SV_ModStart> int mptctl_getiocinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> * karg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> pci_dev * pdev <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ( karg ) <S2SV_ModEnd> ; } if
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,"<S2SV_StartBug> mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> struct pci_dev * pdev ; <S2SV_EndBug> <S2SV_StartBug> return PTR_ERR ( karg ) ; <S2SV_EndBug>"
5542,CWE-434,"static int zipfileupdate ( sqlite3_vtab * pvtab , int nval , sqlite3_value * * apval , sqlite_int64 * prowid ) { zipfiletab * ptab = ( zipfiletab * ) pvtab ; int rc = sqlite_ok ; zipfileentry * pnew = 0 ; u32 mode = 0 ; u32 mtime = 0 ; i64 sz = 0 ; const char * zpath = 0 ; int npath = 0 ; const u8 * pdata = 0 ; int ndata = 0 ; int imethod = 0 ; u8 * pfree = 0 ; char * zfree = 0 ; zipfileentry * pold = 0 ; zipfileentry * pold2 = 0 ; int bupdate = 0 ; int bisdir = 0 ; u32 icrc32 = 0 ; if ( ptab -> pwritefd == 0 ) { rc = zipfilebegin ( pvtab ) ; if ( rc != sqlite_ok ) return rc ; } if ( sqlite3_value_type ( apval [ 0 ] ) != sqlite_null ) { const char * zdelete = ( const char * ) sqlite3_value_text ( apval [ 0 ] ) ; int ndelete = ( int ) strlen ( zdelete ) ; if ( nval > 1 ) { const char * zupdate = ( const char * ) sqlite3_value_text ( apval [ 1 ] ) ; if ( zupdate && zipfilecomparepath ( zupdate , zdelete , ndelete ) != 0 ) { bupdate = 1 ; } } for ( pold = ptab -> pfirstentry ; 1 ; pold = pold -> pnext ) { if ( zipfilecomparepath ( pold -> cds . zfile , zdelete , ndelete ) == 0 ) { break ; } assert ( pold -> pnext ) ; } } if ( nval > 1 ) { if ( sqlite3_value_type ( apval [ 5 ] ) != sqlite_null ) { zipfiletableerr ( ptab , ""sz<s2sv_blank>must<s2sv_blank>be<s2sv_blank>null"" ) ; rc = sqlite_constraint ; } if ( sqlite3_value_type ( apval [ 6 ] ) != sqlite_null ) { zipfiletableerr ( ptab , ""rawdata<s2sv_blank>must<s2sv_blank>be<s2sv_blank>null"" ) ; rc = sqlite_constraint ; } if ( rc == sqlite_ok ) { if ( sqlite3_value_type ( apval [ 7 ] ) == sqlite_null ) { bisdir = 1 ; } else { const u8 * ain = sqlite3_value_blob ( apval [ 7 ] ) ; int nin = sqlite3_value_bytes ( apval [ 7 ] ) ; int bauto = sqlite3_value_type ( apval [ 8 ] ) == sqlite_null ; imethod = sqlite3_value_int ( apval [ 8 ] ) ; sz = nin ; pdata = ain ; ndata = nin ; if ( imethod != 0 && imethod != 8 ) { zipfiletableerr ( ptab , ""unknown<s2sv_blank>compression<s2sv_blank>method:<s2sv_blank>%d"" , imethod ) ; rc = sqlite_constraint ; } else { if ( bauto || imethod ) { int ncmp ; rc = zipfiledeflate ( ain , nin , & pfree , & ncmp , & ptab -> base . zerrmsg ) ; if ( rc == sqlite_ok ) { if ( imethod || ncmp < nin ) { imethod = 8 ; pdata = pfree ; ndata = ncmp ; } } } icrc32 = crc32 ( 0 , ain , nin ) ; } } } if ( rc == sqlite_ok ) { rc = zipfilegetmode ( apval [ 3 ] , bisdir , & mode , & ptab -> base . zerrmsg ) ; } if ( rc == sqlite_ok ) { zpath = ( const char * ) sqlite3_value_text ( apval [ 2 ] ) ; npath = ( int ) strlen ( zpath ) ; mtime = zipfilegettime ( apval [ 4 ] ) ; } if ( rc == sqlite_ok && bisdir ) { if ( zpath [ npath - 1 ] != '/' ) { zfree = sqlite3_mprintf ( ""%s/"" , zpath ) ; if ( zfree == 0 ) { rc = sqlite_nomem ; } zpath = ( const char * ) zfree ; npath ++ ; } } if ( ( pold == 0 || bupdate ) && rc == sqlite_ok ) { zipfileentry * p ; for ( p = ptab -> pfirstentry ; p ; p = p -> pnext ) { if ( zipfilecomparepath ( p -> cds . zfile , zpath , npath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( ptab -> db ) ) { case sqlite_ignore : { goto zipfile_update_done ; } case sqlite_replace : { pold2 = p ; break ; } default : { zipfiletableerr ( ptab , ""duplicate<s2sv_blank>name:<s2sv_blank>\\""%s\\"""" , zpath ) ; rc = sqlite_constraint ; break ; } } break ; } } } if ( rc == sqlite_ok ) { pnew = zipfilenewentry ( zpath ) ; if ( pnew == 0 ) { rc = sqlite_nomem ; } else { pnew -> cds . iversionmadeby = zipfile_newentry_madeby ; pnew -> cds . iversionextract = zipfile_newentry_required ; pnew -> cds . flags = zipfile_newentry_flags ; pnew -> cds . icompression = ( u16 ) imethod ; zipfilemtimetodos ( & pnew -> cds , mtime ) ; pnew -> cds . crc32 = icrc32 ; pnew -> cds . szcompressed = ndata ; pnew -> cds . szuncompressed = ( u32 ) sz ; pnew -> cds . iexternalattr = ( mode << 16 ) ; pnew -> cds . ioffset = ( u32 ) ptab -> szcurrent ; pnew -> cds . nfile = ( u16 ) npath ; pnew -> munixtime = ( u32 ) mtime ; rc = zipfileappendentry ( ptab , pnew , pdata , ndata ) ; zipfileaddentry ( ptab , pold , pnew ) ; } } } if ( rc == sqlite_ok && ( pold || pold2 ) ) { zipfilecsr * pcsr ; for ( pcsr = ptab -> pcsrlist ; pcsr ; pcsr = pcsr -> pcsrnext ) { if ( pcsr -> pcurrent && ( pcsr -> pcurrent == pold || pcsr -> pcurrent == pold2 ) ) { pcsr -> pcurrent = pcsr -> pcurrent -> pnext ; pcsr -> bnoop = 1 ; } } zipfileremoveentryfromlist ( ptab , pold ) ; zipfileremoveentryfromlist ( ptab , pold2 ) ; } zipfile_update_done : sqlite3_free ( pfree ) ; sqlite3_free ( zfree ) ; return rc ; }","<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = """" ;
",sqlite@sqlite/54d501092d88c0cf89bec4279951f548fb0b8618,CVE-2019-19925,https://github.com/sqlite/sqlite/commit/54d501092d88c0cf89bec4279951f548fb0b8618,2019-12-24T17:15Z,<S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug>
8061,CWE-476,"int writefile ( const char * name , struct string * s ) { file * f ; int ret ; f = fopen ( name , ""w"" ) ; if ( ! f ) { warn ( ""open<s2sv_blank>%s:"" , name ) ; return - 1 ; } ret = 0 ; if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { warn ( ""write<s2sv_blank>%s:"" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }","<S2SV_ModStart> ; if ( s && ( <S2SV_ModStart> ) != 0 )
",michaelforney@samurai/e84b6d99c85043fa1ba54851ee500540ec206918,CVE-2021-30218,https://github.com/michaelforney/samurai/commit/e84b6d99c85043fa1ba54851ee500540ec206918,2021-04-29T15:15Z,"<S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug>"
4991,CWE-200,"int parse_config ( char * filename , bridge_t * * bridges ) { dictionary * ubridge_config = null ; const char * value ; const char * bridge_name ; int i , nsec ; if ( ( ubridge_config = iniparser_load ( filename ) ) == null ) { return false ; } nsec = iniparser_getnsec ( ubridge_config ) ; for ( i = 0 ; i < nsec ; i ++ ) { bridge_t * bridge ; nio_t * source_nio = null ; nio_t * destination_nio = null ; bridge_name = iniparser_getsecname ( ubridge_config , i ) ; printf ( ""parsing<s2sv_blank>%s\\n"" , bridge_name ) ; if ( getstr ( ubridge_config , bridge_name , ""source_udp"" , & value ) ) source_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_unix"" , & value ) ) source_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_ethernet"" , & value ) ) source_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""source_tap"" , & value ) ) source_nio = open_tap_device ( value ) ; # ifdef linux_raw else if ( getstr ( ubridge_config , bridge_name , ""source_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __apple__ else if ( getstr ( ubridge_config , bridge_name , ""source_fusion_vmnet"" , & value ) ) source_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""source<s2sv_blank>nio<s2sv_blank>not<s2sv_blank>found\\n"" ) ; if ( getstr ( ubridge_config , bridge_name , ""destination_udp"" , & value ) ) destination_nio = create_udp_tunnel ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_unix"" , & value ) ) destination_nio = create_unix_socket ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_ethernet"" , & value ) ) destination_nio = open_ethernet_device ( value ) ; else if ( getstr ( ubridge_config , bridge_name , ""destination_tap"" , & value ) ) destination_nio = open_tap_device ( value ) ; # ifdef linux_raw else if ( getstr ( ubridge_config , bridge_name , ""destination_linux_raw"" , & value ) ) source_nio = open_linux_raw ( value ) ; # endif # ifdef __apple__ else if ( getstr ( ubridge_config , bridge_name , ""destination_fusion_vmnet"" , & value ) ) destination_nio = open_fusion_vmnet ( value ) ; # endif else fprintf ( stderr , ""destination<s2sv_blank>nio<s2sv_blank>not<s2sv_blank>found\\n"" ) ; if ( source_nio && destination_nio ) { bridge = add_bridge ( bridges ) ; bridge -> source_nio = source_nio ; bridge -> destination_nio = destination_nio ; if ( ! ( bridge -> name = strdup ( bridge_name ) ) ) { fprintf ( stderr , ""bridge<s2sv_blank>creation:<s2sv_blank>insufficient<s2sv_blank>memory\\n"" ) ; return false ; } parse_capture ( ubridge_config , bridge_name , bridge ) ; parse_filter ( ubridge_config , bridge_name , bridge ) ; } else if ( source_nio != null ) free_nio ( source_nio ) ; else if ( destination_nio != null ) free_nio ( destination_nio ) ; } iniparser_freedict ( ubridge_config ) ; return true ; }","<S2SV_ModStart> iniparser_load ( filename , HIDE_ERRORED_LINE_CONTENT
",GNS3@ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db,CVE-2020-14976,https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db,2020-06-23T20:15Z,<S2SV_StartBug> if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) { <S2SV_EndBug>
3140,CWE-20,"int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = null ; struct snd_timer_instance * slave , * tmp ; if ( snd_bug_on ( ! timeri ) ) return - enxio ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & sndrv_timer_iflg_slave ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & sndrv_timer_iflg_callback ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_bug_on ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & sndrv_timer_iflg_callback ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , sndrv_timer_event_resolution ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = null ; slave -> timer = null ; spin_unlock_irq ( & slave_active_lock ) ; } mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,"<S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>"
201,CWE-119,"static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = bpf_op ( insn -> code ) ; int err ; if ( opcode == bpf_end || opcode == bpf_neg ) { if ( opcode == bpf_neg ) { if ( bpf_src ( insn -> code ) != 0 || insn -> src_reg != bpf_reg_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , ""bpf_neg<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } } else { if ( insn -> src_reg != bpf_reg_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || bpf_class ( insn -> code ) == bpf_alu64 ) { verbose ( env , ""bpf_end<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } } err = check_reg_arg ( env , insn -> dst_reg , src_op ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""r%d<s2sv_blank>pointer<s2sv_blank>arithmetic<s2sv_blank>prohibited\\n"" , insn -> dst_reg ) ; return - eacces ; } err = check_reg_arg ( env , insn -> dst_reg , dst_op ) ; if ( err ) return err ; } else if ( opcode == bpf_mov ) { if ( bpf_src ( insn -> code ) == bpf_x ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""bpf_mov<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } err = check_reg_arg ( env , insn -> src_reg , src_op ) ; if ( err ) return err ; } else { if ( insn -> src_reg != bpf_reg_0 || insn -> off != 0 ) { verbose ( env , ""bpf_mov<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } } err = check_reg_arg ( env , insn -> dst_reg , dst_op ) ; if ( err ) return err ; if ( bpf_src ( insn -> code ) == bpf_x ) { if ( bpf_class ( insn -> code ) == bpf_alu64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= reg_live_written ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""r%d<s2sv_blank>partial<s2sv_blank>copy<s2sv_blank>of<s2sv_blank>pointer\\n"" , insn -> src_reg ) ; return - eacces ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = scalar_value ; if ( bpf_class ( insn -> code ) == bpf_alu64 ) { __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } } } else if ( opcode > bpf_end ) { verbose ( env , ""invalid<s2sv_blank>bpf_alu<s2sv_blank>opcode<s2sv_blank>%x\\n"" , opcode ) ; return - einval ; } else { if ( bpf_src ( insn -> code ) == bpf_x ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""bpf_alu<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } err = check_reg_arg ( env , insn -> src_reg , src_op ) ; if ( err ) return err ; } else { if ( insn -> src_reg != bpf_reg_0 || insn -> off != 0 ) { verbose ( env , ""bpf_alu<s2sv_blank>uses<s2sv_blank>reserved<s2sv_blank>fields\\n"" ) ; return - einval ; } } err = check_reg_arg ( env , insn -> dst_reg , src_op ) ; if ( err ) return err ; if ( ( opcode == bpf_mod || opcode == bpf_div ) && bpf_src ( insn -> code ) == bpf_k && insn -> imm == 0 ) { verbose ( env , ""div<s2sv_blank>by<s2sv_blank>zero\\n"" ) ; return - einval ; } if ( ( opcode == bpf_lsh || opcode == bpf_rsh || opcode == bpf_arsh ) && bpf_src ( insn -> code ) == bpf_k ) { int size = bpf_class ( insn -> code ) == bpf_alu64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , ""invalid<s2sv_blank>shift<s2sv_blank>%d\\n"" , insn -> imm ) ; return - einval ; } } err = check_reg_arg ( env , insn -> dst_reg , dst_op_no_mark ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }","<S2SV_ModStart> dst_reg ) ; coerce_reg_to_size <S2SV_ModEnd> ( & regs <S2SV_ModStart> -> dst_reg ] , 4
",torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958,CVE-2017-16996,https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958,2017-12-27T17:08Z,<S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug>
2917,CWE-617,"static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> crn == 9 && r -> crm == 13 ) { if ( r -> op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , pmselr_el0 ) & armv8_pmu_counter_mask ; } else if ( r -> op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = armv8_pmu_cycle_idx ; } else { bug ( ) ; } } else if ( r -> crn == 14 && ( r -> crm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> crm & 3 ) << 3 ) | ( r -> op2 & 7 ) ; } else { bug ( ) ; } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }","<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
",torvalds@linux/9e3f7a29694049edd728e2400ab57ad7553e5aa9,CVE-2017-12168,https://github.com/torvalds/linux/commit/9e3f7a29694049edd728e2400ab57ad7553e5aa9,2017-09-20T08:29Z,<S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug>
7861,CWE-20,"uint16_t enc28j60readphyreg ( netinterface * interface , uint16_t address ) { uint16_t data ; enc28j60writereg ( interface , enc28j60_reg_miregadr , address & reg_addr_mask ) ; enc28j60writereg ( interface , enc28j60_reg_micmd , micmd_miird ) ; while ( ( enc28j60readreg ( interface , enc28j60_reg_mistat ) & mistat_busy ) != 0 ) { } enc28j60writereg ( interface , enc28j60_reg_micmd , 0 ) ; data = enc28j60readreg ( interface , enc28j60_reg_mirdl ) ; data |= enc28j60readreg ( interface , enc28j60_reg_mirdh ) << 8 ; return data ; }","<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_MICMD <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , ENC28J60_MIRDL <S2SV_ModEnd> ) ; data <S2SV_ModStart> ( interface , ENC28J60_MIRDH <S2SV_ModEnd> ) << 8
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug>"
7370,CWE-835,"int dwg_encode_add_object ( dwg_object * restrict obj , bit_chain * restrict dat , unsigned long address ) { int error = 0 ; unsigned long oldpos ; unsigned long end_address = address + obj -> size ; oldpos = bit_position ( dat ) ; assert ( address ) ; dat -> byte = address ; dat -> bit = 0 ; log_info ( ""object<s2sv_blank>number:<s2sv_blank>%lu"" , ( unsigned long ) obj -> index ) ; if ( obj -> size > 0x100000 ) { log_error ( ""object<s2sv_blank>size<s2sv_blank>%u<s2sv_blank>overflow"" , obj -> size ) ; return dwg_err_valueoutofbounds ; } while ( dat -> byte + obj -> size >= dat -> size ) bit_chain_alloc ( dat ) ; bit_write_ms ( dat , obj -> size ) ; obj -> address = dat -> byte ; pre ( r_2010 ) { bit_write_bs ( dat , obj -> type ) ; log_info ( "",<s2sv_blank>size:<s2sv_blank>%d<s2sv_blank>[ms],<s2sv_blank>type:<s2sv_blank>%d<s2sv_blank>[bs]\\n"" , obj -> size , obj -> type ) } later_versions { if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ; bit_write_umc ( dat , obj -> handlestream_size ) ; obj -> address = dat -> byte ; bit_write_bot ( dat , obj -> type ) ; log_info ( "",<s2sv_blank>size:<s2sv_blank>%d<s2sv_blank>[ms],<s2sv_blank>hdlsize:<s2sv_blank>%lu<s2sv_blank>[umc],<s2sv_blank>type:<s2sv_blank>%d<s2sv_blank>[bot]\\n"" , obj -> size , ( unsigned long ) obj -> handlestream_size , obj -> type ) } switch ( obj -> type ) { case dwg_type_text : error = dwg_encode_text ( dat , obj ) ; break ; case dwg_type_attrib : error = dwg_encode_attrib ( dat , obj ) ; break ; case dwg_type_attdef : error = dwg_encode_attdef ( dat , obj ) ; break ; case dwg_type_block : error = dwg_encode_block ( dat , obj ) ; break ; case dwg_type_endblk : error = dwg_encode_endblk ( dat , obj ) ; break ; case dwg_type_seqend : error = dwg_encode_seqend ( dat , obj ) ; break ; case dwg_type_insert : error = dwg_encode_insert ( dat , obj ) ; break ; case dwg_type_minsert : error = dwg_encode_minsert ( dat , obj ) ; break ; case dwg_type_vertex_2d : error = dwg_encode_vertex_2d ( dat , obj ) ; break ; case dwg_type_vertex_3d : error = dwg_encode_vertex_3d ( dat , obj ) ; break ; case dwg_type_vertex_mesh : error = dwg_encode_vertex_mesh ( dat , obj ) ; break ; case dwg_type_vertex_pface : error = dwg_encode_vertex_pface ( dat , obj ) ; break ; case dwg_type_vertex_pface_face : error = dwg_encode_vertex_pface_face ( dat , obj ) ; break ; case dwg_type_polyline_2d : error = dwg_encode_polyline_2d ( dat , obj ) ; break ; case dwg_type_polyline_3d : error = dwg_encode_polyline_3d ( dat , obj ) ; break ; case dwg_type_arc : error = dwg_encode_arc ( dat , obj ) ; break ; case dwg_type_circle : error = dwg_encode_circle ( dat , obj ) ; break ; case dwg_type_line : error = dwg_encode_line ( dat , obj ) ; break ; case dwg_type_dimension_ordinate : error = dwg_encode_dimension_ordinate ( dat , obj ) ; break ; case dwg_type_dimension_linear : error = dwg_encode_dimension_linear ( dat , obj ) ; break ; case dwg_type_dimension_aligned : error = dwg_encode_dimension_aligned ( dat , obj ) ; break ; case dwg_type_dimension_ang3pt : error = dwg_encode_dimension_ang3pt ( dat , obj ) ; break ; case dwg_type_dimension_ang2ln : error = dwg_encode_dimension_ang2ln ( dat , obj ) ; break ; case dwg_type_dimension_radius : error = dwg_encode_dimension_radius ( dat , obj ) ; break ; case dwg_type_dimension_diameter : error = dwg_encode_dimension_diameter ( dat , obj ) ; break ; case dwg_type_point : error = dwg_encode_point ( dat , obj ) ; break ; case dwg_type__3dface : error = dwg_encode__3dface ( dat , obj ) ; break ; case dwg_type_polyline_pface : error = dwg_encode_polyline_pface ( dat , obj ) ; break ; case dwg_type_polyline_mesh : error = dwg_encode_polyline_mesh ( dat , obj ) ; break ; case dwg_type_solid : error = dwg_encode_solid ( dat , obj ) ; break ; case dwg_type_trace : error = dwg_encode_trace ( dat , obj ) ; break ; case dwg_type_shape : error = dwg_encode_shape ( dat , obj ) ; break ; case dwg_type_viewport : error = dwg_encode_viewport ( dat , obj ) ; break ; case dwg_type_ellipse : error = dwg_encode_ellipse ( dat , obj ) ; break ; case dwg_type_spline : error = dwg_encode_spline ( dat , obj ) ; break ; case dwg_type_region : error = dwg_encode_region ( dat , obj ) ; break ; case dwg_type__3dsolid : error = dwg_encode__3dsolid ( dat , obj ) ; break ; case dwg_type_body : error = dwg_encode_body ( dat , obj ) ; break ; case dwg_type_ray : error = dwg_encode_ray ( dat , obj ) ; break ; case dwg_type_xline : error = dwg_encode_xline ( dat , obj ) ; break ; case dwg_type_dictionary : error = dwg_encode_dictionary ( dat , obj ) ; break ; case dwg_type_mtext : error = dwg_encode_mtext ( dat , obj ) ; break ; case dwg_type_leader : error = dwg_encode_leader ( dat , obj ) ; break ; case dwg_type_tolerance : error = dwg_encode_tolerance ( dat , obj ) ; break ; case dwg_type_mline : error = dwg_encode_mline ( dat , obj ) ; break ; case dwg_type_block_control : error = dwg_encode_block_control ( dat , obj ) ; break ; case dwg_type_block_header : error = dwg_encode_block_header ( dat , obj ) ; break ; case dwg_type_layer_control : error = dwg_encode_layer_control ( dat , obj ) ; break ; case dwg_type_layer : error = dwg_encode_layer ( dat , obj ) ; break ; case dwg_type_style_control : error = dwg_encode_style_control ( dat , obj ) ; break ; case dwg_type_style : error = dwg_encode_style ( dat , obj ) ; break ; case dwg_type_ltype_control : error = dwg_encode_ltype_control ( dat , obj ) ; break ; case dwg_type_ltype : error = dwg_encode_ltype ( dat , obj ) ; break ; case dwg_type_view_control : error = dwg_encode_view_control ( dat , obj ) ; break ; case dwg_type_view : error = dwg_encode_view ( dat , obj ) ; break ; case dwg_type_ucs_control : error = dwg_encode_ucs_control ( dat , obj ) ; break ; case dwg_type_ucs : error = dwg_encode_ucs ( dat , obj ) ; break ; case dwg_type_vport_control : error = dwg_encode_vport_control ( dat , obj ) ; break ; case dwg_type_vport : error = dwg_encode_vport ( dat , obj ) ; break ; case dwg_type_appid_control : error = dwg_encode_appid_control ( dat , obj ) ; break ; case dwg_type_appid : error = dwg_encode_appid ( dat , obj ) ; break ; case dwg_type_dimstyle_control : error = dwg_encode_dimstyle_control ( dat , obj ) ; break ; case dwg_type_dimstyle : error = dwg_encode_dimstyle ( dat , obj ) ; break ; case dwg_type_vport_entity_control : error = dwg_encode_vport_entity_control ( dat , obj ) ; break ; case dwg_type_vport_entity_header : error = dwg_encode_vport_entity_header ( dat , obj ) ; break ; case dwg_type_group : error = dwg_encode_group ( dat , obj ) ; break ; case dwg_type_mlinestyle : error = dwg_encode_mlinestyle ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_ole2frame : error = dwg_encode_ole2frame ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_dummy : error = dwg_encode_dummy ( dat , obj ) ; break ; case dwg_type_long_transaction : error = dwg_encode_long_transaction ( dat , obj ) ; break ; case dwg_type_lwpolyline : error = dwg_encode_lwpolyline ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_hatch : error = dwg_encode_hatch ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_xrecord : error = dwg_encode_xrecord ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_placeholder : error = dwg_encode_placeholder ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_oleframe : error = dwg_encode_oleframe ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_vba_project : log_error ( ""unhandled<s2sv_blank>object<s2sv_blank>vba_project.<s2sv_blank>has<s2sv_blank>its<s2sv_blank>own<s2sv_blank>section"" ) ; break ; case dwg_type_layout : error |= dwg_encode_layout ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case dwg_type_proxy_entity : error = dwg_encode_proxy_entity ( dat , obj ) ; break ; case dwg_type_proxy_object : error = dwg_encode_proxy_object ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type && obj -> fixedtype == dwg_type_layout ) { error = dwg_encode_layout ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; } else if ( ( error = dwg_encode_variable_type ( obj -> parent , dat , obj ) ) & dwg_err_unhandledclass ) { dwg_data * dwg = obj -> parent ; int is_entity ; int i = obj -> type - 500 ; dwg_class * klass = dwg_encode_get_class ( dwg , obj ) ; assert ( address ) ; dat -> byte = address ; dat -> bit = 0 ; bit_write_ms ( dat , obj -> size ) ; if ( dat -> version >= r_2010 ) { bit_write_umc ( dat , obj -> handlestream_size ) ; bit_write_bot ( dat , obj -> type ) ; } else bit_write_bs ( dat , obj -> type ) ; if ( klass && obj -> supertype == dwg_supertype_unknown ) is_entity = dwg_class_is_entity ( klass ) ; else is_entity = obj -> supertype == dwg_supertype_entity ; if ( klass && ! is_entity ) error = dwg_encode_unknown_obj ( dat , obj ) ; else if ( klass ) error = dwg_encode_unknown_ent ( dat , obj ) ; else { log_warn ( ""unknown<s2sv_blank>object,<s2sv_blank>skipping<s2sv_blank>eed/reactors/xdic"" ) ; error = dwg_err_unhandledclass ; since ( r_2000 ) { bit_write_rl ( dat , obj -> bitsize ) ; log_info ( ""bitsize:<s2sv_blank>"" format_rl ""<s2sv_blank>[rl]<s2sv_blank>(@%lu.%u)\\n"" , obj -> bitsize , dat -> byte - 4 , dat -> bit ) ; } bit_write_h ( dat , & obj -> handle ) ; log_info ( ""handle:<s2sv_blank>"" format_h ""<s2sv_blank>[h<s2sv_blank>5]\\n"" , args_h ( obj -> handle ) ) ; bit_write_tf ( dat , obj -> tio . unknown , obj -> size ) ; } } } if ( ! obj -> size ) { bitcode_bl pos = bit_position ( dat ) ; assert ( address ) ; obj -> size = dat -> byte - address - 2 ; if ( dat -> bit ) obj -> size ++ ; if ( ! obj -> bitsize ) { log_trace ( ""-bitsize<s2sv_blank>calc<s2sv_blank>from<s2sv_blank>address<s2sv_blank>(no<s2sv_blank>handle)<s2sv_blank>@%lu.%u\\n"" , dat -> byte , dat -> bit ) ; obj -> bitsize = pos - ( obj -> address * 8 ) ; } bit_set_position ( dat , address * 8 ) ; if ( obj -> size > 0x7fff ) log_error ( ""unhandled<s2sv_blank>size<s2sv_blank>%u<s2sv_blank>><s2sv_blank>0x7fff"" , ( unsigned ) obj -> size ) ; bit_write_ms ( dat , obj -> size ) ; log_trace ( ""-size:<s2sv_blank>%u<s2sv_blank>[ms]<s2sv_blank>@%lu\\n"" , obj -> size , address ) ; since ( r_2013 ) { if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ; bit_write_umc ( dat , obj -> handlestream_size ) ; log_trace ( ""-handlestream_size:<s2sv_blank>%lu<s2sv_blank>[umc]\\n"" , obj -> handlestream_size ) ; } since ( r_2000 ) { if ( obj -> bitsize_pos && obj -> bitsize ) { bit_set_position ( dat , obj -> bitsize_pos ) ; bit_write_rl ( dat , obj -> bitsize ) ; log_trace ( ""-bitsize:<s2sv_blank>%u<s2sv_blank>[rl]<s2sv_blank>@%lu.%lu\\n"" , obj -> bitsize , obj -> bitsize_pos / 8 , obj -> bitsize_pos % 8 ) ; } } bit_set_position ( dat , pos ) ; } if ( dat -> bit ) log_trace ( ""padding:<s2sv_blank>+%d<s2sv_blank>[*b]\\n"" , 8 - dat -> bit ) while ( dat -> bit ) bit_write_b ( dat , 1 ) ; end_address = obj -> address + obj -> size ; if ( end_address != dat -> byte ) { if ( obj -> size ) log_warn ( ""wrong<s2sv_blank>object<s2sv_blank>size:<s2sv_blank>%lu<s2sv_blank>+<s2sv_blank>%u<s2sv_blank>=<s2sv_blank>%lu<s2sv_blank>!=<s2sv_blank>%lu:<s2sv_blank>%ld<s2sv_blank>off"" , obj -> address , obj -> size , end_address , dat -> byte , ( long ) ( end_address - dat -> byte ) ) ; dat -> byte = end_address ; } assert ( ! dat -> bit ) ; bit_write_crc ( dat , address , 0xc0c1 ) ; return error ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> is_entity ) error <S2SV_ModStart> ) error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else error = <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
",LibreDWG@libredwg/c6f6668b82bfe595899cc820279ac37bb9ef16f5,CVE-2019-20911,https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5,2020-07-16T18:15Z,"<S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( klass ) <S2SV_EndBug>"
3659,CWE-000,"syscall_define3 ( rt_sigqueueinfo , pid_t , pid , int , sig , siginfo_t __user * , uinfo ) { siginfo_t info ; if ( copy_from_user ( & info , uinfo , sizeof ( siginfo_t ) ) ) return - efault ; if ( info . si_code >= 0 ) return - eperm ; info . si_signo = sig ; return kill_proc_info ( sig , & info , pid ) ; }","<S2SV_ModStart> info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
",torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z,<S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug>
5922,CWE-74,"gboolean flatpak_run_app ( flatpakdecomposed * app_ref , flatpakdeploy * app_deploy , flatpakcontext * extra_context , const char * custom_runtime , const char * custom_runtime_version , const char * custom_runtime_commit , int parent_pid , flatpakrunflags flags , const char * cwd , const char * custom_command , char * args [ ] , int n_args , int instance_id_fd , char * * instance_dir_out , gcancellable * cancellable , gerror * * error ) { g_autoptr ( flatpakdeploy ) runtime_deploy = null ; g_autoptr ( gbytes ) runtime_deploy_data = null ; g_autoptr ( gbytes ) app_deploy_data = null ; g_autoptr ( gfile ) app_files = null ; g_autoptr ( gfile ) runtime_files = null ; g_autoptr ( gfile ) bin_ldconfig = null ; g_autoptr ( gfile ) app_id_dir = null ; g_autoptr ( gfile ) real_app_id_dir = null ; g_autofree char * default_runtime_pref = null ; g_autoptr ( flatpakdecomposed ) default_runtime = null ; g_autofree char * default_command = null ; g_autoptr ( gkeyfile ) metakey = null ; g_autoptr ( gkeyfile ) runtime_metakey = null ; g_autoptr ( flatpakbwrap ) bwrap = null ; const char * command = ""/bin/sh"" ; g_autoptr ( gerror ) my_error = null ; g_autoptr ( flatpakdecomposed ) runtime_ref = null ; int i ; g_autoptr ( gptrarray ) previous_app_id_dirs = null ; g_autofree char * app_id = null ; g_autofree char * app_arch = null ; g_autofree char * app_info_path = null ; g_autofree char * instance_id_host_dir = null ; g_autoptr ( flatpakcontext ) app_context = null ; g_autoptr ( flatpakcontext ) overrides = null ; g_autoptr ( flatpakexports ) exports = null ; g_autofree char * commandline = null ; g_autofree char * doc_mount_path = null ; g_autofree char * app_extensions = null ; g_autofree char * runtime_extensions = null ; g_autofree char * checksum = null ; int ld_so_fd = - 1 ; g_autoptr ( gfile ) runtime_ld_so_conf = null ; gboolean generate_ld_so_conf = true ; gboolean use_ld_so_cache = true ; gboolean sandboxed = ( flags & flatpak_run_flag_sandbox ) != 0 ; gboolean parent_expose_pids = ( flags & flatpak_run_flag_parent_expose_pids ) != 0 ; gboolean parent_share_pids = ( flags & flatpak_run_flag_parent_share_pids ) != 0 ; struct stat s ; if ( ! check_sudo ( error ) ) return false ; app_id = flatpak_decomposed_dup_id ( app_ref ) ; app_arch = flatpak_decomposed_dup_arch ( app_ref ) ; if ( ! check_parental_controls ( app_ref , app_deploy , cancellable , error ) ) return false ; bwrap = flatpak_bwrap_new ( null ) ; flatpak_bwrap_add_arg ( bwrap , flatpak_get_bwrap ( ) ) ; if ( app_deploy == null ) { g_assert ( flatpak_decomposed_is_runtime ( app_ref ) ) ; default_runtime_pref = flatpak_decomposed_dup_pref ( app_ref ) ; } else { const gchar * key ; app_deploy_data = flatpak_deploy_get_deploy_data ( app_deploy , flatpak_deploy_version_any , cancellable , error ) ; if ( app_deploy_data == null ) return false ; if ( ( flags & flatpak_run_flag_devel ) != 0 ) key = flatpak_metadata_key_sdk ; else key = flatpak_metadata_key_runtime ; metakey = flatpak_deploy_get_metadata ( app_deploy ) ; default_runtime_pref = g_key_file_get_string ( metakey , flatpak_metadata_group_application , key , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return false ; } } default_runtime = flatpak_decomposed_new_from_pref ( flatpak_kinds_runtime , default_runtime_pref , error ) ; if ( default_runtime == null ) return false ; if ( custom_runtime != null || custom_runtime_version != null ) { g_auto ( gstrv ) custom_runtime_parts = null ; const char * custom_runtime_id = null ; const char * custom_runtime_arch = null ; if ( custom_runtime ) { custom_runtime_parts = g_strsplit ( custom_runtime , ""/"" , 0 ) ; for ( i = 0 ; i < 3 && custom_runtime_parts [ i ] != null ; i ++ ) { if ( strlen ( custom_runtime_parts [ i ] ) > 0 ) { if ( i == 0 ) custom_runtime_id = custom_runtime_parts [ i ] ; if ( i == 1 ) custom_runtime_arch = custom_runtime_parts [ i ] ; if ( i == 2 && custom_runtime_version == null ) custom_runtime_version = custom_runtime_parts [ i ] ; } } } runtime_ref = flatpak_decomposed_new_from_decomposed ( default_runtime , flatpak_kinds_runtime , custom_runtime_id , custom_runtime_arch , custom_runtime_version , error ) ; if ( runtime_ref == null ) return false ; } else runtime_ref = flatpak_decomposed_ref ( default_runtime ) ; runtime_deploy = flatpak_find_deploy_for_ref ( flatpak_decomposed_get_ref ( runtime_ref ) , custom_runtime_commit , null , cancellable , error ) ; if ( runtime_deploy == null ) return false ; runtime_deploy_data = flatpak_deploy_get_deploy_data ( runtime_deploy , flatpak_deploy_version_any , cancellable , error ) ; if ( runtime_deploy_data == null ) return false ; runtime_metakey = flatpak_deploy_get_metadata ( runtime_deploy ) ; app_context = flatpak_app_compute_permissions ( metakey , runtime_metakey , error ) ; if ( app_context == null ) return false ; if ( app_deploy != null ) { overrides = flatpak_deploy_get_overrides ( app_deploy ) ; flatpak_context_merge ( app_context , overrides ) ; } if ( sandboxed ) flatpak_context_make_sandboxed ( app_context ) ; if ( extra_context ) flatpak_context_merge ( app_context , extra_context ) ; runtime_files = flatpak_deploy_get_files ( runtime_deploy ) ; bin_ldconfig = g_file_resolve_relative_path ( runtime_files , ""bin/ldconfig"" ) ; if ( ! g_file_query_exists ( bin_ldconfig , null ) ) use_ld_so_cache = false ; if ( app_deploy != null ) { g_autofree const char * * previous_ids = null ; gsize len = 0 ; gboolean do_migrate ; real_app_id_dir = flatpak_get_data_dir ( app_id ) ; app_files = flatpak_deploy_get_files ( app_deploy ) ; previous_app_id_dirs = g_ptr_array_new_with_free_func ( g_object_unref ) ; previous_ids = flatpak_deploy_data_get_previous_ids ( app_deploy_data , & len ) ; do_migrate = ! g_file_query_exists ( real_app_id_dir , cancellable ) ; for ( i = len - 1 ; i >= 0 ; i -- ) { g_autoptr ( gfile ) previous_app_id_dir = null ; g_autoptr ( gfileinfo ) previous_app_id_dir_info = null ; g_autoptr ( gerror ) local_error = null ; previous_app_id_dir = flatpak_get_data_dir ( previous_ids [ i ] ) ; previous_app_id_dir_info = g_file_query_info ( previous_app_id_dir , g_file_attribute_standard_is_symlink "","" g_file_attribute_standard_symlink_target , g_file_query_info_nofollow_symlinks , cancellable , & local_error ) ; if ( previous_app_id_dir_info == null ) { if ( ! g_error_matches ( local_error , g_io_error , g_io_error_not_found ) && do_migrate ) { g_warning ( _ ( ""failed<s2sv_blank>to<s2sv_blank>migrate<s2sv_blank>from<s2sv_blank>%s:<s2sv_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; do_migrate = false ; } g_clear_error ( & local_error ) ; continue ; } if ( do_migrate ) { do_migrate = false ; if ( ! flatpak_file_rename ( previous_app_id_dir , real_app_id_dir , cancellable , & local_error ) ) { g_warning ( _ ( ""failed<s2sv_blank>to<s2sv_blank>migrate<s2sv_blank>old<s2sv_blank>app<s2sv_blank>data<s2sv_blank>directory<s2sv_blank>%s<s2sv_blank>to<s2sv_blank>new<s2sv_blank>name<s2sv_blank>%s:<s2sv_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , app_id , local_error -> message ) ; } else { if ( ! g_file_make_symbolic_link ( previous_app_id_dir , app_id , cancellable , & local_error ) ) { g_warning ( _ ( ""failed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>symlink<s2sv_blank>while<s2sv_blank>migrating<s2sv_blank>%s:<s2sv_blank>%s"" ) , flatpak_file_get_path_cached ( previous_app_id_dir ) , local_error -> message ) ; } } } g_ptr_array_add ( previous_app_id_dirs , g_steal_pointer ( & previous_app_id_dir ) ) ; } if ( ! flatpak_ensure_data_dir ( real_app_id_dir , cancellable , error ) ) return false ; if ( ! sandboxed ) app_id_dir = g_object_ref ( real_app_id_dir ) ; } flatpak_run_apply_env_default ( bwrap , use_ld_so_cache ) ; flatpak_run_apply_env_vars ( bwrap , app_context ) ; flatpak_run_apply_env_prompt ( bwrap , app_id ) ; if ( real_app_id_dir ) { g_autoptr ( gfile ) sandbox_dir = g_file_get_child ( real_app_id_dir , ""sandbox"" ) ; flatpak_bwrap_set_env ( bwrap , ""flatpak_sandbox_dir"" , flatpak_file_get_path_cached ( sandbox_dir ) , true ) ; } flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( runtime_files ) , ""/usr"" , ""--lock-file"" , ""/usr/.ref"" , null ) ; if ( app_files != null ) flatpak_bwrap_add_args ( bwrap , ""--ro-bind"" , flatpak_file_get_path_cached ( app_files ) , ""/app"" , ""--lock-file"" , ""/app/.ref"" , null ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/app"" , null ) ; if ( metakey != null && ! flatpak_run_add_extension_args ( bwrap , metakey , app_ref , use_ld_so_cache , & app_extensions , cancellable , error ) ) return false ; if ( ! flatpak_run_add_extension_args ( bwrap , runtime_metakey , runtime_ref , use_ld_so_cache , & runtime_extensions , cancellable , error ) ) return false ; runtime_ld_so_conf = g_file_resolve_relative_path ( runtime_files , ""etc/ld.so.conf"" ) ; if ( lstat ( flatpak_file_get_path_cached ( runtime_ld_so_conf ) , & s ) == 0 ) generate_ld_so_conf = s_isreg ( s . st_mode ) && s . st_size == 0 ; if ( use_ld_so_cache ) { checksum = calculate_ld_cache_checksum ( app_deploy_data , runtime_deploy_data , app_extensions , runtime_extensions ) ; ld_so_fd = regenerate_ld_cache ( bwrap -> argv , bwrap -> fds , app_id_dir , checksum , runtime_files , generate_ld_so_conf , cancellable , error ) ; if ( ld_so_fd == - 1 ) return false ; flatpak_bwrap_add_fd ( bwrap , ld_so_fd ) ; } flags |= flatpak_context_get_run_flags ( app_context ) ; if ( ! flatpak_run_setup_base_argv ( bwrap , runtime_files , app_id_dir , app_arch , flags , error ) ) return false ; if ( generate_ld_so_conf ) { if ( ! add_ld_so_conf ( bwrap , error ) ) return false ; } if ( ld_so_fd != - 1 ) { flatpak_bwrap_add_arg ( bwrap , ""--ro-bind-data"" ) ; flatpak_bwrap_add_arg_printf ( bwrap , ""%d"" , ld_so_fd ) ; flatpak_bwrap_add_arg ( bwrap , ""/etc/ld.so.cache"" ) ; } if ( ! flatpak_run_add_app_info_args ( bwrap , app_files , app_deploy_data , app_extensions , runtime_files , runtime_deploy_data , runtime_extensions , app_id , flatpak_decomposed_get_branch ( app_ref ) , runtime_ref , app_id_dir , app_context , extra_context , sandboxed , false , flags & flatpak_run_flag_devel , & app_info_path , instance_id_fd , & instance_id_host_dir , error ) ) return false ; if ( ! flatpak_run_add_dconf_args ( bwrap , app_id , metakey , error ) ) return false ; if ( ! sandboxed && ! ( flags & flatpak_run_flag_no_documents_portal ) ) add_document_portal_args ( bwrap , app_id , & doc_mount_path ) ; if ( ! flatpak_run_add_environment_args ( bwrap , app_info_path , flags , app_id , app_context , app_id_dir , previous_app_id_dirs , & exports , cancellable , error ) ) return false ; if ( ( app_context -> shares & flatpak_context_shared_network ) != 0 ) flatpak_run_add_resolved_args ( bwrap ) ; flatpak_run_add_journal_args ( bwrap ) ; add_font_path_args ( bwrap ) ; add_icon_path_args ( bwrap ) ; flatpak_bwrap_add_args ( bwrap , ""--symlink"" , ""/app/lib/debug/source"" , ""/run/build"" , ""--symlink"" , ""/usr/lib/debug/source"" , ""/run/build-runtime"" , null ) ; if ( cwd ) flatpak_bwrap_add_args ( bwrap , ""--chdir"" , cwd , null ) ; if ( parent_expose_pids || parent_share_pids ) { g_autofree char * userns_path = null ; g_autofree char * pidns_path = null ; g_autofree char * userns2_path = null ; int userns_fd , userns2_fd , pidns_fd ; if ( parent_pid == 0 ) return flatpak_fail ( error , ""no<s2sv_blank>parent<s2sv_blank>pid<s2sv_blank>specified"" ) ; userns_path = g_strdup_printf ( ""/proc/%d/root/run/.userns"" , parent_pid ) ; userns_fd = open_namespace_fd_if_needed ( userns_path , ""/proc/self/ns/user"" ) ; if ( userns_fd != - 1 ) { flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns"" , userns_fd , null ) ; userns2_path = g_strdup_printf ( ""/proc/%d/ns/user"" , parent_pid ) ; userns2_fd = open_namespace_fd_if_needed ( userns2_path , userns_path ) ; if ( userns2_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--userns2"" , userns2_fd , null ) ; } pidns_path = g_strdup_printf ( ""/proc/%d/ns/pid"" , parent_pid ) ; pidns_fd = open ( pidns_path , o_rdonly | o_cloexec ) ; if ( pidns_fd != - 1 ) flatpak_bwrap_add_args_data_fd ( bwrap , ""--pidns"" , pidns_fd , null ) ; } if ( custom_command ) { command = custom_command ; } else if ( metakey ) { default_command = g_key_file_get_string ( metakey , flatpak_metadata_group_application , flatpak_metadata_key_command , & my_error ) ; if ( my_error ) { g_propagate_error ( error , g_steal_pointer ( & my_error ) ) ; return false ; } command = default_command ; } if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , false , error ) ) return false ; flatpak_bwrap_add_arg ( bwrap , command ) ; if ( ! add_rest_args ( bwrap , app_id , exports , ( flags & flatpak_run_flag_file_forwarding ) != 0 , doc_mount_path , args , n_args , error ) ) return false ; flatpak_bwrap_finish ( bwrap ) ; commandline = flatpak_quote_argv ( ( const char * * ) bwrap -> argv -> pdata , - 1 ) ; g_debug ( ""running<s2sv_blank>\'%s\'"" , commandline ) ; if ( ( flags & flatpak_run_flag_background ) != 0 ) { gpid child_pid ; char pid_str [ 64 ] ; g_autofree char * pid_path = null ; gspawnflags spawn_flags ; spawn_flags = g_spawn_search_path ; if ( flags & flatpak_run_flag_do_not_reap ) spawn_flags |= g_spawn_do_not_reap_child ; spawn_flags |= g_spawn_leave_descriptors_open ; if ( ! g_spawn_async ( null , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return false ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , child_pid ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , null ) ; g_file_set_contents ( pid_path , pid_str , - 1 , null ) ; } else { char pid_str [ 64 ] ; g_autofree char * pid_path = null ; g_snprintf ( pid_str , sizeof ( pid_str ) , ""%d"" , getpid ( ) ) ; pid_path = g_build_filename ( instance_id_host_dir , ""pid"" , null ) ; g_file_set_contents ( pid_path , pid_str , - 1 , null ) ; flatpak_bwrap_child_setup ( bwrap -> fds , false ) ; if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) { g_set_error_literal ( error , g_io_error , g_io_error_from_errno ( errno ) , _ ( ""unable<s2sv_blank>to<s2sv_blank>start<s2sv_blank>app"" ) ) ; return false ; } } if ( instance_dir_out ) * instance_dir_out = g_steal_pointer ( & instance_id_host_dir ) ; return true ; }","<S2SV_ModStart> default_command ; } flatpak_bwrap_envp_to_args ( bwrap ) ; <S2SV_ModStart> |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ; g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; <S2SV_ModStart> FALSE ) ; g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ;
",flatpak@flatpak/6d1773d2a54dde9b099043f07a2094a4f1c2f486,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486,2021-01-14T20:15Z,"<S2SV_StartBug> if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! g_spawn_async ( NULL , <S2SV_EndBug> <S2SV_StartBug> if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) <S2SV_EndBug>"
7656,CWE-401,"static int rsi_send_beacon ( struct rsi_common * common ) { struct sk_buff * skb = null ; u8 dword_align_bytes = 0 ; skb = dev_alloc_skb ( max_mgmt_pkt_size ) ; if ( ! skb ) return - enomem ; memset ( skb -> data , 0 , max_mgmt_pkt_size ) ; dword_align_bytes = ( ( unsigned long ) skb -> data & 0x3f ) ; if ( dword_align_bytes ) skb_pull ( skb , ( 64 - dword_align_bytes ) ) ; if ( rsi_prepare_beacon ( common , skb ) ) { rsi_dbg ( err_zone , ""failed<s2sv_blank>to<s2sv_blank>prepare<s2sv_blank>beacon\\n"" ) ; return - einval ; } skb_queue_tail ( & common -> tx_queue [ mgmt_beacon_q ] , skb ) ; rsi_set_event ( & common -> tx_thread . event ) ; rsi_dbg ( data_tx_zone , ""%s:<s2sv_blank>added<s2sv_blank>to<s2sv_blank>beacon<s2sv_blank>queue\\n"" , __func__ ) ; return 0 ; }","<S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>beacon\\n"" ) ; dev_kfree_skb ( skb ) ;
",torvalds@linux/d563131ef23cbc756026f839a82598c8445bc45f,CVE-2019-19071,https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f,2019-11-18T06:15Z,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>
7865,CWE-20,"error_t enc28j60updatemacaddrfilter ( netinterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint8_t hashtable [ 8 ] ; macfilterentry * entry ; trace_debug ( ""updating<s2sv_blank>mac<s2sv_blank>filter...\\r\\n"" ) ; osmemset ( hashtable , 0 , sizeof ( hashtable ) ) ; for ( i = 0 ; i < mac_addr_filter_size ; i ++ ) { entry = & interface -> macaddrfilter [ i ] ; if ( entry -> refcount > 0 ) { crc = enc28j60calccrc ( & entry -> addr , sizeof ( macaddr ) ) ; k = ( crc >> 23 ) & 0x3f ; hashtable [ k / 8 ] |= ( 1 << ( k % 8 ) ) ; } } enc28j60writereg ( interface , enc28j60_reg_eht0 , hashtable [ 0 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht1 , hashtable [ 1 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht2 , hashtable [ 2 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht3 , hashtable [ 3 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht4 , hashtable [ 4 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht5 , hashtable [ 5 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht6 , hashtable [ 6 ] ) ; enc28j60writereg ( interface , enc28j60_reg_eht7 , hashtable [ 7 ] ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht0<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht0 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht1<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht1 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht2<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht2 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht3<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht3 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht0<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht4 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht1<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht5 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht2<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht6 ) ) ; trace_debug ( ""<s2sv_blank><s2sv_blank>eht3<s2sv_blank>=<s2sv_blank>%02"" prix8 ""\\r\\n"" , enc28j60readreg ( interface , enc28j60_reg_eht7 ) ) ; return no_error ; }","<S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , hashTable [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , hashTable [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , hashTable [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , hashTable [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , hashTable [ 7 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT7 ) ) ; <S2SV_EndBug>"
2875,CWE-310,"static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; snprintf ( rcipher . type , crypto_max_alg_name , ""%s"" , ""cipher"" ) ; rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , cryptocfga_report_cipher , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - emsgsize ; }","<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , ""cipher"" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
",torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,CVE-2013-2548,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,2013-03-15T20:55Z,"<S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug>"
1179,CWE-125,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype ) { struct sock_exterr_skb * serr ; int err ; serr = skb_ext_err ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = enomsg ; serr -> ee . ee_origin = so_ee_origin_timestamping ; serr -> ee . ee_info = tstype ; if ( sk -> sk_tsflags & sof_timestamping_opt_id ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == ipproto_tcp && sk -> sk_type == sock_stream ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }","<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,<S2SV_StartBug> int tstype ) <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug>
227,CWE-17,"static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = udf_i ( dir ) ; struct udf_fileident_bh fibh = { . sbh = null , . ebh = null } ; struct fileidentdesc * fi = null ; struct fileidentdesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = null ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { null , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( udf_name_len , gfp_nofs ) ; if ( ! fname ) { ret = - enomem ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != icbtag_flag_ad_in_icb ) { if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( ext_recorded_allocated >> 30 ) ) { ret = - enoent ; goto out ; } block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( iinfo -> i_alloc_type == icbtag_flag_ad_short ) epos . offset -= sizeof ( struct short_ad ) ; else if ( iinfo -> i_alloc_type == icbtag_flag_ad_long ) epos . offset -= sizeof ( struct long_ad ) ; } else { offset = 0 ; } if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { ret = - eio ; goto out ; } if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; for ( num = 0 ; i > 0 ; i -- ) { block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; tmp = udf_tgetblk ( dir -> i_sb , block ) ; if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) bha [ num ++ ] = tmp ; else brelse ( tmp ) ; } if ( num ) { ll_rw_block ( reada , num , bha ) ; for ( i = 0 ; i < num ; i ++ ) brelse ( bha [ i ] ) ; } } } while ( nf_pos < size ) { struct kernel_lb_addr tloc ; ctx -> pos = ( nf_pos >> 2 ) + 1 ; fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out ; liu = le16_to_cpu ( cfi . lengthofimpuse ) ; lfi = cfi . lengthfileident ; if ( fibh . sbh == fibh . ebh ) { nameptr = fi -> fileident + liu ; } else { int poffset ; poffset = fibh . soffset + sizeof ( struct fileidentdesc ) + liu + lfi ; if ( poffset >= lfi ) { nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; } else { nameptr = fname ; memcpy ( nameptr , fi -> fileident + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh . ebh -> b_data , poffset ) ; } } if ( ( cfi . filecharacteristics & fid_file_char_deleted ) != 0 ) { if ( ! udf_query_flag ( dir -> i_sb , udf_flag_undelete ) ) continue ; } if ( ( cfi . filecharacteristics & fid_file_char_hidden ) != 0 ) { if ( ! udf_query_flag ( dir -> i_sb , udf_flag_unhide ) ) continue ; } if ( cfi . filecharacteristics & fid_file_char_parent ) { if ( ! dir_emit_dotdot ( file , ctx ) ) goto out ; continue ; } flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; if ( ! flen ) continue ; tloc = lelb_to_cpu ( cfi . icb . extlocation ) ; iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; if ( ! dir_emit ( ctx , fname , flen , iblock , dt_unknown ) ) goto out ; } ctx -> pos = ( nf_pos >> 2 ) + 1 ; out : if ( fibh . sbh != fibh . ebh ) brelse ( fibh . ebh ) ; brelse ( fibh . sbh ) ; brelse ( epos . bh ) ; kfree ( fname ) ; return ret ; }","<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug>"
4851,CWE-252,"void vsyslog ( pri , fmt , ap ) int pri ; register const char * fmt ; va_list ap ; { struct tm now_tm ; time_t now ; int fd ; file * f ; char * buf = 0 ; size_t bufsize = 0 ; size_t prioff , msgoff ; struct sigaction action , oldaction ; struct sigaction * oldaction_ptr = null ; int sigpipe ; int saved_errno = errno ; # define internallog log_err | log_cons | log_perror | log_pid if ( pri & ~ ( log_primask | log_facmask ) ) { syslog ( internallog , ""syslog:<s2sv_blank>unknown<s2sv_blank>facility/priority:<s2sv_blank>%x"" , pri ) ; pri &= log_primask | log_facmask ; } if ( ( log_mask ( log_pri ( pri ) ) & logmask ) == 0 ) return ; if ( ( pri & log_facmask ) == 0 ) pri |= logfacility ; f = open_memstream ( & buf , & bufsize ) ; prioff = fprintf ( f , ""<%d>"" , pri ) ; ( void ) time ( & now ) ; # ifdef use_in_libio f -> _io_write_ptr += strftime ( f -> _io_write_ptr , f -> _io_write_end - f -> _io_write_ptr , ""%h<s2sv_blank>%e<s2sv_blank>%t<s2sv_blank>"" , __localtime_r ( & now , & now_tm ) ) ; # else f -> __bufp += strftime ( f -> __bufp , f -> __put_limit - f -> __bufp , ""%h<s2sv_blank>%e<s2sv_blank>%t<s2sv_blank>"" , __localtime_r ( & now , & now_tm ) ) ; # endif msgoff = ftell ( f ) ; if ( logtag == null ) logtag = __progname ; if ( logtag != null ) fputs_unlocked ( logtag , f ) ; if ( logstat & log_pid ) fprintf ( f , ""[%d]"" , __getpid ( ) ) ; if ( logtag != null ) putc_unlocked ( ':' , f ) , putc_unlocked ( '<s2sv_blank>' , f ) ; __set_errno ( saved_errno ) ; vfprintf ( f , fmt , ap ) ; fclose ( f ) ; if ( logstat & log_perror ) { struct iovec iov [ 2 ] ; register struct iovec * v = iov ; v -> iov_base = buf + msgoff ; v -> iov_len = bufsize - msgoff ; ++ v ; v -> iov_base = ( char * ) ""\\n"" ; v -> iov_len = 1 ; ( void ) __writev ( stderr_fileno , iov , 2 ) ; } __libc_cleanup_region_start ( ( void ( * ) ( void * ) ) cancel_handler , & oldaction_ptr ) ; __libc_lock_lock ( syslog_lock ) ; memset ( & action , 0 , sizeof ( action ) ) ; action . sa_handler = sigpipe_handler ; sigemptyset ( & action . sa_mask ) ; sigpipe = __sigaction ( sigpipe , & action , & oldaction ) ; if ( sigpipe == 0 ) oldaction_ptr = & oldaction ; if ( ! connected ) openlog_internal ( logtag , logstat | log_ndelay , 0 ) ; if ( logtype == sock_stream ) ++ bufsize ; if ( ! connected || __send ( logfile , buf , bufsize , 0 ) < 0 ) { closelog_internal ( ) ; if ( logstat & log_cons && ( fd = __open ( _path_console , o_wronly | o_noctty , 0 ) ) >= 0 ) { dprintf ( fd , ""%s\\r\\n"" , buf + msgoff ) ; ( void ) __close ( fd ) ; } } if ( sigpipe == 0 ) __sigaction ( sigpipe , & oldaction , ( struct sigaction * ) null ) ; __libc_cleanup_region_end ( 0 ) ; __libc_lock_unlock ( syslog_lock ) ; free ( buf ) ; }","<S2SV_ModStart> - msgoff ; if ( buf [ bufsize - 1 ] != '\\n' ) { <S2SV_ModStart> = 1 ; } <S2SV_ModStart> , iov , v - iov + 1 <S2SV_ModEnd> ) ; }
",bminor@glibc/2864e767053317538feafa815046fff89e5a16be,CVE-1999-0199,https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be,2020-10-06T13:15Z,"<S2SV_StartBug> ++ v ; <S2SV_EndBug> <S2SV_StartBug> ( void ) __writev ( STDERR_FILENO , iov , 2 ) ; <S2SV_EndBug>"
1268,CWE-264,static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> netdev_ops = & ieee80211_dataif_ops ; dev -> destructor = free_netdev ; },"<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug>
7439,CWE-74,"static gboolean handle_spawn ( portalflatpak * object , gdbusmethodinvocation * invocation , gunixfdlist * fd_list , const gchar * arg_cwd_path , const gchar * const * arg_argv , gvariant * arg_fds , gvariant * arg_envs , guint arg_flags , gvariant * arg_options ) { g_autoptr ( gerror ) error = null ; childsetupdata child_setup_data = { null } ; gpid pid ; piddata * pid_data ; instanceidreaddata * instance_id_read_data = null ; gsize i , j , n_fds , n_envs ; const gint * fds = null ; gint fds_len = 0 ; g_autofree fdmapentry * fd_map = null ; gchar * * env ; gint32 max_fd ; gkeyfile * app_info ; g_autoptr ( gptrarray ) flatpak_argv = g_ptr_array_new_with_free_func ( g_free ) ; g_autofree char * app_id = null ; g_autofree char * branch = null ; g_autofree char * arch = null ; g_autofree char * app_commit = null ; g_autofree char * runtime_ref = null ; g_auto ( gstrv ) runtime_parts = null ; g_autofree char * runtime_commit = null ; g_autofree char * instance_path = null ; g_auto ( gstrv ) extra_args = null ; g_auto ( gstrv ) shares = null ; g_auto ( gstrv ) sockets = null ; g_auto ( gstrv ) devices = null ; g_auto ( gstrv ) sandbox_expose = null ; g_auto ( gstrv ) sandbox_expose_ro = null ; g_autoptr ( gvariant ) sandbox_expose_fd = null ; g_autoptr ( gvariant ) sandbox_expose_fd_ro = null ; g_autoptr ( goutputstream ) instance_id_out_stream = null ; guint sandbox_flags = 0 ; gboolean sandboxed ; gboolean expose_pids ; gboolean share_pids ; gboolean notify_start ; gboolean devel ; g_autoptr ( gstring ) env_string = g_string_new ( """" ) ; child_setup_data . instance_id_fd = - 1 ; child_setup_data . env_fd = - 1 ; if ( fd_list != null ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ; app_info = g_object_get_data ( g_object ( invocation ) , ""app-info"" ) ; g_assert ( app_info != null ) ; app_id = g_key_file_get_string ( app_info , flatpak_metadata_group_application , flatpak_metadata_key_name , null ) ; g_assert ( app_id != null ) ; g_debug ( ""spawn()<s2sv_blank>called<s2sv_blank>from<s2sv_blank>app:<s2sv_blank>\'%s\'"" , app_id ) ; if ( * app_id == 0 ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""org.freedesktop.portal.flatpak.spawn<s2sv_blank>only<s2sv_blank>works<s2sv_blank>in<s2sv_blank>a<s2sv_blank>flatpak"" ) ; return g_dbus_method_invocation_handled ; } if ( * arg_cwd_path == 0 ) arg_cwd_path = null ; if ( arg_argv == null || * arg_argv == null ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""no<s2sv_blank>command<s2sv_blank>given"" ) ; return g_dbus_method_invocation_handled ; } if ( ( arg_flags & ~ flatpak_spawn_flags_all ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""unsupported<s2sv_blank>flags<s2sv_blank>enabled:<s2sv_blank>0x%x"" , arg_flags & ~ flatpak_spawn_flags_all ) ; return g_dbus_method_invocation_handled ; } runtime_ref = g_key_file_get_string ( app_info , flatpak_metadata_group_application , flatpak_metadata_key_runtime , null ) ; if ( runtime_ref == null ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""no<s2sv_blank>runtime<s2sv_blank>found"" ) ; return g_dbus_method_invocation_handled ; } runtime_parts = g_strsplit ( runtime_ref , ""/"" , - 1 ) ; branch = g_key_file_get_string ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_branch , null ) ; instance_path = g_key_file_get_string ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_instance_path , null ) ; arch = g_key_file_get_string ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_arch , null ) ; extra_args = g_key_file_get_string_list ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_extra_args , null , null ) ; app_commit = g_key_file_get_string ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_app_commit , null ) ; runtime_commit = g_key_file_get_string ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_runtime_commit , null ) ; shares = g_key_file_get_string_list ( app_info , flatpak_metadata_group_context , flatpak_metadata_key_shared , null , null ) ; sockets = g_key_file_get_string_list ( app_info , flatpak_metadata_group_context , flatpak_metadata_key_sockets , null , null ) ; devices = g_key_file_get_string_list ( app_info , flatpak_metadata_group_context , flatpak_metadata_key_devices , null , null ) ; devel = g_key_file_get_boolean ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_devel , null ) ; g_variant_lookup ( arg_options , ""sandbox-expose"" , ""^as"" , & sandbox_expose ) ; g_variant_lookup ( arg_options , ""sandbox-expose-ro"" , ""^as"" , & sandbox_expose_ro ) ; g_variant_lookup ( arg_options , ""sandbox-flags"" , ""u"" , & sandbox_flags ) ; sandbox_expose_fd = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd"" , g_variant_type ( ""ah"" ) ) ; sandbox_expose_fd_ro = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd-ro"" , g_variant_type ( ""ah"" ) ) ; if ( ( sandbox_flags & ~ flatpak_spawn_sandbox_flags_all ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""unsupported<s2sv_blank>sandbox<s2sv_blank>flags<s2sv_blank>enabled:<s2sv_blank>0x%x"" , arg_flags & ~ flatpak_spawn_sandbox_flags_all ) ; return g_dbus_method_invocation_handled ; } if ( instance_path == null && ( ( sandbox_expose != null && sandbox_expose [ 0 ] != null ) || ( sandbox_expose_ro != null && sandbox_expose_ro [ 0 ] != null ) ) ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""invalid<s2sv_blank>sandbox<s2sv_blank>expose,<s2sv_blank>caller<s2sv_blank>has<s2sv_blank>no<s2sv_blank>instance<s2sv_blank>path"" ) ; return g_dbus_method_invocation_handled ; } for ( i = 0 ; sandbox_expose != null && sandbox_expose [ i ] != null ; i ++ ) { const char * expose = sandbox_expose [ i ] ; g_debug ( ""exposing<s2sv_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return g_dbus_method_invocation_handled ; } } for ( i = 0 ; sandbox_expose_ro != null && sandbox_expose_ro [ i ] != null ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<s2sv_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return g_dbus_method_invocation_handled ; } } g_debug ( ""running<s2sv_blank>spawn<s2sv_blank>command<s2sv_blank>%s"" , arg_argv [ 0 ] ) ; n_fds = 0 ; if ( fds != null ) n_fds = g_variant_n_children ( arg_fds ) ; fd_map = g_new0 ( fdmapentry , n_fds ) ; child_setup_data . fd_map = fd_map ; child_setup_data . fd_map_len = n_fds ; max_fd = - 1 ; for ( i = 0 ; i < n_fds ; i ++ ) { gint32 handle , dest_fd ; int handle_fd ; g_variant_get_child ( arg_fds , i , ""{uh}"" , & dest_fd , & handle ) ; if ( handle >= fds_len || handle < 0 ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""no<s2sv_blank>file<s2sv_blank>descriptor<s2sv_blank>for<s2sv_blank>handle<s2sv_blank>%d"" , handle ) ; return g_dbus_method_invocation_handled ; } handle_fd = fds [ handle ] ; fd_map [ i ] . to = dest_fd ; fd_map [ i ] . from = handle_fd ; fd_map [ i ] . final = fd_map [ i ] . to ; if ( ( dest_fd == 0 || dest_fd == 1 || dest_fd == 2 ) && ! child_setup_data . set_tty && isatty ( handle_fd ) ) { child_setup_data . set_tty = true ; child_setup_data . tty = handle_fd ; } max_fd = max ( max_fd , fd_map [ i ] . to ) ; max_fd = max ( max_fd , fd_map [ i ] . from ) ; } for ( i = 0 ; i < n_fds ; i ++ ) { int to_fd = fd_map [ i ] . to ; gboolean conflict = false ; for ( j = i + 1 ; j < n_fds ; j ++ ) { int from_fd = fd_map [ j ] . from ; if ( from_fd == to_fd ) { conflict = true ; break ; } } if ( conflict ) fd_map [ i ] . to = ++ max_fd ; } if ( arg_flags & flatpak_spawn_flags_clear_env ) { char * empty [ ] = { null } ; env = g_strdupv ( empty ) ; } else env = g_get_environ ( ) ; n_envs = g_variant_n_children ( arg_envs ) ; for ( i = 0 ; i < n_envs ; i ++ ) { const char * var = null ; const char * val = null ; g_variant_get_child ( arg_envs , i , ""{&s&s}"" , & var , & val ) ; env = g_environ_setenv ( env , var , val , true ) ; } g_ptr_array_add ( flatpak_argv , g_strdup ( ""flatpak"" ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup ( ""run"" ) ) ; sandboxed = ( arg_flags & flatpak_spawn_flags_sandbox ) != 0 ; if ( sandboxed ) { g_ptr_array_add ( flatpak_argv , g_strdup ( ""--sandbox"" ) ) ; if ( sandbox_flags & flatpak_spawn_sandbox_flags_share_display ) { if ( sockets != null && g_strv_contains ( ( const char * const * ) sockets , ""wayland"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=wayland"" ) ) ; if ( sockets != null && g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=fallback-x11"" ) ) ; if ( sockets != null && g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=x11"" ) ) ; if ( shares != null && g_strv_contains ( ( const char * const * ) shares , ""ipc"" ) && sockets != null && ( g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) || g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=ipc"" ) ) ; } if ( sandbox_flags & flatpak_spawn_sandbox_flags_share_sound ) { if ( sockets != null && g_strv_contains ( ( const char * const * ) sockets , ""pulseaudio"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=pulseaudio"" ) ) ; } if ( sandbox_flags & flatpak_spawn_sandbox_flags_share_gpu ) { if ( devices != null && ( g_strv_contains ( ( const char * const * ) devices , ""dri"" ) || g_strv_contains ( ( const char * const * ) devices , ""all"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--device=dri"" ) ) ; } if ( sandbox_flags & flatpak_spawn_sandbox_flags_allow_dbus ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--session-bus"" ) ) ; if ( sandbox_flags & flatpak_spawn_sandbox_flags_allow_a11y ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--a11y-bus"" ) ) ; } else { for ( i = 0 ; extra_args != null && extra_args [ i ] != null ; i ++ ) { if ( g_str_has_prefix ( extra_args [ i ] , ""--env="" ) ) { const char * var_val = extra_args [ i ] + strlen ( ""--env="" ) ; if ( var_val [ 0 ] == '\\0' || var_val [ 0 ] == '=' ) { g_warning ( ""environment<s2sv_blank>variable<s2sv_blank>in<s2sv_blank>extra-args<s2sv_blank>has<s2sv_blank>empty<s2sv_blank>name"" ) ; continue ; } if ( strchr ( var_val , '=' ) == null ) { g_warning ( ""environment<s2sv_blank>variable<s2sv_blank>in<s2sv_blank>extra-args<s2sv_blank>has<s2sv_blank>no<s2sv_blank>value"" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\0' ) ; } else { g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( glnxtmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , ""environ"" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return g_dbus_method_invocation_handled ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--env-fd=%d"" , child_setup_data . env_fd ) ) ; } expose_pids = ( arg_flags & flatpak_spawn_flags_expose_pids ) != 0 ; share_pids = ( arg_flags & flatpak_spawn_flags_share_pids ) != 0 ; if ( expose_pids || share_pids ) { g_autofree char * instance_id = null ; int sender_pid1 = 0 ; if ( ! ( supports & flatpak_spawn_support_flags_expose_pids ) ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_not_supported , ""expose<s2sv_blank>pids<s2sv_blank>not<s2sv_blank>supported<s2sv_blank>with<s2sv_blank>setuid<s2sv_blank>bwrap"" ) ; return g_dbus_method_invocation_handled ; } instance_id = g_key_file_get_string ( app_info , flatpak_metadata_group_instance , flatpak_metadata_key_instance_id , null ) ; if ( instance_id ) { g_autoptr ( flatpakinstance ) instance = flatpak_instance_new_for_id ( instance_id ) ; sender_pid1 = flatpak_instance_get_child_pid ( instance ) ; } if ( sender_pid1 == 0 ) { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""could<s2sv_blank>not<s2sv_blank>find<s2sv_blank>requesting<s2sv_blank>pid"" ) ; return g_dbus_method_invocation_handled ; } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--parent-pid=%d"" , sender_pid1 ) ) ; if ( share_pids ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-share-pids"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-expose-pids"" ) ) ; } notify_start = ( arg_flags & flatpak_spawn_flags_notify_start ) != 0 ; if ( notify_start ) { int pipe_fds [ 2 ] ; if ( pipe ( pipe_fds ) == - 1 ) { int errsv = errno ; g_dbus_method_invocation_return_error ( invocation , g_io_error , g_io_error_from_errno ( errsv ) , ""failed<s2sv_blank>to<s2sv_blank>create<s2sv_blank>instance<s2sv_blank>id<s2sv_blank>pipe:<s2sv_blank>%s"" , g_strerror ( errsv ) ) ; return g_dbus_method_invocation_handled ; } ginputstream * in_stream = g_input_stream ( g_unix_input_stream_new ( pipe_fds [ 0 ] , true ) ) ; instance_id_out_stream = g_output_stream ( g_unix_output_stream_new ( pipe_fds [ 1 ] , true ) ) ; instance_id_read_data = g_new0 ( instanceidreaddata , 1 ) ; g_input_stream_read_async ( in_stream , instance_id_read_data -> buffer , instance_id_buffer_size - 1 , g_priority_default , null , instance_id_read_finish , instance_id_read_data ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--instance-id-fd=%d"" , pipe_fds [ 1 ] ) ) ; child_setup_data . instance_id_fd = pipe_fds [ 1 ] ; } if ( devel ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--devel"" ) ) ; if ( shares != null && g_strv_contains ( ( const char * const * ) shares , ""network"" ) && ! ( arg_flags & flatpak_spawn_flags_no_network ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=network"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--unshare=network"" ) ) ; if ( instance_path ) { for ( i = 0 ; sandbox_expose != null && sandbox_expose [ i ] != null ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose [ i ] , false ) ) ; for ( i = 0 ; sandbox_expose_ro != null && sandbox_expose_ro [ i ] != null ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose_ro [ i ] , true ) ) ; } for ( i = 0 ; sandbox_expose_ro != null && sandbox_expose_ro [ i ] != null ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<s2sv_blank>%s"" , expose ) ; } if ( sandbox_expose_fd != null ) { gsize len = g_variant_n_children ( sandbox_expose_fd ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = null ; gboolean writable = false ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , ! writable ) ) ; } else { g_debug ( ""unable<s2sv_blank>to<s2sv_blank>get<s2sv_blank>path<s2sv_blank>for<s2sv_blank>sandbox-exposed<s2sv_blank>fd<s2sv_blank>%d,<s2sv_blank>ignoring:<s2sv_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""no<s2sv_blank>file<s2sv_blank>descriptor<s2sv_blank>for<s2sv_blank>handle<s2sv_blank>%d"" , handle ) ; return g_dbus_method_invocation_handled ; } } } if ( sandbox_expose_fd_ro != null ) { gsize len = g_variant_n_children ( sandbox_expose_fd_ro ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd_ro , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = null ; gboolean writable = false ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , true ) ) ; } else { g_debug ( ""unable<s2sv_blank>to<s2sv_blank>get<s2sv_blank>path<s2sv_blank>for<s2sv_blank>sandbox-exposed<s2sv_blank>fd<s2sv_blank>%d,<s2sv_blank>ignoring:<s2sv_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , g_dbus_error , g_dbus_error_invalid_args , ""no<s2sv_blank>file<s2sv_blank>descriptor<s2sv_blank>for<s2sv_blank>handle<s2sv_blank>%d"" , handle ) ; return g_dbus_method_invocation_handled ; } } } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime=%s"" , runtime_parts [ 1 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-version=%s"" , runtime_parts [ 3 ] ) ) ; if ( ( arg_flags & flatpak_spawn_flags_latest_version ) == 0 ) { if ( app_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--commit=%s"" , app_commit ) ) ; if ( runtime_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-commit=%s"" , runtime_commit ) ) ; } if ( arg_cwd_path != null ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--cwd=%s"" , arg_cwd_path ) ) ; if ( arg_argv [ 0 ] [ 0 ] != 0 ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--command=%s"" , arg_argv [ 0 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""%s/%s/%s"" , app_id , arch ? arch : """" , branch ? branch : """" ) ) ; for ( i = 1 ; arg_argv [ i ] != null ; i ++ ) g_ptr_array_add ( flatpak_argv , g_strdup ( arg_argv [ i ] ) ) ; g_ptr_array_add ( flatpak_argv , null ) ; if ( opt_verbose ) { g_autoptr ( gstring ) cmd = g_string_new ( """" ) ; for ( i = 0 ; flatpak_argv -> pdata [ i ] != null ; i ++ ) { if ( i > 0 ) g_string_append ( cmd , ""<s2sv_blank>"" ) ; g_string_append ( cmd , flatpak_argv -> pdata [ i ] ) ; } g_debug ( ""starting:<s2sv_blank>%s\\n"" , cmd -> str ) ; } if ( ! g_spawn_async_with_pipes ( null , ( char * * ) flatpak_argv -> pdata , env , g_spawn_search_path | g_spawn_do_not_reap_child | g_spawn_leave_descriptors_open , child_setup_func , & child_setup_data , & pid , null , null , null , & error ) ) { gint code = g_dbus_error_failed ; if ( g_error_matches ( error , g_spawn_error , g_spawn_error_acces ) ) code = g_dbus_error_access_denied ; else if ( g_error_matches ( error , g_spawn_error , g_spawn_error_noent ) ) code = g_dbus_error_file_not_found ; g_dbus_method_invocation_return_error ( invocation , g_dbus_error , code , ""failed<s2sv_blank>to<s2sv_blank>start<s2sv_blank>command:<s2sv_blank>%s"" , error -> message ) ; return g_dbus_method_invocation_handled ; } if ( instance_id_read_data ) instance_id_read_data -> pid = pid ; pid_data = g_new0 ( piddata , 1 ) ; pid_data -> pid = pid ; pid_data -> client = g_strdup ( g_dbus_method_invocation_get_sender ( invocation ) ) ; pid_data -> watch_bus = ( arg_flags & flatpak_spawn_flags_watch_bus ) != 0 ; pid_data -> expose_or_share_pids = ( expose_pids || share_pids ) ; pid_data -> child_watch = g_child_watch_add_full ( g_priority_default , pid , child_watch_died , pid_data , null ) ; g_debug ( ""client<s2sv_blank>pid<s2sv_blank>is<s2sv_blank>%d"" , pid_data -> pid ) ; g_hash_table_replace ( client_pid_data_hash , guint_to_pointer ( pid_data -> pid ) , pid_data ) ; portal_flatpak_complete_spawn ( object , invocation , null , pid ) ; return g_dbus_method_invocation_handled ; }","<S2SV_ModStart> val ) ; if ( var [ 0 ] == '\\0' ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( strchr ( var , '=' ) != NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\'=\'"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_string_append ( env_string , var ) ; g_string_append_c ( env_string , '=' ) ; g_string_append ( env_string , val ) ; g_string_append_c ( env_string , '\\0' <S2SV_ModEnd> ) ; }
",flatpak@flatpak/cc1401043c075268ecc652eac557ef8076b5eaba,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/cc1401043c075268ecc652eac557ef8076b5eaba,2021-01-14T20:15Z,"<S2SV_StartBug> env = g_environ_setenv ( env , var , val , TRUE ) ; <S2SV_EndBug>"
7771,CWE-125,"stmt_ty asyncfor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int lineno , int col_offset , int end_lineno , int end_col_offset , pyarena * arena ) { stmt_ty p ; if ( ! target ) { pyerr_setstring ( pyexc_valueerror , ""field<s2sv_blank>target<s2sv_blank>is<s2sv_blank>required<s2sv_blank>for<s2sv_blank>asyncfor"" ) ; return null ; } if ( ! iter ) { pyerr_setstring ( pyexc_valueerror , ""field<s2sv_blank>iter<s2sv_blank>is<s2sv_blank>required<s2sv_blank>for<s2sv_blank>asyncfor"" ) ; return null ; } p = ( stmt_ty ) pyarena_malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return null ; p -> kind = asyncfor_kind ; p -> v . asyncfor . target = target ; p -> v . asyncfor . iter = iter ; p -> v . asyncfor . body = body ; p -> v . asyncfor . orelse = orelse ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug>"
5074,CWE-400,"const char * nghttp2_strerror ( int error_code ) { switch ( error_code ) { case 0 : return ""success"" ; case nghttp2_err_invalid_argument : return ""invalid<s2sv_blank>argument"" ; case nghttp2_err_buffer_error : return ""out<s2sv_blank>of<s2sv_blank>buffer<s2sv_blank>space"" ; case nghttp2_err_unsupported_version : return ""unsupported<s2sv_blank>spdy<s2sv_blank>version"" ; case nghttp2_err_wouldblock : return ""operation<s2sv_blank>would<s2sv_blank>block"" ; case nghttp2_err_proto : return ""protocol<s2sv_blank>error"" ; case nghttp2_err_invalid_frame : return ""invalid<s2sv_blank>frame<s2sv_blank>octets"" ; case nghttp2_err_eof : return ""eof"" ; case nghttp2_err_deferred : return ""data<s2sv_blank>transfer<s2sv_blank>deferred"" ; case nghttp2_err_stream_id_not_available : return ""no<s2sv_blank>more<s2sv_blank>stream<s2sv_blank>id<s2sv_blank>available"" ; case nghttp2_err_stream_closed : return ""stream<s2sv_blank>was<s2sv_blank>already<s2sv_blank>closed<s2sv_blank>or<s2sv_blank>invalid"" ; case nghttp2_err_stream_closing : return ""stream<s2sv_blank>is<s2sv_blank>closing"" ; case nghttp2_err_stream_shut_wr : return ""the<s2sv_blank>transmission<s2sv_blank>is<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>for<s2sv_blank>this<s2sv_blank>stream"" ; case nghttp2_err_invalid_stream_id : return ""stream<s2sv_blank>id<s2sv_blank>is<s2sv_blank>invalid"" ; case nghttp2_err_invalid_stream_state : return ""invalid<s2sv_blank>stream<s2sv_blank>state"" ; case nghttp2_err_deferred_data_exist : return ""another<s2sv_blank>data<s2sv_blank>frame<s2sv_blank>has<s2sv_blank>already<s2sv_blank>been<s2sv_blank>deferred"" ; case nghttp2_err_start_stream_not_allowed : return ""request<s2sv_blank>headers<s2sv_blank>is<s2sv_blank>not<s2sv_blank>allowed"" ; case nghttp2_err_goaway_already_sent : return ""goaway<s2sv_blank>has<s2sv_blank>already<s2sv_blank>been<s2sv_blank>sent"" ; case nghttp2_err_invalid_header_block : return ""invalid<s2sv_blank>header<s2sv_blank>block"" ; case nghttp2_err_invalid_state : return ""invalid<s2sv_blank>state"" ; case nghttp2_err_temporal_callback_failure : return ""the<s2sv_blank>user<s2sv_blank>callback<s2sv_blank>function<s2sv_blank>failed<s2sv_blank>due<s2sv_blank>to<s2sv_blank>the<s2sv_blank>temporal<s2sv_blank>error"" ; case nghttp2_err_frame_size_error : return ""the<s2sv_blank>length<s2sv_blank>of<s2sv_blank>the<s2sv_blank>frame<s2sv_blank>is<s2sv_blank>invalid"" ; case nghttp2_err_header_comp : return ""header<s2sv_blank>compression/decompression<s2sv_blank>error"" ; case nghttp2_err_flow_control : return ""flow<s2sv_blank>control<s2sv_blank>error"" ; case nghttp2_err_insuff_bufsize : return ""insufficient<s2sv_blank>buffer<s2sv_blank>size<s2sv_blank>given<s2sv_blank>to<s2sv_blank>function"" ; case nghttp2_err_pause : return ""callback<s2sv_blank>was<s2sv_blank>paused<s2sv_blank>by<s2sv_blank>the<s2sv_blank>application"" ; case nghttp2_err_too_many_inflight_settings : return ""too<s2sv_blank>many<s2sv_blank>inflight<s2sv_blank>settings"" ; case nghttp2_err_push_disabled : return ""server<s2sv_blank>push<s2sv_blank>is<s2sv_blank>disabled<s2sv_blank>by<s2sv_blank>peer"" ; case nghttp2_err_data_exist : return ""data<s2sv_blank>or<s2sv_blank>headers<s2sv_blank>frame<s2sv_blank>has<s2sv_blank>already<s2sv_blank>been<s2sv_blank>submitted<s2sv_blank>for<s2sv_blank>the<s2sv_blank>stream"" ; case nghttp2_err_session_closing : return ""the<s2sv_blank>current<s2sv_blank>session<s2sv_blank>is<s2sv_blank>closing"" ; case nghttp2_err_http_header : return ""invalid<s2sv_blank>http<s2sv_blank>header<s2sv_blank>field<s2sv_blank>was<s2sv_blank>received"" ; case nghttp2_err_http_messaging : return ""violation<s2sv_blank>in<s2sv_blank>http<s2sv_blank>messaging<s2sv_blank>rule"" ; case nghttp2_err_refused_stream : return ""stream<s2sv_blank>was<s2sv_blank>refused"" ; case nghttp2_err_internal : return ""internal<s2sv_blank>error"" ; case nghttp2_err_cancel : return ""cancel"" ; case nghttp2_err_settings_expected : return ""when<s2sv_blank>a<s2sv_blank>local<s2sv_blank>endpoint<s2sv_blank>expects<s2sv_blank>to<s2sv_blank>receive<s2sv_blank>settings<s2sv_blank>frame,<s2sv_blank>it<s2sv_blank>"" ""receives<s2sv_blank>an<s2sv_blank>other<s2sv_blank>type<s2sv_blank>of<s2sv_blank>frame"" ; case nghttp2_err_nomem : return ""out<s2sv_blank>of<s2sv_blank>memory"" ; case nghttp2_err_callback_failure : return ""the<s2sv_blank>user<s2sv_blank>callback<s2sv_blank>function<s2sv_blank>failed"" ; case nghttp2_err_bad_client_magic : return ""received<s2sv_blank>bad<s2sv_blank>client<s2sv_blank>magic<s2sv_blank>byte<s2sv_blank>string"" ; case nghttp2_err_flooded : return ""flooding<s2sv_blank>was<s2sv_blank>detected<s2sv_blank>in<s2sv_blank>this<s2sv_blank>http/2<s2sv_blank>session,<s2sv_blank>and<s2sv_blank>it<s2sv_blank>must<s2sv_blank>be<s2sv_blank>"" ""closed"" ; default : return ""unknown<s2sv_blank>error<s2sv_blank>code"" ; } }","<S2SV_ModStart> ""Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>"" ""closed"" ; case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ;
",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z,<S2SV_StartBug> default : <S2SV_EndBug>
6432,CWE-78,"int check_restricted ( void ) { if ( restricted ) { emsg ( _ ( ""e145:<s2sv_blank>shell<s2sv_blank>commands<s2sv_blank>not<s2sv_blank>allowed<s2sv_blank>in<s2sv_blank>rvim"" ) ) ; return true ; } return false ; }","<S2SV_ModStart> ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" <S2SV_ModEnd> ) ) ;
",vim@vim/8c62a08faf89663e5633dc5036cd8695c80f1075,CVE-2019-20807,https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075,2020-05-28T14:15Z,"<S2SV_StartBug> emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ; <S2SV_EndBug>"
3399,CWE-404,"int nfs3svc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; return xdr_argsize_check ( rqstp , p ) ; }","<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug>"
2387,CWE-000,"int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = null ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; bug_on ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; bug_on ( path [ depth ] . p_hdr == null ) ; if ( ex && ( flag != ext4_get_blocks_pre_io ) && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( ""append<s2sv_blank>[%d]%d<s2sv_blank>block<s2sv_blank>to<s2sv_blank>%d:[%d]%d<s2sv_blank>(from<s2sv_blank>%llu)\\n"" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = ext_last_extent ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != ext_max_block ) { ext_debug ( ""next<s2sv_blank>leaf<s2sv_blank>block<s2sv_blank>-<s2sv_blank>%d\\n"" , next ) ; bug_on ( npath != null ) ; npath = ext4_ext_find_extent ( inode , next , null ) ; if ( is_err ( npath ) ) return ptr_err ( npath ) ; bug_on ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( ""next<s2sv_blank>leaf<s2sv_blank>isnt<s2sv_blank>full(%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( ""next<s2sv_blank>leaf<s2sv_blank>has<s2sv_blank>no<s2sv_blank>free<s2sv_blank>space(%d,%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( ""first<s2sv_blank>extent<s2sv_blank>in<s2sv_blank>the<s2sv_blank>leaf:<s2sv_blank>%d:%llu:[%d]%d\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = ext_first_extent ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != ext_last_extent ( eh ) ) { len = ext_max_extent ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<s2sv_blank>%d:%llu:[%d]%d<s2sv_blank>after:<s2sv_blank>nearest<s2sv_blank>0x%p,<s2sv_blank>"" ""move<s2sv_blank>%d<s2sv_blank>from<s2sv_blank>0x%p<s2sv_blank>to<s2sv_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { bug_on ( newext -> ee_block == nearex -> ee_block ) ; len = ( ext_max_extent ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<s2sv_blank>%d:%llu:[%d]%d<s2sv_blank>before:<s2sv_blank>nearest<s2sv_blank>0x%p,<s2sv_blank>"" ""move<s2sv_blank>%d<s2sv_blank>from<s2sv_blank>0x%p<s2sv_blank>to<s2sv_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge : if ( flag != ext4_get_blocks_pre_io ) ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }","<S2SV_ModStart> ( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,<S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug>
2080,CWE-200,"static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ tipc_nla_link_max + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ tipc_nla_link ] ) return - einval ; err = nla_parse_nested ( link , tipc_nla_link_max , attrs [ tipc_nla_link ] , null ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ tipc_nla_link_dest ] ) ; link_info . up = htonl ( nla_get_flag ( link [ tipc_nla_link_up ] ) ) ; strcpy ( link_info . str , nla_data ( link [ tipc_nla_link_name ] ) ) ; return tipc_add_tlv ( msg -> rep , tipc_tlv_link_info , & link_info , sizeof ( link_info ) ) ; }","<S2SV_ModStart> ) ) ; nla_strlcpy <S2SV_ModEnd> ( link_info . <S2SV_ModStart> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME
",torvalds@linux/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,CVE-2016-5243,https://github.com/torvalds/linux/commit/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,2016-06-27T10:59Z,"<S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug>"
2454,CWE-20,"static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = null ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = null ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = ip6_reply_mark ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & ipv6_addr_multicast || skb -> pkt_type != packet_host ) { if ( type != icmpv6_pkt_toobig && ! ( type == icmpv6_paramprob && code == icmpv6_unk_option && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = null ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; else iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; if ( ( addr_type == ipv6_addr_any ) || ( addr_type & ipv6_addr_multicast ) ) { net_dbg_ratelimited ( ""icmp6_send:<s2sv_blank>addr_any/mcast<s2sv_blank>source<s2sv_blank>[%pi6c<s2sv_blank>><s2sv_blank>%pi6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( ""icmp6_send:<s2sv_blank>no<s2sv_blank>reply<s2sv_blank>to<s2sv_blank>icmp<s2sv_blank>error<s2sv_blank>[%pi6c<s2sv_blank>><s2sv_blank>%pi6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = ipproto_icmpv6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( is_err ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = null ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , ipv6_min_mtu - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( ""icmp:<s2sv_blank>len<s2sv_blank>problem<s2sv_blank>[%pi6c<s2sv_blank>><s2sv_blank>%pi6c]\\n"" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , msg_dontwait , & sockc_unused ) ; if ( err ) { icmp6_inc_stats ( net , idev , icmp6_mib_outerrors ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }","<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
",torvalds@linux/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2,CVE-2016-9919,https://github.com/torvalds/linux/commit/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2,2016-12-08T17:59Z,<S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug>
8126,CWE-295,"noexport char * base64 ( int encode , const char * in , int len ) { bio * bio , * b64 ; char * out ; int n ; b64 = bio_new ( bio_f_base64 ( ) ) ; if ( ! b64 ) return null ; bio_set_flags ( b64 , bio_flags_base64_no_nl ) ; bio = bio_new ( bio_s_mem ( ) ) ; if ( ! bio ) { str_free ( b64 ) ; return null ; } if ( encode ) bio = bio_push ( b64 , bio ) ; bio_write ( bio , in , len ) ; ( void ) bio_flush ( bio ) ; if ( encode ) { bio = bio_pop ( bio ) ; bio_free ( b64 ) ; } else { bio = bio_push ( b64 , bio ) ; } n = bio_pending ( bio ) ; out = str_alloc ( n < 32 ? 32 : ( size_t ) n + 1 ) ; n = bio_read ( bio , out , n ) ; if ( n < 0 ) { bio_free_all ( bio ) ; str_free ( out ) ; return null ; } bio_free_all ( bio ) ; return out ; }","<S2SV_ModStart> bio ) { BIO_free <S2SV_ModEnd> ( b64 )
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,<S2SV_StartBug> str_free ( b64 ) ; <S2SV_EndBug>
2773,CWE-200,"static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; bt_dbg ( ""sock<s2sv_blank>%p,<s2sv_blank>sk<s2sv_blank>%p"" , sock , sk ) ; sa -> rc_family = af_bluetooth ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }","<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug>"
3987,CWE-20,"static int misdn_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ; struct sock * sk = sock -> sk ; struct sockaddr_misdn * maddr ; int copied , err ; if ( * debug & debug_socket ) printk ( kern_debug ""%s:<s2sv_blank>len<s2sv_blank>%d,<s2sv_blank>flags<s2sv_blank>%x<s2sv_blank>ch.nr<s2sv_blank>%d,<s2sv_blank>proto<s2sv_blank>%x\\n"" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( msg_oob ) ) return - eopnotsupp ; if ( sk -> sk_state == misdn_closed ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & msg_dontwait , & err ) ; if ( ! skb ) return err ; if ( msg -> msg_namelen >= sizeof ( struct sockaddr_misdn ) ) { msg -> msg_namelen = sizeof ( struct sockaddr_misdn ) ; maddr = ( struct sockaddr_misdn * ) msg -> msg_name ; maddr -> family = af_isdn ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == isdn_p_lapd_te ) || ( sk -> sk_protocol == isdn_p_lapd_nt ) ) { maddr -> channel = ( misdn_head_id ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( misdn_head_id ( skb ) >> 8 ) & 0xff ; maddr -> sapi = misdn_head_id ( skb ) & 0xff ; } else { maddr -> channel = _pms ( sk ) -> ch . nr ; maddr -> sapi = _pms ( sk ) -> ch . addr & 0xff ; maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xff ; } } else { if ( msg -> msg_namelen ) printk ( kern_warning ""%s:<s2sv_blank>too<s2sv_blank>small<s2sv_blank>namelen<s2sv_blank>%d\\n"" , __func__ , msg -> msg_namelen ) ; msg -> msg_namelen = 0 ; } copied = skb -> len + misdn_header_len ; if ( len < copied ) { if ( flags & msg_peek ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - enospc ; } memcpy ( skb_push ( skb , misdn_header_len ) , misdn_head_p ( skb ) , misdn_header_len ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; misdn_sock_cmsg ( sk , msg , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; int copied <S2SV_ModStart> ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> msg -> msg_name <S2SV_ModStart> 0xFF ; } <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = sizeof ( * maddr ) <S2SV_ModEnd> ; } copied
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug>
3883,CWE-264,"static int flakey_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct flakey_c * fc = ti -> private ; return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; }","<S2SV_ModStart> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( fc -> <S2SV_ModStart> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z,"<S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug>"
6233,CWE-000,"static int parsefileinner ( mastate * state , cchar * path ) { madirective * directive ; char * tok , * key , * line , * value ; assert ( state ) ; assert ( path && * path ) ; if ( openconfig ( state , path ) < 0 ) { return mpr_err_cant_open ; } for ( state -> linenumber = 1 ; state -> file && ( line = mprreadline ( state -> file , 0 , null ) ) != 0 ; state -> linenumber ++ ) { for ( tok = line ; isspace ( ( uchar ) * tok ) ; tok ++ ) ; if ( * tok == '\\0' || * tok == '#' ) { continue ; } state -> key = 0 ; key = getdirective ( line , & value ) ; if ( ! state -> enabled ) { if ( key [ 0 ] != '<' ) { continue ; } } if ( ( directive = mprlookupkey ( directives , key ) ) == 0 ) { mprlog ( ""error<s2sv_blank>appweb<s2sv_blank>config"" , 0 , ""unknown<s2sv_blank>directive<s2sv_blank>\\""%s\\"".<s2sv_blank>at<s2sv_blank>line<s2sv_blank>%d<s2sv_blank>in<s2sv_blank>%s"" , key , state -> linenumber , state -> filename ) ; return mpr_err_bad_syntax ; } state -> key = key ; mprpausegc ( ) ; if ( ( * directive ) ( state , key , value ) < 0 ) { mprresumegc ( ) ; mprlog ( ""error<s2sv_blank>appweb<s2sv_blank>config"" , 0 , ""error<s2sv_blank>with<s2sv_blank>directive<s2sv_blank>\\""%s\\"".<s2sv_blank>at<s2sv_blank>line<s2sv_blank>%d<s2sv_blank>in<s2sv_blank>%s"" , state -> key , state -> linenumber , state -> filename ) ; return mpr_err_bad_syntax ; } mprresumegc ( ) ; mpryield ( 0 ) ; state = state -> top -> current ; } if ( state -> prev && state -> file == state -> prev -> file ) { mprlog ( ""error<s2sv_blank>appweb<s2sv_blank>config"" , 0 , ""unclosed<s2sv_blank>directives<s2sv_blank>in<s2sv_blank>%s"" , state -> filename ) ; while ( state -> prev && state -> file == state -> prev -> file ) { state = state -> prev ; } } mprclosefile ( state -> file ) ; return 0 ; }","<S2SV_ModStart> = 0 ; if ( ( <S2SV_ModStart> & value ) ) == 0 ) { continue ; } <S2SV_ModEnd> if ( !
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,"<S2SV_StartBug> key = getDirective ( line , & value ) ; <S2SV_EndBug>"
3945,CWE-476,"static int tls_construct_cke_dhe ( ssl * s , unsigned char * * p , int * len , int * al ) { # ifndef openssl_no_dh dh * dh_clnt = null ; const bignum * pub_key ; evp_pkey * ckey = null , * skey = null ; skey = s -> s3 -> peer_tmp ; if ( skey == null ) { sslerr ( ssl_f_tls_construct_cke_dhe , err_r_internal_error ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; dh_clnt = evp_pkey_get0_dh ( ckey ) ; if ( dh_clnt == null || ssl_derive ( s , ckey , skey ) == 0 ) { sslerr ( ssl_f_tls_construct_cke_dhe , err_r_internal_error ) ; evp_pkey_free ( ckey ) ; return 0 ; } dh_get0_key ( dh_clnt , & pub_key , null ) ; * len = bn_num_bytes ( pub_key ) ; s2n ( * len , * p ) ; bn_bn2bin ( pub_key , * p ) ; * len += 2 ; evp_pkey_free ( ckey ) ; return 1 ; # else sslerr ( ssl_f_tls_construct_cke_dhe , err_r_internal_error ) ; * al = ssl_ad_internal_error ; return 0 ; # endif }","<S2SV_ModStart> skey ) ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; }
",openssl@openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa,CVE-2017-3730,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,2017-05-04T19:29Z,<S2SV_StartBug> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; <S2SV_EndBug>
3302,CWE-125,"void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; struct va_format vaf ; char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & qedi_log_warn ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<s2sv_blank>%pv"" , dev_name ( & qedi -> pdev -> dev ) , nfunc , line , qedi -> host_no , & vaf ) ; else pr_warn ( ""[0000:00:00.0]:[%s:%d]:<s2sv_blank>%pv"" , nfunc , line , & vaf ) ; ret : va_end ( va ) ; }","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug>"
493,CWE-000,"struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) { struct key * keyring ; int bucket ; if ( ! name ) return err_ptr ( - einval ) ; bucket = keyring_hash ( name ) ; read_lock ( & keyring_name_lock ) ; if ( keyring_name_hash [ bucket ] . next ) { list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) { if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ; if ( test_bit ( key_flag_revoked , & keyring -> flags ) ) continue ; if ( strcmp ( keyring -> description , name ) != 0 ) continue ; if ( ! skip_perm_check && key_permission ( make_key_ref ( keyring , 0 ) , key_need_search ) < 0 ) continue ; if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ; keyring -> last_used_at = current_kernel_time ( ) . tv_sec ; goto out ; } } keyring = err_ptr ( - enokey ) ; out : read_unlock ( & keyring_name_lock ) ; return keyring ; }","<S2SV_ModStart> name , bool uid_keyring <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref <S2SV_ModStart> ) continue ; }
",torvalds@linux/237bbd29f7a049d310d907f4b2716a7feef9abf3,CVE-2017-18270,https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3,2018-05-18T16:29Z,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug>"
5806,CWE-119,"static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; readitems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case ofreshoid : if ( int_val ( field ( ( value ) dest , 1 ) ) >= 0 ) caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case oshift : * dest += sp -> arg ; sp -- ; break ; case oreaditems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= prefix_small_int ) { if ( code >= prefix_small_block ) { tag = code & 0xf ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = atom ( tag ) ; } else { v = val_hp ( intern_dest ) ; if ( intern_obj_table != null ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == object_tag ) { assert ( size >= 2 ) ; readitems ( & field ( v , 2 ) , size - 2 ) ; pushitem ( ) ; sp -> op = ofreshoid ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; readitems ( & field ( v , 0 ) , 2 ) ; } else readitems ( & field ( v , 0 ) , size ) ; } } else { v = val_int ( code & 0x3f ) ; } } else { if ( code >= prefix_small_string ) { len = ( code & 0x1f ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = val_hp ( intern_dest ) ; if ( intern_obj_table != null ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = make_header ( size , string_tag , intern_color ) ; intern_dest += 1 + size ; field ( v , size - 1 ) = 0 ; ofs_ind = bsize_wsize ( size ) - 1 ; byte ( v , ofs_ind ) = ofs_ind - len ; readblock ( string_val ( v ) , len ) ; } else { switch ( code ) { case code_int8 : v = val_long ( read8s ( ) ) ; break ; case code_int16 : v = val_long ( read16s ( ) ) ; break ; case code_int32 : v = val_long ( read32s ( ) ) ; break ; case code_int64 : # ifdef arch_sixtyfour v = val_long ( read64s ( ) ) ; break ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<s2sv_blank>integer<s2sv_blank>too<s2sv_blank>large"" ) ; break ; # endif case code_shared8 : ofs = read8u ( ) ; read_shared : assert ( ofs > 0 ) ; assert ( ofs <= obj_counter ) ; assert ( intern_obj_table != null ) ; v = intern_obj_table [ obj_counter - ofs ] ; break ; case code_shared16 : ofs = read16u ( ) ; goto read_shared ; case code_shared32 : ofs = read32u ( ) ; goto read_shared ; case code_block32 : header = ( header_t ) read32u ( ) ; tag = tag_hd ( header ) ; size = wosize_hd ( header ) ; goto read_block ; case code_block64 : # ifdef arch_sixtyfour header = ( header_t ) read64s ( ) ; tag = tag_hd ( header ) ; size = wosize_hd ( header ) ; goto read_block ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<s2sv_blank>data<s2sv_blank>block<s2sv_blank>too<s2sv_blank>large"" ) ; break ; # endif case code_string8 : len = read8u ( ) ; goto read_string ; case code_string32 : len = read32u ( ) ; goto read_string ; case code_double_little : case code_double_big : v = val_hp ( intern_dest ) ; if ( intern_obj_table != null ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = make_header ( double_wosize , double_tag , intern_color ) ; intern_dest += 1 + double_wosize ; readfloat ( ( double * ) v , code ) ; break ; case code_double_array8_little : case code_double_array8_big : len = read8u ( ) ; read_double_array : size = len * double_wosize ; v = val_hp ( intern_dest ) ; if ( intern_obj_table != null ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = make_header ( size , double_array_tag , intern_color ) ; intern_dest += 1 + size ; readfloats ( ( double * ) v , len , code ) ; break ; case code_double_array32_little : case code_double_array32_big : len = read32u ( ) ; goto read_double_array ; case code_codepointer : ofs = read32u ( ) ; readblock ( digest , 16 ) ; codeptr = intern_resolve_code_pointer ( digest , ofs ) ; if ( codeptr != null ) { v = ( value ) codeptr ; } else { value * function_placeholder = caml_named_value ( ""debugger.function_placeholder"" ) ; if ( function_placeholder != null ) { v = * function_placeholder ; } else { intern_cleanup ( ) ; intern_bad_code_pointer ( digest ) ; } } break ; case code_infixpointer : ofs = read32u ( ) ; pushitem ( ) ; sp -> dest = dest ; sp -> op = oshift ; sp -> arg = ofs ; readitems ( dest , 1 ) ; continue ; case code_custom : ops = caml_find_custom_operations ( ( char * ) intern_src ) ; if ( ops == null ) { intern_cleanup ( ) ; caml_failwith ( ""input_value:<s2sv_blank>unknown<s2sv_blank>custom<s2sv_blank>block<s2sv_blank>identifier"" ) ; } while ( * intern_src ++ != 0 ) ; size = ops -> deserialize ( ( void * ) ( intern_dest + 2 ) ) ; size = 1 + ( size + sizeof ( value ) - 1 ) / sizeof ( value ) ; v = val_hp ( intern_dest ) ; if ( intern_obj_table != null ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = make_header ( size , custom_tag , intern_color ) ; custom_ops_val ( v ) = ops ; if ( ops -> finalize != null && is_young ( v ) ) { if ( caml_finalize_table . ptr >= caml_finalize_table . limit ) { camlassert ( caml_finalize_table . ptr == caml_finalize_table . limit ) ; caml_realloc_ref_table ( & caml_finalize_table ) ; } * caml_finalize_table . ptr ++ = ( value * ) v ; } intern_dest += 1 + size ; break ; default : intern_cleanup ( ) ; caml_failwith ( ""input_value:<s2sv_blank>ill-formed<s2sv_blank>message"" ) ; } } } * dest = v ; break ; default : assert ( 0 ) ; } } intern_free_stack ( ) ; }","<S2SV_ModStart> : if ( Long_val <S2SV_ModEnd> ( Field (
",ocaml@ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74,CVE-2015-8869,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,2016-06-13T19:59Z,"<S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug>"
3014,CWE-399,"static void emulate_load_store_insn ( struct pt_regs * regs , void __user * addr , unsigned int __user * pc ) { union mips_instruction insn ; unsigned long value ; unsigned int res ; perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , regs , 0 ) ; __get_user ( insn . word , pc ) ; switch ( insn . i_format . opcode ) { case ll_op : case lld_op : case sc_op : case scd_op : case ldl_op : case ldr_op : case lwl_op : case lwr_op : case sdl_op : case sdr_op : case swl_op : case swr_op : case lb_op : case lbu_op : case sb_op : goto sigbus ; case lh_op : if ( ! access_ok ( verify_read , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __big_endian ""1:\\tlb\\t%0,<s2sv_blank>0(%2)\\n"" ""2:\\tlbu\\t$1,<s2sv_blank>1(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tlb\\t%0,<s2sv_blank>1(%2)\\n"" ""2:\\tlbu\\t$1,<s2sv_blank>0(%2)\\n\\t"" # endif ""sll\\t%0,<s2sv_blank>0x8\\n\\t"" ""or\\t%0,<s2sv_blank>$1\\n\\t"" ""li\\t%1,<s2sv_blank>0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lw_op : if ( ! access_ok ( verify_read , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __big_endian ""1:\\tlwl\\t%0,<s2sv_blank>(%2)\\n"" ""2:\\tlwr\\t%0,<s2sv_blank>3(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tlwl\\t%0,<s2sv_blank>3(%2)\\n"" ""2:\\tlwr\\t%0,<s2sv_blank>(%2)\\n\\t"" # endif ""li\\t%1,<s2sv_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lhu_op : if ( ! access_ok ( verify_read , addr , 2 ) ) goto sigbus ; __asm__ __volatile__ ( "".set\\tnoat\\n"" # ifdef __big_endian ""1:\\tlbu\\t%0,<s2sv_blank>0(%2)\\n"" ""2:\\tlbu\\t$1,<s2sv_blank>1(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tlbu\\t%0,<s2sv_blank>1(%2)\\n"" ""2:\\tlbu\\t$1,<s2sv_blank>0(%2)\\n\\t"" # endif ""sll\\t%0,<s2sv_blank>0x8\\n\\t"" ""or\\t%0,<s2sv_blank>$1\\n\\t"" ""li\\t%1,<s2sv_blank>0\\n"" ""3:\\t.set\\tat\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; case lwu_op : # ifdef config_64bit if ( ! access_ok ( verify_read , addr , 4 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __big_endian ""1:\\tlwl\\t%0,<s2sv_blank>(%2)\\n"" ""2:\\tlwr\\t%0,<s2sv_blank>3(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tlwl\\t%0,<s2sv_blank>3(%2)\\n"" ""2:\\tlwr\\t%0,<s2sv_blank>(%2)\\n\\t"" # endif ""dsll\\t%0,<s2sv_blank>%0,<s2sv_blank>32\\n\\t"" ""dsrl\\t%0,<s2sv_blank>%0,<s2sv_blank>32\\n\\t"" ""li\\t%1,<s2sv_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case ld_op : # ifdef config_64bit if ( ! access_ok ( verify_read , addr , 8 ) ) goto sigbus ; __asm__ __volatile__ ( # ifdef __big_endian ""1:\\tldl\\t%0,<s2sv_blank>(%2)\\n"" ""2:\\tldr\\t%0,<s2sv_blank>7(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tldl\\t%0,<s2sv_blank>7(%2)\\n"" ""2:\\tldr\\t%0,<s2sv_blank>(%2)\\n\\t"" # endif ""li\\t%1,<s2sv_blank>0\\n"" ""3:\\t.section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%1,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=&r"" ( value ) , ""=r"" ( res ) : ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; regs -> regs [ insn . i_format . rt ] = value ; break ; # endif goto sigill ; case sh_op : if ( ! access_ok ( verify_write , addr , 2 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __big_endian "".set\\tnoat\\n"" ""1:\\tsb\\t%1,<s2sv_blank>1(%2)\\n\\t"" ""srl\\t$1,<s2sv_blank>%1,<s2sv_blank>0x8\\n"" ""2:\\tsb\\t$1,<s2sv_blank>0(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif # ifdef __little_endian "".set\\tnoat\\n"" ""1:\\tsb\\t%1,<s2sv_blank>0(%2)\\n\\t"" ""srl\\t$1,%1,<s2sv_blank>0x8\\n"" ""2:\\tsb\\t$1,<s2sv_blank>1(%2)\\n\\t"" "".set\\tat\\n\\t"" # endif ""li\\t%0,<s2sv_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sw_op : if ( ! access_ok ( verify_write , addr , 4 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __big_endian ""1:\\tswl\\t%1,(%2)\\n"" ""2:\\tswr\\t%1,<s2sv_blank>3(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tswl\\t%1,<s2sv_blank>3(%2)\\n"" ""2:\\tswr\\t%1,<s2sv_blank>(%2)\\n\\t"" # endif ""li\\t%0,<s2sv_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; case sd_op : # ifdef config_64bit if ( ! access_ok ( verify_write , addr , 8 ) ) goto sigbus ; value = regs -> regs [ insn . i_format . rt ] ; __asm__ __volatile__ ( # ifdef __big_endian ""1:\\tsdl\\t%1,(%2)\\n"" ""2:\\tsdr\\t%1,<s2sv_blank>7(%2)\\n\\t"" # endif # ifdef __little_endian ""1:\\tsdl\\t%1,<s2sv_blank>7(%2)\\n"" ""2:\\tsdr\\t%1,<s2sv_blank>(%2)\\n\\t"" # endif ""li\\t%0,<s2sv_blank>0\\n"" ""3:\\n\\t"" "".section\\t.fixup,\\""ax\\""\\n\\t"" ""4:\\tli\\t%0,<s2sv_blank>%3\\n\\t"" ""j\\t3b\\n\\t"" "".previous\\n\\t"" "".section\\t__ex_table,\\""a\\""\\n\\t"" str ( ptr ) ""\\t1b,<s2sv_blank>4b\\n\\t"" str ( ptr ) ""\\t2b,<s2sv_blank>4b\\n\\t"" "".previous"" : ""=r"" ( res ) : ""r"" ( value ) , ""r"" ( addr ) , ""i"" ( - efault ) ) ; if ( res ) goto fault ; compute_return_epc ( regs ) ; break ; # endif goto sigill ; case lwc1_op : case ldc1_op : case swc1_op : case sdc1_op : goto sigbus ; case lwc2_op : cu2_notifier_call_chain ( cu2_lwc2_op , regs ) ; break ; case ldc2_op : cu2_notifier_call_chain ( cu2_ldc2_op , regs ) ; break ; case swc2_op : cu2_notifier_call_chain ( cu2_swc2_op , regs ) ; break ; case sdc2_op : cu2_notifier_call_chain ( cu2_sdc2_op , regs ) ; break ; default : goto sigill ; } # ifdef config_debug_fs unaligned_instructions ++ ; # endif return ; fault : if ( fixup_exception ( regs ) ) return ; die_if_kernel ( ""unhandled<s2sv_blank>kernel<s2sv_blank>unaligned<s2sv_blank>access"" , regs ) ; force_sig ( sigsegv , current ) ; return ; sigbus : die_if_kernel ( ""unhandled<s2sv_blank>kernel<s2sv_blank>unaligned<s2sv_blank>access"" , regs ) ; force_sig ( sigbus , current ) ; return ; sigill : die_if_kernel ( ""unhandled<s2sv_blank>kernel<s2sv_blank>unaligned<s2sv_blank>access<s2sv_blank>or<s2sv_blank>invalid<s2sv_blank>instruction"" , regs ) ; force_sig ( sigill , current ) ; }","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
3892,CWE-200,"static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ xfrma_replay_esn_val ] ; if ( ( p -> flags & xfrm_state_esn ) && ! rt ) return - einval ; if ( ! rt ) return 0 ; if ( p -> id . proto != ipproto_esp ) return - einval ; if ( p -> replay_window != 0 ) return - einval ; return 0 ; }","<S2SV_ModStart> XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> ( p -> <S2SV_ModStart> & XFRM_STATE_ESN ) { if ( <S2SV_ModEnd> ! rt ) <S2SV_ModStart> - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; }
",torvalds@linux/ecd7918745234e423dd87fcc0c077da557909720,CVE-2012-6536,https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720,2013-03-15T20:55Z,<S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug>
6648,CWE-125,"void bit_write_mc ( bit_chain * dat , bitcode_mc val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; bitcode_umc mask = 0x0000007f ; bitcode_umc value = ( bitcode_umc ) val ; if ( val < 0 ) { negative = 1 ; value = ( bitcode_umc ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; if ( byte [ i ] & 0x40 ) i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_rc ( dat , byte [ j ] ) ; }","<S2SV_ModStart> ] & 0x40 && i > 0
",LibreDWG@libredwg/95cc9300430d35feb05b06a9badf678419463dbe,CVE-2019-20915,https://github.com/LibreDWG/libredwg/commit/95cc9300430d35feb05b06a9badf678419463dbe,2020-07-16T18:15Z,<S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug>
445,CWE-399,"int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = vfs_i ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = global_root_uid , iuid = global_root_uid ; kgid_t gid = global_root_gid , igid = global_root_gid ; struct xfs_dquot * udqp = null , * gdqp = null ; struct xfs_dquot * olddquot1 = null , * olddquot2 = null ; assert ( ( mask & attr_size ) == 0 ) ; if ( xfs_is_quota_on ( mp ) && ( mask & ( attr_uid | attr_gid ) ) ) { uint qflags = 0 ; if ( ( mask & attr_uid ) && xfs_is_uquota_on ( mp ) ) { uid = iattr -> ia_uid ; qflags |= xfs_qmopt_uquota ; } else { uid = inode -> i_uid ; } if ( ( mask & attr_gid ) && xfs_is_gquota_on ( mp ) ) { gid = iattr -> ia_gid ; qflags |= xfs_qmopt_gquota ; } else { gid = inode -> i_gid ; } assert ( udqp == null ) ; assert ( gdqp == null ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , null ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & m_res ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , xfs_ilock_excl ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & ( attr_uid | attr_gid ) ) { iuid = inode -> i_uid ; igid = inode -> i_gid ; gid = ( mask & attr_gid ) ? iattr -> ia_gid : igid ; uid = ( mask & attr_uid ) ? iattr -> ia_uid : iuid ; if ( xfs_is_quota_running ( mp ) && ( ( xfs_is_uquota_on ( mp ) && ! uid_eq ( iuid , uid ) ) || ( xfs_is_gquota_on ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { assert ( tp ) ; error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , null , capable ( cap_fowner ) ? xfs_qmopt_force_res : 0 ) ; if ( error ) goto out_cancel ; } } if ( mask & ( attr_uid | attr_gid ) ) { if ( ( inode -> i_mode & ( s_isuid | s_isgid ) ) && ! capable ( cap_fsetid ) ) inode -> i_mode &= ~ ( s_isuid | s_isgid ) ; if ( ! uid_eq ( iuid , uid ) ) { if ( xfs_is_quota_running ( mp ) && xfs_is_uquota_on ( mp ) ) { assert ( mask & attr_uid ) ; assert ( udqp ) ; olddquot1 = xfs_qm_vop_chown ( tp , ip , & ip -> i_udquot , udqp ) ; } ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; inode -> i_uid = uid ; } if ( ! gid_eq ( igid , gid ) ) { if ( xfs_is_quota_running ( mp ) && xfs_is_gquota_on ( mp ) ) { assert ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || ! xfs_is_pquota_on ( mp ) ) ; assert ( mask & attr_gid ) ; assert ( gdqp ) ; olddquot2 = xfs_qm_vop_chown ( tp , ip , & ip -> i_gdquot , gdqp ) ; } ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; inode -> i_gid = gid ; } } if ( mask & attr_mode ) xfs_setattr_mode ( ip , iattr ) ; if ( mask & ( attr_atime | attr_ctime | attr_mtime ) ) xfs_setattr_time ( ip , iattr ) ; xfs_trans_log_inode ( tp , ip , xfs_ilog_core ) ; xfs_stats_inc ( mp , xs_ig_attrchg ) ; if ( mp -> m_flags & xfs_mount_wsync ) xfs_trans_set_sync ( tp ) ; error = xfs_trans_commit ( tp ) ; xfs_iunlock ( ip , xfs_ilock_excl ) ; xfs_qm_dqrele ( olddquot1 ) ; xfs_qm_dqrele ( olddquot2 ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; if ( error ) return error ; if ( ( mask & attr_mode ) && ! ( flags & xfs_attr_noacl ) ) { error = posix_acl_chmod ( inode , inode -> i_mode ) ; if ( error ) return error ; } return 0 ; out_cancel : xfs_trans_cancel ( tp ) ; out_dqrele : xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; return error ; }","<S2SV_ModStart> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
",torvalds@linux/1fb254aa983bf190cfd685d40c64a480a9bafaee,CVE-2019-15538,https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee,2019-08-25T16:15Z,<S2SV_StartBug> out_dqrele : <S2SV_EndBug>
4294,CWE-362,int get_evtchn_to_irq ( evtchn_port_t evtchn ) { if ( evtchn >= xen_evtchn_max_channels ( ) ) return - 1 ; if ( evtchn_to_irq [ evtchn_row ( evtchn ) ] == null ) return - 1 ; return evtchn_to_irq [ evtchn_row ( evtchn ) ] [ evtchn_col ( evtchn ) ] ; },"<S2SV_ModStart> 1 ; return READ_ONCE ( <S2SV_ModStart> evtchn ) ] )
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z,<S2SV_StartBug> return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; <S2SV_EndBug>
7895,CWE-20,"error_t httpclientparseheaderfield ( httpclientcontext * context , char_t * line , size_t length ) { error_t error ; char_t * name ; size_t namelen ; char_t * value ; size_t valuelen ; char_t * separator ; line [ length ] = '\\0' ; trace_debug ( ""%s\\r\\n"" , line ) ; error = httpcheckcharset ( line , length , http_charset_text ) ; if ( error ) return error ; if ( line [ 0 ] == '<s2sv_blank>' || line [ 0 ] == '\\t' ) { if ( context -> bufferpos == 0 ) return error_invalid_syntax ; value = strtrimwhitespace ( line ) ; valuelen = osstrlen ( value ) ; if ( valuelen > 0 ) { context -> buffer [ context -> bufferpos - 1 ] = '<s2sv_blank>' ; osmemmove ( context -> buffer + context -> bufferpos , value , valuelen + 1 ) ; context -> bufferlen = context -> bufferpos + valuelen + 1 ; } } else { separator = strchr ( line , ':' ) ; if ( separator == null ) return error_invalid_syntax ; * separator = '\\0' ; name = strtrimwhitespace ( line ) ; value = strtrimwhitespace ( separator + 1 ) ; namelen = osstrlen ( name ) ; valuelen = osstrlen ( value ) ; if ( namelen == 0 ) return error_invalid_syntax ; if ( ! osstrcasecmp ( name , ""connection"" ) ) { httpclientparseconnectionfield ( context , value ) ; } else if ( ! osstrcasecmp ( name , ""transfer-encoding"" ) ) { httpclientparsetransferencodingfield ( context , value ) ; } else if ( ! osstrcasecmp ( name , ""content-length"" ) ) { httpclientparsecontentlengthfield ( context , value ) ; } # if ( http_client_auth_support == enabled ) else if ( ! osstrcasecmp ( name , ""www-authenticate"" ) ) { httpclientparsewwwauthenticatefield ( context , value ) ; } # endif else { } osmemmove ( context -> buffer + context -> bufferpos , name , namelen + 1 ) ; osmemmove ( context -> buffer + context -> bufferpos + namelen + 1 , value , valuelen + 1 ) ; context -> bufferlen = context -> bufferpos + namelen + valuelen + 2 ; } context -> bufferpos = context -> bufferlen ; return no_error ; }","<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( line ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug>"
600,CWE-772,"struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + page_size - 1 ) >> page_shift ; unsigned long start = uaddr >> page_shift ; if ( end < start ) return err_ptr ( - einval ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return err_ptr ( - einval ) ; } if ( ! nr_pages ) return err_ptr ( - einval ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return err_ptr ( - enomem ) ; ret = - enomem ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + page_size - 1 ) >> page_shift ; unsigned long start = uaddr >> page_shift ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & write ) != write , & pages [ cur_page ] ) ; if ( ret < local_nr_pages ) { ret = - efault ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = page_size - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; if ( len <= 0 ) break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; len -= bytes ; offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , bio_user_mapped ) ; bio_get ( bio ) ; return bio ; out_unmap : for ( j = 0 ; j < nr_pages ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return err_ptr ( ret ) ; }","<S2SV_ModStart> struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - <S2SV_ModStart> ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; }
",torvalds@linux/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058,CVE-2017-12190,https://github.com/torvalds/linux/commit/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058,2017-11-22T18:29Z,<S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug>
3466,CWE-399,"int cms_verify ( cms_contentinfo * cms , stack_of ( x509 ) * certs , x509_store * store , bio * dcont , bio * out , unsigned int flags ) { cms_signerinfo * si ; stack_of ( cms_signerinfo ) * sinfos ; stack_of ( x509 ) * cms_certs = null ; stack_of ( x509_crl ) * crls = null ; x509 * signer ; int i , scount = 0 , ret = 0 ; bio * cmsbio = null , * tmpin = null ; if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = cms_get0_signerinfos ( cms ) ; if ( sk_cms_signerinfo_num ( sinfos ) <= 0 ) { cmserr ( cms_f_cms_verify , cms_r_no_signers ) ; goto err ; } for ( i = 0 ; i < sk_cms_signerinfo_num ( sinfos ) ; i ++ ) { si = sk_cms_signerinfo_value ( sinfos , i ) ; cms_signerinfo_get0_algs ( si , null , & signer , null , null ) ; if ( signer ) scount ++ ; } if ( scount != sk_cms_signerinfo_num ( sinfos ) ) scount += cms_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_cms_signerinfo_num ( sinfos ) ) { cmserr ( cms_f_cms_verify , cms_r_signer_certificate_not_found ) ; goto err ; } if ( ! ( flags & cms_no_signer_cert_verify ) ) { cms_certs = cms_get1_certs ( cms ) ; if ( ! ( flags & cms_nocrl ) ) crls = cms_get1_crls ( cms ) ; for ( i = 0 ; i < sk_cms_signerinfo_num ( sinfos ) ; i ++ ) { si = sk_cms_signerinfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & cms_no_attr_verify ) ) { for ( i = 0 ; i < sk_cms_signerinfo_num ( sinfos ) ; i ++ ) { si = sk_cms_signerinfo_value ( sinfos , i ) ; if ( cms_signed_get_attr_count ( si ) < 0 ) continue ; if ( cms_signerinfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( bio_method_type ( dcont ) == bio_type_mem ) ) { char * ptr ; long len ; len = bio_get_mem_data ( dcont , & ptr ) ; tmpin = bio_new_mem_buf ( ptr , len ) ; if ( tmpin == null ) { cmserr ( cms_f_cms_verify , err_r_malloc_failure ) ; return 0 ; } } else tmpin = dcont ; cmsbio = cms_datainit ( cms , tmpin ) ; if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) ) goto err ; if ( ! ( flags & cms_no_content_verify ) ) { for ( i = 0 ; i < sk_cms_signerinfo_num ( sinfos ) ; i ++ ) { si = sk_cms_signerinfo_value ( sinfos , i ) ; if ( cms_signerinfo_verify_content ( si , cmsbio ) <= 0 ) { cmserr ( cms_f_cms_verify , cms_r_content_verify_error ) ; goto err ; } } } ret = 1 ; err : if ( dcont && ( tmpin == dcont ) ) do_free_upto ( cmsbio , dcont ) ; else bio_free_all ( cmsbio ) ; if ( cms_certs ) sk_x509_pop_free ( cms_certs , x509_free ) ; if ( crls ) sk_x509_crl_pop_free ( crls , x509_crl_free ) ; return ret ; }","<S2SV_ModStart> , * tmpin = NULL , * tmpout <S2SV_ModStart> = dcont ; if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> ( cms , tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> goto err ; } <S2SV_ModStart> : if ( ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> cmsbio ) ; } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;
",openssl@openssl/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,CVE-2015-1792,https://github.com/openssl/openssl/commit/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,2015-06-12T19:59Z,"<S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug>"
2901,CWE-310,"static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , i_mutex_parent ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = ptr_err ( dentry ) ; if ( is_err ( dentry ) ) goto out_unlock ; error = - eexist ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ; down_read ( & btrfs_i ( dir ) -> root -> fs_info -> subvol_sem ) ; if ( btrfs_root_refs ( & btrfs_i ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( btrfs_i ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & btrfs_i ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }","<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
",torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z,<S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug>
5189,CWE-772,"static image * readartimage ( const imageinfo * image_info , exceptioninfo * exception ) { const unsigned char * pixels ; image * image ; quantuminfo * quantum_info ; magickbooleantype status ; size_t length ; ssize_t count , y ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; if ( image_info -> debug != magickfalse ) ( void ) logmagickevent ( traceevent , getmagickmodule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } image -> depth = 1 ; image -> endian = msbendian ; ( void ) readbloblsbshort ( image ) ; image -> columns = ( size_t ) readbloblsbshort ( image ) ; ( void ) readbloblsbshort ( image ) ; image -> rows = ( size_t ) readbloblsbshort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; if ( image_info -> ping != magickfalse ) { ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; } status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; setimagecolorspace ( image , graycolorspace , exception ) ; quantum_info = acquirequantuminfo ( image_info , image ) ; if ( quantum_info == ( quantuminfo * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; length = getquantumextent ( image , quantum_info , grayquantum ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register quantum * magick_restrict q ; q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; pixels = ( const unsigned char * ) readblobstream ( image , length , getquantumpixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) throwreaderexception ( corruptimageerror , ""unabletoreadimagedata"" ) ; ( void ) importquantumpixels ( image , ( cacheview * ) null , quantum_info , grayquantum , pixels , exception ) ; pixels = ( const unsigned char * ) readblobstream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , getquantumpixels ( quantum_info ) , & count ) ; if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; if ( setimageprogress ( image , loadimagetag , y , image -> rows ) == magickfalse ) break ; } setquantumimagetype ( image , grayquantum ) ; quantum_info = destroyquantuminfo ( quantum_info ) ; if ( eofblob ( image ) != magickfalse ) throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; }","<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; }
",ImageMagick@ImageMagick/3b0fe05cddd8910f84e51b4d50099702ea45ba4a,CVE-2017-9143,https://github.com/ImageMagick/ImageMagick/commit/3b0fe05cddd8910f84e51b4d50099702ea45ba4a,2017-05-22T14:29Z,"<S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug>"
508,CWE-125,"int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : null ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( ip6cb ( skb ) -> frag_max_size ) { if ( ip6cb ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = ip6cb ( skb ) -> frag_max_size ; if ( mtu < ipv6_min_mtu ) mtu = ipv6_min_mtu ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == checksum_partial && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = ll_reserved_space ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; bug_on ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = nexthdr_fragment ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , gfp_atomic ) ; if ( ! tmp_hdr ) { ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; err = - enomem ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( ip6_mf ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = checksum_none ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( ip6_mf ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) ip6_inc_stats ( net , ip6_dst_idev ( & rt -> dst ) , ipstats_mib_fragcreates ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = null ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { ip6_inc_stats ( net , ip6_dst_idev ( & rt -> dst ) , ipstats_mib_fragoks ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; ip6_inc_stats ( net , ip6_dst_idev ( & rt -> dst ) , ipstats_mib_fragfails ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = null ; frag2 -> destructor = null ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , gfp_atomic ) ; if ( ! frag ) { ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; err = - enomem ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = nexthdr_fragment ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; bug_on ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( ip6_mf ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragcreates ) ; } ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragoks ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , netif_f_gso_mask ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , icmpv6_pkt_toobig , 0 , mtu ) ; err = - emsgsize ; fail : ip6_inc_stats ( net , ip6_dst_idev ( skb_dst ( skb ) ) , ipstats_mib_fragfails ) ; kfree_skb ( skb ) ; return err ; }","<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,"<S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug>"
3015,CWE-399,"static int cop1emulate ( struct pt_regs * xcp , struct mips_fpu_struct * ctx , void * __user * fault_addr ) { mips_instruction ir ; unsigned long emulpc , contpc ; unsigned int cond ; if ( ! access_ok ( verify_read , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return sigbus ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return sigsegv ; } if ( ( xcp -> cp0_cause & causef_bd ) && ! isbranchinstr ( & ir ) ) xcp -> cp0_cause &= ~ causef_bd ; if ( xcp -> cp0_cause & causef_bd ) { emulpc = xcp -> cp0_epc + 4 ; if ( __compute_return_epc ( xcp ) ) { # ifdef cp1dbg printk ( ""failed<s2sv_blank>to<s2sv_blank>emulate<s2sv_blank>branch<s2sv_blank>at<s2sv_blank>%p\\n"" , ( void * ) ( xcp -> cp0_epc ) ) ; # endif return sigill ; } if ( ! access_ok ( verify_read , emulpc , sizeof ( mips_instruction ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return sigbus ; } if ( __get_user ( ir , ( mips_instruction __user * ) emulpc ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = ( mips_instruction __user * ) emulpc ; return sigsegv ; } contpc = xcp -> cp0_epc ; xcp -> cp0_epc = emulpc - 4 ; } else { emulpc = xcp -> cp0_epc ; contpc = xcp -> cp0_epc + 4 ; } emul : perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , xcp , 0 ) ; mips_fpu_emu_inc_stats ( emulated ) ; switch ( mipsinst_opcode ( ir ) ) { case ldc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ mipsinst_rs ( ir ) ] + mipsinst_simm ( ir ) ) ; u64 val ; mips_fpu_emu_inc_stats ( loads ) ; if ( ! access_ok ( verify_read , va , sizeof ( u64 ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigbus ; } if ( __get_user ( val , va ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigsegv ; } ditoreg ( val , mipsinst_rt ( ir ) ) ; break ; } case sdc1_op : { u64 __user * va = ( u64 __user * ) ( xcp -> regs [ mipsinst_rs ( ir ) ] + mipsinst_simm ( ir ) ) ; u64 val ; mips_fpu_emu_inc_stats ( stores ) ; difromreg ( val , mipsinst_rt ( ir ) ) ; if ( ! access_ok ( verify_write , va , sizeof ( u64 ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigbus ; } if ( __put_user ( val , va ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigsegv ; } break ; } case lwc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ mipsinst_rs ( ir ) ] + mipsinst_simm ( ir ) ) ; u32 val ; mips_fpu_emu_inc_stats ( loads ) ; if ( ! access_ok ( verify_read , va , sizeof ( u32 ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigbus ; } if ( __get_user ( val , va ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigsegv ; } sitoreg ( val , mipsinst_rt ( ir ) ) ; break ; } case swc1_op : { u32 __user * va = ( u32 __user * ) ( xcp -> regs [ mipsinst_rs ( ir ) ] + mipsinst_simm ( ir ) ) ; u32 val ; mips_fpu_emu_inc_stats ( stores ) ; sifromreg ( val , mipsinst_rt ( ir ) ) ; if ( ! access_ok ( verify_write , va , sizeof ( u32 ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigbus ; } if ( __put_user ( val , va ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = va ; return sigsegv ; } break ; } case cop1_op : switch ( mipsinst_rs ( ir ) ) { # if defined ( __mips64 ) case dmfc_op : if ( mipsinst_rt ( ir ) != 0 ) { difromreg ( xcp -> regs [ mipsinst_rt ( ir ) ] , mipsinst_rd ( ir ) ) ; } break ; case dmtc_op : ditoreg ( xcp -> regs [ mipsinst_rt ( ir ) ] , mipsinst_rd ( ir ) ) ; break ; # endif case mfc_op : if ( mipsinst_rt ( ir ) != 0 ) { sifromreg ( xcp -> regs [ mipsinst_rt ( ir ) ] , mipsinst_rd ( ir ) ) ; } break ; case mtc_op : sitoreg ( xcp -> regs [ mipsinst_rt ( ir ) ] , mipsinst_rd ( ir ) ) ; break ; case cfc_op : { u32 value ; if ( mipsinst_rd ( ir ) == fpcreg_csr ) { value = ctx -> fcr31 ; value = ( value & ~ fpu_csr_rm ) | mips_rm [ modeindex ( value ) ] ; # ifdef csrtrace printk ( ""%p<s2sv_blank>gpr[%d]<-csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , mipsinst_rt ( ir ) , value ) ; # endif } else if ( mipsinst_rd ( ir ) == fpcreg_rid ) value = 0 ; else value = 0 ; if ( mipsinst_rt ( ir ) ) xcp -> regs [ mipsinst_rt ( ir ) ] = value ; break ; } case ctc_op : { u32 value ; if ( mipsinst_rt ( ir ) == 0 ) value = 0 ; else value = xcp -> regs [ mipsinst_rt ( ir ) ] ; if ( mipsinst_rd ( ir ) == fpcreg_csr ) { # ifdef csrtrace printk ( ""%p<s2sv_blank>gpr[%d]->csr=%08x\\n"" , ( void * ) ( xcp -> cp0_epc ) , mipsinst_rt ( ir ) , value ) ; # endif ctx -> fcr31 = ( value & ~ ( fpu_csr_rsvd | fpu_csr_rm ) ) | ieee_rm [ modeindex ( value ) ] ; } if ( ( ctx -> fcr31 >> 5 ) & ctx -> fcr31 & fpu_csr_all_e ) { return sigfpe ; } break ; } case bc_op : { int likely = 0 ; if ( xcp -> cp0_cause & causef_bd ) return sigill ; # if __mips >= 4 cond = ctx -> fcr31 & fpucondbit [ mipsinst_rt ( ir ) >> 2 ] ; # else cond = ctx -> fcr31 & fpu_csr_cond ; # endif switch ( mipsinst_rt ( ir ) & 3 ) { case bcfl_op : likely = 1 ; case bcf_op : cond = ! cond ; break ; case bctl_op : likely = 1 ; case bct_op : break ; default : return sigill ; } xcp -> cp0_cause |= causef_bd ; if ( cond ) { xcp -> cp0_epc += 4 ; contpc = ( xcp -> cp0_epc + ( mipsinst_simm ( ir ) << 2 ) ) ; if ( ! access_ok ( verify_read , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return sigbus ; } if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { mips_fpu_emu_inc_stats ( errors ) ; * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; return sigsegv ; } switch ( mipsinst_opcode ( ir ) ) { case lwc1_op : case swc1_op : # if ( __mips >= 2 || defined ( __mips64 ) ) case ldc1_op : case sdc1_op : # endif case cop1_op : # if __mips >= 4 && __mips != 32 case cop1x_op : # endif goto emul ; # if __mips >= 4 case spec_op : if ( mipsinst_func ( ir ) == movc_op ) goto emul ; break ; # endif } return mips_dsemul ( xcp , ir , contpc ) ; } else { if ( likely ) { xcp -> cp0_epc += 4 ; contpc += 4 ; } } break ; } default : if ( ! ( mipsinst_rs ( ir ) & 0x10 ) ) return sigill ; { int sig ; if ( ( sig = fpu_emu ( xcp , ctx , ir ) ) ) return sig ; } } break ; # if __mips >= 4 && __mips != 32 case cop1x_op : { int sig = fpux_emu ( xcp , ctx , ir , fault_addr ) ; if ( sig ) return sig ; break ; } # endif # if __mips >= 4 case spec_op : if ( mipsinst_func ( ir ) != movc_op ) return sigill ; cond = fpucondbit [ mipsinst_rt ( ir ) >> 2 ] ; if ( ( ( ctx -> fcr31 & cond ) != 0 ) == ( ( mipsinst_rt ( ir ) & 1 ) != 0 ) ) xcp -> regs [ mipsinst_rd ( ir ) ] = xcp -> regs [ mipsinst_rs ( ir ) ] ; break ; # endif default : return sigill ; } xcp -> cp0_epc = contpc ; xcp -> cp0_cause &= ~ causef_bd ; return 0 ; }","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug>"
2929,CWE-119,"static int complete_emulated_mmio ( struct kvm_vcpu * vcpu ) { struct kvm_run * run = vcpu -> run ; struct kvm_mmio_fragment * frag ; unsigned len ; bug_on ( ! vcpu -> mmio_needed ) ; frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ; len = min ( 8u , frag -> len ) ; if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ; if ( frag -> len <= 8 ) { frag ++ ; vcpu -> mmio_cur_fragment ++ ; } else { frag -> data += len ; frag -> gpa += len ; frag -> len -= len ; } if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { vcpu -> mmio_needed = 0 ; if ( vcpu -> mmio_is_write ) return 1 ; vcpu -> mmio_read_completed = 1 ; return complete_emulated_io ( vcpu ) ; } run -> exit_reason = kvm_exit_mmio ; run -> mmio . phys_addr = frag -> gpa ; if ( vcpu -> mmio_is_write ) memcpy ( run -> mmio . data , frag -> data , min ( 8u , frag -> len ) ) ; run -> mmio . len = min ( 8u , frag -> len ) ; run -> mmio . is_write = vcpu -> mmio_is_write ; vcpu -> arch . complete_userspace_io = complete_emulated_mmio ; return 0 ; }","<S2SV_ModStart> vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
",torvalds@linux/a08d3b3b99efd509133946056531cdf8f3a0c09b,CVE-2014-0049,https://github.com/torvalds/linux/commit/a08d3b3b99efd509133946056531cdf8f3a0c09b,2014-03-11T13:01Z,<S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug>
6893,CWE-119,void lzxd_free ( struct lzxd_stream * lzx ) { struct mspack_system * sys ; if ( lzx ) { sys = lzx -> sys ; sys -> free ( lzx -> inbuf ) ; sys -> free ( lzx -> window ) ; sys -> free ( lzx ) ; } },"<S2SV_ModStart> -> sys ; if ( lzx -> inbuf ) <S2SV_ModStart> inbuf ) ; if ( lzx -> window )
",vrtadmin@clamav-devel/a83773682e856ad6529ba6db8d1792e6d515d7f1,CVE-2017-6419,https://github.com/vrtadmin/clamav-devel/commit/a83773682e856ad6529ba6db8d1792e6d515d7f1,2017-08-07T03:29Z,<S2SV_StartBug> sys -> free ( lzx -> inbuf ) ; <S2SV_EndBug>
3528,CWE-264,"static int load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; }","<S2SV_ModStart> cpl , false , NULL
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <S2SV_EndBug>"
3418,CWE-200,"static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == bt_connect2 && test_bit ( bt_sk_defer_setup , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = bt_config ; release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }","<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;
",torvalds@linux/c8c499175f7d295ef867335bceb9a76a2c3cdc38,CVE-2013-3226,https://github.com/torvalds/linux/commit/c8c499175f7d295ef867335bceb9a76a2c3cdc38,2013-04-22T11:41Z,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug>
7444,CWE-125,"static void l2tp_avp_print ( netdissect_options * ndo , const u_char * dat , int length ) { u_int len ; const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t attr_type ; int hidden = false ; if ( length <= 0 ) { return ; } nd_print ( ( ndo , ""<s2sv_blank>"" ) ) ; nd_tcheck ( * ptr ) ; len = extract_16bits ( ptr ) & l2tp_avp_hdr_len_mask ; if ( len < 6 ) goto trunc ; if ( len > ( u_int ) length ) goto trunc ; nd_tcheck2 ( * ptr , len ) ; if ( extract_16bits ( ptr ) & l2tp_avp_hdr_flag_mandatory ) { nd_print ( ( ndo , ""*"" ) ) ; } if ( extract_16bits ( ptr ) & l2tp_avp_hdr_flag_hidden ) { hidden = true ; nd_print ( ( ndo , ""?"" ) ) ; } ptr ++ ; if ( extract_16bits ( ptr ) ) { nd_print ( ( ndo , ""vendor%04x:"" , extract_16bits ( ptr ) ) ) ; ptr ++ ; nd_print ( ( ndo , ""attr%04x"" , extract_16bits ( ptr ) ) ) ; ptr ++ ; nd_print ( ( ndo , ""("" ) ) ; print_octets ( ndo , ( const u_char * ) ptr , len - 6 ) ; nd_print ( ( ndo , "")"" ) ) ; } else { ptr ++ ; attr_type = extract_16bits ( ptr ) ; ptr ++ ; nd_print ( ( ndo , ""%s"" , tok2str ( l2tp_avp2str , ""avp-#%u"" , attr_type ) ) ) ; nd_print ( ( ndo , ""("" ) ) ; if ( hidden ) { nd_print ( ( ndo , ""???"" ) ) ; } else { switch ( attr_type ) { case l2tp_avp_msgtype : l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_result_code : l2tp_result_code_print ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case l2tp_avp_proto_ver : l2tp_proto_ver_print ( ndo , ptr ) ; break ; case l2tp_avp_framing_cap : l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_bearer_cap : l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_tie_breaker : print_octets ( ndo , ( const u_char * ) ptr , 8 ) ; break ; case l2tp_avp_firm_ver : case l2tp_avp_assnd_tun_id : case l2tp_avp_recv_win_size : case l2tp_avp_assnd_sess_id : print_16bits_val ( ndo , ptr ) ; break ; case l2tp_avp_host_name : case l2tp_avp_vendor_name : case l2tp_avp_calling_number : case l2tp_avp_called_number : case l2tp_avp_sub_address : case l2tp_avp_proxy_auth_name : case l2tp_avp_private_grp_id : print_string ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case l2tp_avp_challenge : case l2tp_avp_ini_recv_lcp : case l2tp_avp_last_sent_lcp : case l2tp_avp_last_recv_lcp : case l2tp_avp_proxy_auth_chal : case l2tp_avp_proxy_auth_resp : case l2tp_avp_random_vector : print_octets ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case l2tp_avp_q931_cc : l2tp_q931_cc_print ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; case l2tp_avp_challenge_resp : print_octets ( ndo , ( const u_char * ) ptr , 16 ) ; break ; case l2tp_avp_call_ser_num : case l2tp_avp_minimum_bps : case l2tp_avp_maximum_bps : case l2tp_avp_tx_conn_speed : case l2tp_avp_phy_channel_id : case l2tp_avp_rx_conn_speed : print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ; break ; case l2tp_avp_bearer_type : l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_framing_type : l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_packet_proc_delay : l2tp_packet_proc_delay_print ( ndo ) ; break ; case l2tp_avp_proxy_auth_type : l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_proxy_auth_id : l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_call_errors : l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_accm : l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ; break ; case l2tp_avp_seq_required : break ; case l2tp_avp_ppp_discon_cc : l2tp_ppp_discon_cc_print ( ndo , ( const u_char * ) ptr , len - 6 ) ; break ; default : break ; } } nd_print ( ( ndo , "")"" ) ) ; } l2tp_avp_print ( ndo , dat + len , length - len ) ; return ; trunc : nd_print ( ( ndo , ""|..."" ) ) ; }","<S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> ndo , ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> case L2TP_AVP_TIE_BREAKER : if ( len - 6 < 8 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_ASSND_SESS_ID : if ( len - 6 < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_CHALLENGE_RESP : if ( len - 6 < 16 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_RX_CONN_SPEED : if ( len - 6 < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,"<S2SV_StartBug> l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proto_ver_print ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> print_16bits_val ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug>"
6062,CWE-000,"static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) { ext4_io_end_t * io = null ; io = kmalloc ( sizeof ( * io ) , gfp_nofs ) ; if ( io ) { igrab ( inode ) ; io -> inode = inode ; io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; io -> error = 0 ; init_work ( & io -> work , ext4_end_io_work ) ; init_list_head ( & io -> list ) ; } return io ; }","<S2SV_ModStart> inode * inode , gfp_t flags <S2SV_ModStart> io ) , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; io -> page = NULL <S2SV_ModEnd> ; INIT_WORK (
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,"<S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug>"
1262,CWE-264,"static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == null ) { netdev_warn ( frad , ""memory<s2sv_blank>squeeze<s2sv_blank>on<s2sv_blank>fr_add_pvc()\\n"" ) ; return - enobufs ; } if ( * get_dev_p ( pvc , type ) ) return - eexist ; used = pvc_is_used ( pvc ) ; if ( type == arphrd_ether ) dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ; else dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""memory<s2sv_blank>squeeze<s2sv_blank>on<s2sv_blank>fr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - enobufs ; } if ( type == arphrd_ether ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = hdlc_max_mtu ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - eio ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }","<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,<S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug>
7646,CWE-611,"void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , null ) ; # ifdef debug_conf ap_log_perror ( aplog_mark , aplog_startup | aplog_noerrno , 0 , mp , ""merge<s2sv_blank>parent<s2sv_blank>%pp<s2sv_blank>child<s2sv_blank>%pp<s2sv_blank>result<s2sv_blank>%pp"" , _parent , _child , merged ) ; # endif if ( merged == null ) return null ; merged -> is_enabled = ( child -> is_enabled == not_set ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == not_set ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == not_set ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == not_set ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == not_set ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == not_set ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == not_set ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == not_set ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == not_set ? parent -> if_limit_action : child -> if_limit_action ) ; merged -> of_limit_action = ( child -> of_limit_action == not_set ? parent -> of_limit_action : child -> of_limit_action ) ; merged -> reqintercept_oe = ( child -> reqintercept_oe == not_set ? parent -> reqintercept_oe : child -> reqintercept_oe ) ; if ( child -> of_mime_types != not_set_p ) { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = 1 ; } else { if ( parent -> of_mime_types == not_set_p ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = not_set ; } else { merged -> of_mime_types = apr_table_overlay ( mp , parent -> of_mime_types , child -> of_mime_types ) ; if ( merged -> of_mime_types == null ) return null ; } } } else { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types_cleared = 1 ; } else { merged -> of_mime_types = parent -> of_mime_types ; merged -> of_mime_types_cleared = parent -> of_mime_types_cleared ; } } if ( child -> debuglog_fd == not_set_p ) { merged -> debuglog_name = parent -> debuglog_name ; merged -> debuglog_fd = parent -> debuglog_fd ; } else { merged -> debuglog_name = child -> debuglog_name ; merged -> debuglog_fd = child -> debuglog_fd ; } merged -> debuglog_level = ( child -> debuglog_level == not_set ? parent -> debuglog_level : child -> debuglog_level ) ; merged -> cookie_format = ( child -> cookie_format == not_set ? parent -> cookie_format : child -> cookie_format ) ; merged -> argument_separator = ( child -> argument_separator == not_set ? parent -> argument_separator : child -> argument_separator ) ; merged -> cookiev0_separator = ( child -> cookiev0_separator == not_set_p ? parent -> cookiev0_separator : child -> cookiev0_separator ) ; if ( ( child -> rule_inheritance == not_set ) || ( child -> rule_inheritance == 1 ) ) { merged -> rule_inheritance = parent -> rule_inheritance ; if ( ( child -> ruleset == null ) && ( parent -> ruleset == null ) ) { # ifdef debug_conf ap_log_perror ( aplog_mark , aplog_startup | aplog_noerrno , 0 , mp , ""no<s2sv_blank>rules<s2sv_blank>in<s2sv_blank>this<s2sv_blank>context."" ) ; # endif } else if ( child -> ruleset == null ) { # ifdef debug_conf ap_log_perror ( aplog_mark , aplog_startup | aplog_noerrno , 0 , mp , ""using<s2sv_blank>parent<s2sv_blank>rules<s2sv_blank>in<s2sv_blank>this<s2sv_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; } else if ( parent -> ruleset == null ) { # ifdef debug_conf ap_log_perror ( aplog_mark , aplog_startup | aplog_noerrno , 0 , mp , ""using<s2sv_blank>child<s2sv_blank>rules<s2sv_blank>in<s2sv_blank>this<s2sv_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } else { # ifdef debug_conf ap_log_perror ( aplog_mark , aplog_startup | aplog_noerrno , 0 , mp , ""using<s2sv_blank>parent<s2sv_blank>then<s2sv_blank>child<s2sv_blank>rules<s2sv_blank>in<s2sv_blank>this<s2sv_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; apr_array_cat ( merged -> ruleset -> phase_request_headers , child -> ruleset -> phase_request_headers ) ; apr_array_cat ( merged -> ruleset -> phase_request_body , child -> ruleset -> phase_request_body ) ; apr_array_cat ( merged -> ruleset -> phase_response_headers , child -> ruleset -> phase_response_headers ) ; apr_array_cat ( merged -> ruleset -> phase_response_body , child -> ruleset -> phase_response_body ) ; apr_array_cat ( merged -> ruleset -> phase_logging , child -> ruleset -> phase_logging ) ; } } else { merged -> rule_inheritance = 0 ; if ( child -> ruleset != null ) { merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } } merged -> rule_exceptions = apr_array_append ( mp , parent -> rule_exceptions , child -> rule_exceptions ) ; merged -> hash_method = apr_array_append ( mp , parent -> hash_method , child -> hash_method ) ; merged -> auditlog_flag = ( child -> auditlog_flag == not_set ? parent -> auditlog_flag : child -> auditlog_flag ) ; merged -> auditlog_type = ( child -> auditlog_type == not_set ? parent -> auditlog_type : child -> auditlog_type ) ; merged -> max_rule_time = ( child -> max_rule_time == not_set ? parent -> max_rule_time : child -> max_rule_time ) ; merged -> auditlog_dirperms = ( child -> auditlog_dirperms == not_set ? parent -> auditlog_dirperms : child -> auditlog_dirperms ) ; merged -> auditlog_fileperms = ( child -> auditlog_fileperms == not_set ? parent -> auditlog_fileperms : child -> auditlog_fileperms ) ; if ( child -> auditlog_fd != not_set_p ) { merged -> auditlog_fd = child -> auditlog_fd ; merged -> auditlog_name = child -> auditlog_name ; } else { merged -> auditlog_fd = parent -> auditlog_fd ; merged -> auditlog_name = parent -> auditlog_name ; } if ( child -> auditlog2_fd != not_set_p ) { merged -> auditlog2_fd = child -> auditlog2_fd ; merged -> auditlog2_name = child -> auditlog2_name ; } else { merged -> auditlog2_fd = parent -> auditlog2_fd ; merged -> auditlog2_name = parent -> auditlog2_name ; } merged -> auditlog_storage_dir = ( child -> auditlog_storage_dir == not_set_p ? parent -> auditlog_storage_dir : child -> auditlog_storage_dir ) ; merged -> auditlog_parts = ( child -> auditlog_parts == not_set_p ? parent -> auditlog_parts : child -> auditlog_parts ) ; merged -> auditlog_relevant_regex = ( child -> auditlog_relevant_regex == not_set_p ? parent -> auditlog_relevant_regex : child -> auditlog_relevant_regex ) ; merged -> tmp_dir = ( child -> tmp_dir == not_set_p ? parent -> tmp_dir : child -> tmp_dir ) ; merged -> upload_dir = ( child -> upload_dir == not_set_p ? parent -> upload_dir : child -> upload_dir ) ; merged -> upload_keep_files = ( child -> upload_keep_files == not_set ? parent -> upload_keep_files : child -> upload_keep_files ) ; merged -> upload_validates_files = ( child -> upload_validates_files == not_set ? parent -> upload_validates_files : child -> upload_validates_files ) ; merged -> upload_filemode = ( child -> upload_filemode == not_set ? parent -> upload_filemode : child -> upload_filemode ) ; merged -> upload_file_limit = ( child -> upload_file_limit == not_set ? parent -> upload_file_limit : child -> upload_file_limit ) ; merged -> data_dir = ( child -> data_dir == not_set_p ? parent -> data_dir : child -> data_dir ) ; merged -> webappid = ( child -> webappid == not_set_p ? parent -> webappid : child -> webappid ) ; merged -> sensor_id = ( child -> sensor_id == not_set_p ? parent -> sensor_id : child -> sensor_id ) ; merged -> httpblkey = ( child -> httpblkey == not_set_p ? parent -> httpblkey : child -> httpblkey ) ; merged -> content_injection_enabled = ( child -> content_injection_enabled == not_set ? parent -> content_injection_enabled : child -> content_injection_enabled ) ; merged -> stream_inbody_inspection = ( child -> stream_inbody_inspection == not_set ? parent -> stream_inbody_inspection : child -> stream_inbody_inspection ) ; merged -> stream_outbody_inspection = ( child -> stream_outbody_inspection == not_set ? parent -> stream_outbody_inspection : child -> stream_outbody_inspection ) ; merged -> geo = ( child -> geo == not_set_p ? parent -> geo : child -> geo ) ; merged -> gsb = ( child -> gsb == not_set_p ? parent -> gsb : child -> gsb ) ; merged -> u_map = ( child -> u_map == not_set_p ? parent -> u_map : child -> u_map ) ; merged -> cache_trans = ( child -> cache_trans == not_set ? parent -> cache_trans : child -> cache_trans ) ; merged -> cache_trans_incremental = ( child -> cache_trans_incremental == not_set ? parent -> cache_trans_incremental : child -> cache_trans_incremental ) ; merged -> cache_trans_min = ( child -> cache_trans_min == ( apr_size_t ) not_set ? parent -> cache_trans_min : child -> cache_trans_min ) ; merged -> cache_trans_max = ( child -> cache_trans_max == ( apr_size_t ) not_set ? parent -> cache_trans_max : child -> cache_trans_max ) ; merged -> cache_trans_maxitems = ( child -> cache_trans_maxitems == ( apr_size_t ) not_set ? parent -> cache_trans_maxitems : child -> cache_trans_maxitems ) ; merged -> component_signatures = apr_array_append ( mp , parent -> component_signatures , child -> component_signatures ) ; merged -> request_encoding = ( child -> request_encoding == not_set_p ? parent -> request_encoding : child -> request_encoding ) ; merged -> disable_backend_compression = ( child -> disable_backend_compression == not_set ? parent -> disable_backend_compression : child -> disable_backend_compression ) ; merged -> col_timeout = ( child -> col_timeout == not_set ? parent -> col_timeout : child -> col_timeout ) ; merged -> crypto_key = ( child -> crypto_key == not_set_p ? parent -> crypto_key : child -> crypto_key ) ; merged -> crypto_key_len = ( child -> crypto_key_len == not_set ? parent -> crypto_key_len : child -> crypto_key_len ) ; merged -> crypto_key_add = ( child -> crypto_key_add == not_set ? parent -> crypto_key_add : child -> crypto_key_add ) ; merged -> crypto_param_name = ( child -> crypto_param_name == not_set_p ? parent -> crypto_param_name : child -> crypto_param_name ) ; merged -> hash_is_enabled = ( child -> hash_is_enabled == not_set ? parent -> hash_is_enabled : child -> hash_is_enabled ) ; merged -> hash_enforcement = ( child -> hash_enforcement == not_set ? parent -> hash_enforcement : child -> hash_enforcement ) ; merged -> crypto_hash_href_rx = ( child -> crypto_hash_href_rx == not_set ? parent -> crypto_hash_href_rx : child -> crypto_hash_href_rx ) ; merged -> crypto_hash_faction_rx = ( child -> crypto_hash_faction_rx == not_set ? parent -> crypto_hash_faction_rx : child -> crypto_hash_faction_rx ) ; merged -> crypto_hash_location_rx = ( child -> crypto_hash_location_rx == not_set ? parent -> crypto_hash_location_rx : child -> crypto_hash_location_rx ) ; merged -> crypto_hash_iframesrc_rx = ( child -> crypto_hash_iframesrc_rx == not_set ? parent -> crypto_hash_iframesrc_rx : child -> crypto_hash_iframesrc_rx ) ; merged -> crypto_hash_framesrc_rx = ( child -> crypto_hash_framesrc_rx == not_set ? parent -> crypto_hash_framesrc_rx : child -> crypto_hash_framesrc_rx ) ; merged -> crypto_hash_href_pm = ( child -> crypto_hash_href_pm == not_set ? parent -> crypto_hash_href_pm : child -> crypto_hash_href_pm ) ; merged -> crypto_hash_faction_pm = ( child -> crypto_hash_faction_pm == not_set ? parent -> crypto_hash_faction_pm : child -> crypto_hash_faction_pm ) ; merged -> crypto_hash_location_pm = ( child -> crypto_hash_location_pm == not_set ? parent -> crypto_hash_location_pm : child -> crypto_hash_location_pm ) ; merged -> crypto_hash_iframesrc_pm = ( child -> crypto_hash_iframesrc_pm == not_set ? parent -> crypto_hash_iframesrc_pm : child -> crypto_hash_iframesrc_pm ) ; merged -> crypto_hash_framesrc_pm = ( child -> crypto_hash_framesrc_pm == not_set ? parent -> crypto_hash_framesrc_pm : child -> crypto_hash_framesrc_pm ) ; return merged ; }","<S2SV_ModStart> crypto_hash_framesrc_pm ) ; merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;
",SpiderLabs@ModSecurity/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,CVE-2013-1915,https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,2013-04-25T23:55Z,<S2SV_StartBug> return merged ; <S2SV_EndBug>
5601,CWE-674,"static krb5_error_code split_der ( asn1buf * buf , uint8_t * const * der , size_t len , taginfo * tag_out ) { krb5_error_code ret ; const uint8_t * contents , * remainder ; size_t clen , rlen ; ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ; if ( ret ) return ret ; if ( rlen != 0 ) return asn1_bad_length ; insert_bytes ( buf , contents , clen ) ; return 0 ; }","<S2SV_ModStart> , & rlen , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z,"<S2SV_StartBug> ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ; <S2SV_EndBug>"
5615,CWE-125,"void messageaddargument ( message * m , const char * arg ) { int offset ; char * p ; assert ( m != null ) ; if ( arg == null ) return ; while ( isspace ( * arg ) ) arg ++ ; if ( * arg == '\\0' ) return ; cli_dbgmsg ( ""messageaddargument,<s2sv_blank>arg=\'%s\'\\n"" , arg ) ; if ( ! usefularg ( arg ) ) return ; for ( offset = 0 ; offset < m -> numberofarguments ; offset ++ ) if ( m -> mimearguments [ offset ] == null ) break ; else if ( strcasecmp ( arg , m -> mimearguments [ offset ] ) == 0 ) return ; if ( offset == m -> numberofarguments ) { char * * q ; m -> numberofarguments ++ ; q = ( char * * ) cli_realloc ( m -> mimearguments , m -> numberofarguments * sizeof ( char * ) ) ; if ( q == null ) { m -> numberofarguments -- ; return ; } m -> mimearguments = q ; } p = m -> mimearguments [ offset ] = rfc2231 ( arg ) ; if ( ! p ) { cli_dbgmsg ( ""messageaddargument,<s2sv_blank>error<s2sv_blank>from<s2sv_blank>rfc2231()\\n"" ) ; return ; } if ( strchr ( p , '=' ) == null ) { if ( strncmp ( p , ""filename"" , 8 ) == 0 ) { cli_dbgmsg ( ""possible<s2sv_blank>data<s2sv_blank>corruption<s2sv_blank>fixed\\n"" ) ; p [ 8 ] = '=' ; } else { if ( * p ) cli_dbgmsg ( ""messageaddargument,<s2sv_blank>\'%s\'<s2sv_blank>contains<s2sv_blank>no<s2sv_blank>\'=\'\\n"" , p ) ; free ( m -> mimearguments [ offset ] ) ; m -> mimearguments [ offset ] = null ; return ; } } if ( ( strncasecmp ( p , ""filename="" , 9 ) == 0 ) || ( strncasecmp ( p , ""name="" , 5 ) == 0 ) ) if ( messagegetmimetype ( m ) == nomime ) { cli_dbgmsg ( ""force<s2sv_blank>mime<s2sv_blank>encoding<s2sv_blank>to<s2sv_blank>application\\n"" ) ; messagesetmimetype ( m , ""application"" ) ; } }","<S2SV_ModStart> 0 ) { if ( strlen ( p ) > 8 ) { <S2SV_ModStart> } else { cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\n"" ) ; } } else {
",vrtadmin@clamav-devel/586a5180287262070637c8943f2f7efd652e4a2c,CVE-2017-6418,https://github.com/vrtadmin/clamav-devel/commit/586a5180287262070637c8943f2f7efd652e4a2c,2017-08-07T03:29Z,"<S2SV_StartBug> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * p ) <S2SV_EndBug>"
3595,CWE-476,"int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = f2fs_raw_super ( sbi ) ; struct f2fs_checkpoint * ckpt = f2fs_ckpt ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , gfp_kernel ) ; if ( ! sm_info ) return - enomem ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * def_reclaim_prefree_segments / 100 ; if ( sm_info -> rec_prefree_segments > def_max_reclaim_prefree_segments ) sm_info -> rec_prefree_segments = def_max_reclaim_prefree_segments ; if ( ! test_opt ( sbi , lfs ) ) sm_info -> ipu_policy = 1 << f2fs_ipu_fsync ; sm_info -> min_ipu_util = def_min_ipu_util ; sm_info -> min_fsync_blocks = def_min_fsync_blocks ; sm_info -> min_hot_blocks = def_min_hot_blocks ; sm_info -> trim_sections = def_batched_trim_sections ; init_list_head ( & sm_info -> sit_entry_set ) ; if ( test_opt ( sbi , flush_merge ) && ! f2fs_readonly ( sbi -> sb ) ) { err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return err ; err = build_sit_info ( sbi ) ; if ( err ) return err ; err = build_free_segmap ( sbi ) ; if ( err ) return err ; err = build_curseg ( sbi ) ; if ( err ) return err ; build_sit_entries ( sbi ) ; init_free_segmap ( sbi ) ; err = build_dirty_segmap ( sbi ) ; if ( err ) return err ; init_min_max_mtime ( sbi ) ; return 0 ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
",torvalds@linux/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,CVE-2017-18241,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,2018-03-21T16:29Z,"<S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug>"
4111,CWE-416,static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; put_device ( & dev -> dev ) ; return 0 ; },"<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
",torvalds@linux/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,CVE-2017-16528,https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,2017-11-04T01:29Z,<S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug>
3023,CWE-399,"static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , regs , address ) ; destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( verify_read , ( unsigned long ) address , 1ul << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = null ; regs -> sr |= sr_fd ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( config_cpu_little_endian ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( ""unexpected<s2sv_blank>width_shift<s2sv_blank>%d<s2sv_blank>in<s2sv_blank>misaligned_fpu_load,<s2sv_blank>pc=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( ""misaligned<s2sv_blank>fpu<s2sv_blank>load<s2sv_blank>inside<s2sv_blank>kernel"" , regs , 0 ) ; return - 1 ; } }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug>"
4467,CWE-125,"static void youngcollection ( lua_state * l , global_state * g ) { gcobject * * psurvival ; lua_assert ( g -> gcstate == gcspropagate ) ; markold ( g , g -> survival , g -> reallyold ) ; markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( l ) ; psurvival = sweepgen ( l , g , & g -> allgc , g -> survival ) ; sweepgen ( l , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( l , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( l , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( l , g , & g -> tobefnz , null ) ; finishgencycle ( l , g ) ; }","<S2SV_ModStart> , g -> allgc <S2SV_ModEnd> , g ->
",lua@lua/127e7a6c8942b362aa3c6627f44d660a4fb75312,CVE-2020-15889,https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312,2020-07-21T22:15Z,"<S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug>"
6525,CWE-119,"cjson * cjson_createintarray ( int64_t * numbers , int count ) { int i ; cjson * n = 0 , * p = 0 , * a = cjson_createarray ( ) ; for ( i = 0 ; a && i < count ; ++ i ) { n = cjson_createint ( numbers [ i ] ) ; if ( ! i ) a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }","<S2SV_ModStart> * cJSON_CreateIntArray ( const int <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,"<S2SV_StartBug> cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateInt ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug>"
2628,CWE-000,"static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; struct sk_buff * skb ; skb = nlmsg_new ( nlmsg_default_size , gfp_atomic ) ; if ( ! skb ) return err_ptr ( - enomem ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; if ( dump_one_state ( x , 0 , & info ) ) { kfree_skb ( skb ) ; return null ; } return skb ; }","<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
",torvalds@linux/864745d291b5ba80ea0bd0edcbe67273de368836,CVE-2013-1826,https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836,2013-03-22T11:59Z,"<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug>"
900,CWE-200,"void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; }","<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
",torvalds@linux/4116def2337991b39919f3b448326e21c40e0dbb,CVE-2016-5244,https://github.com/torvalds/linux/commit/4116def2337991b39919f3b448326e21c40e0dbb,2016-06-27T10:59Z,"<S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug>"
4648,CWE-190,"static int mongo_cursor_get_more ( mongo_cursor * cursor ) { int res ; if ( cursor -> limit > 0 && cursor -> seen >= cursor -> limit ) { cursor -> err = mongo_cursor_exhausted ; return mongo_error ; } else if ( ! cursor -> reply ) { cursor -> err = mongo_cursor_invalid ; return mongo_error ; } else if ( ! cursor -> reply -> fields . cursorid ) { cursor -> err = mongo_cursor_exhausted ; return mongo_error ; } else { char * data ; int sl = strlen ( cursor -> ns ) + 1 ; int limit = 0 ; mongo_message * mm ; if ( cursor -> limit > 0 ) limit = cursor -> limit - cursor -> seen ; mm = mongo_message_create ( 16 + 4 + sl + 4 + 8 , 0 , 0 , mongo_op_get_more ) ; data = & mm -> data ; data = mongo_data_append32 ( data , & zero ) ; data = mongo_data_append ( data , cursor -> ns , sl ) ; data = mongo_data_append32 ( data , & limit ) ; mongo_data_append64 ( data , & cursor -> reply -> fields . cursorid ) ; bson_free ( cursor -> reply ) ; res = mongo_message_send ( cursor -> conn , mm ) ; if ( res != mongo_ok ) { mongo_cursor_destroy ( cursor ) ; return mongo_error ; } res = mongo_read_response ( cursor -> conn , & ( cursor -> reply ) ) ; if ( res != mongo_ok ) { mongo_cursor_destroy ( cursor ) ; return mongo_error ; } cursor -> current . data = null ; cursor -> seen += cursor -> reply -> fields . num ; return mongo_ok ; } }","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> sl = strlen
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,<S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug>
2863,CWE-000,"asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) { console_verbose ( ) ; pr_crit ( ""bad<s2sv_blank>mode<s2sv_blank>in<s2sv_blank>%s<s2sv_blank>handler<s2sv_blank>detected,<s2sv_blank>code<s2sv_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; die ( ""oops<s2sv_blank>-<s2sv_blank>bad<s2sv_blank>mode"" , regs , 0 ) ; local_irq_disable ( ) ; panic ( ""bad<s2sv_blank>mode"" ) ; }","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
",torvalds@linux/9955ac47f4ba1c95ecb6092aeaefb40a22e99268,CVE-2013-4220,https://github.com/torvalds/linux/commit/9955ac47f4ba1c95ecb6092aeaefb40a22e99268,2013-08-25T03:27Z,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug>"
3956,CWE-17,"static ssize_t pipe_write ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t ppos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; ssize_t ret ; int do_wakeup ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; ssize_t chars ; total_len = iov_length ( iov , nr_segs ) ; if ( unlikely ( total_len == 0 ) ) return 0 ; do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; if ( ! pipe -> readers ) { send_sig ( sigpipe , current , 0 ) ; ret = - epipe ; goto out ; } chars = total_len & ( page_size - 1 ) ; if ( pipe -> nrbufs && chars != 0 ) { int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + lastbuf ; const struct pipe_buf_operations * ops = buf -> ops ; int offset = buf -> offset + buf -> len ; if ( ops -> can_merge && offset + chars <= page_size ) { int error , atomic = 1 ; void * addr ; error = ops -> confirm ( pipe , buf ) ; if ( error ) goto out ; iov_fault_in_pages_read ( iov , chars ) ; redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; ret = error ; do_wakeup = 1 ; if ( error ) { if ( atomic ) { atomic = 0 ; goto redo1 ; } goto out ; } buf -> len += chars ; total_len -= chars ; ret = chars ; if ( ! total_len ) goto out ; } } for ( ; ; ) { int bufs ; if ( ! pipe -> readers ) { send_sig ( sigpipe , current , 0 ) ; if ( ! ret ) ret = - epipe ; break ; } bufs = pipe -> nrbufs ; if ( bufs < pipe -> buffers ) { int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + newbuf ; struct page * page = pipe -> tmp_page ; char * src ; int error , atomic = 1 ; if ( ! page ) { page = alloc_page ( gfp_highuser ) ; if ( unlikely ( ! page ) ) { ret = ret ? : - enomem ; break ; } pipe -> tmp_page = page ; } do_wakeup = 1 ; chars = page_size ; if ( chars > total_len ) chars = total_len ; iov_fault_in_pages_read ( iov , chars ) ; redo2 : if ( atomic ) src = kmap_atomic ( page ) ; else src = kmap ( page ) ; error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( src ) ; else kunmap ( page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo2 ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> page = page ; buf -> ops = & anon_pipe_buf_ops ; buf -> offset = 0 ; buf -> len = chars ; buf -> flags = 0 ; if ( is_packetized ( filp ) ) { buf -> ops = & packet_pipe_buf_ops ; buf -> flags = pipe_buf_flag_packet ; } pipe -> nrbufs = ++ bufs ; pipe -> tmp_page = null ; total_len -= chars ; if ( ! total_len ) break ; } if ( bufs < pipe -> buffers ) continue ; if ( filp -> f_flags & o_nonblock ) { if ( ! ret ) ret = - eagain ; break ; } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - erestartsys ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , pollin | pollrdnorm ) ; kill_fasync ( & pipe -> fasync_readers , sigio , poll_in ) ; do_wakeup = 0 ; } pipe -> waiting_writers ++ ; pipe_wait ( pipe ) ; pipe -> waiting_writers -- ; } out : __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , pollin | pollrdnorm ) ; kill_fasync ( & pipe -> fasync_readers , sigio , poll_in ) ; } if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { int err = file_update_time ( filp ) ; if ( err ) ret = err ; sb_end_write ( file_inode ( filp ) -> i_sb ) ; } return ret ; }","<S2SV_ModStart> * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;
",torvalds@linux/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,CVE-2015-1805,https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045,2015-08-08T10:59Z,"<S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> <S2SV_StartBug> char * src ; <S2SV_EndBug> <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> <S2SV_StartBug> ret += chars ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug>"
5706,CWE-269,"void virtio_config_writeb ( virtiodevice * vdev , uint32_t addr , uint32_t data ) { virtiodeviceclass * k = virtio_device_get_class ( vdev ) ; uint8_t val = data ; if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ; stb_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }","<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stb_p ( vdev
",qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d,CVE-2013-2016,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,2019-12-30T22:15Z,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug>
4293,CWE-362,"evtchn_port_t evtchn_from_irq ( unsigned irq ) { if ( warn ( irq >= nr_irqs , ""invalid<s2sv_blank>irq<s2sv_blank>%d!\\n"" , irq ) ) return 0 ; return info_for_irq ( irq ) -> evtchn ; }","<S2SV_ModStart> irq ) { const struct irq_info * info = NULL ; if ( likely ( irq < nr_irqs ) ) info = info_for_irq ( irq ) ; if ( ! info <S2SV_ModEnd> ) return 0 <S2SV_ModStart> 0 ; return info <S2SV_ModEnd> -> evtchn ;
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z,"<S2SV_StartBug> if ( WARN ( irq >= nr_irqs , ""Invalid<S2SV_blank>irq<S2SV_blank>%d!\\n"" , irq ) ) <S2SV_EndBug> <S2SV_StartBug> return info_for_irq ( irq ) -> evtchn ; <S2SV_EndBug>"
3467,CWE-399,"static int cms_copy_content ( bio * out , bio * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ; bio * tmpout = null ; if ( out == null ) tmpout = bio_new ( bio_s_null ( ) ) ; else if ( flags & cms_text ) { tmpout = bio_new ( bio_s_mem ( ) ) ; bio_set_mem_eof_return ( tmpout , 0 ) ; } else tmpout = out ; if ( ! tmpout ) { cmserr ( cms_f_cms_copy_content , err_r_malloc_failure ) ; goto err ; } for ( ; ; ) { i = bio_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( bio_method_type ( in ) == bio_type_cipher ) { if ( ! bio_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( bio_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & cms_text ) { if ( ! smime_text ( tmpout , out ) ) { cmserr ( cms_f_cms_copy_content , cms_r_smime_text_error ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) bio_free ( tmpout ) ; return r ; }","<S2SV_ModStart> BIO * tmpout ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> if ( flags <S2SV_ModStart> CMS_TEXT ) { <S2SV_ModEnd> if ( !
",openssl@openssl/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,CVE-2015-1792,https://github.com/openssl/openssl/commit/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,2015-06-12T19:59Z,<S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug>
4523,CWE-125,"pyobject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; pyobject * result = null , * value = null ; if ( ! o ) { py_incref ( py_none ) ; return py_none ; } result = pytype_genericnew ( alias_type , null , null ) ; if ( ! result ) return null ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_name , value ) == - 1 ) goto failed ; py_decref ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _pyobject_setattrid ( result , & pyid_asname , value ) == - 1 ) goto failed ; py_decref ( value ) ; return result ; failed : py_xdecref ( value ) ; py_xdecref ( result ) ; return null ; }","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug>
5196,CWE-476,"void gf_isom_cenc_get_default_info_internal ( gf_trackbox * trak , u32 sampledescriptionindex , u32 * container_type , bool * default_isencrypted , u8 * crypt_byte_block , u8 * skip_byte_block , const u8 * * key_info , u32 * key_info_size ) { gf_protectionschemeinfobox * sinf ; if ( default_isencrypted ) * default_isencrypted = gf_false ; if ( crypt_byte_block ) * crypt_byte_block = 0 ; if ( skip_byte_block ) * skip_byte_block = 0 ; if ( container_type ) * container_type = 0 ; if ( key_info ) * key_info = null ; if ( key_info_size ) * key_info_size = 0 ; sinf = isom_get_sinf_entry ( trak , sampledescriptionindex , gf_isom_cenc_scheme , null ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampledescriptionindex , gf_isom_cbc_scheme , null ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampledescriptionindex , gf_isom_cens_scheme , null ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampledescriptionindex , gf_isom_cbcs_scheme , null ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampledescriptionindex , gf_isom_piff_scheme , null ) ; if ( ! sinf ) { u32 i , nb_stsd = gf_list_count ( trak -> media -> information -> sampletable -> sampledescription -> child_boxes ) ; for ( i = 0 ; i < nb_stsd ; i ++ ) { gf_protectionschemeinfobox * a_sinf ; gf_sampleentrybox * sentry = null ; if ( i + 1 == sampledescriptionindex ) continue ; sentry = gf_list_get ( trak -> media -> information -> sampletable -> sampledescription -> child_boxes , i ) ; a_sinf = ( gf_protectionschemeinfobox * ) gf_isom_box_find_child ( sentry -> child_boxes , gf_isom_box_type_sinf ) ; if ( ! a_sinf ) continue ; return ; } } if ( sinf && sinf -> info && sinf -> info -> tenc ) { if ( default_isencrypted ) * default_isencrypted = sinf -> info -> tenc -> isprotected ; if ( crypt_byte_block ) * crypt_byte_block = sinf -> info -> tenc -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = sinf -> info -> tenc -> skip_byte_block ; if ( key_info ) * key_info = sinf -> info -> tenc -> key_info ; if ( key_info_size ) { * key_info_size = 20 ; if ( ! sinf -> info -> tenc -> key_info [ 3 ] ) * key_info_size += 1 + sinf -> info -> tenc -> key_info [ 20 ] ; } if ( container_type ) * container_type = gf_isom_box_type_senc ; } else if ( sinf && sinf -> info && sinf -> info -> piff_tenc ) { if ( default_isencrypted ) * default_isencrypted = gf_true ; if ( key_info ) * key_info = sinf -> info -> piff_tenc -> key_info ; if ( key_info_size ) * key_info_size = 19 ; if ( container_type ) * container_type = gf_isom_box_uuid_psec ; } else { u32 i , count = 0 ; gf_cencsampleencryptiongroupentry * seig_entry = null ; if ( ! trak -> moov -> mov -> is_smooth ) count = gf_list_count ( trak -> media -> information -> sampletable -> samplegroupsdescription ) ; for ( i = 0 ; i < count ; i ++ ) { gf_samplegroupdescriptionbox * sgdesc = ( gf_samplegroupdescriptionbox * ) gf_list_get ( trak -> media -> information -> sampletable -> samplegroupsdescription , i ) ; if ( sgdesc -> grouping_type != gf_isom_sample_group_seig ) continue ; if ( sgdesc -> default_description_index ) seig_entry = gf_list_get ( sgdesc -> group_descriptions , sgdesc -> default_description_index - 1 ) ; else seig_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; if ( ! seig_entry -> key_info [ 0 ] ) seig_entry = null ; break ; } if ( seig_entry ) { if ( default_isencrypted ) * default_isencrypted = seig_entry -> isprotected ; if ( crypt_byte_block ) * crypt_byte_block = seig_entry -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = seig_entry -> skip_byte_block ; if ( key_info ) * key_info = seig_entry -> key_info ; if ( key_info_size ) * key_info_size = seig_entry -> key_info_size ; if ( container_type ) * container_type = gf_isom_box_type_senc ; } else { if ( ! trak -> moov -> mov -> is_smooth ) { trak -> moov -> mov -> is_smooth = gf_true ; gf_log ( gf_log_warning , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>senc<s2sv_blank>box<s2sv_blank>without<s2sv_blank>tenc,<s2sv_blank>assuming<s2sv_blank>ms<s2sv_blank>smooth+piff\\n"" ) ) ; } if ( default_isencrypted ) * default_isencrypted = gf_true ; if ( container_type ) * container_type = gf_isom_box_uuid_psec ; } } if ( container_type && trak -> sample_encryption ) { if ( trak -> sample_encryption -> type == gf_isom_box_type_senc ) * container_type = gf_isom_box_type_senc ; else if ( trak -> sample_encryption -> type == gf_isom_box_type_uuid ) * container_type = ( ( gf_uuidbox * ) trak -> sample_encryption ) -> internal_4cc ; } }","<S2SV_ModStart> ; if ( seig_entry &&
",gpac@gpac/3b84ffcbacf144ce35650df958432f472b6483f8,CVE-2021-31259,https://github.com/gpac/gpac/commit/3b84ffcbacf144ce35650df958432f472b6483f8,2021-04-19T19:15Z,<S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug>
8248,CWE-787,"static inline int l2cap_connect_rsp ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u8 * data ) { struct l2cap_conn_rsp * rsp = ( struct l2cap_conn_rsp * ) data ; u16 scid , dcid , result , status ; struct sock * sk ; u8 req [ 128 ] ; scid = __le16_to_cpu ( rsp -> scid ) ; dcid = __le16_to_cpu ( rsp -> dcid ) ; result = __le16_to_cpu ( rsp -> result ) ; status = __le16_to_cpu ( rsp -> status ) ; bt_dbg ( ""dcid<s2sv_blank>0x%4.4x<s2sv_blank>scid<s2sv_blank>0x%4.4x<s2sv_blank>result<s2sv_blank>0x%2.2x<s2sv_blank>status<s2sv_blank>0x%2.2x"" , dcid , scid , result , status ) ; if ( scid ) { sk = l2cap_get_chan_by_scid ( & conn -> chan_list , scid ) ; if ( ! sk ) return 0 ; } else { sk = l2cap_get_chan_by_ident ( & conn -> chan_list , cmd -> ident ) ; if ( ! sk ) return 0 ; } switch ( result ) { case l2cap_cr_success : sk -> sk_state = bt_config ; l2cap_pi ( sk ) -> ident = 0 ; l2cap_pi ( sk ) -> dcid = dcid ; l2cap_pi ( sk ) -> conf_state |= l2cap_conf_req_sent ; l2cap_pi ( sk ) -> conf_state &= ~ l2cap_conf_connect_pend ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , l2cap_conf_req , l2cap_build_conf_req ( sk , req ) , req ) ; break ; case l2cap_cr_pend : l2cap_pi ( sk ) -> conf_state |= l2cap_conf_connect_pend ; break ; default : l2cap_chan_del ( sk , econnrefused ) ; break ; } bh_unlock_sock ( sk ) ; return 0 ; }","<S2SV_ModStart> req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,<S2SV_StartBug> break ; <S2SV_EndBug>
7900,CWE-20,"error_t httpreadrequestheader ( httpconnection * connection ) { error_t error ; size_t length ; error = socketsettimeout ( connection -> socket , http_server_idle_timeout ) ; if ( error ) return error ; error = httpreceive ( connection , connection -> buffer , http_server_buffer_size - 1 , & length , socket_flag_break_crlf ) ; if ( error ) return error ; error = socketsettimeout ( connection -> socket , http_server_timeout ) ; if ( error ) return error ; connection -> buffer [ length ] = '\\0' ; trace_info ( ""%s"" , connection -> buffer ) ; error = httpparserequestline ( connection , connection -> buffer ) ; if ( error ) return error ; connection -> request . chunkedencoding = false ; connection -> request . contentlength = 0 ; # if ( http_server_web_socket_support == enabled ) connection -> request . upgradewebsocket = false ; connection -> request . connectionupgrade = false ; osstrcpy ( connection -> request . clientkey , """" ) ; # endif if ( connection -> request . version >= http_version_1_0 ) { char_t firstchar ; char_t * separator ; char_t * name ; char_t * value ; firstchar = '\\0' ; while ( 1 ) { error = httpreadheaderfield ( connection , connection -> buffer , http_server_buffer_size , & firstchar ) ; if ( error ) return error ; trace_debug ( ""%s"" , connection -> buffer ) ; if ( ! osstrcmp ( connection -> buffer , ""\\r\\n"" ) ) break ; separator = strchr ( connection -> buffer , ':' ) ; if ( separator != null ) { * separator = '\\0' ; name = strtrimwhitespace ( connection -> buffer ) ; value = strtrimwhitespace ( separator + 1 ) ; httpparseheaderfield ( connection , name , value ) ; } } } if ( connection -> request . chunkedencoding ) { connection -> request . bytecount = 0 ; connection -> request . firstchunk = true ; connection -> request . lastchunk = false ; } else { connection -> request . bytecount = connection -> request . contentlength ; } return no_error ; }","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,"<S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug>"
4938,CWE-617,void pci_lintr_deassert ( struct pci_vdev * dev ) { assert ( dev -> lintr . pin > 0 ) ; pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == asserted ) { dev -> lintr . state = idle ; pci_irq_deassert ( dev ) ; } else if ( dev -> lintr . state == pending ) dev -> lintr . state = idle ; pthread_mutex_unlock ( & dev -> lintr . lock ) ; },"<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,<S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug>
2263,CWE-20,"static int do_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags , pte_t orig_pte ) { pgoff_t pgoff = ( ( ( address & page_mask ) - vma -> vm_start ) >> page_shift ) + vma -> vm_pgoff ; pte_unmap ( page_table ) ; if ( ! ( flags & fault_flag_write ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; if ( ! ( vma -> vm_flags & vm_shared ) ) return do_cow_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; return do_shared_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; }","<S2SV_ModStart> ( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z,<S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug>
6110,CWE-203,"int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) { at91_aes_key_size_t key_size ; unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ at91_aes_iv_size_word ] ; unsigned int computed_cmac [ at91_aes_block_size_word ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; init_keys ( & key_size , cipher_key , cmac_key , iv ) ; at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; if ( memcmp ( cmac , computed_cmac , at91_aes_block_size_byte ) ) goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }","<S2SV_ModStart> ; if ( ! consttime_memequal <S2SV_ModEnd> ( cmac ,
",linux4sam@at91bootstrap/7753914c9a622c245f3a3cf2af5e24b6a9904213,CVE-2020-11683,https://github.com/linux4sam/at91bootstrap/commit/7753914c9a622c245f3a3cf2af5e24b6a9904213,2020-09-14T14:15Z,"<S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug>"
3322,CWE-399,"static int ceph_x_decrypt ( struct ceph_crypto_key * secret , void * * p , void * end , void * obuf , size_t olen ) { struct ceph_x_encrypt_header head ; size_t head_len = sizeof ( head ) ; int len , ret ; len = ceph_decode_32 ( p ) ; if ( * p + len > end ) return - einval ; dout ( ""ceph_x_decrypt<s2sv_blank>len<s2sv_blank>%d\\n"" , len ) ; ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , * p , len ) ; if ( ret ) return ret ; if ( head . struct_v != 1 || le64_to_cpu ( head . magic ) != cephx_enc_magic ) return - eperm ; * p += len ; return olen ; }","<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6418,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z,"<S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug>"
5198,CWE-284,"static my_bool get_one_option ( int optid , const struct my_option * opt , char * argument ) { my_bool add_option = true ; switch ( optid ) { case '?' : printf ( ""%s<s2sv_blank><s2sv_blank>ver<s2sv_blank>%s<s2sv_blank>distrib<s2sv_blank>%s,<s2sv_blank>for<s2sv_blank>%s<s2sv_blank>(%s)\\n"" , my_progname , ver , mysql_server_version , system_type , machine_type ) ; puts ( oracle_welcome_copyright_notice ( ""2000"" ) ) ; puts ( ""mysql<s2sv_blank>utility<s2sv_blank>for<s2sv_blank>upgrading<s2sv_blank>databases<s2sv_blank>to<s2sv_blank>new<s2sv_blank>mysql<s2sv_blank>versions.\\n"" ) ; my_print_help ( my_long_options ) ; exit ( 0 ) ; break ; case '#' : dbug_push ( argument ? argument : default_dbug_option ) ; add_option = false ; debug_check_flag = 1 ; break ; case 'p' : if ( argument == disabled_my_option ) argument = ( char * ) """" ; tty_password = 1 ; add_option = false ; if ( argument ) { add_one_option ( & ds_args , opt , argument ) ; while ( * argument ) * argument ++ = 'x' ; tty_password = 0 ; } break ; case 't' : my_stpnmov ( opt_tmpdir , argument , sizeof ( opt_tmpdir ) ) ; add_option = false ; break ; case 'k' : case 'v' : case 'f' : case 's' : case opt_write_binlog : add_option = false ; break ; case 'h' : case 'w' : case 'p' : case 's' : case opt_mysql_protocol : case opt_shared_memory_base_name : case opt_plugin_dir : case opt_default_auth : add_one_option ( & conn_args , opt , argument ) ; break ; } if ( add_option ) { add_one_option ( & ds_args , opt , argument ) ; } return 0 ; }","<S2SV_ModStart> ; break ; # include < sslopt - case . h >
",mysql@mysql-server/3bd5589e1a5a93f9c224badf983cd65c45215390,CVE-2015-3152,https://github.com/mysql/mysql-server/commit/3bd5589e1a5a93f9c224badf983cd65c45215390,2016-05-16T10:59Z,<S2SV_StartBug> case 'h' : <S2SV_EndBug>
8041,CWE-347,"void pointzz_pmul ( pointzz_p * rop , const pointzz_p * point , const mpz_t scalar , const curvezz_p * curve ) { pointzz_p r0 , r1 , tmp ; mpz_inits ( r1 . x , r1 . y , tmp . x , tmp . y , null ) ; mpz_init_set ( r0 . x , point -> x ) ; mpz_init_set ( r0 . y , point -> y ) ; pointzz_pdouble ( & r1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , r0 . x ) ; mpz_set ( tmp . y , r0 . y ) ; pointzz_padd ( & r0 , & r1 , & tmp , curve ) ; mpz_set ( tmp . x , r1 . x ) ; mpz_set ( tmp . y , r1 . y ) ; pointzz_pdouble ( & r1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , r1 . x ) ; mpz_set ( tmp . y , r1 . y ) ; pointzz_padd ( & r1 , & r0 , & tmp , curve ) ; mpz_set ( tmp . x , r0 . x ) ; mpz_set ( tmp . y , r0 . y ) ; pointzz_pdouble ( & r0 , & tmp , curve ) ; } } mpz_init_set ( rop -> x , r0 . x ) ; mpz_init_set ( rop -> y , r0 . y ) ; mpz_clears ( r0 . x , r0 . y , r1 . x , r1 . y , tmp . x , tmp . y , null ) ; }","<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
",AntonKueltz@fastecdsa/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,CVE-2020-12607,https://github.com/AntonKueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,2020-06-02T21:15Z,"<S2SV_StartBug> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <S2SV_EndBug>"
2459,CWE-404,"static int cp2112_gpio_get_all ( struct gpio_chip * chip ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; unsigned long flags ; int ret ; spin_lock_irqsave ( & dev -> lock , flags ) ; ret = hid_hw_raw_request ( hdev , cp2112_gpio_get , buf , cp2112_gpio_get_length , hid_feature_report , hid_req_get_report ) ; if ( ret != cp2112_gpio_get_length ) { hid_err ( hdev , ""error<s2sv_blank>requesting<s2sv_blank>gpio<s2sv_blank>values:<s2sv_blank>%d\\n"" , ret ) ; ret = ret < 0 ? ret : - eio ; goto exit ; } ret = buf [ 1 ] ; exit : spin_unlock_irqrestore ( & dev -> lock , flags ) ; return ret ; }","<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
",torvalds@linux/7a7b5df84b6b4e5d599c7289526eed96541a0654,CVE-2017-8071,https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654,2017-04-23T05:59Z,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug>"
7168,CWE-552,"static ssize_t _consolefs_read ( oe_fd_t * file_ , void * buf , size_t count ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( file_ ) ; if ( ! file ) oe_raise_errno ( oe_einval ) ; if ( oe_syscall_read_ocall ( & ret , file -> host_fd , buf , count ) != oe_ok ) oe_raise_errno ( oe_einval ) ; done : return ret ; }","<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>
3405,CWE-404,"int nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) { struct svc_export * exp = * expp , * exp2 = null ; struct dentry * dentry = * dpp ; struct path path = { . mnt = mntget ( exp -> ex_path . mnt ) , . dentry = dget ( dentry ) } ; int err = 0 ; err = follow_down ( & path ) ; if ( err < 0 ) goto out ; exp2 = rqst_exp_get_by_name ( rqstp , & path ) ; if ( is_err ( exp2 ) ) { err = ptr_err ( exp2 ) ; if ( err == - enoent && ! ( exp -> ex_flags & nfsexp_v4root ) ) err = 0 ; path_put ( & path ) ; goto out ; } if ( nfsd_v4client ( rqstp ) || ( exp -> ex_flags & nfsexp_crossmount ) || ex_nohide ( exp2 ) ) { * dpp = path . dentry ; path . dentry = dentry ; * expp = exp2 ; exp2 = exp ; } path_put ( & path ) ; exp_put ( exp2 ) ; out : return err ; }","<S2SV_ModStart> goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,<S2SV_StartBug> goto out ; <S2SV_EndBug>
2930,CWE-416,"int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = null ; struct iov_iter i ; int ret ; if ( map_data ) copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , bio_user_mapped ) ) rq -> cmd_flags |= req_copy_user ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; rq -> bio = null ; return - einval ; }","<S2SV_ModStart> ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> bio ) ; fail :
",torvalds@linux/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,CVE-2016-9576,https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,2016-12-28T07:59Z,<S2SV_StartBug> if ( map_data ) <S2SV_EndBug> <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug>
2745,CWE-119,void pid_ns_release_proc ( struct pid_namespace * ns ) { mntput ( ns -> proc_mnt ) ; },"<S2SV_ModStart> ns ) { kern_unmount <S2SV_ModEnd> ( ns ->
",torvalds@linux/905ad269c55fc62bee3da29f7b1d1efeba8aa1e1,CVE-2012-2127,https://github.com/torvalds/linux/commit/905ad269c55fc62bee3da29f7b1d1efeba8aa1e1,2012-06-21T23:55Z,<S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug>
6415,CWE-399,"void mono_reflection_create_dynamic_method ( monoreflectiondynamicmethod * mb ) { reflectionmethodbuilder rmb ; monomethodsignature * sig ; monoclass * klass ; gslist * l ; int i ; sig = dynamic_method_to_signature ( mb ) ; reflection_methodbuilder_from_dynamic_method ( & rmb , mb ) ; rmb . nrefs = mb -> nrefs ; rmb . refs = g_new0 ( gpointer , mb -> nrefs + 1 ) ; for ( i = 0 ; i < mb -> nrefs ; i += 2 ) { monoclass * handle_class ; gpointer ref ; monoobject * obj = mono_array_get ( mb -> refs , monoobject * , i ) ; if ( strcmp ( obj -> vtable -> klass -> name , ""dynamicmethod"" ) == 0 ) { monoreflectiondynamicmethod * method = ( monoreflectiondynamicmethod * ) obj ; if ( method -> mhandle ) { ref = method -> mhandle ; } else { ref = method ; method -> referenced_by = g_slist_append ( method -> referenced_by , mb ) ; } handle_class = mono_defaults . methodhandle_class ; } else { monoexception * ex = null ; ref = resolve_object ( mb -> module -> image , obj , & handle_class , null ) ; if ( ! ref ) ex = mono_get_exception_type_load ( null , null ) ; else if ( mono_security_get_mode ( ) == mono_security_mode_core_clr ) ex = mono_security_core_clr_ensure_dynamic_method_resolved_object ( ref , handle_class ) ; if ( ex ) { g_free ( rmb . refs ) ; mono_raise_exception ( ex ) ; return ; } } rmb . refs [ i ] = ref ; rmb . refs [ i + 1 ] = handle_class ; } klass = mb -> owner ? mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( monoreflectiontype * ) mb -> owner ) ) : mono_defaults . object_class ; mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ; for ( l = mb -> referenced_by ; l ; l = l -> next ) { monoreflectiondynamicmethod * method = ( monoreflectiondynamicmethod * ) l -> data ; monomethodwrapper * wrapper = ( monomethodwrapper * ) method -> mhandle ; gpointer * data ; g_assert ( method -> mhandle ) ; data = ( gpointer * ) wrapper -> method_data ; for ( i = 0 ; i < gpointer_to_uint ( data [ 0 ] ) ; i += 2 ) { if ( ( data [ i + 1 ] == mb ) && ( data [ i + 1 + 1 ] == mono_defaults . methodhandle_class ) ) data [ i + 1 ] = mb -> mhandle ; } } g_slist_free ( mb -> referenced_by ) ; g_free ( rmb . refs ) ; mb -> ilgen = null ; }","<S2SV_ModStart> mb ) { MonoReferenceQueue * queue ; MonoMethod * handle ; DynamicMethodReleaseData * release_data ; <S2SV_ModStart> int i ; if ( mono_runtime_is_shutting_down ( ) ) mono_raise_exception ( mono_get_exception_invalid_operation ( """" ) ) ; if ( ! ( queue = dynamic_method_queue ) ) { mono_loader_lock ( ) ; if ( ! ( queue = dynamic_method_queue ) ) queue = dynamic_method_queue = mono_gc_reference_queue_new ( free_dynamic_method ) ; mono_loader_unlock ( ) ; } <S2SV_ModStart> -> mhandle = handle = <S2SV_ModStart> rmb , sig ) ; release_data = g_new ( DynamicMethodReleaseData , 1 ) ; release_data -> handle = handle ; release_data -> domain = mono_object_get_domain ( ( MonoObject * ) mb ) ; if ( ! mono_gc_reference_queue_add ( queue , ( MonoObject * ) mb , release_data ) ) g_free ( release_data
",mono@mono/89d1455a80ef13cddee5d79ec00c06055da3085c,CVE-2011-0991,https://github.com/mono/mono/commit/89d1455a80ef13cddee5d79ec00c06055da3085c,2011-04-13T21:55Z,"<S2SV_StartBug> ReflectionMethodBuilder rmb ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ; <S2SV_EndBug>"
3763,CWE-119,"static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = null ; struct fileentry * fe ; struct extendedfileentry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = udf_i ( inode ) ; struct udf_sb_info * sbi = udf_sb ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int ret = - eio ; reread : if ( iloc -> logicalblocknum >= sbi -> s_partmaps [ iloc -> partitionreferencenum ] . s_partition_len ) { udf_debug ( ""block=%d,<s2sv_blank>partition=%d<s2sv_blank>out<s2sv_blank>of<s2sv_blank>range\\n"" , iloc -> logicalblocknum , iloc -> partitionreferencenum ) ; return - eio ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<s2sv_blank>%ld)<s2sv_blank>failed<s2sv_blank>!bh\\n"" , inode -> i_ino ) ; return - eio ; } if ( ident != tag_ident_fe && ident != tag_ident_efe && ident != tag_ident_use ) { udf_err ( inode -> i_sb , ""(ino<s2sv_blank>%ld)<s2sv_blank>failed<s2sv_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; goto out ; } fe = ( struct fileentry * ) bh -> b_data ; efe = ( struct extendedfileentry * ) bh -> b_data ; if ( fe -> icbtag . strategytype == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; if ( ident == tag_ident_ie && ibh ) { struct kernel_lb_addr loc ; struct indirectentry * ie ; ie = ( struct indirectentry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirecticb . extlocation ) ; if ( ie -> indirecticb . extlength ) { brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > udf_max_icb_nesting ) { udf_err ( inode -> i_sb , ""too<s2sv_blank>many<s2sv_blank>icbs<s2sv_blank>in<s2sv_blank>icb<s2sv_blank>hierarchy"" ""<s2sv_blank>(max<s2sv_blank>%d<s2sv_blank>supported)\\n"" , udf_max_icb_nesting ) ; goto out ; } brelse ( bh ) ; goto reread ; } } brelse ( ibh ) ; } else if ( fe -> icbtag . strategytype != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<s2sv_blank>strategy<s2sv_blank>type:<s2sv_blank>%d\\n"" , le16_to_cpu ( fe -> icbtag . strategytype ) ) ; goto out ; } if ( fe -> icbtag . strategytype == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbtag . flags ) & icbtag_flag_ad_mask ; iinfo -> i_unique = 0 ; iinfo -> i_leneattr = 0 ; iinfo -> i_lenextents = 0 ; iinfo -> i_lenalloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> desctag . tagident == cpu_to_le16 ( tag_ident_efe ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedfileentry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedfileentry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedfileentry ) ) ; } else if ( fe -> desctag . tagident == cpu_to_le16 ( tag_ident_fe ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileentry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileentry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileentry ) ) ; } else if ( fe -> desctag . tagident == cpu_to_le16 ( tag_ident_use ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenalloc = le32_to_cpu ( ( ( struct unallocspaceentry * ) bh -> b_data ) -> lengthallocdescs ) ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocspaceentry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocspaceentry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocspaceentry ) ) ; return 0 ; } ret = - eio ; read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || udf_query_flag ( inode -> i_sb , udf_flag_uid_ignore ) || udf_query_flag ( inode -> i_sb , udf_flag_uid_set ) ) inode -> i_uid = udf_sb ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || udf_query_flag ( inode -> i_sb , udf_flag_gid_ignore ) || udf_query_flag ( inode -> i_sb , udf_flag_gid_set ) ) inode -> i_gid = udf_sb ( inode -> i_sb ) -> s_gid ; if ( fe -> icbtag . filetype != icbtag_file_type_directory && sbi -> s_fmode != udf_invalid_mode ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbtag . filetype == icbtag_file_type_directory && sbi -> s_dmode != udf_invalid_mode ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> filelinkcount ) ; if ( ! link_count ) { if ( ! hidden_inode ) { ret = - estale ; goto out ; } link_count = 1 ; } set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationlength ) ; iinfo -> i_lenextents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalblocksrecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accesstime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationtime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrtime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueid ) ; iinfo -> i_leneattr = le32_to_cpu ( fe -> lengthextendedattr ) ; iinfo -> i_lenalloc = le32_to_cpu ( fe -> lengthallocdescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalblocksrecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accesstime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationtime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createtime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrtime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueid ) ; iinfo -> i_leneattr = le32_to_cpu ( efe -> lengthextendedattr ) ; iinfo -> i_lenalloc = le32_to_cpu ( efe -> lengthallocdescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } inode -> i_generation = iinfo -> i_unique ; switch ( fe -> icbtag . filetype ) { case icbtag_file_type_directory : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= s_ifdir ; inc_nlink ( inode ) ; break ; case icbtag_file_type_realtime : case icbtag_file_type_regular : case icbtag_file_type_undef : case icbtag_file_type_vat20 : if ( iinfo -> i_alloc_type == icbtag_flag_ad_in_icb ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= s_ifreg ; break ; case icbtag_file_type_block : inode -> i_mode |= s_ifblk ; break ; case icbtag_file_type_char : inode -> i_mode |= s_ifchr ; break ; case icbtag_file_type_fifo : init_special_inode ( inode , inode -> i_mode | s_ififo , 0 ) ; break ; case icbtag_file_type_socket : init_special_inode ( inode , inode -> i_mode | s_ifsock , 0 ) ; break ; case icbtag_file_type_symlink : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = s_iflnk | s_irwxugo ; break ; case icbtag_file_type_main : udf_debug ( ""metadata<s2sv_blank>file-----\\n"" ) ; break ; case icbtag_file_type_mirror : udf_debug ( ""metadata<s2sv_blank>mirror<s2sv_blank>file-----\\n"" ) ; break ; case icbtag_file_type_bitmap : udf_debug ( ""metadata<s2sv_blank>bitmap<s2sv_blank>file-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<s2sv_blank>%ld)<s2sv_blank>failed<s2sv_blank>unknown<s2sv_blank>file<s2sv_blank>type=%d\\n"" , inode -> i_ino , fe -> icbtag . filetype ) ; goto out ; } if ( s_ischr ( inode -> i_mode ) || s_isblk ( inode -> i_mode ) ) { struct devicespec * dsea = ( struct devicespec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , mkdev ( le32_to_cpu ( dsea -> majordeviceident ) , le32_to_cpu ( dsea -> minordeviceident ) ) ) ; } else goto out ; } ret = 0 ; out : brelse ( bh ) ; return ret ; }","<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
",torvalds@linux/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,CVE-2014-9728,https://github.com/torvalds/linux/commit/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,2015-08-31T10:59Z,<S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug>
4396,CWE-000,"static int list_fields ( mysql * mysql , const char * db , const char * table , const char * wild ) { char query [ 1024 ] , * end ; mysql_res * result ; mysql_row row ; ulong uninit_var ( rows ) ; if ( mysql_select_db ( mysql , db ) ) { fprintf ( stderr , ""%s:<s2sv_blank>cannot<s2sv_blank>connect<s2sv_blank>to<s2sv_blank>db:<s2sv_blank>%s:<s2sv_blank>%s\\n"" , my_progname , db , mysql_error ( mysql ) ) ; return 1 ; } if ( opt_count ) { sprintf ( query , ""select<s2sv_blank>count(*)<s2sv_blank>from<s2sv_blank>`%s`"" , table ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<s2sv_blank>cannot<s2sv_blank>get<s2sv_blank>record<s2sv_blank>count<s2sv_blank>for<s2sv_blank>db:<s2sv_blank>%s,<s2sv_blank>table:<s2sv_blank>%s:<s2sv_blank>%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } row = mysql_fetch_row ( result ) ; rows = ( ulong ) strtoull ( row [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( result ) ; } end = strmov ( strmov ( strmov ( query , ""show<s2sv_blank>/*!32332<s2sv_blank>full<s2sv_blank>*/<s2sv_blank>columns<s2sv_blank>from<s2sv_blank>`"" ) , table ) , ""`"" ) ; if ( wild && wild [ 0 ] ) strxmov ( end , ""<s2sv_blank>like<s2sv_blank>\'"" , wild , ""\'"" , nulls ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<s2sv_blank>cannot<s2sv_blank>list<s2sv_blank>columns<s2sv_blank>in<s2sv_blank>db:<s2sv_blank>%s,<s2sv_blank>table:<s2sv_blank>%s:<s2sv_blank>%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } printf ( ""database:<s2sv_blank>%s<s2sv_blank><s2sv_blank>table:<s2sv_blank>%s"" , db , table ) ; if ( opt_count ) printf ( ""<s2sv_blank><s2sv_blank>rows:<s2sv_blank>%lu"" , rows ) ; if ( wild && wild [ 0 ] ) printf ( ""<s2sv_blank><s2sv_blank>wildcard:<s2sv_blank>%s"" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; if ( opt_show_keys ) { end = strmov ( strmov ( strmov ( query , ""show<s2sv_blank>keys<s2sv_blank>from<s2sv_blank>`"" ) , table ) , ""`"" ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , ""%s:<s2sv_blank>cannot<s2sv_blank>list<s2sv_blank>keys<s2sv_blank>in<s2sv_blank>db:<s2sv_blank>%s,<s2sv_blank>table:<s2sv_blank>%s:<s2sv_blank>%s\\n"" , my_progname , db , table , mysql_error ( mysql ) ) ; return 1 ; } if ( mysql_num_rows ( result ) ) { print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; } else puts ( ""table<s2sv_blank>has<s2sv_blank>no<s2sv_blank>keys"" ) ; } mysql_free_result ( result ) ; return 0 ; }","<S2SV_ModStart> char query [ NAME_LEN + 100 ] ; int len <S2SV_ModEnd> ; MYSQL_RES * <S2SV_ModStart> opt_count ) { my_snprintf ( query , sizeof ( query ) <S2SV_ModEnd> , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , <S2SV_ModStart> ) ; } len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> , ""<S2SV_blank>like<S2SV_blank>\'"" , <S2SV_ModStart> opt_show_keys ) { my_snprintf ( query , sizeof ( query ) , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> ) ; if
",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z,"<S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ; <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug>"
7749,CWE-000,"static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) { switch ( open_flags ) { case fmode_write : state -> n_wronly ++ ; break ; case fmode_read : state -> n_rdonly ++ ; break ; case fmode_read | fmode_write : state -> n_rdwr ++ ; } nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; }","<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { switch <S2SV_ModStart> { switch ( fmode <S2SV_ModEnd> ) { case <S2SV_ModStart> -> state | fmode <S2SV_ModEnd> ) ; }
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> <S2SV_StartBug> nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; <S2SV_EndBug>"
5856,CWE-20,"sds genredisinfostring ( void ) { sds info ; time_t uptime = time ( null ) - server . stat_starttime ; int j ; char hmem [ 64 ] ; struct rusage self_ru , c_ru ; getrusage ( rusage_self , & self_ru ) ; getrusage ( rusage_children , & c_ru ) ; bytestohuman ( hmem , zmalloc_used_memory ( ) ) ; info = sdscatprintf ( sdsempty ( ) , ""redis_version:%s\\r\\n"" ""redis_git_sha1:%s\\r\\n"" ""redis_git_dirty:%d\\r\\n"" ""arch_bits:%s\\r\\n"" ""multiplexing_api:%s\\r\\n"" ""process_id:%ld\\r\\n"" ""uptime_in_seconds:%ld\\r\\n"" ""uptime_in_days:%ld\\r\\n"" ""lru_clock:%ld\\r\\n"" ""used_cpu_sys:%.2f\\r\\n"" ""used_cpu_user:%.2f\\r\\n"" ""used_cpu_sys_childrens:%.2f\\r\\n"" ""used_cpu_user_childrens:%.2f\\r\\n"" ""connected_clients:%d\\r\\n"" ""connected_slaves:%d\\r\\n"" ""blocked_clients:%d\\r\\n"" ""used_memory:%zu\\r\\n"" ""used_memory_human:%s\\r\\n"" ""used_memory_rss:%zu\\r\\n"" ""mem_fragmentation_ratio:%.2f\\r\\n"" ""use_tcmalloc:%d\\r\\n"" ""loading:%d\\r\\n"" ""aof_enabled:%d\\r\\n"" ""changes_since_last_save:%lld\\r\\n"" ""bgsave_in_progress:%d\\r\\n"" ""last_save_time:%ld\\r\\n"" ""bgrewriteaof_in_progress:%d\\r\\n"" ""total_connections_received:%lld\\r\\n"" ""total_commands_processed:%lld\\r\\n"" ""expired_keys:%lld\\r\\n"" ""evicted_keys:%lld\\r\\n"" ""keyspace_hits:%lld\\r\\n"" ""keyspace_misses:%lld\\r\\n"" ""hash_max_zipmap_entries:%zu\\r\\n"" ""hash_max_zipmap_value:%zu\\r\\n"" ""pubsub_channels:%ld\\r\\n"" ""pubsub_patterns:%u\\r\\n"" ""vm_enabled:%d\\r\\n"" ""role:%s\\r\\n"" , redis_version , redisgitsha1 ( ) , strtol ( redisgitdirty ( ) , null , 10 ) > 0 , ( sizeof ( long ) == 8 ) ? ""64"" : ""32"" , aegetapiname ( ) , ( long ) getpid ( ) , uptime , uptime / ( 3600 * 24 ) , ( unsigned long ) server . lruclock , ( float ) self_ru . ru_utime . tv_sec + ( float ) self_ru . ru_utime . tv_usec / 1000000 , ( float ) self_ru . ru_stime . tv_sec + ( float ) self_ru . ru_stime . tv_usec / 1000000 , ( float ) c_ru . ru_utime . tv_sec + ( float ) c_ru . ru_utime . tv_usec / 1000000 , ( float ) c_ru . ru_stime . tv_sec + ( float ) c_ru . ru_stime . tv_usec / 1000000 , listlength ( server . clients ) - listlength ( server . slaves ) , listlength ( server . slaves ) , server . bpop_blocked_clients , zmalloc_used_memory ( ) , hmem , zmalloc_get_rss ( ) , zmalloc_get_fragmentation_ratio ( ) , # ifdef use_tcmalloc 1 , # else 0 , # endif server . loading , server . appendonly , server . dirty , server . bgsavechildpid != - 1 , server . lastsave , server . bgrewritechildpid != - 1 , server . stat_numconnections , server . stat_numcommands , server . stat_expiredkeys , server . stat_evictedkeys , server . stat_keyspace_hits , server . stat_keyspace_misses , server . hash_max_zipmap_entries , server . hash_max_zipmap_value , dictsize ( server . pubsub_channels ) , listlength ( server . pubsub_patterns ) , server . vm_enabled != 0 , server . masterhost == null ? ""master"" : ""slave"" ) ; if ( server . masterhost ) { info = sdscatprintf ( info , ""master_host:%s\\r\\n"" ""master_port:%d\\r\\n"" ""master_link_status:%s\\r\\n"" ""master_last_io_seconds_ago:%d\\r\\n"" ""master_sync_in_progress:%d\\r\\n"" , server . masterhost , server . masterport , ( server . replstate == redis_repl_connected ) ? ""up"" : ""down"" , server . master ? ( ( int ) ( time ( null ) - server . master -> lastinteraction ) ) : - 1 , server . replstate == redis_repl_transfer ) ; if ( server . replstate == redis_repl_transfer ) { info = sdscatprintf ( info , ""master_sync_left_bytes:%ld\\r\\n"" ""master_sync_last_io_seconds_ago:%d\\r\\n"" , ( long ) server . repl_transfer_left , ( int ) ( time ( null ) - server . repl_transfer_lastio ) ) ; } } if ( server . vm_enabled ) { lockthreadedio ( ) ; info = sdscatprintf ( info , ""vm_conf_max_memory:%llu\\r\\n"" ""vm_conf_page_size:%llu\\r\\n"" ""vm_conf_pages:%llu\\r\\n"" ""vm_stats_used_pages:%llu\\r\\n"" ""vm_stats_swapped_objects:%llu\\r\\n"" ""vm_stats_swappin_count:%llu\\r\\n"" ""vm_stats_swappout_count:%llu\\r\\n"" ""vm_stats_io_newjobs_len:%lu\\r\\n"" ""vm_stats_io_processing_len:%lu\\r\\n"" ""vm_stats_io_processed_len:%lu\\r\\n"" ""vm_stats_io_active_threads:%lu\\r\\n"" ""vm_stats_blocked_clients:%lu\\r\\n"" , ( unsigned long long ) server . vm_max_memory , ( unsigned long long ) server . vm_page_size , ( unsigned long long ) server . vm_pages , ( unsigned long long ) server . vm_stats_used_pages , ( unsigned long long ) server . vm_stats_swapped_objects , ( unsigned long long ) server . vm_stats_swapins , ( unsigned long long ) server . vm_stats_swapouts , ( unsigned long ) listlength ( server . io_newjobs ) , ( unsigned long ) listlength ( server . io_processing ) , ( unsigned long ) listlength ( server . io_processed ) , ( unsigned long ) server . io_active_threads , ( unsigned long ) server . vm_blocked_clients ) ; unlockthreadedio ( ) ; } if ( server . loading ) { double perc ; time_t eta , elapsed ; off_t remaining_bytes = server . loading_total_bytes - server . loading_loaded_bytes ; perc = ( ( double ) server . loading_loaded_bytes / server . loading_total_bytes ) * 100 ; elapsed = time ( null ) - server . loading_start_time ; if ( elapsed == 0 ) { eta = 1 ; } else { eta = ( elapsed * remaining_bytes ) / server . loading_loaded_bytes ; } info = sdscatprintf ( info , ""loading_start_time:%ld\\r\\n"" ""loading_total_bytes:%llu\\r\\n"" ""loading_loaded_bytes:%llu\\r\\n"" ""loading_loaded_perc:%.2f\\r\\n"" ""loading_eta_seconds:%ld\\r\\n"" , ( unsigned long ) server . loading_start_time , ( unsigned long long ) server . loading_total_bytes , ( unsigned long long ) server . loading_loaded_bytes , perc , eta ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long keys , vkeys ; keys = dictsize ( server . db [ j ] . dict ) ; vkeys = dictsize ( server . db [ j ] . expires ) ; if ( keys || vkeys ) { info = sdscatprintf ( info , ""db%d:keys=%lld,expires=%lld\\r\\n"" , j , keys , vkeys ) ; } } return info ; }","<S2SV_ModStart> ""hash_max_zipmap_value:%zu\\r\\n"" ""pubsub_channels:%ld\\r\\n"" ""pubsub_patterns:%u\\r\\n"" ""ds_enabled:%d\\r\\n"" <S2SV_ModEnd> ""role:%s\\r\\n"" , REDIS_VERSION <S2SV_ModStart> , server . ds_enabled <S2SV_ModEnd> != 0 , <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> ) { lockThreadedIO <S2SV_ModStart> ( info , ""cache_max_memory:%llu\\r\\n"" ""cache_blocked_clients:%lu\\r\\n"" <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> ) server . cache_max_memory <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> ( unsigned long ) server . cache_blocked_clients <S2SV_ModEnd> ) ; unlockThreadedIO
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,"<S2SV_StartBug> ""vm_enabled:%d\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> server . vm_enabled != 0 , <S2SV_EndBug> <S2SV_StartBug> if ( server . vm_enabled ) { <S2SV_EndBug> <S2SV_StartBug> ""vm_conf_max_memory:%llu\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> , ( unsigned long long ) server . vm_max_memory , <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) server . vm_page_size , <S2SV_EndBug>"
1289,CWE-200,"static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { walk -> private += __mincore_unmapped_range ( addr , end , walk -> vma , walk -> private ) ; return 0 ; }","<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
",torvalds@linux/574823bfab82d9d8fa47f422778043fbb4b4f50e,CVE-2019-5489,https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e,2019-01-07T17:29Z,"<S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug>"
3064,CWE-119,"static void logi_dj_recv_add_djhid_device ( struct dj_receiver_dev * djrcv_dev , struct dj_report * dj_report ) { struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct hid_device * dj_hiddev ; struct dj_device * dj_dev ; unsigned char tmpstr [ 3 ] ; if ( dj_report -> report_params [ device_paired_param_spfunction ] & spfunction_device_list_empty ) { dbg_hid ( ""%s:<s2sv_blank>device<s2sv_blank>list<s2sv_blank>is<s2sv_blank>empty\\n"" , __func__ ) ; djrcv_dev -> querying_devices = false ; return ; } if ( ( dj_report -> device_index < dj_device_index_min ) || ( dj_report -> device_index > dj_device_index_max ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<s2sv_blank>invalid<s2sv_blank>device<s2sv_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return ; } if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] ) { dbg_hid ( ""%s:<s2sv_blank>device<s2sv_blank>is<s2sv_blank>already<s2sv_blank>known\\n"" , __func__ ) ; return ; } dj_hiddev = hid_allocate_device ( ) ; if ( is_err ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<s2sv_blank>hid_allocate_device<s2sv_blank>failed\\n"" , __func__ ) ; return ; } dj_hiddev -> ll_driver = & logi_dj_ll_driver ; dj_hiddev -> dev . parent = & djrcv_hdev -> dev ; dj_hiddev -> bus = bus_usb ; dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idvendor ) ; dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idproduct ) ; snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , ""logitech<s2sv_blank>unifying<s2sv_blank>device.<s2sv_blank>wireless<s2sv_blank>pid:%02x%02x"" , dj_report -> report_params [ device_paired_param_equad_id_msb ] , dj_report -> report_params [ device_paired_param_equad_id_lsb ] ) ; usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ) ; snprintf ( tmpstr , sizeof ( tmpstr ) , "":%d"" , dj_report -> device_index ) ; strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ) ; dj_dev = kzalloc ( sizeof ( struct dj_device ) , gfp_kernel ) ; if ( ! dj_dev ) { dev_err ( & djrcv_hdev -> dev , ""%s:<s2sv_blank>failed<s2sv_blank>allocating<s2sv_blank>dj_device\\n"" , __func__ ) ; goto dj_device_allocate_fail ; } dj_dev -> reports_supported = get_unaligned_le32 ( dj_report -> report_params + device_paired_rf_report_type ) ; dj_dev -> hdev = dj_hiddev ; dj_dev -> dj_receiver_dev = djrcv_dev ; dj_dev -> device_index = dj_report -> device_index ; dj_hiddev -> driver_data = dj_dev ; djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev ; if ( hid_add_device ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<s2sv_blank>failed<s2sv_blank>adding<s2sv_blank>dj_device\\n"" , __func__ ) ; goto hid_add_device_fail ; } return ; hid_add_device_fail : djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = null ; kfree ( dj_dev ) ; dj_device_allocate_fail : hid_destroy_device ( dj_hiddev ) ; }","<S2SV_ModStart> } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices
",torvalds@linux/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,CVE-2014-3182,https://github.com/torvalds/linux/commit/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,2014-09-28T10:55Z,<S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug>
8023,CWE-835,"void class parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , seek_set ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'm' || fgetc ( ifp ) - 'r' ) return ; order = fgetc ( ifp ) * 0x101 ; offset = base + get4 ( ) + 8 ; while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ; switch ( tag ) { case 0x505244 : fseek ( ifp , 8 , seek_cur ) ; high = get2 ( ) ; wide = get2 ( ) ; # ifdef libraw_library_build imgdata . makernotes . sony . prd_imageheight = get2 ( ) ; imgdata . makernotes . sony . prd_imagewidth = get2 ( ) ; fseek ( ifp , 1l , seek_cur ) ; imgdata . makernotes . sony . prd_rawbitdepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_storagemethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4l , seek_cur ) ; imgdata . makernotes . sony . prd_bayerpattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef libraw_library_build case 0x524946 : if ( ! strncasecmp ( model , ""dslr-a100"" , 9 ) ) { fseek ( ifp , 8 , seek_cur ) ; imgdata . color . wb_coeffs [ libraw_wbi_tungsten ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_tungsten ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_daylight ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_daylight ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_cloudy ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_cloudy ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_w ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_w ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_flash ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_flash ] [ 2 ] = get2 ( ) ; get4 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_shade ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_shade ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_d ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_d ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_n ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_n ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_ww ] [ 0 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_fl_ww ] [ 2 ] = get2 ( ) ; imgdata . color . wb_coeffs [ libraw_wbi_daylight ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_daylight ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_tungsten ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_tungsten ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_flash ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_flash ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_cloudy ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_cloudy ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_shade ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_shade ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_d ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_d ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_n ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_n ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_w ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_w ] [ 3 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_ww ] [ 1 ] = imgdata . color . wb_coeffs [ libraw_wbi_fl_ww ] [ 3 ] = 0x100 ; } break ; # endif case 0x574247 : get4 ( ) ; i = strcmp ( model , ""dimage<s2sv_blank>a200"" ) ? 0 : 3 ; forc4 cam_mul [ c ^ ( c >> 1 ) ^ i ] = get2 ( ) ; break ; case 0x545457 : parse_tiff ( ftell ( ifp ) ) ; data_offset = offset ; } fseek ( ifp , save + len + 8 , seek_set ) ; } raw_height = high ; raw_width = wide ; order = sorder ; }","<S2SV_ModStart> + 8 ; # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <S2SV_ModStart> ( ) ; if ( len < 0 ) return ;
",LibRaw@LibRaw/e47384546b43d0fd536e933249047bc397a4d88b,CVE-2018-5813,https://github.com/LibRaw/LibRaw/commit/e47384546b43d0fd536e933249047bc397a4d88b,2018-12-07T22:29Z,<S2SV_StartBug> offset = base + get4 ( ) + 8 ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) <S2SV_EndBug>
498,CWE-264,"static inline int check_sticky ( struct inode * dir , struct inode * inode ) { kuid_t fsuid = current_fsuid ( ) ; if ( ! ( dir -> i_mode & s_isvtx ) ) return 0 ; if ( uid_eq ( inode -> i_uid , fsuid ) ) return 0 ; if ( uid_eq ( dir -> i_uid , fsuid ) ) return 0 ; return ! inode_capable ( inode , cap_fowner ) ; }","<S2SV_ModStart> ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z,"<S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug>"
4977,CWE-119,"static int stellaris_enet_init ( sysbusdevice * sbd ) { devicestate * dev = device ( sbd ) ; stellaris_enet_state * s = stellaris_enet ( dev ) ; memory_region_init_io ( & s -> mmio , object ( s ) , & stellaris_enet_ops , s , ""stellaris_enet"" , 0x1000 ) ; sysbus_init_mmio ( sbd , & s -> mmio ) ; sysbus_init_irq ( sbd , & s -> irq ) ; qemu_macaddr_default_if_unset ( & s -> conf . macaddr ) ; s -> nic = qemu_new_nic ( & net_stellaris_enet_info , & s -> conf , object_get_typename ( object ( dev ) ) , dev -> id , s ) ; qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ; stellaris_enet_reset ( s ) ; register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , stellaris_enet_save , stellaris_enet_load , s ) ; return 0 ; }","<S2SV_ModStart> s ) ; <S2SV_ModEnd> return 0 ;
",qemu@qemu/2e1198672759eda6e122ff38fcf6df06f27e0fe2,CVE-2013-4532,https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2,2020-01-02T16:15Z,"<S2SV_StartBug> register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , <S2SV_EndBug>"
6930,CWE-400,"static int x86_pmu_handle_irq ( struct pt_regs * regs ) { struct perf_sample_data data ; struct cpu_hw_events * cpuc ; struct perf_event * event ; int idx , handled = 0 ; u64 val ; perf_sample_data_init ( & data , 0 ) ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; apic_write ( apic_lvtpc , apic_dm_nmi ) ; for ( idx = 0 ; idx < x86_pmu . num_counters ; idx ++ ) { if ( ! test_bit ( idx , cpuc -> active_mask ) ) { if ( __test_and_clear_bit ( idx , cpuc -> running ) ) handled ++ ; continue ; } event = cpuc -> events [ idx ] ; val = x86_perf_event_update ( event ) ; if ( val & ( 1ull << ( x86_pmu . cntval_bits - 1 ) ) ) continue ; handled ++ ; data . period = event -> hw . last_period ; if ( ! x86_perf_event_set_period ( event ) ) continue ; if ( perf_event_overflow ( event , 1 , & data , regs ) ) x86_pmu_stop ( event , 0 ) ; } if ( handled ) inc_irq_stat ( apic_perf_irqs ) ; return handled ; }","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <S2SV_EndBug>"
5997,CWE-119,"sndfile * sf_open ( const char * path , int mode , sf_info * sfinfo ) { sf_private * psf ; assert ( sizeof ( sf_count_t ) == 8 ) ; if ( ( psf = calloc ( 1 , sizeof ( sf_private ) ) ) == null ) { sf_errno = sfe_malloc_failed ; return null ; } ; psf_init_files ( psf ) ; psf_log_printf ( psf , ""file<s2sv_blank>:<s2sv_blank>%s\\n"" , path ) ; if ( copy_filename ( psf , path ) != 0 ) { sf_errno = psf -> error ; return null ; } ; psf -> file . mode = mode ; if ( strcmp ( path , ""-"" ) == 0 ) psf -> error = psf_set_stdio ( psf ) ; else psf -> error = psf_fopen ( psf ) ; return psf_open_file ( psf , sfinfo ) ; }","<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug>"
986,CWE-119,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = bpf_op ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( bpf_class ( insn -> code ) != bpf_alu64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case bpf_add : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case bpf_sub : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case bpf_mul : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > u32_max || dst_reg -> umax_value > u32_max ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > s64_max ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case bpf_and : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case bpf_or : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case bpf_lsh : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; if ( dst_reg -> umax_value > 1ull << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = u64_max ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case bpf_rsh : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = s64_min ; dst_reg -> smax_value = s64_max ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","<S2SV_ModStart> , umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
",torvalds@linux/468f6eafa6c44cb2c5d8aad35e12f06c240a812a,CVE-2017-17852,https://github.com/torvalds/linux/commit/468f6eafa6c44cb2c5d8aad35e12f06c240a812a,2017-12-27T17:08Z,<S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug>
6948,CWE-400,"static void sample_hbp_handler ( struct perf_event * bp , int nmi , struct perf_sample_data * data , struct pt_regs * regs ) { printk ( kern_info ""%s<s2sv_blank>value<s2sv_blank>is<s2sv_blank>changed\\n"" , ksym_name ) ; dump_stack ( ) ; printk ( kern_info ""dump<s2sv_blank>stack<s2sv_blank>from<s2sv_blank>sample_hbp_handler\\n"" ) ; }","<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <S2SV_EndBug>"
5921,CWE-74,"gboolean flatpak_run_add_environment_args ( flatpakbwrap * bwrap , const char * app_info_path , flatpakrunflags flags , const char * app_id , flatpakcontext * context , gfile * app_id_dir , gptrarray * previous_app_id_dirs , flatpakexports * * exports_out , gcancellable * cancellable , gerror * * error ) { g_autoptr ( gerror ) my_error = null ; g_autoptr ( flatpakexports ) exports = null ; g_autoptr ( flatpakbwrap ) proxy_arg_bwrap = flatpak_bwrap_new ( flatpak_bwrap_empty_env ) ; gboolean has_wayland = false ; gboolean allow_x11 = false ; if ( ( context -> shares & flatpak_context_shared_ipc ) == 0 ) { g_debug ( ""disallowing<s2sv_blank>ipc<s2sv_blank>access"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-ipc"" , null ) ; } if ( ( context -> shares & flatpak_context_shared_network ) == 0 ) { g_debug ( ""disallowing<s2sv_blank>network<s2sv_blank>access"" ) ; flatpak_bwrap_add_args ( bwrap , ""--unshare-net"" , null ) ; } if ( context -> devices & flatpak_context_device_all ) { flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev"" , ""/dev"" , null ) ; if ( g_file_test ( ""/dev/shm"" , g_file_test_is_dir ) ) { if ( ( context -> devices & flatpak_context_device_shm ) == 0 ) flatpak_bwrap_add_args ( bwrap , ""--tmpfs"" , ""/dev/shm"" , null ) ; } else if ( g_file_test ( ""/dev/shm"" , g_file_test_is_symlink ) ) { g_autofree char * link = flatpak_readlink ( ""/dev/shm"" , null ) ; if ( g_strcmp0 ( link , ""/run/shm"" ) == 0 ) { if ( context -> devices & flatpak_context_device_shm && g_file_test ( ""/run/shm"" , g_file_test_is_dir ) ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , ""/run/shm"" , ""/run/shm"" , null ) ; else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/run/shm"" , null ) ; } else g_warning ( ""unexpected<s2sv_blank>/dev/shm<s2sv_blank>symlink<s2sv_blank>%s"" , link ) ; } } else { flatpak_bwrap_add_args ( bwrap , ""--dev"" , ""/dev"" , null ) ; if ( context -> devices & flatpak_context_device_dri ) { g_debug ( ""allowing<s2sv_blank>dri<s2sv_blank>access"" ) ; int i ; char * dri_devices [ ] = { ""/dev/dri"" , ""/dev/mali"" , ""/dev/mali0"" , ""/dev/umplock"" , ""/dev/nvidiactl"" , ""/dev/nvidia-modeset"" , ""/dev/nvidia-uvm"" , ""/dev/nvidia-uvm-tools"" , } ; for ( i = 0 ; i < g_n_elements ( dri_devices ) ; i ++ ) { if ( g_file_test ( dri_devices [ i ] , g_file_test_exists ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , dri_devices [ i ] , dri_devices [ i ] , null ) ; } char nvidia_dev [ 14 ] ; for ( i = 0 ; i < 20 ; i ++ ) { g_snprintf ( nvidia_dev , sizeof ( nvidia_dev ) , ""/dev/nvidia%d"" , i ) ; if ( g_file_test ( nvidia_dev , g_file_test_exists ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , nvidia_dev , nvidia_dev , null ) ; } } if ( context -> devices & flatpak_context_device_kvm ) { g_debug ( ""allowing<s2sv_blank>kvm<s2sv_blank>access"" ) ; if ( g_file_test ( ""/dev/kvm"" , g_file_test_exists ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev/kvm"" , ""/dev/kvm"" , null ) ; } if ( context -> devices & flatpak_context_device_shm ) { g_autofree char * real_dev_shm = realpath ( ""/dev/shm"" , null ) ; g_debug ( ""allowing<s2sv_blank>/dev/shm<s2sv_blank>access<s2sv_blank>(as<s2sv_blank>%s)"" , real_dev_shm ) ; if ( real_dev_shm != null ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , real_dev_shm , ""/dev/shm"" , null ) ; } } flatpak_context_append_bwrap_filesystem ( context , bwrap , app_id , app_id_dir , previous_app_id_dirs , & exports ) ; if ( context -> sockets & flatpak_context_socket_wayland ) { g_debug ( ""allowing<s2sv_blank>wayland<s2sv_blank>access"" ) ; has_wayland = flatpak_run_add_wayland_args ( bwrap ) ; } if ( ( context -> sockets & flatpak_context_socket_fallback_x11 ) != 0 ) allow_x11 = ! has_wayland ; else allow_x11 = ( context -> sockets & flatpak_context_socket_x11 ) != 0 ; flatpak_run_add_x11_args ( bwrap , allow_x11 ) ; if ( context -> sockets & flatpak_context_socket_ssh_auth ) { flatpak_run_add_ssh_args ( bwrap ) ; } if ( context -> sockets & flatpak_context_socket_pulseaudio ) { g_debug ( ""allowing<s2sv_blank>pulseaudio<s2sv_blank>access"" ) ; flatpak_run_add_pulseaudio_args ( bwrap ) ; } if ( context -> sockets & flatpak_context_socket_pcsc ) { flatpak_run_add_pcsc_args ( bwrap ) ; } if ( context -> sockets & flatpak_context_socket_cups ) { flatpak_run_add_cups_args ( bwrap ) ; } flatpak_run_add_session_dbus_args ( bwrap , proxy_arg_bwrap , context , flags , app_id ) ; flatpak_run_add_system_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; flatpak_run_add_a11y_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ; if ( g_environ_getenv ( bwrap -> envp , ""ld_library_path"" ) != null ) { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""ld_library_path"" , g_environ_getenv ( bwrap -> envp , ""ld_library_path"" ) , null ) ; flatpak_bwrap_unset_env ( bwrap , ""ld_library_path"" ) ; } if ( g_environ_getenv ( bwrap -> envp , ""tmpdir"" ) != null ) { flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""tmpdir"" , g_environ_getenv ( bwrap -> envp , ""tmpdir"" ) , null ) ; flatpak_bwrap_unset_env ( bwrap , ""tmpdir"" ) ; } if ( ! flatpak_run_in_transient_unit ( app_id , & my_error ) ) { g_debug ( ""failed<s2sv_blank>to<s2sv_blank>run<s2sv_blank>in<s2sv_blank>transient<s2sv_blank>scope:<s2sv_blank>%s"" , my_error -> message ) ; g_clear_error ( & my_error ) ; } if ( ! flatpak_bwrap_is_empty ( proxy_arg_bwrap ) && ! start_dbus_proxy ( bwrap , proxy_arg_bwrap , app_info_path , error ) ) return false ; if ( exports_out ) * exports_out = g_steal_pointer ( & exports ) ; return true ; }","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! flatpak_run_in_transient_unit (
",flatpak@flatpak/6d1773d2a54dde9b099043f07a2094a4f1c2f486,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486,2021-01-14T20:15Z,"<S2SV_StartBug> if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL ) <S2SV_EndBug>"
5054,CWE-189,"static varbit * bit_catenate ( varbit * arg1 , varbit * arg2 ) { varbit * result ; int bitlen1 , bitlen2 , bytelen , bit1pad , bit2shift ; bits8 * pr , * pa ; bitlen1 = varbitlen ( arg1 ) ; bitlen2 = varbitlen ( arg2 ) ; bytelen = varbittotallen ( bitlen1 + bitlen2 ) ; result = ( varbit * ) palloc ( bytelen ) ; set_varsize ( result , bytelen ) ; varbitlen ( result ) = bitlen1 + bitlen2 ; memcpy ( varbits ( result ) , varbits ( arg1 ) , varbitbytes ( arg1 ) ) ; bit1pad = varbitpad ( arg1 ) ; if ( bit1pad == 0 ) { memcpy ( varbits ( result ) + varbitbytes ( arg1 ) , varbits ( arg2 ) , varbitbytes ( arg2 ) ) ; } else if ( bitlen2 > 0 ) { bit2shift = bits_per_byte - bit1pad ; pr = varbits ( result ) + varbitbytes ( arg1 ) - 1 ; for ( pa = varbits ( arg2 ) ; pa < varbitend ( arg2 ) ; pa ++ ) { * pr |= ( ( * pa >> bit2shift ) & bitmask ) ; pr ++ ; if ( pr < varbitend ( result ) ) * pr = ( * pa << bit1pad ) & bitmask ; } } return result ; }","<S2SV_ModStart> VARBITLEN ( arg2 ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) )
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug>
8426,CWE-74,"int nntp_open_connection ( struct nntpaccountdata * adata ) { struct connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == nntp_ok ) return 0 ; if ( adata -> status == nntp_bye ) return - 1 ; adata -> status = nntp_none ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , ""200"" , case_match ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , ""201"" , case_match ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( ""%s"" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , ""mode<s2sv_blank>reader\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , ""200"" , case_match ) ) posting = true ; else if ( mutt_str_startswith ( buf , ""201"" , case_match ) ) posting = false ; else if ( adata -> hascapabilities ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""could<s2sv_blank>not<s2sv_blank>switch<s2sv_blank>to<s2sv_blank>reader<s2sv_blank>mode"" ) ) ; return - 1 ; } if ( adata -> hascapabilities ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( ""connected<s2sv_blank>to<s2sv_blank>%s.<s2sv_blank>%s"" ) , conn -> account . host , posting ? _ ( ""posting<s2sv_blank>is<s2sv_blank>ok"" ) : _ ( ""posting<s2sv_blank>is<s2sv_blank>not<s2sv_blank>ok"" ) ) ; mutt_sleep ( 1 ) ; # ifdef use_ssl if ( ( adata -> use_tls != 1 ) && ( adata -> hasstarttls || c_sslforcetls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = c_sslforcetls || query_quadoption ( c_sslstarttls , _ ( ""secure<s2sv_blank>connection<s2sv_blank>with<s2sv_blank>tls?"" ) ) == mutt_yes ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , ""starttls\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , ""382"" , case_match ) ) { adata -> use_tls = 0 ; mutt_error ( ""starttls:<s2sv_blank>%s"" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = nntp_none ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( ""could<s2sv_blank>not<s2sv_blank>negotiate<s2sv_blank>tls<s2sv_blank>connection"" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & mutt_acct_user ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , ""stat\\r\\n"" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , ""480"" , case_match ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hascapabilities && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( ""could<s2sv_blank>not<s2sv_blank>switch<s2sv_blank>to<s2sv_blank>reader<s2sv_blank>mode"" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = nntp_ok ; return 0 ; }","<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;
",neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc,CVE-2020-14954,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,2020-06-21T17:15Z,<S2SV_StartBug> } <S2SV_EndBug>
7745,CWE-000,"static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( nfs_i ( inode ) -> delegation ) ; if ( delegation == null || ( delegation -> type & open_flags ) == open_flags ) { rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }","<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,"<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug>"
4844,CWE-401,"static int i40e_setup_macvlans ( struct i40e_vsi * vsi , u16 macvlan_cnt , u16 qcnt , struct net_device * vdev ) { struct i40e_pf * pf = vsi -> back ; struct i40e_hw * hw = & pf -> hw ; struct i40e_vsi_context ctxt ; u16 sections , qmap , num_qps ; struct i40e_channel * ch ; int i , pow , ret = 0 ; u8 offset = 0 ; if ( vsi -> type != i40e_vsi_main || ! macvlan_cnt ) return - einval ; num_qps = vsi -> num_queue_pairs - ( macvlan_cnt * qcnt ) ; pow = fls ( roundup_pow_of_two ( num_qps ) - 1 ) ; qmap = ( offset << i40e_aq_vsi_tc_que_offset_shift ) | ( pow << i40e_aq_vsi_tc_que_number_shift ) ; sections = i40e_aq_vsi_prop_queue_map_valid ; sections |= i40e_aq_vsi_prop_sched_valid ; memset ( & ctxt , 0 , sizeof ( ctxt ) ) ; ctxt . seid = vsi -> seid ; ctxt . pf_num = vsi -> back -> hw . pf_id ; ctxt . vf_num = 0 ; ctxt . uplink_seid = vsi -> uplink_seid ; ctxt . info = vsi -> info ; ctxt . info . tc_mapping [ 0 ] = cpu_to_le16 ( qmap ) ; ctxt . info . mapping_flags |= cpu_to_le16 ( i40e_aq_vsi_que_map_contig ) ; ctxt . info . queue_mapping [ 0 ] = cpu_to_le16 ( vsi -> base_queue ) ; ctxt . info . valid_sections |= cpu_to_le16 ( sections ) ; vsi -> rss_size = max_t ( u16 , num_qps , qcnt ) ; ret = i40e_vsi_config_rss ( vsi ) ; if ( ret ) { dev_info ( & pf -> pdev -> dev , ""failed<s2sv_blank>to<s2sv_blank>reconfig<s2sv_blank>rss<s2sv_blank>for<s2sv_blank>num_queues<s2sv_blank>(%u)\\n"" , vsi -> rss_size ) ; return ret ; } vsi -> reconfig_rss = true ; dev_dbg ( & vsi -> back -> pdev -> dev , ""reconfigured<s2sv_blank>rss<s2sv_blank>with<s2sv_blank>num_queues<s2sv_blank>(%u)\\n"" , vsi -> rss_size ) ; vsi -> next_base_queue = num_qps ; vsi -> cnt_q_avail = vsi -> num_queue_pairs - num_qps ; ret = i40e_aq_update_vsi_params ( hw , & ctxt , null ) ; if ( ret ) { dev_info ( & pf -> pdev -> dev , ""update<s2sv_blank>vsi<s2sv_blank>tc<s2sv_blank>config<s2sv_blank>failed,<s2sv_blank>err<s2sv_blank>%s<s2sv_blank>aq_err<s2sv_blank>%s\\n"" , i40e_stat_str ( hw , ret ) , i40e_aq_str ( hw , hw -> aq . asq_last_status ) ) ; return ret ; } i40e_vsi_update_queue_map ( vsi , & ctxt ) ; vsi -> info . valid_sections = 0 ; init_list_head ( & vsi -> macvlan_list ) ; for ( i = 0 ; i < macvlan_cnt ; i ++ ) { ch = kzalloc ( sizeof ( * ch ) , gfp_kernel ) ; if ( ! ch ) { ret = - enomem ; goto err_free ; } init_list_head ( & ch -> list ) ; ch -> num_queue_pairs = qcnt ; if ( ! i40e_setup_channel ( pf , vsi , ch ) ) { ret = - einval ; goto err_free ; } ch -> parent_vsi = vsi ; vsi -> cnt_q_avail -= ch -> num_queue_pairs ; vsi -> macvlan_cnt ++ ; list_add_tail ( & ch -> list , & vsi -> macvlan_list ) ; } return ret ; err_free : dev_info ( & pf -> pdev -> dev , ""failed<s2sv_blank>to<s2sv_blank>setup<s2sv_blank>macvlans\\n"" ) ; i40e_free_macvlan_channels ( vsi ) ; return ret ; }","<S2SV_ModStart> - EINVAL ; kfree ( ch ) ;
",torvalds@linux/27d461333459d282ffa4a2bdb6b215a59d493a8f,CVE-2019-19043,https://github.com/torvalds/linux/commit/27d461333459d282ffa4a2bdb6b215a59d493a8f,2019-11-18T06:15Z,<S2SV_StartBug> goto err_free ; <S2SV_EndBug>
7798,CWE-125,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { pyobject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg ; int i = start ; int j = 0 ; if ( kwonlyargs == null ) { ast_error ( c , child ( n , start ) , ""named<s2sv_blank>arguments<s2sv_blank>must<s2sv_blank>follow<s2sv_blank>bare<s2sv_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != null ) ; while ( i < nch ( n ) ) { ch = child ( n , i ) ; switch ( type ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < nch ( n ) && type ( child ( n , i + 1 ) ) == equal ) { expression = ast_for_expr ( c , child ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_set ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_set ( kwdefaults , j , null ) ; } if ( nch ( ch ) == 3 ) { annotation = ast_for_expr ( c , child ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = null ; } ch = child ( ch , 0 ) ; argname = new_identifier ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , lineno ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_set ( kwonlyargs , j ++ , arg ) ; i += 2 ; break ; case doublestar : return i ; default : ast_error ( c , ch , ""unexpected<s2sv_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }","<S2SV_ModStart> , annotation , NULL , <S2SV_ModStart> ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 <S2SV_ModEnd> ; break ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,"<S2SV_StartBug> arg = arg ( argname , annotation , LINENO ( ch ) , ch -> n_col_offset , <S2SV_EndBug> <S2SV_StartBug> i += 2 ; <S2SV_EndBug>"
108,CWE-119,"static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""kvp:<s2sv_blank>transaction<s2sv_blank>not<s2sv_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == null ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = hv_e_fail ; goto response_done ; } keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , ( wchar_t * ) kvp_data -> data . key ) ; kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; valuelen = utf8s_to_utf16s ( value , strlen ( value ) , ( wchar_t * ) kvp_data -> data . value ) ; kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = reg_sz ; icmsghdrp -> status = hv_s_ok ; response_done : icmsghdrp -> icflags = icmsghdrflag_transaction | icmsghdrflag_response ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , vm_pkt_data_inband , 0 ) ; }","<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z,"<S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug>"
4521,CWE-125,"static int add_ast_fields ( void ) { pyobject * empty_tuple , * d ; if ( pytype_ready ( & ast_type ) < 0 ) return - 1 ; d = ast_type . tp_dict ; empty_tuple = pytuple_new ( 0 ) ; if ( ! empty_tuple || pydict_setitemstring ( d , ""_fields"" , empty_tuple ) < 0 || pydict_setitemstring ( d , ""_attributes"" , empty_tuple ) < 0 ) { py_xdecref ( empty_tuple ) ; return - 1 ; } py_decref ( empty_tuple ) ; return 0 ; }","<S2SV_ModStart> ! empty_tuple || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__fields <S2SV_ModEnd> , empty_tuple ) <S2SV_ModStart> < 0 || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__attributes <S2SV_ModEnd> , empty_tuple )
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,"<S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug>"
2739,CWE-399,"static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { struct hstate * h = hstate_vma ( vma ) ; struct page * page ; struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return err_ptr ( - vm_fault_oom ) ; if ( chg ) if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) return err_ptr ( - vm_fault_sigbus ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , numa_no_node ) ; if ( ! page ) { hugetlb_put_quota ( inode -> i_mapping , chg ) ; return err_ptr ( - vm_fault_sigbus ) ; } } set_page_private ( page , ( unsigned long ) mapping ) ; vma_commit_reservation ( h , vma , addr ) ; return page ; }","<S2SV_ModStart> ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> page * page <S2SV_ModEnd> ; long chg <S2SV_ModStart> ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z,"<S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug>"
6884,CWE-310,"void bn_mul_comba4 ( bn_ulong * r , bn_ulong * a , bn_ulong * b ) { bn_ulong t1 , t2 ; bn_ulong c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 3 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 2 ] , b [ 2 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 3 ] , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 3 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 3 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 3 ] , b [ 3 ] , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; r [ 7 ] = c2 ; }","<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug>"
1251,CWE-119,"static inline bool unconditional ( const struct ipt_ip * ip ) { static const struct ipt_ip uncond ; return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; # undef fwinv }","<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug>"
7189,CWE-552,"int oe_iov_sync ( const struct oe_iovec * iov , int iovcnt , const void * buf_ , size_t buf_size ) { struct oe_iovec * buf = ( struct oe_iovec * ) buf_ ; int ret = - 1 ; int i ; size_t n ; if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) ) goto done ; for ( i = 0 , n = buf_size ; i < iovcnt ; i ++ ) { if ( buf [ i ] . iov_len != iov [ i ] . iov_len ) goto done ; if ( buf [ i ] . iov_len ) { if ( buf [ i ] . iov_base && ! iov [ i ] . iov_base ) goto done ; if ( ! buf [ i ] . iov_base && iov [ i ] . iov_base ) goto done ; if ( ! buf [ i ] . iov_base ) continue ; if ( n < buf [ i ] . iov_len ) goto done ; { uint8_t * src = ( uint8_t * ) buf [ i ] . iov_base + ( uint64_t ) buf ; size_t src_size = buf [ i ] . iov_len ; uint8_t * dest = ( uint8_t * ) iov [ i ] . iov_base ; size_t dest_size = iov [ i ] . iov_len ; if ( src_size != dest_size ) goto done ; if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size ) goto done ; if ( oe_memcpy_s ( dest , dest_size , src , src_size ) != oe_ok ) goto done ; } } n -= buf [ i ] . iov_len ; } ret = 0 ; done : return ret ; }","<S2SV_ModStart> buf || src + src_size < src || src + src_size
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,<S2SV_StartBug> if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size ) <S2SV_EndBug>
3530,CWE-264,"static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , vcpu_regs_rax ) = tss -> eax ; * reg_write ( ctxt , vcpu_regs_rcx ) = tss -> ecx ; * reg_write ( ctxt , vcpu_regs_rdx ) = tss -> edx ; * reg_write ( ctxt , vcpu_regs_rbx ) = tss -> ebx ; * reg_write ( ctxt , vcpu_regs_rsp ) = tss -> esp ; * reg_write ( ctxt , vcpu_regs_rbp ) = tss -> ebp ; * reg_write ( ctxt , vcpu_regs_rsi ) = tss -> esi ; * reg_write ( ctxt , vcpu_regs_rdi ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , vcpu_sreg_ldtr ) ; set_segment_selector ( ctxt , tss -> es , vcpu_sreg_es ) ; set_segment_selector ( ctxt , tss -> cs , vcpu_sreg_cs ) ; set_segment_selector ( ctxt , tss -> ss , vcpu_sreg_ss ) ; set_segment_selector ( ctxt , tss -> ds , vcpu_sreg_ds ) ; set_segment_selector ( ctxt , tss -> fs , vcpu_sreg_fs ) ; set_segment_selector ( ctxt , tss -> gs , vcpu_sreg_gs ) ; if ( ctxt -> eflags & x86_eflags_vm ) { ctxt -> mode = x86emul_mode_vm86 ; cpl = 3 ; } else { ctxt -> mode = x86emul_mode_prot32 ; cpl = tss -> cs & 3 ; } ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , vcpu_sreg_ldtr , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> es , vcpu_sreg_es , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> cs , vcpu_sreg_cs , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> ss , vcpu_sreg_ss , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> ds , vcpu_sreg_ds , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> fs , vcpu_sreg_fs , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; ret = __load_segment_descriptor ( ctxt , tss -> gs , vcpu_sreg_gs , cpl , true ) ; if ( ret != x86emul_continue ) return ret ; return x86emul_continue ; }","<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug>"
5582,CWE-399,"void cib_remote_connection_destroy ( gpointer user_data ) { cib_client_t * client = user_data ; if ( client == null ) { return ; } crm_trace ( ""cleaning<s2sv_blank>up<s2sv_blank>after<s2sv_blank>client<s2sv_blank>disconnect:<s2sv_blank>%s/%s"" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != null ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( ""client<s2sv_blank>%s<s2sv_blank>not<s2sv_blank>found<s2sv_blank>in<s2sv_blank>the<s2sv_blank>hashtable"" , client -> name ) ; } } crm_trace ( ""destroying<s2sv_blank>%s<s2sv_blank>(%p)"" , client -> name , user_data ) ; num_clients -- ; crm_trace ( ""num<s2sv_blank>unfree\'d<s2sv_blank>clients:<s2sv_blank>%d"" , num_clients ) ; free ( client -> name ) ; free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; free ( client ) ; crm_trace ( ""freed<s2sv_blank>the<s2sv_blank>cib<s2sv_blank>client"" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }","<S2SV_ModStart> client = user_data ; int csock = 0 <S2SV_ModStart> num_clients ) ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <S2SV_ModStart> free ( client -> recv_buf ) ; free ( client
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,<S2SV_StartBug> cib_client_t * client = user_data ; <S2SV_EndBug> <S2SV_StartBug> free ( client -> name ) ; <S2SV_EndBug> <S2SV_StartBug> free ( client ) ; <S2SV_EndBug>
6557,CWE-119,static char * print_string ( cjson * item ) { return print_string_ptr ( item -> valuestring ) ; },"<S2SV_ModStart> cJSON * item , printbuffer * p <S2SV_ModStart> item -> valuestring , p
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug>
2392,CWE-119,"long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , unsigned int flags ) { struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg = { . fh = ff -> fh , . cmd = cmd , . arg = arg , . flags = flags } ; struct fuse_ioctl_out outarg ; struct fuse_req * req = null ; struct page * * pages = null ; struct page * iov_page = null ; struct iovec * in_iov = null , * out_iov = null ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; build_bug_on ( sizeof ( struct iovec ) * fuse_ioctl_max_iov > page_size ) ; err = - enomem ; pages = kzalloc ( sizeof ( pages [ 0 ] ) * fuse_max_pages_per_req , gfp_kernel ) ; iov_page = alloc_page ( gfp_kernel ) ; if ( ! pages || ! iov_page ) goto out ; if ( ! ( flags & fuse_ioctl_unrestricted ) ) { struct iovec * iov = page_address ( iov_page ) ; iov -> iov_base = ( void __user * ) arg ; iov -> iov_len = _ioc_size ( cmd ) ; if ( _ioc_dir ( cmd ) & _ioc_write ) { in_iov = iov ; in_iovs = 1 ; } if ( _ioc_dir ( cmd ) & _ioc_read ) { out_iov = iov ; out_iovs = 1 ; } } retry : inarg . in_size = in_size = iov_length ( in_iov , in_iovs ) ; inarg . out_size = out_size = iov_length ( out_iov , out_iovs ) ; out_size = max_t ( size_t , out_size , page_size ) ; max_pages = div_round_up ( max ( in_size , out_size ) , page_size ) ; err = - enomem ; if ( max_pages > fuse_max_pages_per_req ) goto out ; while ( num_pages < max_pages ) { pages [ num_pages ] = alloc_page ( gfp_kernel | __gfp_highmem ) ; if ( ! pages [ num_pages ] ) goto out ; num_pages ++ ; } req = fuse_get_req ( fc ) ; if ( is_err ( req ) ) { err = ptr_err ( req ) ; req = null ; goto out ; } memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ) ; req -> num_pages = num_pages ; req -> in . h . opcode = fuse_ioctl ; req -> in . h . nodeid = ff -> nodeid ; req -> in . numargs = 1 ; req -> in . args [ 0 ] . size = sizeof ( inarg ) ; req -> in . args [ 0 ] . value = & inarg ; if ( in_size ) { req -> in . numargs ++ ; req -> in . args [ 1 ] . size = in_size ; req -> in . argpages = 1 ; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ) ; if ( err ) goto out ; } req -> out . numargs = 2 ; req -> out . args [ 0 ] . size = sizeof ( outarg ) ; req -> out . args [ 0 ] . value = & outarg ; req -> out . args [ 1 ] . size = out_size ; req -> out . argpages = 1 ; req -> out . argvar = 1 ; fuse_request_send ( fc , req ) ; err = req -> out . h . error ; transferred = req -> out . args [ 1 ] . size ; fuse_put_request ( fc , req ) ; req = null ; if ( err ) goto out ; if ( outarg . flags & fuse_ioctl_retry ) { char * vaddr ; err = - eio ; if ( ! ( flags & fuse_ioctl_unrestricted ) ) goto out ; in_iovs = outarg . in_iovs ; out_iovs = outarg . out_iovs ; err = - enomem ; if ( in_iovs > fuse_ioctl_max_iov || out_iovs > fuse_ioctl_max_iov || in_iovs + out_iovs > fuse_ioctl_max_iov ) goto out ; vaddr = kmap_atomic ( pages [ 0 ] , km_user0 ) ; err = fuse_copy_ioctl_iovec ( page_address ( iov_page ) , vaddr , transferred , in_iovs + out_iovs , ( flags & fuse_ioctl_compat ) != 0 ) ; kunmap_atomic ( vaddr , km_user0 ) ; if ( err ) goto out ; in_iov = page_address ( iov_page ) ; out_iov = in_iov + in_iovs ; goto retry ; } err = - eio ; if ( transferred > inarg . out_size ) goto out ; err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ) ; out : if ( req ) fuse_put_request ( fc , req ) ; if ( iov_page ) __free_page ( iov_page ) ; while ( num_pages ) __free_page ( pages [ -- num_pages ] ) ; kfree ( pages ) ; return err ? err : outarg . result ; }","<S2SV_ModStart> + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
",torvalds@linux/7572777eef78ebdee1ecb7c258c0ef94d35bad16,CVE-2010-4650,https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16,2012-06-21T23:55Z,<S2SV_StartBug> goto retry ; <S2SV_EndBug>
30,CWE-200,"int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) { struct btrfs_path * path ; struct extent_buffer * leaf ; struct btrfs_file_extent_item * fi ; struct btrfs_key key ; struct btrfs_key found_key ; u64 extent_start = 0 ; u64 extent_num_bytes = 0 ; u64 extent_offset = 0 ; u64 item_end = 0 ; u64 last_size = new_size ; u32 found_type = ( u8 ) - 1 ; int found_extent ; int del_item ; int pending_del_nr = 0 ; int pending_del_slot = 0 ; int extent_type = - 1 ; int ret ; int err = 0 ; u64 ino = btrfs_ino ( inode ) ; u64 bytes_deleted = 0 ; bool be_nice = 0 ; bool should_throttle = 0 ; bool should_end = 0 ; bug_on ( new_size > 0 && min_type != btrfs_extent_data_key ) ; if ( ! btrfs_is_free_space_inode ( inode ) && test_bit ( btrfs_root_ref_cows , & root -> state ) ) be_nice = 1 ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - enomem ; path -> reada = - 1 ; if ( test_bit ( btrfs_root_ref_cows , & root -> state ) || root == root -> fs_info -> tree_root ) btrfs_drop_extent_cache ( inode , align ( new_size , root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; if ( min_type == 0 && root == btrfs_i ( inode ) -> root ) btrfs_kill_delayed_inode_items ( inode ) ; key . objectid = ino ; key . offset = ( u64 ) - 1 ; key . type = ( u8 ) - 1 ; search_again : if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { if ( btrfs_should_end_transaction ( trans , root ) ) { err = - eagain ; goto error ; } } path -> leave_spinning = 1 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; goto out ; } if ( ret > 0 ) { if ( path -> slots [ 0 ] == 0 ) goto out ; path -> slots [ 0 ] -- ; } while ( 1 ) { fi = null ; leaf = path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; found_type = found_key . type ; if ( found_key . objectid != ino ) break ; if ( found_type < min_type ) break ; item_end = found_key . offset ; if ( found_type == btrfs_extent_data_key ) { fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_file_extent_item ) ; extent_type = btrfs_file_extent_type ( leaf , fi ) ; if ( extent_type != btrfs_file_extent_inline ) { item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ; } else if ( extent_type == btrfs_file_extent_inline ) { item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ; } item_end -- ; } if ( found_type > min_type ) { del_item = 1 ; } else { if ( item_end < new_size ) break ; if ( found_key . offset >= new_size ) del_item = 1 ; else del_item = 0 ; } found_extent = 0 ; if ( found_type != btrfs_extent_data_key ) goto delete ; if ( del_item ) last_size = found_key . offset ; else last_size = new_size ; if ( extent_type != btrfs_file_extent_inline ) { u64 num_dec ; extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; if ( ! del_item ) { u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ; extent_num_bytes = align ( new_size - found_key . offset , root -> sectorsize ) ; btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ; num_dec = ( orig_num_bytes - extent_num_bytes ) ; if ( test_bit ( btrfs_root_ref_cows , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { extent_num_bytes = btrfs_file_extent_disk_num_bytes ( leaf , fi ) ; extent_offset = found_key . offset - btrfs_file_extent_offset ( leaf , fi ) ; num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; if ( extent_start != 0 ) { found_extent = 1 ; if ( test_bit ( btrfs_root_ref_cows , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ; } } } else if ( extent_type == btrfs_file_extent_inline ) { if ( ! del_item && btrfs_file_extent_compression ( leaf , fi ) == 0 && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { u32 size = new_size - found_key . offset ; if ( test_bit ( btrfs_root_ref_cows , & root -> state ) ) inode_sub_bytes ( inode , item_end + 1 - new_size ) ; btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; size = btrfs_file_extent_calc_inline_size ( size ) ; btrfs_truncate_item ( root , path , size , 1 ) ; } else if ( test_bit ( btrfs_root_ref_cows , & root -> state ) ) { inode_sub_bytes ( inode , item_end + 1 - found_key . offset ) ; } } delete : if ( del_item ) { if ( ! pending_del_nr ) { pending_del_slot = path -> slots [ 0 ] ; pending_del_nr = 1 ; } else if ( pending_del_nr && path -> slots [ 0 ] + 1 == pending_del_slot ) { pending_del_nr ++ ; pending_del_slot = path -> slots [ 0 ] ; } else { bug ( ) ; } } else { break ; } should_throttle = 0 ; if ( found_extent && ( test_bit ( btrfs_root_ref_cows , & root -> state ) || root == root -> fs_info -> tree_root ) ) { btrfs_set_path_blocking ( path ) ; bytes_deleted += extent_num_bytes ; ret = btrfs_free_extent ( trans , root , extent_start , extent_num_bytes , 0 , btrfs_header_owner ( leaf ) , ino , extent_offset , 0 ) ; bug_on ( ret ) ; if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) btrfs_async_run_delayed_refs ( root , trans -> delayed_ref_updates * 2 , 0 ) ; if ( be_nice ) { if ( truncate_space_check ( trans , root , extent_num_bytes ) ) { should_end = 1 ; } if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) { should_throttle = 1 ; } } } if ( found_type == btrfs_inode_item_key ) break ; if ( path -> slots [ 0 ] == 0 || path -> slots [ 0 ] != pending_del_slot || should_throttle || should_end ) { if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto error ; } pending_del_nr = 0 ; } btrfs_release_path ( path ) ; if ( should_throttle ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } if ( should_end ) { err = - eagain ; goto error ; } goto search_again ; } else { path -> slots [ 0 ] -- ; } } out : if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; } error : if ( root -> root_key . objectid != btrfs_tree_log_objectid ) btrfs_ordered_update_i_size ( inode , last_size , null ) ; btrfs_free_path ( path ) ; if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } return err ; }","<S2SV_ModStart> ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> if ( test_bit <S2SV_ModStart> state ) ) { <S2SV_ModStart> 1 - new_size <S2SV_ModEnd> ) ; }
",torvalds@linux/0305cd5f7fca85dae392b9ba85b116896eb7c1c7,CVE-2015-8374,https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7,2015-12-28T11:59Z,"<S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> <S2SV_StartBug> new_size ) ; <S2SV_EndBug>"
557,CWE-000,"int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = ocfs2_sb ( sb ) ; struct buffer_head * bh = null ; handle_t * handle = null ; struct dquot * transfer_to [ maxquotas ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) ocfs2_i ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( s_islnk ( inode -> i_mode ) ) attr -> ia_valid &= ~ attr_size ; # define ocfs2_valid_attrs ( attr_atime | attr_mtime | attr_ctime | attr_size | attr_gid | attr_uid | attr_mode ) if ( ! ( attr -> ia_valid & ocfs2_valid_attrs ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = s_isreg ( inode -> i_mode ) && attr -> ia_valid & attr_size ; if ( size_change ) { status = ocfs2_rw_lock ( inode , 1 ) ; if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ml_error , ""another<s2sv_blank>case<s2sv_blank>of<s2sv_blank>recursive<s2sv_blank>locking:\\n"" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - enospc ) mlog_errno ( status ) ; status = - enospc ; goto bail_unlock ; } } if ( ( attr -> ia_valid & attr_uid && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & attr_gid && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & attr_uid && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && ocfs2_has_ro_compat_feature ( sb , ocfs2_feature_ro_compat_usrquota ) ) { transfer_to [ usrquota ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( is_err ( transfer_to [ usrquota ] ) ) { status = ptr_err ( transfer_to [ usrquota ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & attr_gid && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && ocfs2_has_ro_compat_feature ( sb , ocfs2_feature_ro_compat_grpquota ) ) { transfer_to [ grpquota ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( is_err ( transfer_to [ grpquota ] ) ) { status = ptr_err ( transfer_to [ grpquota ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , ocfs2_inode_update_credits + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( is_err ( handle ) ) { status = ptr_err ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , ocfs2_inode_update_credits ) ; if ( is_err ( handle ) ) { status = ptr_err ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < ocfs2_maxquotas ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & attr_mode ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }","<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
",torvalds@linux/28f5a8a7c033cbf3e32277f4cc9c6afd74f05300,CVE-2017-18204,https://github.com/torvalds/linux/commit/28f5a8a7c033cbf3e32277f4cc9c6afd74f05300,2018-02-27T20:29Z,"<S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug>"
3483,CWE-264,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""bad<s2sv_blank>offset<s2sv_blank>%p\\n"" , e ) ; return - einval ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<s2sv_blank>element<s2sv_blank>%p<s2sv_blank>size<s2sv_blank>%u\\n"" , e , e -> next_offset ) ; return - einval ; } if ( ! arp_checkentry ( & e -> arp ) ) return - einval ; err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; if ( err ) return err ; for ( h = 0 ; h < nf_arp_numhooks ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""underflows<s2sv_blank>must<s2sv_blank>be<s2sv_blank>unconditional<s2sv_blank>and<s2sv_blank>"" ""use<s2sv_blank>the<s2sv_blank>standard<s2sv_blank>target<s2sv_blank>with<s2sv_blank>"" ""accept/drop\\n"" ) ; return - einval ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }","<S2SV_ModStart> , e -> elems , e ->
",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug>"
5424,CWE-119,"hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = null ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == null ) goto error ; h -> msglvl = flags & hivex_open_msglvl_mask ; const char * debug = getenv ( ""hivex_debug"" ) ; if ( debug && streq ( debug , ""1"" ) ) h -> msglvl = 2 ; debug ( 2 , ""created<s2sv_blank>handle<s2sv_blank>%p"" , h ) ; h -> writable = ! ! ( flags & hivex_open_write ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == null ) goto error ; # ifdef o_cloexec h -> fd = open ( filename , o_rdonly | o_cloexec | o_binary ) ; # else h -> fd = open ( filename , o_rdonly | o_binary ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef o_cloexec fcntl ( h -> fd , f_setfd , fd_cloexec ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { set_errno ( einval , ""%s:<s2sv_blank>file<s2sv_blank>is<s2sv_blank>too<s2sv_blank>small<s2sv_blank>to<s2sv_blank>be<s2sv_blank>a<s2sv_blank>windows<s2sv_blank>nt<s2sv_blank>registry<s2sv_blank>hive<s2sv_blank>file"" , filename ) ; goto error ; } if ( ! h -> writable ) { h -> addr = mmap ( null , h -> size , prot_read , map_shared , h -> fd , 0 ) ; if ( h -> addr == map_failed ) goto error ; debug ( 2 , ""mapped<s2sv_blank>file<s2sv_blank>at<s2sv_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == null ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { set_errno ( enotsup , ""%s:<s2sv_blank>not<s2sv_blank>a<s2sv_blank>windows<s2sv_blank>nt<s2sv_blank>registry<s2sv_blank>hive<s2sv_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { set_errno ( enotsup , ""%s:<s2sv_blank>hive<s2sv_blank>file<s2sv_blank>major<s2sv_blank>version<s2sv_blank>%"" priu32 ""<s2sv_blank>(expected<s2sv_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == null ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { set_errno ( einval , ""%s:<s2sv_blank>bad<s2sv_blank>checksum<s2sv_blank>in<s2sv_blank>hive<s2sv_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<s2sv_blank>header<s2sv_blank>fields:\\n"" ""<s2sv_blank><s2sv_blank>file<s2sv_blank>version<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%"" priu32 "".%"" priu32 ""\\n"" ""<s2sv_blank><s2sv_blank>sequence<s2sv_blank>nos<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%"" priu32 ""<s2sv_blank>%"" priu32 ""\\n"" ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(sequences<s2sv_blank>nos<s2sv_blank>should<s2sv_blank>match<s2sv_blank>if<s2sv_blank>hive<s2sv_blank>was<s2sv_blank>synched<s2sv_blank>at<s2sv_blank>shutdown)\\n"" ""<s2sv_blank><s2sv_blank>last<s2sv_blank>modified<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%"" priu64 ""\\n"" ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(windows<s2sv_blank>filetime,<s2sv_blank>x<s2sv_blank>100<s2sv_blank>ns<s2sv_blank>since<s2sv_blank>1601-01-01)\\n"" ""<s2sv_blank><s2sv_blank>original<s2sv_blank>file<s2sv_blank>name<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%s\\n"" ""<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>(only<s2sv_blank>32<s2sv_blank>chars<s2sv_blank>are<s2sv_blank>stored,<s2sv_blank>name<s2sv_blank>is<s2sv_blank>probably<s2sv_blank>truncated)\\n"" ""<s2sv_blank><s2sv_blank>root<s2sv_blank>offset<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>0x%x<s2sv_blank>+<s2sv_blank>0x1000\\n"" ""<s2sv_blank><s2sv_blank>end<s2sv_blank>of<s2sv_blank>last<s2sv_blank>page<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>0x%x<s2sv_blank>+<s2sv_blank>0x1000<s2sv_blank>(total<s2sv_blank>file<s2sv_blank>size<s2sv_blank>0x%zx)\\n"" ""<s2sv_blank><s2sv_blank>checksum<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>0x%x<s2sv_blank>(calculated<s2sv_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<s2sv_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; debug ( 2 , ""root<s2sv_blank>offset<s2sv_blank>=<s2sv_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = size_max , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = size_max , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { set_errno ( enotsup , ""%s:<s2sv_blank>trailing<s2sv_blank>garbage<s2sv_blank>at<s2sv_blank>end<s2sv_blank>of<s2sv_blank>file<s2sv_blank>"" ""(at<s2sv_blank>0x%zx,<s2sv_blank>after<s2sv_blank>%zu<s2sv_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; debug ( 2 , ""page<s2sv_blank>at<s2sv_blank>0x%zx,<s2sv_blank>size<s2sv_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { set_errno ( enotsup , ""%s:<s2sv_blank>page<s2sv_blank>size<s2sv_blank>%zu<s2sv_blank>at<s2sv_blank>0x%zx,<s2sv_blank>bad<s2sv_blank>registry"" , filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { set_errno ( enotsup , ""%s:<s2sv_blank>block<s2sv_blank>size<s2sv_blank>%"" priu32 ""<s2sv_blank>at<s2sv_blank>0x%zx,<s2sv_blank>bad<s2sv_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<s2sv_blank>%s:<s2sv_blank>"" ""%s<s2sv_blank>block<s2sv_blank>id<s2sv_blank>%d,%d<s2sv_blank>(%c%c)<s2sv_blank>at<s2sv_blank>0x%zx<s2sv_blank>size<s2sv_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<s2sv_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; bitmap_set ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { set_errno ( enotsup , ""%s:<s2sv_blank>no<s2sv_blank>root<s2sv_blank>block<s2sv_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { set_errno ( enotsup , ""%s:<s2sv_blank>bad<s2sv_blank>root<s2sv_blank>block<s2sv_blank>(free<s2sv_blank>or<s2sv_blank>not<s2sv_blank>nk)"" , filename ) ; goto error ; } debug ( 1 , ""successfully<s2sv_blank>read<s2sv_blank>windows<s2sv_blank>registry<s2sv_blank>hive<s2sv_blank>file:\\n"" ""<s2sv_blank><s2sv_blank>pages:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu<s2sv_blank>[sml:<s2sv_blank>%zu,<s2sv_blank>lge:<s2sv_blank>%zu]\\n"" ""<s2sv_blank><s2sv_blank>blocks:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu<s2sv_blank>[sml:<s2sv_blank>%zu,<s2sv_blank>avg:<s2sv_blank>%zu,<s2sv_blank>lge:<s2sv_blank>%zu]\\n"" ""<s2sv_blank><s2sv_blank>blocks<s2sv_blank>used:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu\\n"" ""<s2sv_blank><s2sv_blank>bytes<s2sv_blank>used:<s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank><s2sv_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != map_failed ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return null ; }","<S2SV_ModStart> ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry""
",libguestfs@hivex/4bbdf555f88baeae0fa804a369a81a83908bd705,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/4bbdf555f88baeae0fa804a369a81a83908bd705,2014-12-08T16:59Z,"<S2SV_StartBug> ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , <S2SV_EndBug>"
1,CWE-362,"static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + flush_pending_timeout ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { flush_rq -> mq_ctx = first_rq -> mq_ctx ; flush_rq -> tag = first_rq -> tag ; } flush_rq -> cmd_type = req_type_fs ; flush_rq -> cmd_flags = write_flush | req_flush_seq ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }","<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,<S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug>
2500,CWE-20,"static fp_info * fp_set_per_packet_inf_from_conv ( umts_fp_conversation_info_t * p_conv_data , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree _u_ ) { fp_info * fpi ; guint8 tfi , c_t ; int offset = 0 , i = 0 , j = 0 , num_tbs , chan , tb_size , tb_bit_off ; gboolean is_control_frame ; umts_mac_info * macinf ; rlc_info * rlcinf ; guint8 fake_lchid = 0 ; gint * cur_val = null ; fpi = wmem_new0 ( wmem_file_scope ( ) , fp_info ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 , fpi ) ; fpi -> iface_type = p_conv_data -> iface_type ; fpi -> division = p_conv_data -> division ; fpi -> release = 7 ; fpi -> release_year = 2006 ; fpi -> release_month = 12 ; fpi -> channel = p_conv_data -> channel ; fpi -> dch_crc_present = p_conv_data -> dch_crc_present ; fpi -> link_type = fp_link_ethernet ; # if 0 if ( ! pinfo -> fd -> flags . visited && p_conv_data -> reset_frag ) { fpi -> reset_frag = p_conv_data -> reset_frag ; p_conv_data -> reset_frag = false ; } # endif fpi -> srcport = pinfo -> srcport ; fpi -> destport = pinfo -> destport ; fpi -> com_context_id = p_conv_data -> com_context_id ; if ( pinfo -> link_dir == p2p_dir_ul ) { fpi -> is_uplink = true ; } else { fpi -> is_uplink = false ; } is_control_frame = tvb_get_guint8 ( tvb , offset ) & 0x01 ; switch ( fpi -> channel ) { case channel_hsdsch : fpi -> hsdsch_entity = p_conv_data -> hsdsch_entity ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; fpi -> hsdsch_macflowd_id = p_conv_data -> hsdsch_macdflow_id ; macinf -> content [ 0 ] = hsdsch_macdflow_id_mac_content_map [ p_conv_data -> hsdsch_macdflow_id ] ; macinf -> lchid [ 0 ] = p_conv_data -> hsdsch_macdflow_id ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; rlcinf -> mode [ 0 ] = hsdsch_macdflow_id_rlc_map [ p_conv_data -> hsdsch_macdflow_id ] ; if ( fpi -> hsdsch_entity == hs ) { for ( i = 0 ; i < max_num_hsdhsch_macdflow ; i ++ ) { if ( ( cur_val = ( gint * ) g_tree_lookup ( hsdsch_muxed_flows , gint_to_pointer ( ( gint ) p_conv_data -> hrnti ) ) ) != null ) { j = 1 << i ; fpi -> hsdhsch_macfdlow_is_mux [ i ] = j & * cur_val ; } else { fpi -> hsdhsch_macfdlow_is_mux [ i ] = false ; } } } rlcinf -> urnti [ 0 ] = fpi -> com_context_id ; rlcinf -> li_size [ 0 ] = rlc_li_7bits ; rlcinf -> ciphered [ 0 ] = false ; rlcinf -> deciphered [ 0 ] = false ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; return fpi ; case channel_edch : macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; fpi -> no_ddi_entries = p_conv_data -> no_ddi_entries ; for ( i = 0 ; i < fpi -> no_ddi_entries ; i ++ ) { fpi -> edch_ddi [ i ] = p_conv_data -> edch_ddi [ i ] ; fpi -> edch_macd_pdu_size [ i ] = p_conv_data -> edch_macd_pdu_size [ i ] ; fpi -> edch_lchid [ i ] = p_conv_data -> edch_lchid [ i ] ; } fpi -> edch_type = p_conv_data -> edch_type ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; rlcinf -> urnti [ 0 ] = fpi -> com_context_id ; rlcinf -> li_size [ 0 ] = rlc_li_7bits ; rlcinf -> ciphered [ 0 ] = false ; rlcinf -> deciphered [ 0 ] = false ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; return fpi ; case channel_pch : fpi -> paging_indications = p_conv_data -> paging_indications ; fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } offset = 3 ; break ; case channel_dch : fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; offset = 2 ; fakes = 5 ; for ( chan = 0 ; chan < fpi -> num_chans ; chan ++ ) { tfi = tvb_get_bits8 ( tvb , 3 + offset * 8 , 5 ) ; num_tbs = ( fpi -> is_uplink ) ? p_conv_data -> fp_dch_channel_info [ chan ] . ul_chan_num_tbs [ tfi ] : p_conv_data -> fp_dch_channel_info [ chan ] . dl_chan_num_tbs [ tfi ] ; tb_size = ( fpi -> is_uplink ) ? p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_tf_size [ tfi ] : p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_tf_size [ tfi ] ; if ( p_conv_data -> dchs_in_flow_list [ chan ] != 31 && ( p_conv_data -> dchs_in_flow_list [ chan ] == 24 && tb_size != 340 ) ) { fake_lchid = make_fake_lchid ( pinfo , p_conv_data -> dchs_in_flow_list [ chan ] ) ; } tb_bit_off = ( 2 + p_conv_data -> num_dch_in_flow ) * 8 ; for ( j = 0 ; j < num_tbs && j + chan < max_mac_frames ; j ++ ) { macinf -> trchid [ j + chan ] = p_conv_data -> dchs_in_flow_list [ chan ] ; if ( p_conv_data -> dchs_in_flow_list [ chan ] == 31 || p_conv_data -> dchs_in_flow_list [ chan ] == 24 ) { if ( 0 ) { macinf -> ctmux [ j + chan ] = false ; macinf -> lchid [ j + chan ] = 1 ; macinf -> content [ j + chan ] = lchid_type_table [ 1 ] ; rlcinf -> mode [ j + chan ] = lchid_rlc_map [ 1 ] ; } else if ( p_conv_data -> dchs_in_flow_list [ chan ] == 24 && tb_size != 340 ) { macinf -> ctmux [ j + chan ] = false ; macinf -> lchid [ j + chan ] = fake_lchid ; macinf -> fake_chid [ j + chan ] = true ; macinf -> content [ j + chan ] = mac_content_ps_dtch ; rlcinf -> mode [ j + chan ] = rlc_am ; } else { macinf -> ctmux [ j + chan ] = true ; c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; macinf -> lchid [ j + chan ] = c_t + 1 ; macinf -> content [ j + chan ] = lchid_type_table [ c_t + 1 ] ; rlcinf -> mode [ j + chan ] = lchid_rlc_map [ c_t + 1 ] ; } } else { fake_lchid = make_fake_lchid ( pinfo , p_conv_data -> dchs_in_flow_list [ chan ] ) ; macinf -> ctmux [ j + chan ] = false ; macinf -> content [ j + chan ] = lchid_type_table [ fake_lchid ] ; rlcinf -> mode [ j + chan ] = lchid_rlc_map [ fake_lchid ] ; macinf -> fake_chid [ j + chan ] = true ; macinf -> lchid [ j + chan ] = fake_lchid ; } rlcinf -> urnti [ j + chan ] = p_conv_data -> com_context_id ; rlcinf -> li_size [ j + chan ] = rlc_li_7bits ; # if 0 if ( rrc_ciph_inf && g_tree_lookup ( rrc_ciph_inf , gint_to_pointer ( ( gint ) p_conv_data -> com_context_id ) ) != null ) { rlcinf -> ciphered [ j + chan ] = true ; } else { rlcinf -> ciphered [ j + chan ] = false ; } # endif rlcinf -> ciphered [ j + chan ] = false ; rlcinf -> deciphered [ j + chan ] = false ; rlcinf -> rbid [ j + chan ] = macinf -> lchid [ j + chan ] ; tb_bit_off += tb_size + 4 ; } offset ++ ; } p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; offset = 2 ; break ; case channel_fach_fdd : fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } offset = 2 ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; macinf -> ctmux [ 0 ] = 1 ; macinf -> content [ 0 ] = mac_content_dcch ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; rlcinf -> urnti [ 0 ] = fpi -> channel ; rlcinf -> mode [ 0 ] = rlc_am ; rlcinf -> li_size [ 0 ] = rlc_li_7bits ; rlcinf -> ciphered [ 0 ] = false ; rlcinf -> deciphered [ 0 ] = false ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; break ; case channel_rach_fdd : fpi -> num_chans = p_conv_data -> num_dch_in_flow ; if ( is_control_frame ) { return fpi ; } offset = 2 ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; for ( chan = 0 ; chan < fpi -> num_chans ; chan ++ ) { macinf -> ctmux [ chan ] = 1 ; macinf -> content [ chan ] = mac_content_dcch ; rlcinf -> urnti [ chan ] = fpi -> com_context_id ; } p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; break ; case channel_hsdsch_common : rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; break ; default : expert_add_info ( pinfo , null , & ei_fp_transport_channel_type_unknown ) ; return null ; } for ( i = 0 ; i < fpi -> num_chans ; i ++ ) { tfi = tvb_get_guint8 ( tvb , offset ) ; if ( pinfo -> link_dir == p2p_dir_ul ) { fpi -> chan_tf_size [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_tf_size [ tfi ] ; fpi -> chan_num_tbs [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_num_tbs [ tfi ] ; } else { fpi -> chan_tf_size [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_tf_size [ tfi ] ; fpi -> chan_num_tbs [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_num_tbs [ tfi ] ; } offset ++ ; } return fpi ; }","<S2SV_ModStart> ; c_t = ( <S2SV_ModStart> , 4 ) + 1 ) % 0xf <S2SV_ModStart> ] = c_t <S2SV_ModEnd> ; macinf -> <S2SV_ModStart> lchId_type_table [ c_t <S2SV_ModEnd> ] ; rlcinf <S2SV_ModStart> lchId_rlc_map [ c_t <S2SV_ModEnd> ] ; }
",wireshark@wireshark/7d7190695ce2ff269fdffb04e87139995cde21f4,CVE-2016-5353,https://github.com/wireshark/wireshark/commit/7d7190695ce2ff269fdffb04e87139995cde21f4,2016-08-07T16:59Z,"<S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug>"
7178,CWE-552,"static int _hostsock_getsockname ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; oe_errno = 0 ; if ( ! sock ) oe_raise_errno ( oe_einval ) ; if ( addrlen ) addrlen_in = * addrlen ; if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , addrlen ) != oe_ok ) { oe_raise_errno ( oe_einval ) ; } done : return ret ; }","<S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; addrlen_in = * addrlen ; if ( addrlen_in < 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> oe_syscall_getsockname_ocall ( & <S2SV_ModStart> -> host_fd , <S2SV_ModEnd> addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,"<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> ( struct oe_sockaddr * ) addr , <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug>"
2612,CWE-476,"static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - einval ; if ( tmp >= o2nm_max_nodes ) return - erange ; if ( ! test_bit ( o2nm_node_attr_address , & node -> nd_set_attributes ) || ! test_bit ( o2nm_node_attr_port , & node -> nd_set_attributes ) ) return - einval ; write_lock ( & cluster -> cl_nodes_lock ) ; if ( cluster -> cl_nodes [ tmp ] ) ret = - eexist ; else if ( test_and_set_bit ( o2nm_node_attr_num , & node -> nd_set_attributes ) ) ret = - ebusy ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; if ( ret ) return ret ; return count ; }","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
",torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug>
4189,CWE-120,"static int try_read_command_binary ( conn * c ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { memcpy ( & c -> binary_header , c -> rcurr , sizeof ( c -> binary_header ) ) ; protocol_binary_request_header * req ; req = & c -> binary_header ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d<s2sv_blank>read<s2sv_blank>binary<s2sv_blank>protocol<s2sv_blank>data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d<s2sv_blank><s2sv_blank><s2sv_blank>"" , c -> sfd ) ; } fprintf ( stderr , ""<s2sv_blank>0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != protocol_binary_req ) { if ( settings . verbose ) { fprintf ( stderr , ""invalid<s2sv_blank>magic:<s2sv_blank><s2sv_blank>%x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } uint8_t extlen = c -> binary_header . request . extlen ; uint16_t keylen = c -> binary_header . request . keylen ; if ( c -> rbytes < keylen + extlen + sizeof ( c -> binary_header ) ) { return 0 ; } if ( ! resp_start ( c ) ) { conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; c -> last_cmd_time = current_time ; char extbuf [ sizeof ( c -> binary_header ) + bin_max_extlen ] ; memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ; c -> rbytes -= sizeof ( c -> binary_header ) + extlen + keylen ; c -> rcurr += sizeof ( c -> binary_header ) + extlen + keylen ; dispatch_bin_command ( c , extbuf ) ; } return 1 ; }","<S2SV_ModStart> ) + BIN_MAX_EXTLEN + 1 <S2SV_ModStart> binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN :
",memcached@memcached/02c6a2b62ddcb6fa4569a591d3461a156a636305,CVE-2020-10931,https://github.com/memcached/memcached/commit/02c6a2b62ddcb6fa4569a591d3461a156a636305,2020-03-24T15:15Z,"<S2SV_StartBug> char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ; <S2SV_EndBug>"
4319,CWE-787,"int tcp_test ( const char * ip_str , const short port ) { int sock , i ; struct sockaddr_in s_in ; int packetsize = 1024 ; unsigned char packet [ packetsize ] ; struct timeval tv , tv2 , tv3 ; int caplen = 0 ; int times [ requests ] ; int min , avg , max , len ; struct net_hdr nh ; tv3 . tv_sec = 0 ; tv3 . tv_usec = 1 ; s_in . sin_family = pf_inet ; s_in . sin_port = htons ( port ) ; if ( ! inet_aton ( ip_str , & s_in . sin_addr ) ) return - 1 ; if ( ( sock = socket ( s_in . sin_family , sock_stream , ipproto_tcp ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , f_setfl , o_nonblock ) < 0 ) { perror ( ""fcntl(o_nonblock)<s2sv_blank>failed"" ) ; return ( 1 ) ; } gettimeofday ( & tv , null ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != einprogress && errno != ealready ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""failed<s2sv_blank>to<s2sv_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , null ) ; break ; } gettimeofday ( & tv2 , null ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 3000 * 1000 ) ) { printf ( ""connection<s2sv_blank>timed<s2sv_blank>out\\n"" ) ; close ( sock ) ; return ( - 1 ) ; } usleep ( 10 ) ; } pct ; printf ( ""tcp<s2sv_blank>connection<s2sv_blank>successful\\n"" ) ; memset ( & nh , 0 , sizeof ( nh ) ) ; nh . nh_type = 2 ; nh . nh_len = htonl ( 0 ) ; if ( send ( sock , & nh , sizeof ( nh ) , 0 ) != sizeof ( nh ) ) { perror ( ""send"" ) ; return - 1 ; } gettimeofday ( & tv , null ) ; i = 0 ; while ( 1 ) { caplen = read ( sock , & nh , sizeof ( nh ) ) ; if ( caplen == - 1 ) { if ( errno != eagain ) { perror ( ""read"" ) ; return - 1 ; } } if ( ( unsigned ) caplen == sizeof ( nh ) ) { len = ntohl ( nh . nh_len ) ; if ( nh . nh_type == 1 && i == 0 ) { i = 1 ; caplen = read ( sock , packet , len ) ; if ( caplen == len ) { i = 2 ; break ; } else { i = 0 ; } } else { caplen = read ( sock , packet , len ) ; } } gettimeofday ( & tv2 , null ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } if ( caplen == - 1 ) usleep ( 10 ) ; } if ( i == 2 ) { pct ; printf ( ""airserv-ng<s2sv_blank>found\\n"" ) ; } else { pct ; printf ( ""airserv-ng<s2sv_blank>not<s2sv_blank>found\\n"" ) ; } close ( sock ) ; for ( i = 0 ; i < requests ; i ++ ) { if ( ( sock = socket ( s_in . sin_family , sock_stream , ipproto_tcp ) ) == - 1 ) return - 1 ; if ( fcntl ( sock , f_setfl , o_nonblock ) < 0 ) { perror ( ""fcntl(o_nonblock)<s2sv_blank>failed"" ) ; return ( 1 ) ; } usleep ( 1000 ) ; gettimeofday ( & tv , null ) ; while ( 1 ) { if ( connect ( sock , ( struct sockaddr * ) & s_in , sizeof ( s_in ) ) == - 1 ) { if ( errno != einprogress && errno != ealready ) { perror ( ""connect"" ) ; close ( sock ) ; printf ( ""failed<s2sv_blank>to<s2sv_blank>connect\\n"" ) ; return - 1 ; } } else { gettimeofday ( & tv2 , null ) ; break ; } gettimeofday ( & tv2 , null ) ; if ( ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) > ( 1000 * 1000 ) ) { break ; } select ( 1 , null , null , null , & tv3 ) ; } times [ i ] = ( ( tv2 . tv_sec * 1000000 - tv . tv_sec * 1000000 ) + ( tv2 . tv_usec - tv . tv_usec ) ) ; printf ( ""\\r%d/%d\\r"" , i , requests ) ; fflush ( stdout ) ; close ( sock ) ; } min = int_max ; avg = 0 ; max = 0 ; for ( i = 0 ; i < requests ; i ++ ) { if ( times [ i ] < min ) min = times [ i ] ; if ( times [ i ] > max ) max = times [ i ] ; avg += times [ i ] ; } avg /= requests ; pct ; printf ( ""ping<s2sv_blank>%s:%d<s2sv_blank>(min/avg/max):<s2sv_blank>%.3fms/%.3fms/%.3fms\\n"" , ip_str , port , min / 1000.0 , avg / 1000.0 , max / 1000.0 ) ; return 0 ; }","<S2SV_ModStart> ; if ( len > 1024 || len < 0 ) continue ; if (
",aircrack-ng@aircrack-ng/091b153f294b9b695b0b2831e65936438b550d7b,CVE-2014-8322,https://github.com/aircrack-ng/aircrack-ng/commit/091b153f294b9b695b0b2831e65936438b550d7b,2020-01-31T22:15Z,<S2SV_StartBug> if ( nh . nh_type == 1 && i == 0 ) <S2SV_EndBug>
6737,CWE-522,"int imap_open_connection ( struct imapaccountdata * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = imap_connected ; if ( imap_cmd_step ( adata ) != imap_res_ok ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""*<s2sv_blank>ok"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""*<s2sv_blank>ok<s2sv_blank>[capability"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef use_ssl if ( ( adata -> conn -> ssf == 0 ) && ( c_sslforcetls || ( adata -> capabilities & imap_cap_starttls ) ) ) { enum quadoption ans ; if ( c_sslforcetls ) ans = mutt_yes ; else if ( ( ans = query_quadoption ( c_sslstarttls , _ ( ""secure<s2sv_blank>connection<s2sv_blank>with<s2sv_blank>tls?"" ) ) ) == mutt_abort ) { goto err_close_conn ; } if ( ans == mutt_yes ) { enum imapexecresult rc = imap_exec ( adata , ""starttls"" , imap_cmd_single ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == imap_exec_fatal ) goto bail ; if ( rc != imap_exec_error ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""could<s2sv_blank>not<s2sv_blank>negotiate<s2sv_blank>tls<s2sv_blank>connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""capability"" , imap_cmd_no_flags ) ) goto bail ; } } } } if ( c_sslforcetls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""encrypted<s2sv_blank>connection<s2sv_blank>unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""*<s2sv_blank>preauth"" ) ) { # ifdef use_ssl if ( ( adata -> conn -> ssf == 0 ) && c_sslforcetls ) { mutt_error ( _ ( ""encrypted<s2sv_blank>connection<s2sv_blank>unavailable"" ) ) ; goto err_close_conn ; } # endif adata -> state = imap_authenticated ; if ( check_capabilities ( adata ) != 0 ) goto bail ; free ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef use_ssl err_close_conn : imap_close_connection ( adata ) ; # endif bail : free ( & adata -> capstr ) ; return - 1 ; }","<S2SV_ModStart> ) { goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> return 0 ; bail <S2SV_ModEnd> : imap_close_connection ( <S2SV_ModStart> adata ) ; <S2SV_ModEnd> FREE ( &
",neomutt@neomutt/9c36717a3e2af1f2c1b7242035455ec8112b4b06,CVE-2020-28896,https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06,2020-11-23T19:15Z,<S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug>
2649,CWE-399,"static int udp_push_pending_frames ( struct sock * sk ) { struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct flowi4 * fl4 = & inet -> cork . fl . u . ip4 ; struct sk_buff * skb ; int err = 0 ; skb = ip_finish_skb ( sk , fl4 ) ; if ( ! skb ) goto out ; err = udp_send_skb ( skb , fl4 ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int udp_push_pending_frames (
",torvalds@linux/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1,CVE-2013-4162,https://github.com/torvalds/linux/commit/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1,2013-07-29T13:59Z,<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug>
287,CWE-416,"static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & perf_ef_start ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { warn_on_once ( swhash -> online ) ; return - einval ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
",torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z,<S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
6871,CWE-79,"static int rndr_quote ( struct buf * ob , const struct buf * text , void * opaque ) { if ( ! text || ! text -> size ) return 0 ; bufputsl ( ob , ""<q>"" ) ; bufput ( ob , text -> data , text -> size ) ; bufputsl ( ob , ""</q>"" ) ; return 1 ; }","<S2SV_ModStart> return 0 ; struct html_renderopt * options = opaque ; <S2SV_ModStart> ""<q>"" ) ; if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ; else
",vmg@redcarpet/a699c82292b17c8e6a62e1914d5eccc252272793,CVE-2020-26298,https://github.com/vmg/redcarpet/commit/a699c82292b17c8e6a62e1914d5eccc252272793,2021-01-11T19:15Z,"<S2SV_StartBug> BUFPUTSL ( ob , ""<q>"" ) ; <S2SV_EndBug>"
3086,CWE-264,"static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { int i ; int ret ; ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < pci_rom_resource ; i ++ ) { if ( dev -> resource [ i ] . flags & ioresource_io ) * value |= pci_command_io ; if ( dev -> resource [ i ] . flags & ioresource_mem ) * value |= pci_command_memory ; } return ret ; }","<S2SV_ModStart> ) { int ret = pci_read_config_word <S2SV_ModEnd> ( dev , <S2SV_ModStart> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> * value |= <S2SV_ModStart> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ;
",torvalds@linux/af6fc858a35b90e89ea7a7ee58e66628c55c776b,CVE-2015-2150,https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b,2015-03-12T14:59Z,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug>"
6332,CWE-772,"chrand_ret * chrand_principal_2_svc ( chrand_arg * arg , struct svc_req * rqstp ) { static chrand_ret ret ; krb5_keyblock * k ; int nkeys ; char * prime_arg , * funcname ; gss_buffer_desc client_name , service_name ; om_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = null ; xdr_free ( xdr_chrand_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_randkey_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = kadm5_failure ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = kadm5_bad_principal ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = randkey_principal_wrapper_3 ( ( void * ) handle , arg -> princ , false , 0 , null , & k , & nkeys ) ; } else if ( ! ( changepw_service ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , acl_changepw , arg -> princ , null ) ) { ret . code = kadm5_randkey_principal ( ( void * ) handle , arg -> princ , & k , & nkeys ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = kadm5_auth_changepw ; } if ( ret . code == kadm5_ok ) { ret . keys = k ; ret . n_keys = nkeys ; } if ( ret . code != kadm5_auth_changepw ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != null ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug>"
4200,CWE-772,"static image * readpalmimage ( const imageinfo * image_info , exceptioninfo * exception ) { image * image ; magickbooleantype status ; magickoffsettype totaloffset , seeknextdepth ; pixelinfo transpix ; quantum index ; register ssize_t i , x ; register quantum * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextdepthoffset , transparentindex , compressiontype , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char * lastrow , * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; if ( image_info -> debug != magickfalse ) ( void ) logmagickevent ( traceevent , getmagickmodule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { ( void ) destroyimagelist ( image ) ; return ( ( image * ) null ) ; } totaloffset = 0 ; do { image -> columns = readblobmsbshort ( image ) ; image -> rows = readblobmsbshort ( image ) ; if ( eofblob ( image ) != magickfalse ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) throwreaderexception ( corruptimageerror , ""negativeorzeroimagesize"" ) ; status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; bytes_per_row = readblobmsbshort ( image ) ; flags = readblobmsbshort ( image ) ; bits_per_pixel = ( size_t ) readblobbyte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) throwreaderexception ( corruptimageerror , ""unrecognizedbitsperpixel"" ) ; version = ( size_t ) readblobbyte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) throwreaderexception ( corruptimageerror , ""fileformatversionmismatch"" ) ; nextdepthoffset = ( size_t ) readblobmsbshort ( image ) ; transparentindex = ( size_t ) readblobbyte ( image ) ; compressiontype = ( size_t ) readblobbyte ( image ) ; if ( ( compressiontype != palm_compression_none ) && ( compressiontype != palm_compression_scanline ) && ( compressiontype != palm_compression_rle ) ) throwreaderexception ( corruptimageerror , ""unrecognizedimagecompression"" ) ; pad = readblobmsbshort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( acquireimagecolormap ( image , one << bits_per_pixel , exception ) == magickfalse ) ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; getpixelinfo ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) readblobbyte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) readblobbyte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) readblobbyte ( image ) ; ( void ) bluebits ; readblobbyte ( image ) ; readblobbyte ( image ) ; transpix . red = ( double ) ( quantumrange * readblobbyte ( image ) / 31 ) ; transpix . green = ( double ) ( quantumrange * readblobbyte ( image ) / 63 ) ; transpix . blue = ( double ) ( quantumrange * readblobbyte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { ssize_t index ; if ( flags & palm_has_colormap_flag ) { count = ( ssize_t ) readblobmsbshort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { readblobbyte ( image ) ; index = constraincolormapindex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( magickrealtype ) scalechartoquantum ( ( unsigned char ) readblobbyte ( image ) ) ; image -> colormap [ index ] . green = ( magickrealtype ) scalechartoquantum ( ( unsigned char ) readblobbyte ( image ) ) ; image -> colormap [ index ] . blue = ( magickrealtype ) scalechartoquantum ( ( unsigned char ) readblobbyte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1l << bits_per_pixel ) ; i ++ ) { index = constraincolormapindex ( image , 255 - i , exception ) ; image -> colormap [ index ] . red = ( magickrealtype ) scalechartoquantum ( palmpalette [ i ] [ 0 ] ) ; image -> colormap [ index ] . green = ( magickrealtype ) scalechartoquantum ( palmpalette [ i ] [ 1 ] ) ; image -> colormap [ index ] . blue = ( magickrealtype ) scalechartoquantum ( palmpalette [ i ] [ 2 ] ) ; } } if ( flags & palm_is_compressed_flag ) size = readblobmsbshort ( image ) ; ( void ) size ; image -> storage_class = directclass ; if ( bits_per_pixel < 16 ) { image -> storage_class = pseudoclass ; image -> depth = 8 ; } if ( image_info -> ping != magickfalse ) { ( void ) closeblob ( image ) ; return ( image ) ; } status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; one_row = ( unsigned char * ) acquirequantummemory ( magickmax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; lastrow = ( unsigned char * ) null ; if ( compressiontype == palm_compression_scanline ) { lastrow = ( unsigned char * ) acquirequantummemory ( magickmax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * lastrow ) ) ; if ( lastrow == ( unsigned char * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; } mask = ( size_t ) ( 1u << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & palm_is_compressed_flag ) == 0 ) { image -> compression = nocompression ; count = readblob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressiontype == palm_compression_rle ) { image -> compression = rlecompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) readblobbyte ( image ) ; if ( count < 0 ) break ; count = magickmin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) readblobbyte ( image ) ; ( void ) resetmagickmemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressiontype == palm_compression_scanline ) { size_t one ; one = 1 ; image -> compression = faxcompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) readblobbyte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) magickmin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) readblobbyte ( image ) ; else one_row [ i + bit ] = lastrow [ i + bit ] ; } } ( void ) copymagickmemory ( lastrow , one_row , bytes_per_row ) ; } } ptr = one_row ; q = queueauthenticpixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) break ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) relinquishmagickmemory ( one_row ) ; if ( compressiontype == palm_compression_scanline ) lastrow = ( unsigned char * ) relinquishmagickmemory ( lastrow ) ; throwreaderexception ( corruptimageerror , ""corruptimage"" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; setpixelred ( image , ( quantum ) ( ( quantumrange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) , q ) ; setpixelgreen ( image , ( quantum ) ( ( quantumrange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) , q ) ; setpixelblue ( image , ( quantum ) ( ( quantumrange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) , q ) ; setpixelalpha ( image , opaquealpha , q ) ; q += getpixelchannels ( image ) ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) relinquishmagickmemory ( one_row ) ; if ( compressiontype == palm_compression_scanline ) lastrow = ( unsigned char * ) relinquishmagickmemory ( lastrow ) ; throwreaderexception ( corruptimageerror , ""corruptimage"" ) ; } index = ( quantum ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; setpixelindex ( image , index , q ) ; setpixelviapixelinfo ( image , image -> colormap + ( ssize_t ) index , q ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q += getpixelchannels ( image ) ; } if ( syncauthenticpixels ( image , exception ) == magickfalse ) break ; } if ( image -> previous == ( image * ) null ) { status = setimageprogress ( image , loadimagetag , ( magickoffsettype ) y , image -> rows ) ; if ( status == magickfalse ) break ; } } if ( flags & palm_has_transparency_flag ) { ssize_t index = constraincolormapindex ( image , ( ssize_t ) ( mask - transparentindex ) , exception ) ; if ( bits_per_pixel != 16 ) transpix = image -> colormap [ index ] ; ( void ) transparentpaintimage ( image , & transpix , ( quantum ) transparentalpha , magickfalse , exception ) ; } one_row = ( unsigned char * ) relinquishmagickmemory ( one_row ) ; if ( compressiontype == palm_compression_scanline ) lastrow = ( unsigned char * ) relinquishmagickmemory ( lastrow ) ; if ( eofblob ( image ) != magickfalse ) { throwfileexception ( exception , corruptimageerror , ""unexpectedendoffile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextdepthoffset != 0 ) { totaloffset += ( magickoffsettype ) ( nextdepthoffset * 4 ) ; if ( totaloffset >= ( magickoffsettype ) getblobsize ( image ) ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) else seeknextdepth = seekblob ( image , totaloffset , seek_set ) ; if ( seeknextdepth != totaloffset ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; acquirenextimage ( image_info , image , exception ) ; if ( getnextimageinlist ( image ) == ( image * ) null ) { ( void ) destroyimagelist ( image ) ; return ( ( image * ) null ) ; } image = syncnextimageinlist ( image ) ; status = setimageprogress ( image , loadimagestag , tellblob ( image ) , getblobsize ( image ) ) ; if ( status == magickfalse ) break ; } } while ( nextdepthoffset != 0 ) ; ( void ) closeblob ( image ) ; return ( getfirstimageinlist ( image ) ) ; }","<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if
",ImageMagick@ImageMagick/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89,CVE-2017-12664,https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89,2017-08-07T21:29Z,"<S2SV_StartBug> * lastrow , <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug>"
977,CWE-416,"int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( is_err ( dst ) ) { sk -> sk_err_soft = - ptr_err ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return ptr_err ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ; res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; rcu_read_unlock ( ) ; return res ; }","<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug>"
3730,CWE-200,"__be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { static u32 ip6_idents_hashrnd __read_mostly ; u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; return htonl ( id ) ; }","<S2SV_ModStart> saddr ) { u32 id <S2SV_ModEnd> ; id = <S2SV_ModStart> __ipv6_select_ident ( net <S2SV_ModEnd> , daddr ,
",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z,"<S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug>"
8429,CWE-401,"static int gs_can_open ( struct net_device * netdev ) { struct gs_can * dev = netdev_priv ( netdev ) ; struct gs_usb * parent = dev -> parent ; int rc , i ; struct gs_device_mode * dm ; u32 ctrlmode ; rc = open_candev ( netdev ) ; if ( rc ) return rc ; if ( atomic_add_return ( 1 , & parent -> active_channels ) == 1 ) { for ( i = 0 ; i < gs_max_rx_urbs ; i ++ ) { struct urb * urb ; u8 * buf ; urb = usb_alloc_urb ( 0 , gfp_kernel ) ; if ( ! urb ) return - enomem ; buf = usb_alloc_coherent ( dev -> udev , sizeof ( struct gs_host_frame ) , gfp_kernel , & urb -> transfer_dma ) ; if ( ! buf ) { netdev_err ( netdev , ""no<s2sv_blank>memory<s2sv_blank>left<s2sv_blank>for<s2sv_blank>usb<s2sv_blank>buffer\\n"" ) ; usb_free_urb ( urb ) ; return - enomem ; } usb_fill_bulk_urb ( urb , dev -> udev , usb_rcvbulkpipe ( dev -> udev , gsusb_endpoint_in ) , buf , sizeof ( struct gs_host_frame ) , gs_usb_receive_bulk_callback , parent ) ; urb -> transfer_flags |= urb_no_transfer_dma_map ; usb_anchor_urb ( urb , & parent -> rx_submitted ) ; rc = usb_submit_urb ( urb , gfp_kernel ) ; if ( rc ) { if ( rc == - enodev ) netif_device_detach ( dev -> netdev ) ; netdev_err ( netdev , ""usb_submit<s2sv_blank>failed<s2sv_blank>(err=%d)\\n"" , rc ) ; usb_unanchor_urb ( urb ) ; break ; } usb_free_urb ( urb ) ; } } dm = kmalloc ( sizeof ( * dm ) , gfp_kernel ) ; if ( ! dm ) return - enomem ; ctrlmode = dev -> can . ctrlmode ; dm -> flags = 0 ; if ( ctrlmode & can_ctrlmode_loopback ) dm -> flags |= gs_can_mode_loop_back ; else if ( ctrlmode & can_ctrlmode_listenonly ) dm -> flags |= gs_can_mode_listen_only ; if ( ctrlmode & can_ctrlmode_one_shot ) dm -> flags |= gs_can_mode_one_shot ; if ( ctrlmode & can_ctrlmode_3_samples ) dm -> flags |= gs_can_mode_triple_sample ; dm -> mode = gs_can_mode_start ; rc = usb_control_msg ( interface_to_usbdev ( dev -> iface ) , usb_sndctrlpipe ( interface_to_usbdev ( dev -> iface ) , 0 ) , gs_usb_breq_mode , usb_dir_out | usb_type_vendor | usb_recip_interface , dev -> channel , 0 , dm , sizeof ( * dm ) , 1000 ) ; if ( rc < 0 ) { netdev_err ( netdev , ""couldn\'t<s2sv_blank>start<s2sv_blank>device<s2sv_blank>(err=%d)\\n"" , rc ) ; kfree ( dm ) ; return rc ; } kfree ( dm ) ; dev -> can . state = can_state_error_active ; if ( ! ( dev -> can . ctrlmode & can_ctrlmode_listenonly ) ) netif_start_queue ( netdev ) ; return 0 ; }","<S2SV_ModStart> ) ; usb_unanchor_urb ( urb ) ; usb_free_urb
",torvalds@linux/fb5be6a7b4863ecc44963bb80ca614584b6c7817,CVE-2019-19052,https://github.com/torvalds/linux/commit/fb5be6a7b4863ecc44963bb80ca614584b6c7817,2019-11-18T06:15Z,<S2SV_StartBug> usb_unanchor_urb ( urb ) ; <S2SV_EndBug>
6922,CWE-400,"int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = fpustate ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? fprs_dl : fprs_du ; perf_sw_event ( perf_count_sw_emulation_faults , 1 , 0 , regs , 0 ) ; save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case asi_p : case asi_s : break ; case asi_pl : case asi_sl : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > asi_snfl ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & fprs_fef ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = fprs_fef ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug>"
5362,CWE-264,"static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; # ifdef config_tcp_md5sig struct tcp_md5sig_key * key ; # endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( eth_p_ip ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return null ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef config_tcp_md5sig newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> ipv6_ac_list = null ; newnp -> ipv6_fl_list = null ; newnp -> pktoptions = null ; newnp -> opt = null ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , ipproto_tcp ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = skb_gso_tcpv6 ; __ip6_dst_store ( newsk , dst , null , null ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = null ; newnp -> ipv6_ac_list = null ; newnp -> ipv6_fl_list = null ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = null ; newnp -> opt = null ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; if ( np -> opt ) newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; if ( tcp_sk ( sk ) -> rx_opt . user_mss && tcp_sk ( sk ) -> rx_opt . user_mss < newtp -> advmss ) newtp -> advmss = tcp_sk ( sk ) -> rx_opt . user_mss ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = loopback4_ipv6 ; newinet -> inet_rcv_saddr = loopback4_ipv6 ; # ifdef config_tcp_md5sig key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , af_inet6 , key -> key , key -> keylen , sk_gfp_atomic ( sk , gfp_atomic ) ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_atomic ( sk , gfp_atomic ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = null ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } return newsk ; out_overflow : net_inc_stats_bh ( sock_net ( sk ) , linux_mib_listenoverflows ) ; out_nonewsk : dst_release ( dst ) ; out : net_inc_stats_bh ( sock_net ( sk ) , linux_mib_listendrops ) ; return null ; }","<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( <S2SV_ModEnd> opt ) inet_csk <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; tcp_ca_openreq_child (
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug>"
1094,CWE-264,"static inline unsigned long zap_pmd_range ( struct mmu_gather * tlb , struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , struct zap_details * details ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( next - addr != hpage_pmd_size ) { vm_bug_on ( ! rwsem_is_locked ( & tlb -> mm -> mmap_sem ) ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; } else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) continue ; } if ( pmd_none_or_clear_bad ( pmd ) ) continue ; next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; cond_resched ( ) ; } while ( pmd ++ , addr = next , addr != end ) ; return addr ; }","<S2SV_ModStart> addr ) ) goto next <S2SV_ModEnd> ; } if <S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) <S2SV_ModStart> pmd ) ) goto next <S2SV_ModEnd> ; next = <S2SV_ModStart> details ) ; next :
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,"<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug>"
4810,CWE-000,"rfbbool setformatandencodings ( rfbclient * client ) { rfbsetpixelformatmsg spf ; char buf [ sz_rfbsetencodingsmsg + max_encodings * 4 ] ; rfbsetencodingsmsg * se = ( rfbsetencodingsmsg * ) buf ; uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbsetencodingsmsg ] ) ; int len = 0 ; rfbbool requestcompresslevel = false ; rfbbool requestqualitylevel = false ; rfbbool requestlastrectencoding = false ; rfbclientprotocolextension * e ; if ( ! supportsclient2server ( client , rfbsetpixelformat ) ) return true ; spf . type = rfbsetpixelformat ; spf . pad1 = 0 ; spf . pad2 = 0 ; spf . format = client -> format ; spf . format . redmax = rfbclientswap16ifle ( spf . format . redmax ) ; spf . format . greenmax = rfbclientswap16ifle ( spf . format . greenmax ) ; spf . format . bluemax = rfbclientswap16ifle ( spf . format . bluemax ) ; if ( ! writetorfbserver ( client , ( char * ) & spf , sz_rfbsetpixelformatmsg ) ) return false ; if ( ! supportsclient2server ( client , rfbsetencodings ) ) return true ; se -> type = rfbsetencodings ; se -> pad = 0 ; se -> nencodings = 0 ; if ( client -> appdata . encodingsstring ) { const char * encstr = client -> appdata . encodingsstring ; int encstrlen ; do { const char * nextencstr = strchr ( encstr , '<s2sv_blank>' ) ; if ( nextencstr ) { encstrlen = nextencstr - encstr ; nextencstr ++ ; } else { encstrlen = strlen ( encstr ) ; } if ( strncasecmp ( encstr , ""raw"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingraw ) ; } else if ( strncasecmp ( encstr , ""copyrect"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingcopyrect ) ; # ifdef libvncserver_have_libz # ifdef libvncserver_have_libjpeg } else if ( strncasecmp ( encstr , ""tight"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingtight ) ; requestlastrectencoding = true ; if ( client -> appdata . compresslevel >= 0 && client -> appdata . compresslevel <= 9 ) requestcompresslevel = true ; if ( client -> appdata . enablejpeg ) requestqualitylevel = true ; # endif # endif } else if ( strncasecmp ( encstr , ""hextile"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodinghextile ) ; # ifdef libvncserver_have_libz } else if ( strncasecmp ( encstr , ""zlib"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzlib ) ; if ( client -> appdata . compresslevel >= 0 && client -> appdata . compresslevel <= 9 ) requestcompresslevel = true ; } else if ( strncasecmp ( encstr , ""zlibhex"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzlibhex ) ; if ( client -> appdata . compresslevel >= 0 && client -> appdata . compresslevel <= 9 ) requestcompresslevel = true ; } else if ( strncasecmp ( encstr , ""trle"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingtrle ) ; } else if ( strncasecmp ( encstr , ""zrle"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzrle ) ; } else if ( strncasecmp ( encstr , ""zywrle"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzywrle ) ; requestqualitylevel = true ; # endif } else if ( ( strncasecmp ( encstr , ""ultra"" , encstrlen ) == 0 ) || ( strncasecmp ( encstr , ""ultrazip"" , encstrlen ) == 0 ) ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingultra ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingultrazip ) ; } else if ( strncasecmp ( encstr , ""corre"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingcorre ) ; } else if ( strncasecmp ( encstr , ""rre"" , encstrlen ) == 0 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingrre ) ; } else { rfbclientlog ( ""unknown<s2sv_blank>encoding<s2sv_blank>\'%.*s\'\\n"" , encstrlen , encstr ) ; } encstr = nextencstr ; } while ( encstr && se -> nencodings < max_encodings ) ; if ( se -> nencodings < max_encodings && requestcompresslevel ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( client -> appdata . compresslevel + rfbencodingcompresslevel0 ) ; } if ( se -> nencodings < max_encodings && requestqualitylevel ) { if ( client -> appdata . qualitylevel < 0 || client -> appdata . qualitylevel > 9 ) client -> appdata . qualitylevel = 5 ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( client -> appdata . qualitylevel + rfbencodingqualitylevel0 ) ; } } else { if ( samemachine ( client -> sock ) ) { rfbclientlog ( ""same<s2sv_blank>machine:<s2sv_blank>preferring<s2sv_blank>raw<s2sv_blank>encoding\\n"" ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingraw ) ; } encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingcopyrect ) ; # ifdef libvncserver_have_libz # ifdef libvncserver_have_libjpeg encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingtight ) ; requestlastrectencoding = true ; # endif # endif encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodinghextile ) ; # ifdef libvncserver_have_libz encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzlib ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzrle ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingzywrle ) ; # endif encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingultra ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingultrazip ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingcorre ) ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingrre ) ; if ( client -> appdata . compresslevel >= 0 && client -> appdata . compresslevel <= 9 ) { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( client -> appdata . compresslevel + rfbencodingcompresslevel0 ) ; } else { encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingcompresslevel1 ) ; } if ( client -> appdata . enablejpeg ) { if ( client -> appdata . qualitylevel < 0 || client -> appdata . qualitylevel > 9 ) client -> appdata . qualitylevel = 5 ; encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( client -> appdata . qualitylevel + rfbencodingqualitylevel0 ) ; } } if ( client -> appdata . useremotecursor ) { if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingxcursor ) ; if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingrichcursor ) ; if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingpointerpos ) ; } if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingkeyboardledstate ) ; if ( se -> nencodings < max_encodings && client -> canhandlenewfbsize ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingnewfbsize ) ; if ( se -> nencodings < max_encodings && requestlastrectencoding ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodinglastrect ) ; if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingsupportedmessages ) ; if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingsupportedencodings ) ; if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingserveridentity ) ; if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( rfbencodingxvp ) ; for ( e = rfbclientextensions ; e ; e = e -> next ) if ( e -> encodings ) { int * enc ; for ( enc = e -> encodings ; * enc ; enc ++ ) if ( se -> nencodings < max_encodings ) encs [ se -> nencodings ++ ] = rfbclientswap32ifle ( * enc ) ; } len = sz_rfbsetencodingsmsg + se -> nencodings * 4 ; se -> nencodings = rfbclientswap16ifle ( se -> nencodings ) ; if ( ! writetorfbserver ( client , buf , len ) ) return false ; return true ; }","<S2SV_ModStart> rfbSetPixelFormatMsg spf ; union { char bytes <S2SV_ModEnd> [ sz_rfbSetEncodingsMsg + <S2SV_ModStart> ] ; rfbSetEncodingsMsg msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> ; uint32_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> client , buf . bytes
",LibVNC@libvncserver/23e5cbe6b090d7f22982aee909a6a618174d3c2d,CVE-2020-14399,https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d,2020-06-17T16:15Z,"<S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug>"
2479,CWE-120,"static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , gfp_kernel ) ; if ( ! * ie_ptr ) return - enomem ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( mwifiex_auto_idx_mask ) ; } * ie_ptr = ie ; return 0 ; }","<S2SV_ModStart> ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
",torvalds@linux/7caac62ed598a196d6ddf8d9c121e12e082cac3a,CVE-2019-14814,https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a,2019-09-20T19:15Z,"<S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug>"
3601,CWE-399,"static struct kioctx * ioctx_alloc ( unsigned nr_events ) { struct mm_struct * mm = current -> mm ; struct kioctx * ctx ; int err = - enomem ; nr_events = max ( nr_events , num_possible_cpus ( ) * 4 ) ; nr_events *= 2 ; if ( ( nr_events > ( 0x10000000u / sizeof ( struct io_event ) ) ) || ( nr_events > ( 0x10000000u / sizeof ( struct kiocb ) ) ) ) { pr_debug ( ""enomem:<s2sv_blank>nr_events<s2sv_blank>too<s2sv_blank>high\\n"" ) ; return err_ptr ( - einval ) ; } if ( ! nr_events || ( unsigned long ) nr_events > ( aio_max_nr * 2ul ) ) return err_ptr ( - eagain ) ; ctx = kmem_cache_zalloc ( kioctx_cachep , gfp_kernel ) ; if ( ! ctx ) return err_ptr ( - enomem ) ; ctx -> max_reqs = nr_events ; if ( percpu_ref_init ( & ctx -> users , free_ioctx_users ) ) goto err ; if ( percpu_ref_init ( & ctx -> reqs , free_ioctx_reqs ) ) goto err ; spin_lock_init ( & ctx -> ctx_lock ) ; spin_lock_init ( & ctx -> completion_lock ) ; mutex_init ( & ctx -> ring_lock ) ; init_waitqueue_head ( & ctx -> wait ) ; init_list_head ( & ctx -> active_reqs ) ; ctx -> cpu = alloc_percpu ( struct kioctx_cpu ) ; if ( ! ctx -> cpu ) goto err ; if ( aio_setup_ring ( ctx ) < 0 ) goto err ; atomic_set ( & ctx -> reqs_available , ctx -> nr_events - 1 ) ; ctx -> req_batch = ( ctx -> nr_events - 1 ) / ( num_possible_cpus ( ) * 4 ) ; if ( ctx -> req_batch < 1 ) ctx -> req_batch = 1 ; spin_lock ( & aio_nr_lock ) ; if ( aio_nr + nr_events > ( aio_max_nr * 2ul ) || aio_nr + nr_events < aio_nr ) { spin_unlock ( & aio_nr_lock ) ; err = - eagain ; goto err ; } aio_nr += ctx -> max_reqs ; spin_unlock ( & aio_nr_lock ) ; percpu_ref_get ( & ctx -> users ) ; err = ioctx_add_table ( ctx , mm ) ; if ( err ) goto err_cleanup ; pr_debug ( ""allocated<s2sv_blank>ioctx<s2sv_blank>%p[%ld]:<s2sv_blank>mm=%p<s2sv_blank>mask=0x%x\\n"" , ctx , ctx -> user_id , mm , ctx -> nr_events ) ; return ctx ; err_cleanup : aio_nr_sub ( ctx -> max_reqs ) ; err : aio_free_ring ( ctx ) ; free_percpu ( ctx -> cpu ) ; free_percpu ( ctx -> reqs . pcpu_count ) ; free_percpu ( ctx -> users . pcpu_count ) ; kmem_cache_free ( kioctx_cachep , ctx ) ; pr_debug ( ""error<s2sv_blank>allocating<s2sv_blank>ioctx<s2sv_blank>%d\\n"" , err ) ; return err_ptr ( err ) ; }","<S2SV_ModStart> ; err : <S2SV_ModEnd> free_percpu ( ctx
",torvalds@linux/d558023207e008a4476a3b7bb8706b2a2bf5d84f,CVE-2013-7348,https://github.com/torvalds/linux/commit/d558023207e008a4476a3b7bb8706b2a2bf5d84f,2014-04-01T06:35Z,<S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug>
1097,CWE-264,"static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug>
3523,CWE-200,"static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; spin_lock_irq ( & tu -> qlock ) ; while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & o_nonblock ) != 0 || result > 0 ) { err = - eagain ; goto _error ; } set_current_state ( task_interruptible ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; schedule ( ) ; spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - enodev ; goto _error ; } if ( signal_pending ( current ) ) { err = - erestartsys ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; mutex_lock ( & tu -> ioctl_lock ) ; if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - efault ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - efault ; } mutex_unlock ( & tu -> ioctl_lock ) ; spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; return result > 0 ? result : err ; }","<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
",torvalds@linux/d11662f4f798b50d8c8743f433842c3e40fe3378,CVE-2017-1000380,https://github.com/torvalds/linux/commit/d11662f4f798b50d8c8743f433842c3e40fe3378,2017-06-17T18:29Z,<S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug>
5052,CWE-189,"datum txid_current_snapshot ( pg_function_args ) { txidsnapshot * snap ; uint32 nxip , i , size ; txidepoch state ; snapshot cur ; cur = getactivesnapshot ( ) ; if ( cur == null ) elog ( error , ""no<s2sv_blank>active<s2sv_blank>snapshot<s2sv_blank>set"" ) ; load_xid_epoch ( & state ) ; nxip = cur -> xcnt ; size = txid_snapshot_size ( nxip ) ; snap = palloc ( size ) ; set_varsize ( snap , size ) ; snap -> xmin = convert_xid ( cur -> xmin , & state ) ; snap -> xmax = convert_xid ( cur -> xmax , & state ) ; snap -> nxip = nxip ; for ( i = 0 ; i < nxip ; i ++ ) snap -> xip [ i ] = convert_xid ( cur -> xip [ i ] , & state ) ; sort_snapshot ( snap ) ; pg_return_pointer ( snap ) ; }","<S2SV_ModStart> ( & state ) ; StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()""
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,<S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug>
7938,CWE-476,"gf_err mergetrack ( gf_trackbox * trak , gf_trackfragmentbox * traf , gf_moviefragmentbox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , descindex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; bool first_samp_in_traf = gf_true ; bool store_traf_map = gf_false ; u8 * moof_template = null ; u32 moof_template_size = 0 ; bool is_seg_start = gf_false ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; gf_trackfragmentrunbox * trun ; gf_trunentry * ent ; # ifdef gf_enable_ctrn gf_trackfragmentbox * traf_ref = null ; # endif gf_err stbl_appendtime ( gf_sampletablebox * stbl , u32 duration , u32 nb_pack ) ; gf_err stbl_appendsize ( gf_sampletablebox * stbl , u32 size , u32 nb_pack ) ; gf_err stbl_appendchunk ( gf_sampletablebox * stbl , u64 offset ) ; gf_err stbl_appendsampletochunk ( gf_sampletablebox * stbl , u32 descindex , u32 samplesinchunk ) ; gf_err stbl_appendctsoffset ( gf_sampletablebox * stbl , s32 ctsoffset ) ; gf_err stbl_appendrap ( gf_sampletablebox * stbl , u8 israp ) ; gf_err stbl_appendpadding ( gf_sampletablebox * stbl , u8 padding ) ; gf_err stbl_appenddegradation ( gf_sampletablebox * stbl , u16 degradationpriority ) ; if ( trak -> header -> trackid != traf -> tfhd -> trackid ) return gf_ok ; if ( ! trak -> media -> information -> sampletable || ! trak -> media -> information -> sampletable -> samplesize || ! trak -> media -> information -> sampletable -> timetosample || ! trak -> media -> information -> sampletable -> sampletochunk || ! trak -> media -> information -> sampletable -> chunkoffset ) { return gf_isom_invalid_file ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; descindex = ( traf -> tfhd -> flags & gf_isom_traf_sample_desc ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! descindex ) { gf_log ( gf_log_error , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>default<s2sv_blank>sample<s2sv_blank>description<s2sv_blank>set<s2sv_blank>to<s2sv_blank>0,<s2sv_blank>likely<s2sv_blank>broken<s2sv_blank>!<s2sv_blank>fixing<s2sv_blank>to<s2sv_blank>1\\n"" ) ) ; descindex = 1 ; } else if ( descindex > gf_list_count ( trak -> media -> information -> sampletable -> sampledescription -> child_boxes ) ) { gf_log ( gf_log_error , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>default<s2sv_blank>sample<s2sv_blank>description<s2sv_blank>set<s2sv_blank>to<s2sv_blank>%d<s2sv_blank>but<s2sv_blank>only<s2sv_blank>%d<s2sv_blank>sample<s2sv_blank>description(s),<s2sv_blank>likely<s2sv_blank>broken<s2sv_blank>!<s2sv_blank>fixing<s2sv_blank>to<s2sv_blank>1\\n"" , descindex , gf_list_count ( trak -> media -> information -> sampletable -> sampledescription -> child_boxes ) ) ) ; descindex = 1 ; } # ifdef gf_enable_ctrn if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> tracklist ) ; for ( i = 0 ; i < traf_count ; i ++ ) { gf_trackfragmentbox * atraf = gf_list_get ( moof_box -> tracklist , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackid == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & gf_isom_traf_sample_dur ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & gf_isom_traf_sample_size ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & gf_isom_traf_sample_flags ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & gf_isom_traf_base_offset ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & gf_isom_moof_base_offset ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef gpac_disable_log if ( trak -> moov -> mov -> nextmoofnumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> basemediadecodetime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> basemediadecodetime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { gf_log ( gf_log_warning , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>warning:<s2sv_blank>tfdt<s2sv_blank>timing<s2sv_blank>"" lld ""<s2sv_blank>less<s2sv_blank>than<s2sv_blank>cumulated<s2sv_blank>timing<s2sv_blank>"" lld ""<s2sv_blank>-<s2sv_blank>using<s2sv_blank>tfdt\\n"" , traf -> tfdt -> basemediadecodetime , trak -> dts_at_seg_start ) ) ; } else { gf_log ( gf_log_info , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>tfdt<s2sv_blank>timing<s2sv_blank>"" lld ""<s2sv_blank>higher<s2sv_blank>than<s2sv_blank>cumulated<s2sv_blank>timing<s2sv_blank>"" lld ""<s2sv_blank>(last<s2sv_blank>sample<s2sv_blank>got<s2sv_blank>extended<s2sv_blank>in<s2sv_blank>duration)\\n"" , traf -> tfdt -> basemediadecodetime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> basemediadecodetime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( gf_box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = gf_true ; if ( is_first_merge ) { gf_moviefragmentbox * moof_clone = null ; gf_isom_box_freeze_order ( ( gf_box * ) moof_box ) ; gf_isom_clone_box ( ( gf_box * ) moof_box , ( gf_box * * ) & moof_clone ) ; if ( moof_clone ) { gf_bitstream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> tracklist ) ; i ++ ) { gf_trackfragmentbox * traf_clone = gf_list_get ( moof_clone -> tracklist , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> trackruns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> samplegroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> samplegroupsdescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( gf_box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = null ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( gf_box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = null ; } } gf_isom_box_size ( ( gf_box * ) moof_clone ) ; bs = gf_bs_new ( null , 0 , gf_bitstream_write ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( gf_box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( gf_box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( gf_box * ) moof_clone , bs ) ; gf_isom_box_del ( ( gf_box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = gf_true ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = gf_true ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = gf_true ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( gf_trackfragmentrunbox * ) gf_list_enum ( traf -> trackruns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { gf_err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { gf_log ( gf_log_error , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>track<s2sv_blank>%d<s2sv_blank>doesn\'t<s2sv_blank>have<s2sv_blank>enough<s2sv_blank>trun<s2sv_blank>entries<s2sv_blank>(%d)<s2sv_blank>compared<s2sv_blank>to<s2sv_blank>sample<s2sv_blank>count<s2sv_blank>(%d)<s2sv_blank>in<s2sv_blank>run\\n"" , traf -> trex -> trackid , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> cts_offset ; # ifdef gf_enable_ctrn if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & gf_isom_ctrn_first_sample ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xf0 ) { gf_trunentry * ref_entry ; if ( ! traf_ref ) { gf_log ( gf_log_error , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>track<s2sv_blank>%d<s2sv_blank>use<s2sv_blank>traf<s2sv_blank>inheritance<s2sv_blank>to<s2sv_blank>track<s2sv_blank>id<s2sv_blank>%d<s2sv_blank>but<s2sv_blank>reference<s2sv_blank>traf<s2sv_blank>not<s2sv_blank>found\\n"" , traf -> trex -> trackid , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { gf_log ( gf_log_error , gf_log_container , ( ""[iso<s2sv_blank>file]<s2sv_blank>track<s2sv_blank>%d<s2sv_blank>use<s2sv_blank>traf<s2sv_blank>inheritance<s2sv_blank>but<s2sv_blank>sample<s2sv_blank>%d<s2sv_blank>not<s2sv_blank>found<s2sv_blank>in<s2sv_blank>reference<s2sv_blank>traf\\n"" , traf -> trex -> trackid , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & gf_isom_ctrn_inherit_dur ) duration = ref_entry -> duration ; if ( trun -> ctrn_flags & gf_isom_ctrn_inherit_size ) size = ref_entry -> size ; if ( trun -> ctrn_flags & gf_isom_ctrn_inherit_flags ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & gf_isom_ctrn_inherit_ctso ) cts_offset = ref_entry -> cts_offset ; } } else # endif { if ( trun -> flags & gf_isom_trun_duration ) duration = ent -> duration ; if ( trun -> flags & gf_isom_trun_size ) size = ent -> size ; if ( trun -> flags & gf_isom_trun_flags ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & gf_isom_trun_first_flag ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> duration = duration ; ent -> flags = flags ; ent -> cts_offset = cts_offset ; last_dts += duration ; if ( ! trak -> media -> information -> sampletable -> samplesize ) { trak -> media -> information -> sampletable -> samplesize = ( gf_samplesizebox * ) gf_isom_box_new_parent ( & trak -> media -> information -> sampletable -> child_boxes , gf_isom_box_type_stsz ) ; if ( ! trak -> media -> information -> sampletable -> samplesize ) return gf_out_of_mem ; } e = stbl_appendsize ( trak -> media -> information -> sampletable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> media -> information -> sampletable -> timetosample ) { trak -> media -> information -> sampletable -> timetosample = ( gf_timetosamplebox * ) gf_isom_box_new_parent ( & trak -> media -> information -> sampletable -> child_boxes , gf_isom_box_type_stts ) ; if ( ! trak -> media -> information -> sampletable -> timetosample ) return gf_out_of_mem ; } e = stbl_appendtime ( trak -> media -> information -> sampletable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & gf_isom_trun_data_offset ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> media -> information -> sampletable -> chunkoffset ) { trak -> media -> information -> sampletable -> chunkoffset = gf_isom_box_new_parent ( & trak -> media -> information -> sampletable -> child_boxes , gf_isom_box_type_stco ) ; if ( ! trak -> media -> information -> sampletable -> chunkoffset ) return gf_out_of_mem ; } e = stbl_appendchunk ( trak -> media -> information -> sampletable , final_offset ) ; if ( e ) return e ; if ( ! trak -> media -> information -> sampletable -> sampletochunk ) { trak -> media -> information -> sampletable -> sampletochunk = ( gf_sampletochunkbox * ) gf_isom_box_new_parent ( & trak -> media -> information -> sampletable -> child_boxes , gf_isom_box_type_stsc ) ; if ( ! trak -> media -> information -> sampletable -> sampletochunk ) return gf_out_of_mem ; } e = stbl_appendsampletochunk ( trak -> media -> information -> sampletable , descindex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = gf_false ; e = stbl_appendtrafmap ( trak -> media -> information -> sampletable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = null ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_appendctsoffset ( trak -> media -> information -> sampletable , cts_offset ) ; if ( e ) return e ; sync = gf_isom_get_frag_sync ( flags ) ; if ( trak -> media -> information -> sampletable -> no_sync_found && sync ) { trak -> media -> information -> sampletable -> no_sync_found = 0 ; } e = stbl_appendrap ( trak -> media -> information -> sampletable , sync ) ; if ( e ) return e ; pad = gf_isom_get_frag_pad ( flags ) ; if ( pad ) { e = stbl_appendpadding ( trak -> media -> information -> sampletable , pad ) ; if ( e ) return e ; } degr = gf_isom_get_frag_deg ( flags ) ; if ( degr ) { e = stbl_appenddegradation ( trak -> media -> information -> sampletable , degr ) ; if ( e ) return e ; } e = stbl_appenddependencytype ( trak -> media -> information -> sampletable , gf_isom_get_frag_lead ( flags ) , gf_isom_get_frag_depends ( flags ) , gf_isom_get_frag_depended ( flags ) , gf_isom_get_frag_redundant ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editbox && trak -> editbox -> editlist ) { for ( i = 0 ; i < gf_list_count ( trak -> editbox -> editlist -> entrylist ) ; i ++ ) { gf_edtsentry * edts_e = gf_list_get ( trak -> editbox -> editlist -> entrylist , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timescale ; extend_dur /= trak -> media -> mediaheader -> timescale ; edts_e -> segmentduration += extend_dur ; } else if ( ! edts_e -> segmentduration ) { edts_e -> was_empty_dur = gf_true ; if ( ( s64 ) traf_duration > edts_e -> mediatime ) traf_duration -= edts_e -> mediatime ; else traf_duration = 0 ; edts_e -> segmentduration = traf_duration ; edts_e -> segmentduration *= trak -> moov -> mvhd -> timescale ; edts_e -> segmentduration /= trak -> media -> mediaheader -> timescale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> samplegroups ) { gf_list * groups ; gf_list * groupdescs ; bool is_identical_sgpd = gf_true ; u32 * new_idx = null , new_idx_count = 0 ; if ( ! trak -> media -> information -> sampletable -> samplegroups ) trak -> media -> information -> sampletable -> samplegroups = gf_list_new ( ) ; if ( ! trak -> media -> information -> sampletable -> samplegroupsdescription ) trak -> media -> information -> sampletable -> samplegroupsdescription = gf_list_new ( ) ; groupdescs = trak -> media -> information -> sampletable -> samplegroupsdescription ; for ( i = 0 ; i < gf_list_count ( traf -> samplegroupsdescription ) ; i ++ ) { gf_samplegroupdescriptionbox * new_sgdesc = null ; gf_samplegroupdescriptionbox * sgdesc = gf_list_get ( traf -> samplegroupsdescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupdescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupdescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = null ; } if ( ! new_sgdesc ) { gf_list_add ( groupdescs , sgdesc ) ; gf_list_add ( trak -> media -> information -> sampletable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> samplegroupsdescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return gf_out_of_mem ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; bool new_entry = gf_true ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = gf_false ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> media -> information -> sampletable -> samplegroups ; for ( i = 0 ; i < gf_list_count ( traf -> samplegroups ) ; i ++ ) { gf_samplegroupbox * stbl_group = null ; gf_samplegroupbox * frag_group = gf_list_get ( traf -> samplegroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = null ; } if ( ! stbl_group ) { stbl_group = ( gf_samplegroupbox * ) gf_isom_box_new_parent ( & trak -> media -> information -> sampletable -> child_boxes , gf_isom_box_type_sbgp ) ; if ( ! stbl_group ) return gf_out_of_mem ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0ffff ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( gf_samplegroupentry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( gf_samplegroupentry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( gf_samplegroupentry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( gf_samplegroupentry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( gf_samplegroupentry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { gf_log ( gf_log_warning , gf_log_container , ( ""[isobmf]<s2sv_blank>corrupted<s2sv_blank>sample<s2sv_blank>group<s2sv_blank>index<s2sv_blank>in<s2sv_blank>fragment<s2sv_blank>%d<s2sv_blank>but<s2sv_blank>only<s2sv_blank>%d<s2sv_blank>group<s2sv_blank>descriptions<s2sv_blank>in<s2sv_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( gf_samplegroupentry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> header -> trackid ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , descindex ) || traf -> sample_encryption ) { gf_sampleencryptionbox * senc = null ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , descindex , null , & scheme_type , null ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> media -> information -> sampletable -> child_boxes ) ; i ++ ) { gf_box * a = ( gf_box * ) gf_list_get ( trak -> media -> information -> sampletable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == gf_isom_box_type_uuid ) && ( ( ( gf_uuidbox * ) a ) -> internal_4cc == gf_isom_box_uuid_psec ) ) { senc = ( gf_sampleencryptionbox * ) a ; break ; } else if ( a -> type == gf_isom_box_type_senc ) { senc = ( gf_sampleencryptionbox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( gf_sampleencryptionbox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , null ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> media -> information -> sampletable -> child_boxes ) trak -> media -> information -> sampletable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; gf_err e ; bool is_encrypted ; gf_sampleauxiliaryinfooffsetbox * saio = null ; gf_sampleauxiliaryinfosizebox * saiz = null ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( gf_sampleauxiliaryinfooffsetbox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == gf_isom_cenc_scheme ) || ( aux_info_type == gf_isom_cbc_scheme ) || ( aux_info_type == gf_isom_cens_scheme ) || ( aux_info_type == gf_isom_cbcs_scheme ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) { offset = saio -> offsets [ 0 ] + moof_offset ; nb_saio = saio -> entry_count ; break ; } } for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { saiz = ( gf_sampleauxiliaryinfosizebox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == gf_isom_cenc_scheme ) || ( aux_info_type == gf_isom_cbc_scheme ) || ( aux_info_type == gf_isom_cens_scheme ) || ( aux_info_type == gf_isom_cbcs_scheme ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ; } } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { gf_cencsampleauxinfo * sai ; const u8 * key_info = null ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> moviefilemap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> moviefilemap -> bs , offset ) ; gf_safealloc ( sai , gf_cencsampleauxinfo ) ; if ( ! sai ) return gf_out_of_mem ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , null , null , & key_info , & key_info_size ) ; if ( e ) { gf_log ( gf_log_error , gf_log_container , ( ""[isobmf]<s2sv_blank>could<s2sv_blank>not<s2sv_blank>get<s2sv_blank>cenc<s2sv_blank>info<s2sv_blank>for<s2sv_blank>sample<s2sv_blank>%d:<s2sv_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return gf_out_of_mem ; gf_bs_read_data ( trak -> moov -> mov -> moviefilemap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isnotprotected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> moviefilemap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> media -> information -> sampletable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_parse ( trak -> moov -> mov -> moviefilemap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> algorithmid = traf -> sample_encryption -> algorithmid ; if ( ! trak -> sample_encryption -> iv_size ) trak -> sample_encryption -> iv_size = traf -> sample_encryption -> iv_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return gf_ok ; }","<S2SV_ModStart> ) ) { if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> ; } } saio = NULL ; } <S2SV_ModStart> break ; } saiz = NULL ;
",gpac@gpac/df8fffd839fe5ae9acd82d26fd48280a397411d9,CVE-2021-31260,https://github.com/gpac/gpac/commit/df8fffd839fe5ae9acd82d26fd48280a397411d9,2021-04-19T19:15Z,<S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
393,CWE-264,"static int rio_ioctl ( struct net_device * dev , struct ifreq * rq , int cmd ) { int phy_addr ; struct netdev_private * np = netdev_priv ( dev ) ; struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; struct netdev_desc * desc ; int i ; phy_addr = np -> phy_addr ; switch ( cmd ) { case siocdevprivate : break ; case siocdevprivate + 1 : miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; break ; case siocdevprivate + 2 : mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; break ; case siocdevprivate + 3 : break ; case siocdevprivate + 4 : break ; case siocdevprivate + 5 : netif_stop_queue ( dev ) ; break ; case siocdevprivate + 6 : netif_wake_queue ( dev ) ; break ; case siocdevprivate + 7 : printk ( ""tx_full=%x<s2sv_blank>cur_tx=%lx<s2sv_blank>old_tx=%lx<s2sv_blank>cur_rx=%lx<s2sv_blank>old_rx=%lx\\n"" , netif_queue_stopped ( dev ) , np -> cur_tx , np -> old_tx , np -> cur_rx , np -> old_rx ) ; break ; case siocdevprivate + 8 : printk ( ""tx<s2sv_blank>ring:\\n"" ) ; for ( i = 0 ; i < tx_ring_size ; i ++ ) { desc = & np -> tx_ring [ i ] ; printk ( ""%02x:cur:%08x<s2sv_blank>next:%08x<s2sv_blank>status:%08x<s2sv_blank>frag1:%08x<s2sv_blank>frag0:%08x"" , i , ( u32 ) ( np -> tx_ring_dma + i * sizeof ( * desc ) ) , ( u32 ) le64_to_cpu ( desc -> next_desc ) , ( u32 ) le64_to_cpu ( desc -> status ) , ( u32 ) ( le64_to_cpu ( desc -> fraginfo ) >> 32 ) , ( u32 ) le64_to_cpu ( desc -> fraginfo ) ) ; printk ( ""\\n"" ) ; } printk ( ""\\n"" ) ; break ; default : return - eopnotsupp ; } return 0 ; }","<S2SV_ModStart> ) ; struct mii_ioctl_data <S2SV_ModEnd> * miidata = <S2SV_ModStart> * miidata = if_mii ( rq ) <S2SV_ModEnd> ; phy_addr = <S2SV_ModStart> ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> break ; case <S2SV_ModStart> break ; case SIOCGMIIREG <S2SV_ModEnd> : miidata -> <S2SV_ModStart> : miidata -> val_out <S2SV_ModEnd> = mii_read ( <S2SV_ModStart> break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> mii_write ( dev <S2SV_ModStart> , miidata -> val_in <S2SV_ModEnd> ) ; break
",torvalds@linux/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,CVE-2012-2313,https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,2012-06-13T10:24Z,"<S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug>"
8042,CWE-000,"int sqlite3select ( parse * pparse , select * p , selectdest * pdest ) { int i , j ; whereinfo * pwinfo ; vdbe * v ; int isagg ; exprlist * pelist = 0 ; srclist * ptablist ; expr * pwhere ; exprlist * pgroupby ; expr * phaving ; int rc = 1 ; distinctctx sdistinct ; sortctx ssort ; agginfo sagginfo ; int iend ; sqlite3 * db ; exprlist * pminmaxorderby = 0 ; u8 minmaxflag ; db = pparse -> db ; v = sqlite3getvdbe ( pparse ) ; if ( p == 0 || db -> mallocfailed || pparse -> nerr ) { return 1 ; } if ( sqlite3authcheck ( pparse , sqlite_select , 0 , 0 , 0 ) ) return 1 ; memset ( & sagginfo , 0 , sizeof ( sagginfo ) ) ; # if selecttrace_enabled selecttrace ( 1 , pparse , p , ( ""begin<s2sv_blank>processing:\\n"" , pparse -> addrexplain ) ) ; if ( sqlite3selecttrace & 0x100 ) { sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif assert ( p -> porderby == 0 || pdest -> edest != srt_distfifo ) ; assert ( p -> porderby == 0 || pdest -> edest != srt_fifo ) ; assert ( p -> porderby == 0 || pdest -> edest != srt_distqueue ) ; assert ( p -> porderby == 0 || pdest -> edest != srt_queue ) ; if ( ignorableorderby ( pdest ) ) { assert ( pdest -> edest == srt_exists || pdest -> edest == srt_union || pdest -> edest == srt_except || pdest -> edest == srt_discard || pdest -> edest == srt_queue || pdest -> edest == srt_distfifo || pdest -> edest == srt_distqueue || pdest -> edest == srt_fifo ) ; sqlite3exprlistdelete ( db , p -> porderby ) ; p -> porderby = 0 ; p -> selflags &= ~ sf_distinct ; } sqlite3selectprep ( pparse , p , 0 ) ; if ( pparse -> nerr || db -> mallocfailed ) { goto select_end ; } assert ( p -> pelist != 0 ) ; # if selecttrace_enabled if ( sqlite3selecttrace & 0x104 ) { selecttrace ( 0x104 , pparse , p , ( ""after<s2sv_blank>name<s2sv_blank>resolution:\\n"" ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif if ( pdest -> edest == srt_output ) { generatecolumnnames ( pparse , p ) ; } # ifndef sqlite_omit_windowfunc if ( sqlite3windowrewrite ( pparse , p ) ) { goto select_end ; } # if selecttrace_enabled if ( p -> pwin && ( sqlite3selecttrace & 0x108 ) != 0 ) { selecttrace ( 0x104 , pparse , p , ( ""after<s2sv_blank>window<s2sv_blank>rewrite:\\n"" ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif # endif ptablist = p -> psrc ; isagg = ( p -> selflags & sf_aggregate ) != 0 ; memset ( & ssort , 0 , sizeof ( ssort ) ) ; ssort . porderby = p -> porderby ; # if ! defined ( sqlite_omit_subquery ) || ! defined ( sqlite_omit_view ) for ( i = 0 ; ! p -> pprior && i < ptablist -> nsrc ; i ++ ) { struct srclist_item * pitem = & ptablist -> a [ i ] ; select * psub = pitem -> pselect ; table * ptab = pitem -> ptab ; if ( ( pitem -> fg . jointype & jt_left ) != 0 && sqlite3exprimpliesnonnullrow ( p -> pwhere , pitem -> icursor ) && optimizationenabled ( db , sqlite_simplifyjoin ) ) { selecttrace ( 0x100 , pparse , p , ( ""left-join<s2sv_blank>simplifies<s2sv_blank>to<s2sv_blank>join<s2sv_blank>on<s2sv_blank>term<s2sv_blank>%d\\n"" , i ) ) ; pitem -> fg . jointype &= ~ ( jt_left | jt_outer ) ; unsetjoinexpr ( p -> pwhere , pitem -> icursor ) ; } if ( psub == 0 ) continue ; if ( ptab -> ncol != psub -> pelist -> nexpr ) { sqlite3errormsg ( pparse , ""expected<s2sv_blank>%d<s2sv_blank>columns<s2sv_blank>for<s2sv_blank>\'%s\'<s2sv_blank>but<s2sv_blank>got<s2sv_blank>%d"" , ptab -> ncol , ptab -> zname , psub -> pelist -> nexpr ) ; goto select_end ; } if ( ( psub -> selflags & sf_aggregate ) != 0 ) continue ; assert ( psub -> pgroupby == 0 ) ; if ( psub -> porderby != 0 && i == 0 && ( p -> selflags & sf_complexresult ) != 0 && ( ptablist -> nsrc == 1 || ( ptablist -> a [ 1 ] . fg . jointype & ( jt_left | jt_cross ) ) != 0 ) ) { continue ; } if ( flattensubquery ( pparse , p , i , isagg ) ) { if ( pparse -> nerr ) goto select_end ; i = - 1 ; } ptablist = p -> psrc ; if ( db -> mallocfailed ) goto select_end ; if ( ! ignorableorderby ( pdest ) ) { ssort . porderby = p -> porderby ; } } # endif # ifndef sqlite_omit_compound_select if ( p -> pprior ) { rc = multiselect ( pparse , p , pdest ) ; # if selecttrace_enabled selecttrace ( 0x1 , pparse , p , ( ""end<s2sv_blank>compound-select<s2sv_blank>processing\\n"" ) ) ; if ( ( sqlite3selecttrace & 0x2000 ) != 0 && explainqueryplanparent ( pparse ) == 0 ) { sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif if ( p -> pnext == 0 ) explainqueryplanpop ( pparse ) ; return rc ; } # endif if ( ptablist -> nsrc > 1 && optimizationenabled ( db , sqlite_propagateconst ) && propagateconstants ( pparse , p ) ) { # if selecttrace_enabled if ( sqlite3selecttrace & 0x100 ) { selecttrace ( 0x100 , pparse , p , ( ""after<s2sv_blank>constant<s2sv_blank>propagation:\\n"" ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif } else { selecttrace ( 0x100 , pparse , p , ( ""constant<s2sv_blank>propagation<s2sv_blank>not<s2sv_blank>helpful\\n"" ) ) ; } # ifdef sqlite_countofview_optimization if ( optimizationenabled ( db , sqlite_queryflattener | sqlite_countofview ) && countofviewoptimization ( pparse , p ) ) { if ( db -> mallocfailed ) goto select_end ; pelist = p -> pelist ; ptablist = p -> psrc ; } # endif for ( i = 0 ; i < ptablist -> nsrc ; i ++ ) { struct srclist_item * pitem = & ptablist -> a [ i ] ; selectdest dest ; select * psub ; # if ! defined ( sqlite_omit_subquery ) || ! defined ( sqlite_omit_view ) const char * zsavedauthcontext ; # endif if ( pitem -> colused == 0 && pitem -> zname != 0 ) { sqlite3authcheck ( pparse , sqlite_read , pitem -> zname , """" , pitem -> zdatabase ) ; } # if ! defined ( sqlite_omit_subquery ) || ! defined ( sqlite_omit_view ) psub = pitem -> pselect ; if ( psub == 0 ) continue ; testcase ( pitem -> addrfillsub != 0 ) ; pparse -> nheight += sqlite3selectexprheight ( p ) ; if ( optimizationenabled ( db , sqlite_pushdown ) && pushdownwhereterms ( pparse , psub , p -> pwhere , pitem -> icursor , ( pitem -> fg . jointype & jt_outer ) != 0 ) ) { # if selecttrace_enabled if ( sqlite3selecttrace & 0x100 ) { selecttrace ( 0x100 , pparse , p , ( ""after<s2sv_blank>where-clause<s2sv_blank>push-down<s2sv_blank>into<s2sv_blank>subquery<s2sv_blank>%d:\\n"" , psub -> selid ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif } else { selecttrace ( 0x100 , pparse , p , ( ""push-down<s2sv_blank>not<s2sv_blank>possible\\n"" ) ) ; } zsavedauthcontext = pparse -> zauthcontext ; pparse -> zauthcontext = pitem -> zname ; if ( i == 0 && ( ptablist -> nsrc == 1 || ( ptablist -> a [ 1 ] . fg . jointype & ( jt_left | jt_cross ) ) != 0 ) ) { int addrtop = sqlite3vdbecurrentaddr ( v ) + 1 ; pitem -> regreturn = ++ pparse -> nmem ; sqlite3vdbeaddop3 ( v , op_initcoroutine , pitem -> regreturn , 0 , addrtop ) ; vdbecomment ( ( v , ""%s"" , pitem -> ptab -> zname ) ) ; pitem -> addrfillsub = addrtop ; sqlite3selectdestinit ( & dest , srt_coroutine , pitem -> regreturn ) ; explainqueryplan ( ( pparse , 1 , ""co-routine<s2sv_blank>%u"" , psub -> selid ) ) ; sqlite3select ( pparse , psub , & dest ) ; pitem -> ptab -> nrowlogest = psub -> nselectrow ; pitem -> fg . viacoroutine = 1 ; pitem -> regresult = dest . isdst ; sqlite3vdbeendcoroutine ( v , pitem -> regreturn ) ; sqlite3vdbejumphere ( v , addrtop - 1 ) ; sqlite3cleartempregcache ( pparse ) ; } else { int topaddr ; int onceaddr = 0 ; int retaddr ; struct srclist_item * pprior ; testcase ( pitem -> addrfillsub == 0 ) ; pitem -> regreturn = ++ pparse -> nmem ; topaddr = sqlite3vdbeaddop2 ( v , op_integer , 0 , pitem -> regreturn ) ; pitem -> addrfillsub = topaddr + 1 ; if ( pitem -> fg . iscorrelated == 0 ) { onceaddr = sqlite3vdbeaddop0 ( v , op_once ) ; vdbecoverage ( v ) ; vdbecomment ( ( v , ""materialize<s2sv_blank>\\""%s\\"""" , pitem -> ptab -> zname ) ) ; } else { vdbenoopcomment ( ( v , ""materialize<s2sv_blank>\\""%s\\"""" , pitem -> ptab -> zname ) ) ; } pprior = isselfjoinview ( ptablist , pitem ) ; if ( pprior ) { sqlite3vdbeaddop2 ( v , op_opendup , pitem -> icursor , pprior -> icursor ) ; assert ( pprior -> pselect != 0 ) ; psub -> nselectrow = pprior -> pselect -> nselectrow ; } else { sqlite3selectdestinit ( & dest , srt_ephemtab , pitem -> icursor ) ; explainqueryplan ( ( pparse , 1 , ""materialize<s2sv_blank>%u"" , psub -> selid ) ) ; sqlite3select ( pparse , psub , & dest ) ; } pitem -> ptab -> nrowlogest = psub -> nselectrow ; if ( onceaddr ) sqlite3vdbejumphere ( v , onceaddr ) ; retaddr = sqlite3vdbeaddop1 ( v , op_return , pitem -> regreturn ) ; vdbecomment ( ( v , ""end<s2sv_blank>%s"" , pitem -> ptab -> zname ) ) ; sqlite3vdbechangep1 ( v , topaddr , retaddr ) ; sqlite3cleartempregcache ( pparse ) ; } if ( db -> mallocfailed ) goto select_end ; pparse -> nheight -= sqlite3selectexprheight ( p ) ; pparse -> zauthcontext = zsavedauthcontext ; # endif } pelist = p -> pelist ; pwhere = p -> pwhere ; pgroupby = p -> pgroupby ; phaving = p -> phaving ; sdistinct . istnct = ( p -> selflags & sf_distinct ) != 0 ; # if selecttrace_enabled if ( sqlite3selecttrace & 0x400 ) { selecttrace ( 0x400 , pparse , p , ( ""after<s2sv_blank>all<s2sv_blank>from-clause<s2sv_blank>analysis:\\n"" ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif if ( ( p -> selflags & ( sf_distinct | sf_aggregate ) ) == sf_distinct && sqlite3exprlistcompare ( ssort . porderby , pelist , - 1 ) == 0 ) { p -> selflags &= ~ sf_distinct ; pgroupby = p -> pgroupby = sqlite3exprlistdup ( db , pelist , 0 ) ; assert ( sdistinct . istnct ) ; # if selecttrace_enabled if ( sqlite3selecttrace & 0x400 ) { selecttrace ( 0x400 , pparse , p , ( ""transform<s2sv_blank>distinct<s2sv_blank>into<s2sv_blank>group<s2sv_blank>by:\\n"" ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif } if ( ssort . porderby ) { keyinfo * pkeyinfo ; pkeyinfo = sqlite3keyinfofromexprlist ( pparse , ssort . porderby , 0 , pelist -> nexpr ) ; ssort . iecursor = pparse -> ntab ++ ; ssort . addrsortindex = sqlite3vdbeaddop4 ( v , op_openephemeral , ssort . iecursor , ssort . porderby -> nexpr + 1 + pelist -> nexpr , 0 , ( char * ) pkeyinfo , p4_keyinfo ) ; } else { ssort . addrsortindex = - 1 ; } if ( pdest -> edest == srt_ephemtab ) { sqlite3vdbeaddop2 ( v , op_openephemeral , pdest -> isdparm , pelist -> nexpr ) ; } iend = sqlite3vdbemakelabel ( pparse ) ; if ( ( p -> selflags & sf_fixedlimit ) == 0 ) { p -> nselectrow = 320 ; } computelimitregisters ( pparse , p , iend ) ; if ( p -> ilimit == 0 && ssort . addrsortindex >= 0 ) { sqlite3vdbechangeopcode ( v , ssort . addrsortindex , op_sorteropen ) ; ssort . sortflags |= sortflag_usesorter ; } if ( p -> selflags & sf_distinct ) { sdistinct . tabtnct = pparse -> ntab ++ ; sdistinct . addrtnct = sqlite3vdbeaddop4 ( v , op_openephemeral , sdistinct . tabtnct , 0 , 0 , ( char * ) sqlite3keyinfofromexprlist ( pparse , p -> pelist , 0 , 0 ) , p4_keyinfo ) ; sqlite3vdbechangep5 ( v , btree_unordered ) ; sdistinct . etncttype = where_distinct_unordered ; } else { sdistinct . etncttype = where_distinct_noop ; } if ( ! isagg && pgroupby == 0 ) { u16 wctrlflags = ( sdistinct . istnct ? where_want_distinct : 0 ) | ( p -> selflags & sf_fixedlimit ) ; # ifndef sqlite_omit_windowfunc window * pwin = p -> pwin ; if ( pwin ) { sqlite3windowcodeinit ( pparse , pwin ) ; } # endif assert ( where_use_limit == sf_fixedlimit ) ; selecttrace ( 1 , pparse , p , ( ""wherebegin\\n"" ) ) ; pwinfo = sqlite3wherebegin ( pparse , ptablist , pwhere , ssort . porderby , p -> pelist , wctrlflags , p -> nselectrow ) ; if ( pwinfo == 0 ) goto select_end ; if ( sqlite3whereoutputrowcount ( pwinfo ) < p -> nselectrow ) { p -> nselectrow = sqlite3whereoutputrowcount ( pwinfo ) ; } if ( sdistinct . istnct && sqlite3whereisdistinct ( pwinfo ) ) { sdistinct . etncttype = sqlite3whereisdistinct ( pwinfo ) ; } if ( ssort . porderby ) { ssort . nobsat = sqlite3whereisordered ( pwinfo ) ; ssort . labeloblopt = sqlite3whereorderbylimitoptlabel ( pwinfo ) ; if ( ssort . nobsat == ssort . porderby -> nexpr ) { ssort . porderby = 0 ; } } if ( ssort . addrsortindex >= 0 && ssort . porderby == 0 ) { sqlite3vdbechangetonoop ( v , ssort . addrsortindex ) ; } assert ( p -> pelist == pelist ) ; # ifndef sqlite_omit_windowfunc if ( pwin ) { int addrgosub = sqlite3vdbemakelabel ( pparse ) ; int icont = sqlite3vdbemakelabel ( pparse ) ; int ibreak = sqlite3vdbemakelabel ( pparse ) ; int reggosub = ++ pparse -> nmem ; sqlite3windowcodestep ( pparse , p , pwinfo , reggosub , addrgosub ) ; sqlite3vdbeaddop2 ( v , op_goto , 0 , ibreak ) ; sqlite3vdberesolvelabel ( v , addrgosub ) ; vdbenoopcomment ( ( v , ""inner-loop<s2sv_blank>subroutine"" ) ) ; ssort . labeloblopt = 0 ; selectinnerloop ( pparse , p , - 1 , & ssort , & sdistinct , pdest , icont , ibreak ) ; sqlite3vdberesolvelabel ( v , icont ) ; sqlite3vdbeaddop1 ( v , op_return , reggosub ) ; vdbecomment ( ( v , ""end<s2sv_blank>inner-loop<s2sv_blank>subroutine"" ) ) ; sqlite3vdberesolvelabel ( v , ibreak ) ; } else # endif { selectinnerloop ( pparse , p , - 1 , & ssort , & sdistinct , pdest , sqlite3wherecontinuelabel ( pwinfo ) , sqlite3wherebreaklabel ( pwinfo ) ) ; sqlite3whereend ( pwinfo ) ; } } else { namecontext snc ; int iamem ; int ibmem ; int iuseflag ; int iabortflag ; int groupbysort ; int addrend ; int sortptab = 0 ; int sortout = 0 ; int orderbygrp = 0 ; if ( pgroupby ) { int k ; struct exprlist_item * pitem ; for ( k = p -> pelist -> nexpr , pitem = p -> pelist -> a ; k > 0 ; k -- , pitem ++ ) { pitem -> u . x . ialias = 0 ; } for ( k = pgroupby -> nexpr , pitem = pgroupby -> a ; k > 0 ; k -- , pitem ++ ) { pitem -> u . x . ialias = 0 ; } assert ( 66 == sqlite3logest ( 100 ) ) ; if ( p -> nselectrow > 66 ) p -> nselectrow = 66 ; if ( ssort . porderby && pgroupby -> nexpr == ssort . porderby -> nexpr ) { int ii ; for ( ii = 0 ; ii < pgroupby -> nexpr ; ii ++ ) { u8 sortflags = ssort . porderby -> a [ ii ] . sortflags & keyinfo_order_desc ; pgroupby -> a [ ii ] . sortflags = sortflags ; } if ( sqlite3exprlistcompare ( pgroupby , ssort . porderby , - 1 ) == 0 ) { orderbygrp = 1 ; } } } else { assert ( 0 == sqlite3logest ( 1 ) ) ; p -> nselectrow = 0 ; } addrend = sqlite3vdbemakelabel ( pparse ) ; memset ( & snc , 0 , sizeof ( snc ) ) ; snc . pparse = pparse ; snc . psrclist = ptablist ; snc . unc . pagginfo = & sagginfo ; vva_only ( snc . ncflags = nc_uagginfo ; ) sagginfo . mnreg = pparse -> nmem + 1 ; sagginfo . nsortingcolumn = pgroupby ? pgroupby -> nexpr : 0 ; sagginfo . pgroupby = pgroupby ; sqlite3expranalyzeagglist ( & snc , pelist ) ; sqlite3expranalyzeagglist ( & snc , ssort . porderby ) ; if ( phaving ) { if ( pgroupby ) { assert ( pwhere == p -> pwhere ) ; assert ( phaving == p -> phaving ) ; assert ( pgroupby == p -> pgroupby ) ; havingtowhere ( pparse , p ) ; pwhere = p -> pwhere ; } sqlite3expranalyzeaggregates ( & snc , phaving ) ; } sagginfo . naccumulator = sagginfo . ncolumn ; if ( p -> pgroupby == 0 && p -> phaving == 0 && sagginfo . nfunc == 1 ) { minmaxflag = minmaxquery ( db , sagginfo . afunc [ 0 ] . pexpr , & pminmaxorderby ) ; } else { minmaxflag = where_orderby_normal ; } for ( i = 0 ; i < sagginfo . nfunc ; i ++ ) { expr * pexpr = sagginfo . afunc [ i ] . pexpr ; assert ( ! exprhasproperty ( pexpr , ep_xisselect ) ) ; snc . ncflags |= nc_inaggfunc ; sqlite3expranalyzeagglist ( & snc , pexpr -> x . plist ) ; # ifndef sqlite_omit_windowfunc assert ( ! iswindowfunc ( pexpr ) ) ; if ( exprhasproperty ( pexpr , ep_winfunc ) ) { sqlite3expranalyzeaggregates ( & snc , pexpr -> y . pwin -> pfilter ) ; } # endif snc . ncflags &= ~ nc_inaggfunc ; } sagginfo . mxreg = pparse -> nmem ; if ( db -> mallocfailed ) goto select_end ; # if selecttrace_enabled if ( sqlite3selecttrace & 0x400 ) { int ii ; selecttrace ( 0x400 , pparse , p , ( ""after<s2sv_blank>aggregate<s2sv_blank>analysis:\\n"" ) ) ; sqlite3treeviewselect ( 0 , p , 0 ) ; for ( ii = 0 ; ii < sagginfo . ncolumn ; ii ++ ) { sqlite3debugprintf ( ""agg-column[%d]<s2sv_blank>imem=%d\\n"" , ii , sagginfo . acol [ ii ] . imem ) ; sqlite3treeviewexpr ( 0 , sagginfo . acol [ ii ] . pexpr , 0 ) ; } for ( ii = 0 ; ii < sagginfo . nfunc ; ii ++ ) { sqlite3debugprintf ( ""agg-func[%d]:<s2sv_blank>imem=%d\\n"" , ii , sagginfo . afunc [ ii ] . imem ) ; sqlite3treeviewexpr ( 0 , sagginfo . afunc [ ii ] . pexpr , 0 ) ; } } # endif if ( pgroupby ) { keyinfo * pkeyinfo ; int addr1 ; int addroutputrow ; int regoutputrow ; int addrsetabort ; int addrtopofloop ; int addrsortingidx ; int addrreset ; int regreset ; sagginfo . sortingidx = pparse -> ntab ++ ; pkeyinfo = sqlite3keyinfofromexprlist ( pparse , pgroupby , 0 , sagginfo . ncolumn ) ; addrsortingidx = sqlite3vdbeaddop4 ( v , op_sorteropen , sagginfo . sortingidx , sagginfo . nsortingcolumn , 0 , ( char * ) pkeyinfo , p4_keyinfo ) ; iuseflag = ++ pparse -> nmem ; iabortflag = ++ pparse -> nmem ; regoutputrow = ++ pparse -> nmem ; addroutputrow = sqlite3vdbemakelabel ( pparse ) ; regreset = ++ pparse -> nmem ; addrreset = sqlite3vdbemakelabel ( pparse ) ; iamem = pparse -> nmem + 1 ; pparse -> nmem += pgroupby -> nexpr ; ibmem = pparse -> nmem + 1 ; pparse -> nmem += pgroupby -> nexpr ; sqlite3vdbeaddop2 ( v , op_integer , 0 , iabortflag ) ; vdbecomment ( ( v , ""clear<s2sv_blank>abort<s2sv_blank>flag"" ) ) ; sqlite3vdbeaddop3 ( v , op_null , 0 , iamem , iamem + pgroupby -> nexpr - 1 ) ; sqlite3vdbeaddop2 ( v , op_gosub , regreset , addrreset ) ; selecttrace ( 1 , pparse , p , ( ""wherebegin\\n"" ) ) ; pwinfo = sqlite3wherebegin ( pparse , ptablist , pwhere , pgroupby , 0 , where_groupby | ( orderbygrp ? where_sortbygroup : 0 ) , 0 ) ; if ( pwinfo == 0 ) goto select_end ; if ( sqlite3whereisordered ( pwinfo ) == pgroupby -> nexpr ) { groupbysort = 0 ; } else { int regbase ; int regrecord ; int ncol ; int ngroupby ; explaintemptable ( pparse , ( sdistinct . istnct && ( p -> selflags & sf_distinct ) == 0 ) ? ""distinct"" : ""group<s2sv_blank>by"" ) ; groupbysort = 1 ; ngroupby = pgroupby -> nexpr ; ncol = ngroupby ; j = ngroupby ; for ( i = 0 ; i < sagginfo . ncolumn ; i ++ ) { if ( sagginfo . acol [ i ] . isortercolumn >= j ) { ncol ++ ; j ++ ; } } regbase = sqlite3gettemprange ( pparse , ncol ) ; sqlite3exprcodeexprlist ( pparse , pgroupby , regbase , 0 , 0 ) ; j = ngroupby ; for ( i = 0 ; i < sagginfo . ncolumn ; i ++ ) { struct agginfo_col * pcol = & sagginfo . acol [ i ] ; if ( pcol -> isortercolumn >= j ) { int r1 = j + regbase ; sqlite3exprcodegetcolumnoftable ( v , pcol -> ptab , pcol -> itable , pcol -> icolumn , r1 ) ; j ++ ; } } regrecord = sqlite3gettempreg ( pparse ) ; sqlite3vdbeaddop3 ( v , op_makerecord , regbase , ncol , regrecord ) ; sqlite3vdbeaddop2 ( v , op_sorterinsert , sagginfo . sortingidx , regrecord ) ; sqlite3releasetempreg ( pparse , regrecord ) ; sqlite3releasetemprange ( pparse , regbase , ncol ) ; sqlite3whereend ( pwinfo ) ; sagginfo . sortingidxptab = sortptab = pparse -> ntab ++ ; sortout = sqlite3gettempreg ( pparse ) ; sqlite3vdbeaddop3 ( v , op_openpseudo , sortptab , sortout , ncol ) ; sqlite3vdbeaddop2 ( v , op_sortersort , sagginfo . sortingidx , addrend ) ; vdbecomment ( ( v , ""group<s2sv_blank>by<s2sv_blank>sort"" ) ) ; vdbecoverage ( v ) ; sagginfo . usesortingidx = 1 ; } if ( orderbygrp && optimizationenabled ( db , sqlite_groupbyorder ) && ( groupbysort || sqlite3whereissorted ( pwinfo ) ) ) { ssort . porderby = 0 ; sqlite3vdbechangetonoop ( v , ssort . addrsortindex ) ; } addrtopofloop = sqlite3vdbecurrentaddr ( v ) ; if ( groupbysort ) { sqlite3vdbeaddop3 ( v , op_sorterdata , sagginfo . sortingidx , sortout , sortptab ) ; } for ( j = 0 ; j < pgroupby -> nexpr ; j ++ ) { if ( groupbysort ) { sqlite3vdbeaddop3 ( v , op_column , sortptab , j , ibmem + j ) ; } else { sagginfo . directmode = 1 ; sqlite3exprcode ( pparse , pgroupby -> a [ j ] . pexpr , ibmem + j ) ; } } sqlite3vdbeaddop4 ( v , op_compare , iamem , ibmem , pgroupby -> nexpr , ( char * ) sqlite3keyinforef ( pkeyinfo ) , p4_keyinfo ) ; addr1 = sqlite3vdbecurrentaddr ( v ) ; sqlite3vdbeaddop3 ( v , op_jump , addr1 + 1 , 0 , addr1 + 1 ) ; vdbecoverage ( v ) ; sqlite3exprcodemove ( pparse , ibmem , iamem , pgroupby -> nexpr ) ; sqlite3vdbeaddop2 ( v , op_gosub , regoutputrow , addroutputrow ) ; vdbecomment ( ( v , ""output<s2sv_blank>one<s2sv_blank>row"" ) ) ; sqlite3vdbeaddop2 ( v , op_ifpos , iabortflag , addrend ) ; vdbecoverage ( v ) ; vdbecomment ( ( v , ""check<s2sv_blank>abort<s2sv_blank>flag"" ) ) ; sqlite3vdbeaddop2 ( v , op_gosub , regreset , addrreset ) ; vdbecomment ( ( v , ""reset<s2sv_blank>accumulator"" ) ) ; sqlite3vdbejumphere ( v , addr1 ) ; updateaccumulator ( pparse , iuseflag , & sagginfo ) ; sqlite3vdbeaddop2 ( v , op_integer , 1 , iuseflag ) ; vdbecomment ( ( v , ""indicate<s2sv_blank>data<s2sv_blank>in<s2sv_blank>accumulator"" ) ) ; if ( groupbysort ) { sqlite3vdbeaddop2 ( v , op_sorternext , sagginfo . sortingidx , addrtopofloop ) ; vdbecoverage ( v ) ; } else { sqlite3whereend ( pwinfo ) ; sqlite3vdbechangetonoop ( v , addrsortingidx ) ; } sqlite3vdbeaddop2 ( v , op_gosub , regoutputrow , addroutputrow ) ; vdbecomment ( ( v , ""output<s2sv_blank>final<s2sv_blank>row"" ) ) ; sqlite3vdbegoto ( v , addrend ) ; addrsetabort = sqlite3vdbecurrentaddr ( v ) ; sqlite3vdbeaddop2 ( v , op_integer , 1 , iabortflag ) ; vdbecomment ( ( v , ""set<s2sv_blank>abort<s2sv_blank>flag"" ) ) ; sqlite3vdbeaddop1 ( v , op_return , regoutputrow ) ; sqlite3vdberesolvelabel ( v , addroutputrow ) ; addroutputrow = sqlite3vdbecurrentaddr ( v ) ; sqlite3vdbeaddop2 ( v , op_ifpos , iuseflag , addroutputrow + 2 ) ; vdbecoverage ( v ) ; vdbecomment ( ( v , ""groupby<s2sv_blank>result<s2sv_blank>generator<s2sv_blank>entry<s2sv_blank>point"" ) ) ; sqlite3vdbeaddop1 ( v , op_return , regoutputrow ) ; finalizeaggfunctions ( pparse , & sagginfo ) ; sqlite3expriffalse ( pparse , phaving , addroutputrow + 1 , sqlite_jumpifnull ) ; selectinnerloop ( pparse , p , - 1 , & ssort , & sdistinct , pdest , addroutputrow + 1 , addrsetabort ) ; sqlite3vdbeaddop1 ( v , op_return , regoutputrow ) ; vdbecomment ( ( v , ""end<s2sv_blank>groupby<s2sv_blank>result<s2sv_blank>generator"" ) ) ; sqlite3vdberesolvelabel ( v , addrreset ) ; resetaccumulator ( pparse , & sagginfo ) ; sqlite3vdbeaddop2 ( v , op_integer , 0 , iuseflag ) ; vdbecomment ( ( v , ""indicate<s2sv_blank>accumulator<s2sv_blank>empty"" ) ) ; sqlite3vdbeaddop1 ( v , op_return , regreset ) ; } else { # ifndef sqlite_omit_btreecount table * ptab ; if ( ( ptab = issimplecount ( p , & sagginfo ) ) != 0 ) { const int idb = sqlite3schematoindex ( pparse -> db , ptab -> pschema ) ; const int icsr = pparse -> ntab ++ ; index * pidx ; keyinfo * pkeyinfo = 0 ; index * pbest = 0 ; int iroot = ptab -> tnum ; sqlite3codeverifyschema ( pparse , idb ) ; sqlite3tablelock ( pparse , idb , ptab -> tnum , 0 , ptab -> zname ) ; if ( ! hasrowid ( ptab ) ) pbest = sqlite3primarykeyindex ( ptab ) ; for ( pidx = ptab -> pindex ; pidx ; pidx = pidx -> pnext ) { if ( pidx -> bunordered == 0 && pidx -> szidxrow < ptab -> sztabrow && pidx -> ppartidxwhere == 0 && ( ! pbest || pidx -> szidxrow < pbest -> szidxrow ) ) { pbest = pidx ; } } if ( pbest ) { iroot = pbest -> tnum ; pkeyinfo = sqlite3keyinfoofindex ( pparse , pbest ) ; } sqlite3vdbeaddop4int ( v , op_openread , icsr , iroot , idb , 1 ) ; if ( pkeyinfo ) { sqlite3vdbechangep4 ( v , - 1 , ( char * ) pkeyinfo , p4_keyinfo ) ; } sqlite3vdbeaddop2 ( v , op_count , icsr , sagginfo . afunc [ 0 ] . imem ) ; sqlite3vdbeaddop1 ( v , op_close , icsr ) ; explainsimplecount ( pparse , ptab , pbest ) ; } else # endif { int regacc = 0 ; if ( sagginfo . naccumulator ) { for ( i = 0 ; i < sagginfo . nfunc ; i ++ ) { if ( exprhasproperty ( sagginfo . afunc [ i ] . pexpr , ep_winfunc ) ) continue ; if ( sagginfo . afunc [ i ] . pfunc -> funcflags & sqlite_func_needcoll ) break ; } if ( i == sagginfo . nfunc ) { regacc = ++ pparse -> nmem ; sqlite3vdbeaddop2 ( v , op_integer , 0 , regacc ) ; } } assert ( p -> pgroupby == 0 ) ; resetaccumulator ( pparse , & sagginfo ) ; assert ( minmaxflag == where_orderby_normal || pminmaxorderby != 0 ) ; assert ( pminmaxorderby == 0 || pminmaxorderby -> nexpr == 1 ) ; selecttrace ( 1 , pparse , p , ( ""wherebegin\\n"" ) ) ; pwinfo = sqlite3wherebegin ( pparse , ptablist , pwhere , pminmaxorderby , 0 , minmaxflag , 0 ) ; if ( pwinfo == 0 ) { goto select_end ; } updateaccumulator ( pparse , regacc , & sagginfo ) ; if ( regacc ) sqlite3vdbeaddop2 ( v , op_integer , 1 , regacc ) ; if ( sqlite3whereisordered ( pwinfo ) > 0 ) { sqlite3vdbegoto ( v , sqlite3wherebreaklabel ( pwinfo ) ) ; vdbecomment ( ( v , ""%s()<s2sv_blank>by<s2sv_blank>index"" , ( minmaxflag == where_orderby_min ? ""min"" : ""max"" ) ) ) ; } sqlite3whereend ( pwinfo ) ; finalizeaggfunctions ( pparse , & sagginfo ) ; } ssort . porderby = 0 ; sqlite3expriffalse ( pparse , phaving , addrend , sqlite_jumpifnull ) ; selectinnerloop ( pparse , p , - 1 , 0 , 0 , pdest , addrend , addrend ) ; } sqlite3vdberesolvelabel ( v , addrend ) ; } if ( sdistinct . etncttype == where_distinct_unordered ) { explaintemptable ( pparse , ""distinct"" ) ; } if ( ssort . porderby ) { explaintemptable ( pparse , ssort . nobsat > 0 ? ""right<s2sv_blank>part<s2sv_blank>of<s2sv_blank>order<s2sv_blank>by"" : ""order<s2sv_blank>by"" ) ; assert ( p -> pelist == pelist ) ; generatesorttail ( pparse , p , & ssort , pelist -> nexpr , pdest ) ; } sqlite3vdberesolvelabel ( v , iend ) ; rc = ( pparse -> nerr > 0 ) ; select_end : sqlite3exprlistdelete ( db , pminmaxorderby ) ; sqlite3dbfree ( db , sagginfo . acol ) ; sqlite3dbfree ( db , sagginfo . afunc ) ; # if selecttrace_enabled selecttrace ( 0x1 , pparse , p , ( ""end<s2sv_blank>processing\\n"" ) ) ; if ( ( sqlite3selecttrace & 0x2000 ) != 0 && explainqueryplanparent ( pparse ) == 0 ) { sqlite3treeviewselect ( 0 , p , 0 ) ; } # endif explainqueryplanpop ( pparse ) ; return rc ; }","<S2SV_ModStart> ) == 0 && p -> pWin == 0
",sqlite@sqlite/e59c562b3f6894f84c715772c4b116d7b5c01348,CVE-2019-19244,https://github.com/sqlite/sqlite/commit/e59c562b3f6894f84c715772c4b116d7b5c01348,2019-11-25T20:15Z,<S2SV_StartBug> ) { <S2SV_EndBug>
3486,CWE-264,"int xt_check_entry_offsets ( const void * base , unsigned int target_offset , unsigned int next_offset ) { const struct xt_entry_target * t ; const char * e = base ; if ( target_offset + sizeof ( * t ) > next_offset ) return - einval ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - einval ; if ( target_offset + t -> u . target_size > next_offset ) return - einval ; if ( strcmp ( t -> u . user . name , xt_standard_target ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - einval ; return 0 ; }","<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL
",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug>"
4509,CWE-125,"dfa * ta3grammar_finddfa ( grammar * g , int type ) { dfa * d ; # if 1 d = & g -> g_dfa [ type - nt_offset ] ; assert ( d -> d_type == type ) ; return d ; # else int i ; for ( i = g -> g_ndfas , d = g -> g_dfa ; -- i >= 0 ; d ++ ) { if ( d -> d_type == type ) return d ; } assert ( 0 ) ; # endif }","<S2SV_ModStart> d ; } abort ( <S2SV_ModEnd> ) ; #
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug>
3565,CWE-400,"static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( is_mnt_new ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = cl_make_shared ; } else { struct mount * n , * p ; bool done ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || is_mnt_marked ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; type = cl_slave ; if ( is_mnt_shared ( m ) ) type |= cl_make_shared ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= cl_unprivileged ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( is_err ( child ) ) return ptr_err ( child ) ; child -> mnt . mnt_flags &= ~ mnt_locked ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; set_mnt_mark ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }","<S2SV_ModStart> ) ; return count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z,<S2SV_StartBug> return 0 ; <S2SV_EndBug>
2550,CWE-189,"static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= max_user_controls ) return - enomem ; if ( info -> count < 1 ) return - einval ; access = info -> access == 0 ? sndrv_ctl_elem_access_readwrite : ( info -> access & ( sndrv_ctl_elem_access_readwrite | sndrv_ctl_elem_access_inactive | sndrv_ctl_elem_access_tlv_readwrite ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - ebusy ; } else { if ( replace ) err = - enoent ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= sndrv_ctl_elem_access_user ; if ( info -> type == sndrv_ctl_elem_type_enumerated ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & sndrv_ctl_elem_access_read ) kctl . get = snd_ctl_elem_user_get ; if ( access & sndrv_ctl_elem_access_write ) kctl . put = snd_ctl_elem_user_put ; if ( access & sndrv_ctl_elem_access_tlv_readwrite ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= sndrv_ctl_elem_access_tlv_callback ; } switch ( info -> type ) { case sndrv_ctl_elem_type_boolean : case sndrv_ctl_elem_type_integer : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - einval ; break ; case sndrv_ctl_elem_type_integer64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - einval ; break ; case sndrv_ctl_elem_type_enumerated : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - einval ; break ; case sndrv_ctl_elem_type_bytes : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - einval ; break ; case sndrv_ctl_elem_type_iec958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - einval ; break ; default : return - einval ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , gfp_kernel ) ; if ( ue == null ) return - enomem ; ue -> card = card ; ue -> info = * info ; ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == sndrv_ctl_elem_type_enumerated ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == null ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - enomem ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }","<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (
",torvalds@linux/82262a46627bebb0febcc26664746c25cef08563,CVE-2014-4655,https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563,2014-07-03T04:22Z,<S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug>
8119,CWE-295,"int options_cmdline ( char * arg1 , char * arg2 ) { char * name ; conf_type type ; # ifdef use_win32 ( void ) arg2 ; # endif if ( ! arg1 ) { name = # ifdef confdir confdir # ifdef use_win32 ""\\\\"" # else ""/"" # endif # endif ""stunnel.conf"" ; type = conf_file ; } else if ( ! strcasecmp ( arg1 , ""-help"" ) ) { parse_global_option ( cmd_print_help , null , null ) ; parse_service_option ( cmd_print_help , null , null , null ) ; log_flush ( log_mode_info ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-version"" ) ) { parse_global_option ( cmd_print_defaults , null , null ) ; parse_service_option ( cmd_print_defaults , null , null , null ) ; log_flush ( log_mode_info ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-sockets"" ) ) { socket_options_print ( ) ; log_flush ( log_mode_info ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-options"" ) ) { print_ssl_options ( ) ; log_flush ( log_mode_info ) ; return 2 ; } else # ifndef use_win32 if ( ! strcasecmp ( arg1 , ""-fd"" ) ) { if ( ! arg2 ) { s_log ( log_err , ""no<s2sv_blank>file<s2sv_blank>descriptor<s2sv_blank>specified"" ) ; print_syntax ( ) ; return 1 ; } name = arg2 ; type = conf_fd ; } else # endif { name = arg1 ; type = conf_file ; } if ( type == conf_file ) { # ifdef have_realpath char * real_path = null ; # ifdef maxpathlen real_path = malloc ( maxpathlen ) ; # endif real_path = realpath ( name , real_path ) ; if ( ! real_path ) { s_log ( log_err , ""invalid<s2sv_blank>configuration<s2sv_blank>file<s2sv_blank>name<s2sv_blank>\\""%s\\"""" , name ) ; ioerror ( ""realpath"" ) ; return 1 ; } configuration_file = str_dup ( real_path ) ; free ( real_path ) ; # else configuration_file = str_dup ( name ) ; # endif # ifndef use_win32 } else if ( type == conf_fd ) { configuration_file = str_dup ( name ) ; # endif } return options_parse ( type ) ; }","<S2SV_ModStart> NULL , NULL , NULL <S2SV_ModStart> parse_global_option ( CMD_PRINT_DEFAULTS , NULL
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,"<S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug>"
7052,CWE-476,"static gf_av1config * av1_duplicateconfig ( gf_av1config const * const cfg ) { u32 i = 0 ; gf_av1config * out = gf_malloc ( sizeof ( gf_av1config ) ) ; out -> marker = cfg -> marker ; out -> version = cfg -> version ; out -> seq_profile = cfg -> seq_profile ; out -> seq_level_idx_0 = cfg -> seq_level_idx_0 ; out -> seq_tier_0 = cfg -> seq_tier_0 ; out -> high_bitdepth = cfg -> high_bitdepth ; out -> twelve_bit = cfg -> twelve_bit ; out -> monochrome = cfg -> monochrome ; out -> chroma_subsampling_x = cfg -> chroma_subsampling_x ; out -> chroma_subsampling_y = cfg -> chroma_subsampling_y ; out -> chroma_sample_position = cfg -> chroma_sample_position ; out -> initial_presentation_delay_present = cfg -> initial_presentation_delay_present ; out -> initial_presentation_delay_minus_one = cfg -> initial_presentation_delay_minus_one ; out -> obu_array = gf_list_new ( ) ; for ( i = 0 ; i < gf_list_count ( cfg -> obu_array ) ; ++ i ) { gf_av1_obuarrayentry * dst = gf_malloc ( sizeof ( gf_av1_obuarrayentry ) ) , * src = gf_list_get ( cfg -> obu_array , i ) ; dst -> obu_length = src -> obu_length ; dst -> obu_type = src -> obu_type ; dst -> obu = gf_malloc ( ( size_t ) dst -> obu_length ) ; memcpy ( dst -> obu , src -> obu , ( size_t ) src -> obu_length ) ; gf_list_add ( out -> obu_array , dst ) ; } return out ; }","
",gpac@gpac/b2eab95e07cb5819375a50358d4806a8813b6e50,CVE-2021-31262,https://github.com/gpac/gpac/commit/b2eab95e07cb5819375a50358d4806a8813b6e50,2021-04-19T19:15Z,
7836,CWE-20,"error_t rawsocketreceiveippacket ( socket * socket , socketmsg * message , uint_t flags ) { error_t error ; socketqueueitem * queueitem ; if ( ( flags & socket_flag_dont_wait ) == 0 ) { if ( socket -> receivequeue == null ) { socket -> eventmask = socket_event_rx_ready ; osresetevent ( & socket -> event ) ; osreleasemutex ( & netmutex ) ; oswaitforevent ( & socket -> event , socket -> timeout ) ; osacquiremutex ( & netmutex ) ; } } if ( socket -> receivequeue != null ) { queueitem = socket -> receivequeue ; message -> length = netbufferread ( message -> data , queueitem -> buffer , queueitem -> offset , message -> size ) ; message -> srcipaddr = queueitem -> srcipaddr ; message -> srcport = queueitem -> srcport ; message -> destipaddr = queueitem -> destipaddr ; message -> ttl = queueitem -> ancillary . ttl ; # if ( eth_support == enabled ) message -> srcmacaddr = queueitem -> ancillary . srcmacaddr ; message -> destmacaddr = queueitem -> ancillary . destmacaddr ; # endif # if ( eth_port_tagging_support == enabled ) message -> switchport = queueitem -> ancillary . port ; # endif # if ( eth_timestamp_support == enabled ) message -> timestamp = queueitem -> ancillary . timestamp ; # endif if ( ( flags & socket_flag_peek ) == 0 ) { socket -> receivequeue = queueitem -> next ; netbufferfree ( queueitem -> buffer ) ; } rawsocketupdateevents ( socket ) ; error = no_error ; } else { message -> length = 0 ; error = error_timeout ; } return error ; }","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug>
6170,CWE-772,"static image * readmatimage ( const imageinfo * image_info , exceptioninfo * exception ) { image * image , * image2 = null , * rotated_image ; register quantum * q ; unsigned int status ; matheader matlab_hdr ; size_t size ; size_t celltype ; quantuminfo * quantum_info ; imageinfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * bimgbuff = null ; double minval , maxval ; unsigned z , z2 ; unsigned frames ; int logging ; int sample_size ; magickoffsettype filepos = 0x80 ; blobinfo * blob ; size_t one ; unsigned int ( * readblobxxxlong ) ( image * image ) ; unsigned short ( * readblobxxxshort ) ( image * image ) ; void ( * readblobdoublesxxx ) ( image * image , size_t len , double * data ) ; void ( * readblobfloatsxxx ) ( image * image , size_t len , float * data ) ; assert ( image_info != ( const imageinfo * ) null ) ; assert ( image_info -> signature == magickcoresignature ) ; assert ( exception != ( exceptioninfo * ) null ) ; assert ( exception -> signature == magickcoresignature ) ; logging = logmagickevent ( coderevent , getmagickmodule ( ) , ""enter"" ) ; image = acquireimage ( image_info , exception ) ; status = openblob ( image_info , image , readbinaryblobmode , exception ) ; if ( status == magickfalse ) { image = destroyimagelist ( image ) ; return ( ( image * ) null ) ; } clone_info = cloneimageinfo ( image_info ) ; if ( readblob ( image , 124 , ( unsigned char * ) & matlab_hdr . identific ) != 124 ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; if ( strncmp ( matlab_hdr . identific , ""matlab"" , 6 ) != 0 ) { image2 = readmatimagev4 ( image_info , image , exception ) ; if ( image2 == null ) goto matlab_ko ; image = image2 ; goto end_of_reading ; } matlab_hdr . version = readbloblsbshort ( image ) ; if ( readblob ( image , 2 , ( unsigned char * ) & matlab_hdr . endianindicator ) != 2 ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""<s2sv_blank><s2sv_blank>endian<s2sv_blank>%c%c"" , matlab_hdr . endianindicator [ 0 ] , matlab_hdr . endianindicator [ 1 ] ) ; if ( ! strncmp ( matlab_hdr . endianindicator , ""im"" , 2 ) ) { readblobxxxlong = readbloblsblong ; readblobxxxshort = readbloblsbshort ; readblobdoublesxxx = readblobdoubleslsb ; readblobfloatsxxx = readblobfloatslsb ; image -> endian = lsbendian ; } else if ( ! strncmp ( matlab_hdr . endianindicator , ""mi"" , 2 ) ) { readblobxxxlong = readblobmsblong ; readblobxxxshort = readblobmsbshort ; readblobdoublesxxx = readblobdoublesmsb ; readblobfloatsxxx = readblobfloatsmsb ; image -> endian = msbendian ; } else goto matlab_ko ; if ( strncmp ( matlab_hdr . identific , ""matlab"" , 6 ) ) matlab_ko : throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; filepos = tellblob ( image ) ; while ( ! eofblob ( image ) ) { frames = 1 ; ( void ) seekblob ( image , filepos , seek_set ) ; matlab_hdr . datatype = readblobxxxlong ( image ) ; if ( eofblob ( image ) ) break ; matlab_hdr . objectsize = readblobxxxlong ( image ) ; if ( eofblob ( image ) ) break ; filepos += matlab_hdr . objectsize + 4 + 4 ; image2 = image ; # if defined ( magickcore_zlib_delegate ) if ( matlab_hdr . datatype == micompressed ) { image2 = decompressblock ( image , matlab_hdr . objectsize , clone_info , exception ) ; if ( image2 == null ) continue ; matlab_hdr . datatype = readblobxxxlong ( image2 ) ; } # endif if ( matlab_hdr . datatype != mimatrix ) continue ; matlab_hdr . unknown1 = readblobxxxlong ( image2 ) ; matlab_hdr . unknown2 = readblobxxxlong ( image2 ) ; matlab_hdr . unknown5 = readblobxxxlong ( image2 ) ; matlab_hdr . structureclass = matlab_hdr . unknown5 & 0xff ; matlab_hdr . structureflag = ( matlab_hdr . unknown5 >> 8 ) & 0xff ; matlab_hdr . unknown3 = readblobxxxlong ( image2 ) ; if ( image != image2 ) matlab_hdr . unknown4 = readblobxxxlong ( image2 ) ; matlab_hdr . unknown4 = readblobxxxlong ( image2 ) ; matlab_hdr . dimflag = readblobxxxlong ( image2 ) ; matlab_hdr . sizex = readblobxxxlong ( image2 ) ; matlab_hdr . sizey = readblobxxxlong ( image2 ) ; switch ( matlab_hdr . dimflag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = readblobxxxlong ( image2 ) ; ( void ) readblobxxxlong ( image2 ) ; if ( z != 3 ) throwreaderexception ( codererror , ""multidimensionalmatricesarenotsupported"" ) ; break ; case 16 : z2 = z = readblobxxxlong ( image2 ) ; if ( z != 3 && z != 1 ) throwreaderexception ( codererror , ""multidimensionalmatricesarenotsupported"" ) ; frames = readblobxxxlong ( image2 ) ; if ( frames == 0 ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; break ; default : throwreaderexception ( codererror , ""multidimensionalmatricesarenotsupported"" ) ; } matlab_hdr . flag1 = readblobxxxshort ( image2 ) ; matlab_hdr . nameflag = readblobxxxshort ( image2 ) ; if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""matlab_hdr.structureclass<s2sv_blank>%d"" , matlab_hdr . structureclass ) ; if ( matlab_hdr . structureclass != mxchar_class && matlab_hdr . structureclass != mxsingle_class && matlab_hdr . structureclass != mxdouble_class && matlab_hdr . structureclass != mxint8_class && matlab_hdr . structureclass != mxuint8_class && matlab_hdr . structureclass != mxint16_class && matlab_hdr . structureclass != mxuint16_class && matlab_hdr . structureclass != mxint32_class && matlab_hdr . structureclass != mxuint32_class && matlab_hdr . structureclass != mxint64_class && matlab_hdr . structureclass != mxuint64_class ) throwreaderexception ( codererror , ""unsupportedcelltypeinthematrix"" ) ; switch ( matlab_hdr . nameflag ) { case 0 : size = readblobxxxlong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) seekblob ( image2 , size , seek_cur ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) readblob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto matlab_ko ; } celltype = readblobxxxlong ( image2 ) ; if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""matlab_hdr.celltype:<s2sv_blank>%.20g"" , ( double ) celltype ) ; ( void ) readblob ( image2 , 4 , ( unsigned char * ) & size ) ; next_frame : switch ( celltype ) { case miint8 : case miuint8 : sample_size = 8 ; if ( matlab_hdr . structureflag & flag_logical ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) matlab_hdr . sizex ; break ; case miint16 : case miuint16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * matlab_hdr . sizex ) ; break ; case miint32 : case miuint32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * matlab_hdr . sizex ) ; break ; case miint64 : case miuint64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * matlab_hdr . sizex ) ; break ; case misingle : sample_size = 32 ; image -> depth = 32 ; ( void ) setimageoption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( matlab_hdr . structureflag & flag_complex ) { } ldblk = ( ssize_t ) ( 4 * matlab_hdr . sizex ) ; break ; case midouble : sample_size = 64 ; image -> depth = 64 ; ( void ) setimageoption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; disablemscwarning ( 4127 ) if ( sizeof ( double ) != 8 ) restoremscwarning throwreaderexception ( codererror , ""incompatiblesizeofdouble"" ) ; if ( matlab_hdr . structureflag & flag_complex ) { } ldblk = ( ssize_t ) ( 8 * matlab_hdr . sizex ) ; break ; default : throwreaderexception ( codererror , ""unsupportedcelltypeinthematrix"" ) ; } ( void ) sample_size ; image -> columns = matlab_hdr . sizex ; image -> rows = matlab_hdr . sizey ; quantum_info = acquirequantuminfo ( clone_info , image ) ; if ( quantum_info == ( quantuminfo * ) null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto matlab_ko ; if ( ( matlab_hdr . dimflag == 8 ) && ( ( matlab_hdr . structureflag & flag_complex ) == 0 ) ) { image -> type = grayscaletype ; setimagecolorspace ( image , graycolorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = setimageextent ( image , image -> columns , image -> rows , exception ) ; if ( status == magickfalse ) return ( destroyimagelist ( image ) ) ; bimgbuff = ( unsigned char * ) acquirequantummemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( bimgbuff == null ) throwreaderexception ( resourcelimiterror , ""memoryallocationfailed"" ) ; ( void ) resetmagickmemory ( bimgbuff , 0 , ldblk * sizeof ( double ) ) ; minval = 0 ; maxval = 0 ; if ( celltype == midouble || celltype == misingle ) { calcminmax ( image2 , image_info -> endian , matlab_hdr . sizex , matlab_hdr . sizey , celltype , ldblk , bimgbuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) matlab_hdr . sizey ; i ++ ) { q = getauthenticpixels ( image , 0 , matlab_hdr . sizey - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( quantum * ) null ) { if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""<s2sv_blank><s2sv_blank>mat<s2sv_blank>set<s2sv_blank>image<s2sv_blank>pixels<s2sv_blank>returns<s2sv_blank>unexpected<s2sv_blank>null<s2sv_blank>on<s2sv_blank>a<s2sv_blank>row<s2sv_blank>%u."" , ( unsigned ) ( matlab_hdr . sizey - i - 1 ) ) ; goto done_reading ; } if ( readblob ( image2 , ldblk , ( unsigned char * ) bimgbuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""<s2sv_blank><s2sv_blank>mat<s2sv_blank>cannot<s2sv_blank>read<s2sv_blank>scanrow<s2sv_blank>%u<s2sv_blank>from<s2sv_blank>a<s2sv_blank>file."" , ( unsigned ) ( matlab_hdr . sizey - i - 1 ) ) ; goto exitloop ; } if ( ( celltype == miint8 || celltype == miuint8 ) && ( matlab_hdr . structureflag & flag_logical ) ) { fixlogical ( ( unsigned char * ) bimgbuff , ldblk ) ; if ( importquantumpixels ( image , ( cacheview * ) null , quantum_info , z2qtype [ z ] , bimgbuff , exception ) <= 0 ) { importquantumpixelsfailed : if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""<s2sv_blank><s2sv_blank>mat<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>importquantumpixels<s2sv_blank>for<s2sv_blank>a<s2sv_blank>row<s2sv_blank>%u"" , ( unsigned ) ( matlab_hdr . sizey - i - 1 ) ) ; break ; } } else { if ( importquantumpixels ( image , ( cacheview * ) null , quantum_info , z2qtype [ z ] , bimgbuff , exception ) <= 0 ) goto importquantumpixelsfailed ; if ( z <= 1 && ( celltype == miint8 || celltype == miint16 || celltype == miint32 || celltype == miint64 ) ) fixsignedvalues ( image , q , matlab_hdr . sizex ) ; } if ( ! syncauthenticpixels ( image , exception ) ) { if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""<s2sv_blank><s2sv_blank>mat<s2sv_blank>failed<s2sv_blank>to<s2sv_blank>sync<s2sv_blank>image<s2sv_blank>pixels<s2sv_blank>for<s2sv_blank>a<s2sv_blank>row<s2sv_blank>%u"" , ( unsigned ) ( matlab_hdr . sizey - i - 1 ) ) ; goto exitloop ; } } } while ( z -- >= 2 ) ; exitloop : if ( matlab_hdr . structureflag & flag_complex ) { celltype = readblobxxxlong ( image2 ) ; i = readblobxxxlong ( image2 ) ; if ( celltype == midouble || celltype == misingle ) { calcminmax ( image2 , image_info -> endian , matlab_hdr . sizex , matlab_hdr . sizey , celltype , ldblk , bimgbuff , & minval , & maxval ) ; } if ( celltype == midouble ) for ( i = 0 ; i < ( ssize_t ) matlab_hdr . sizey ; i ++ ) { readblobdoublesxxx ( image2 , ldblk , ( double * ) bimgbuff ) ; insertcomplexdoublerow ( image , ( double * ) bimgbuff , i , minval , maxval , exception ) ; } if ( celltype == misingle ) for ( i = 0 ; i < ( ssize_t ) matlab_hdr . sizey ; i ++ ) { readblobfloatsxxx ( image2 , ldblk , ( float * ) bimgbuff ) ; insertcomplexfloatrow ( image , ( float * ) bimgbuff , i , minval , maxval , exception ) ; } } if ( ( matlab_hdr . dimflag == 8 ) && ( ( matlab_hdr . structureflag & flag_complex ) == 0 ) ) image -> type = grayscaletype ; if ( image -> depth == 1 ) image -> type = bileveltype ; if ( image2 == image ) image2 = null ; rotated_image = rotateimage ( image , 90.0 , exception ) ; if ( rotated_image != ( image * ) null ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; appendimagetolist ( & image , rotated_image ) ; deleteimagefromlist ( & image ) ; } done_reading : if ( image2 != null ) if ( image2 != image ) { deleteimagefromlist ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = null ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } acquirenextimage ( image_info , image , exception ) ; if ( image -> next == ( image * ) null ) break ; image = syncnextimageinlist ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; relinquishmagickmemory ( bimgbuff ) ; bimgbuff = null ; if ( -- frames > 0 ) { z = z2 ; if ( image2 == null ) image2 = image ; goto next_frame ; } if ( ( image2 != null ) && ( image2 != image ) ) { deleteimagefromlist ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = null ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } relinquishmagickmemory ( bimgbuff ) ; quantum_info = destroyquantuminfo ( quantum_info ) ; end_of_reading : clone_info = destroyimageinfo ( clone_info ) ; closeblob ( image ) ; { image * p ; ssize_t scene = 0 ; p = image ; image = null ; while ( p != ( image * ) null ) { image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; deleteimagefromlist ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( image * ) null ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != null ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = null ; ( void ) remove_utf8 ( clone_info -> filename ) ; } destroyimageinfo ( clone_info ) ; clone_info = null ; } if ( logging ) ( void ) logmagickevent ( coderevent , getmagickmodule ( ) , ""return"" ) ; if ( image == null ) throwreaderexception ( corruptimageerror , ""improperimageheader"" ) ; return ( image ) ; }","<S2SV_ModStart> ) ; } quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
",ImageMagick@ImageMagick/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,CVE-2017-13146,https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,2017-08-23T06:29Z,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug>
