Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0.1,raw_predictions,correctly_predicted
21,CWE-787,"CWE-787 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
","<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,9,"<S2SV_ModStart> left ; luaL_checkstack ( L, 1, ""in <S2SV_blank> function <S2SV_blank> mp_unpack_full"" ) ; luaL_checkstack ( L, 2, ""in <S2SV_blank> function <S2SV_blank> mp_unpack_full"" ) ;",0
41,CWE-787,"CWE-787 static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; <S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
","<S2SV_ModStart> , password , length <S2SV_ModEnd> ) ; attr
",FreeRADIUS@pam_radius/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,CVE-2015-9542,https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,2020-02-24T15:15Z,16,"<S2SV_ModStart> length ) ; if ( strlen ( password ) > AUTH_PASS_LEN ) { printf ( ""Password <S2SV_blank> length <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d) <S2SV_blank> (%d)"", length, AUTH_PASS_LEN ) ; return ; }",0
75,CWE-787,"CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }
","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z,25,"<S2SV_ModStart> num_video ) { av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num_video ) ; av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num_video ) ; av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num_video ) ; av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num_video ) ; av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num_video ) ; av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num_video ) ; av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks",0
276,CWE-787,"CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
","<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,83,<S2SV_ModStart> 1 ) { if ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ]!= 0 ) { ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] = 0 ; } <S2SV_ModStart> 1 ) { if ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ]!= 0 ) { ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] = 0 ; } <S2SV_ModStart> 1 ) { if ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ]!= 0 ) { ptr,0
290,CWE-787,"CWE-787 static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }
","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z,88,"<S2SV_ModStart> + x > diffBlock <S2SV_ModEnd> + diffBlockLength || <S2SV_ModStart> NULL ; } if ( diffPtr + x > <S2SV_ModStart> + diffBlockLength || extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } <S2SV_ModStart> + x > diffBlock <S2SV_ModEnd> + diffBlockLength || <S2SV_ModStart> + diffBlockLength || extraPtr + y <S2SV_ModEnd> > extraBlock + <S2SV_ModStart> extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } <S2SV_ModStart> extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } <S2SV_ModStart> + x > diffBlock <S2SV_ModEnd> + diffBlockLength || <S2SV_ModStart> + diffBlockLength || extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; }",0
595,CWE-787,"CWE-787 static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b6ae2f9e0ab13343c0281732d479757a8e8979c7,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7,2017-04-20T18:59Z,183,"<S2SV_ModStart> image ) ; if ( ( image -> columns % 2 )!= 0 ) { for ( bit = 0 ; bit < ( image -> columns % 2 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 2 )!= 0 ) { for ( bit = 0 ; bit < ( image -> columns % 2 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; } if ( ( image -> columns % 2 )!= 0 ) { for ( bit = 0 ; bit < ( image -> columns % 2 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q",0
713,CWE-787,"CWE-787 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; <S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
",ImageMagick@ImageMagick/998c687fb83993c13fa711d75f59a95b38ceab77,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77,2017-04-20T18:59Z,236,"<S2SV_ModStart> ) break ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> ) break ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError, ""ImproperImage <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug>",0
751,CWE-787,"CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ; break ; <S2SV_ModEnd> } } if <S2SV_ModStart> 1 ; } }
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,247,<S2SV_ModStart> k_start ; } if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 16 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 16 ) { if ( ptr_hbe_txposer -> k_start > 16 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 16 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 16 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer -> k_start > 24 ) { if ( ptr_hbe_txposer ->,0
801,CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,261,<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (,1
863,CWE-787,"CWE-787 static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d<S2SV_blank>PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; <S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
","<S2SV_ModStart> 0x02 ) ; if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;
",OpenSC@OpenSC/9d294de90d1cc66956389856e60b6944b27b4817,CVE-2020-26572,https://github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817,2020-10-06T02:15Z,286,"<S2SV_ModStart> 0x02 ) ; if ( crgram_len > 0 && crgram_len < SC_MAX_APDU_BUFFER_SIZE - 1 ) { r = sc_transmit_apdu ( card, & apdu ) ; LOG_TEST_RET ( card -> ctx, r, ""APDU <S2SV_blank> length <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", crgram_len ) ; } else if ( crgram_len > 0 && crgram_len < SC_MAX_APDU_BUFFER_SIZE - 1 ) { r = sc_transmit_apdu ( card, & apdu ) ; LOG_TEST_RET ( card -> ctx, r, ""APDU <S2SV_blank> length <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", crgram_len ) ; } else { if ( crgram_len > 0 && crgram_len < SC_MAX_APDU_BUFFER_SIZE - 1 ) { r = sc_transmit_apdu ( card, & apdu ) ; } else { r = sc_transmit_apdu ( card, & apdu ) ; } }",0
870,CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; } } return - 1 ;
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,288,"<S2SV_ModStart> } } } if (! ( action = strtok ( NULL, "";"" ) ) ) { return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok ( NULL, "";"" ) ) ) { return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok ( NULL, "";"" ) ) ) { eprintf ( ""action: <S2SV_blank> %s\\n"", action ) ; return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok ( NULL, "";"" ) ) ) { return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok ( NULL, "";"" ) ) ) { return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok ( NULL, "";"" ) ) ) { eprintf ( ""action: <S2SV_blank> %s\\n"", action ) ; return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok ( NULL, "";"" ) ) ) { return send_msg ( g, ""E01"" ) ; } if (! ( action = strtok",0
958,CWE-787,"CWE-787 VOID ixheaacd_esbr_radix4bfly ( const WORD32 * w , WORD32 * x , WORD32 index1 , WORD32 index ) { int i ; WORD32 l1 , l2 , h2 , fft_jmp ; <S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; WORD32 x_h2_0 , x_h2_1 ; WORD32 si10 , si20 , si30 , co10 , co20 , co30 ; WORD64 mul_1 , mul_2 , mul_3 , mul_4 , mul_5 , mul_6 ; WORD64 mul_7 , mul_8 , mul_9 , mul_10 , mul_11 , mul_12 ; WORD32 * x_l1 ; WORD32 * x_l2 ; WORD32 * x_h2 ; const WORD32 * w_ptr = w ; WORD32 i1 ; h2 = index << 1 ; l1 = index << 2 ; l2 = ( index << 2 ) + ( index << 1 ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; fft_jmp = 6 * ( index ) ; for ( i1 = 0 ; i1 < index1 ; i1 ++ ) { for ( i = 0 ; i < index ; i ++ ) { si10 = ( * w_ptr ++ ) ; co10 = ( * w_ptr ++ ) ; si20 = ( * w_ptr ++ ) ; co20 = ( * w_ptr ++ ) ; si30 = ( * w_ptr ++ ) ; co30 = ( * w_ptr ++ ) ; x_0 = x [ 0 ] ; x_h2_0 = x [ h2 ] ; x_l1_0 = x [ l1 ] ; x_l2_0 = x [ l2 ] ; <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> x_1 = x [ 1 ] ; x_h2_1 = x [ h2 + 1 ] ; x_l1_1 = x [ l1 + 1 ] ; x_l2_1 = x [ l2 + 1 ] ; <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ; mul_3 = ixheaacd_mult64 ( yt2_0 , si30 ) ; x [ l2 ] = ( WORD32 ) ( ( mul_3 + mul_11 ) >> 32 ) << RADIXSHIFT ; mul_5 = ixheaacd_mult64 ( xt2_0 , si30 ) ; mul_9 = ixheaacd_mult64 ( yt2_0 , co30 ) ; x [ l2 + 1 ] = ( WORD32 ) ( ( mul_9 - mul_5 ) >> 32 ) << RADIXSHIFT ; mul_12 = ixheaacd_mult64 ( xt0_0 , co20 ) ; mul_2 = ixheaacd_mult64 ( yt0_0 , si20 ) ; x [ l1 ] = ( WORD32 ) ( ( mul_2 + mul_12 ) >> 32 ) << RADIXSHIFT ; mul_6 = ixheaacd_mult64 ( xt0_0 , si20 ) ; mul_8 = ixheaacd_mult64 ( yt0_0 , co20 ) ; x [ l1 + 1 ] = ( WORD32 ) ( ( mul_8 - mul_6 ) >> 32 ) << RADIXSHIFT ; mul_4 = ixheaacd_mult64 ( xt1_0 , co10 ) ; mul_1 = ixheaacd_mult64 ( yt1_0 , si10 ) ; x [ h2 ] = ( WORD32 ) ( ( mul_1 + mul_4 ) >> 32 ) << RADIXSHIFT ; mul_10 = ixheaacd_mult64 ( xt1_0 , si10 ) ; mul_7 = ixheaacd_mult64 ( yt1_0 , co10 ) ; x [ h2 + 1 ] = ( WORD32 ) ( ( mul_7 - mul_10 ) >> 32 ) << RADIXSHIFT ; x += 2 ; } x += fft_jmp ; w_ptr = w_ptr - fft_jmp ; } }
","<S2SV_ModStart> , fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , yt0_0 <S2SV_ModStart> , yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , xh1_0 <S2SV_ModStart> ; xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xl0_0 <S2SV_ModStart> ; xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xh20_0 <S2SV_ModStart> ; xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; xl20_0 <S2SV_ModStart> ; xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; x <S2SV_ModStart> 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> ; xt0_0 = <S2SV_ModStart> ; xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> xh20_0 ; x_1 <S2SV_ModStart> ; xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xl1_0 <S2SV_ModStart> ; xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xh21_0 <S2SV_ModStart> ; xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; xl21_0 <S2SV_ModStart> ; xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; x <S2SV_ModStart> 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> ; yt0_0 = <S2SV_ModStart> ; yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> xh21_0 ; xt1_0 <S2SV_ModStart> ; xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> xl21_0 ; xt2_0 <S2SV_ModStart> ; xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> xl21_0 ; yt2_0 <S2SV_ModStart> ; yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> xl20_0 ; yt1_0 <S2SV_ModStart> ; yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> xl20_0 ; mul_11
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,320,"<S2SV_ModStart>, fft_jmp ; WORD32 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0 ; WORD32 x_0, x_1, x_l1_0, x_l1_1 ; WORD32 x_l2_0, x_l2_0, x_l2_1 ; WORD32 x_h2_0, x_h2_1 ; WORD32 x_0, x_1, x_l1_0, x_l1_1 ; WORD32 x_l1_0, x_l1_1 ; WORD32 x_l2_0, x_l2_0, x_l2_1 ; WORD32 x_h2_0, x_h2_1 ; WORD32 x_l1_0, x_l1_1 ; WORD32 x_l1_0, x_l1_1 ; WORD32 x_l1_0, x_l1_1 ; WORD32 x_l1_0, x_l",0
994,CWE-787,"CWE-787 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; <S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> } }
","<S2SV_ModStart> = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
",external@libmpeg2/bef16671c891e16f25a7b174bc528eea109357be,CVE-2018-9497,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be,2018-10-02T19:29Z,336,<S2SV_ModStart> u4_num_Bytes ) ; if ( ps_op -> s_ivd_video_decode_op_t. u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t. u4_num_Bytes = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; } else { if ( ps_op -> s_ivd_video_decode_op_t. u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t. u4_num_Bytes = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; } else { if ( ps_op -> s_ivd_video_decode_op_t. u4_num_Bytes > ps_ip -> s_ivd_video_,0
1053,CWE-787,"CWE-787 static int l2cap_build_conf_req ( struct sock * sk , void * data ) { struct l2cap_pinfo * pi = l2cap_pi ( sk ) ; struct l2cap_conf_req * req = data ; <S2SV_StartBug> struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; <S2SV_EndBug> void * ptr = req -> data ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; <S2SV_StartBug> switch ( pi -> mode ) { <S2SV_EndBug> case L2CAP_MODE_BASIC : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ; break ; case L2CAP_MODE_ERTM : rfc . mode = L2CAP_MODE_ERTM ; <S2SV_StartBug> rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; <S2SV_EndBug> rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ; <S2SV_StartBug> rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; <S2SV_EndBug> <S2SV_StartBug> rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; <S2SV_EndBug> rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; } req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> flags = cpu_to_le16 ( 0 ) ; return ptr - data ; }
","<S2SV_ModStart> . mode = L2CAP_MODE_ERTM <S2SV_ModEnd> } ; void <S2SV_ModStart> sk ) ; if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> . txwin_size = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . retrans_timeout = 0 <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . monitor_timeout = 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ; rfc .
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,354,"<S2SV_ModStart> = data ; struct l2cap_conf_rfc rfc ; BT_DBG ( ""sk <S2SV_blank> %p"", sk ) ; req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; req -> retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; req -> monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; req -> max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; req -> max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; req -> retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; req -> retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; req -> max_pdu_size = cpu",0
1086,CWE-787,"CWE-787 VOID ixheaacd_esbr_postradixcompute2 ( WORD32 * ptr_y , WORD32 * ptr_x , const WORD32 * pdig_rev_tbl , WORD32 npoints ) { WORD32 i , k ; WORD32 h2 ; WORD32 x_0 , x_1 , x_2 , x_3 ; WORD32 x_4 , x_5 , x_6 , x_7 ; <S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ; WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ; WORD32 n0 , j0 ; WORD32 * x2 , * x0 ; WORD32 * y0 , * y1 , * y2 , * y3 ; y0 = ptr_y ; y2 = ptr_y + ( WORD32 ) npoints ; x0 = ptr_x ; x2 = ptr_x + ( WORD32 ) ( npoints >> 1 ) ; y1 = y0 + ( WORD32 ) ( npoints >> 2 ) ; y3 = y2 + ( WORD32 ) ( npoints >> 2 ) ; j0 = 8 ; n0 = npoints >> 1 ; for ( k = 0 ; k < 2 ; k ++ ) { for ( i = 0 ; i < npoints >> 1 ; i += 8 ) { h2 = * pdig_rev_tbl ++ >> 2 ; x_0 = * x0 ++ ; x_1 = * x0 ++ ; x_2 = * x0 ++ ; x_3 = * x0 ++ ; x_4 = * x0 ++ ; x_5 = * x0 ++ ; x_6 = * x0 ++ ; x_7 = * x0 ++ ; <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> n01 = x_1 + x_3 ; n20 = x_0 - x_2 ; n21 = x_1 - x_3 ; n10 = x_4 + x_6 ; n11 = x_5 + x_7 ; n30 = x_4 - x_6 ; n31 = x_5 - x_7 ; y0 [ h2 ] = n00 ; y0 [ h2 + 1 ] = n01 ; <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> y2 [ h2 ] = n20 ; y2 [ h2 + 1 ] = n21 ; <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; n02 = x_8 + x_a ; n03 = x_9 + x_b ; n22 = x_8 - x_a ; n23 = x_9 - x_b ; n12 = x_c + x_e ; n13 = x_d + x_f ; n32 = x_c - x_e ; n33 = x_d - x_f ; y0 [ h2 + 2 ] = n02 ; y0 [ h2 + 3 ] = n03 ; y1 [ h2 + 2 ] = n12 ; y1 [ h2 + 3 ] = n13 ; y2 [ h2 + 2 ] = n22 ; y2 [ h2 + 3 ] = n23 ; y3 [ h2 + 2 ] = n32 ; y3 [ h2 + 3 ] = n33 ; } x0 += ( WORD32 ) npoints >> 1 ; x2 += ( WORD32 ) npoints >> 1 ; } }
","<S2SV_ModStart> x_e , x_f <S2SV_ModEnd> ; WORD32 n0 <S2SV_ModStart> x0 ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; } x0
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,369,"<S2SV_ModStart>, x_7 ; WORD32 x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f ; WORD32 x_10, x_11, x_12, x_13, x_14, x_15, <S2SV_ModStart> x0 ++ ; x_10 = x_0 + x_2 ; x_11 = x_1 + x_3 ; x_12 = x_4 + x_6 ; x_11 = x_5 + x_7 ; x_12 = x_1 + x_3 ; x_11 = x_4 + x_6 ; x_12 = x_5 + x_7 ; x_13 = x_4 + x_7 ; x_14 = x_5 + x_6 ; x_15 = x_5 + x_7 ; x_12 = x_1 + x_3 ; x13 = x_4 + x_6 ; x13 = x_5 + x_7 ; x13 = x_1 + x_3 ; x14 = x_4 + x_6 ; x14 = x_5 +",0
1136,CWE-787,"CWE-787 static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>"" ""beginning<S2SV_blank>of<S2SV_blank>image.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>SOI<S2SV_blank>marker<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>first<S2SV_blank>"" ""marker<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>SOI.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>image<S2SV_blank>content<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } length = AV_RB16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker<S2SV_blank>segment.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == JPEG_MARKER_SOS ) { length = AV_RB16 ( frag -> data + start ) ; <S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! data ) return AVERROR ( ENOMEM ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) return err ; if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }
","<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z,388,"<S2SV_ModStart> return AVERROR_INVALIDDATA ; } if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> "" ""no <S2SV_blank> SOI <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> "" ""no <S2SV_blank> SOI <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> "" ""no <S2SV_blank> SOI <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> "" ""no <S2SV_blank> SOI <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_",0
1167,CWE-787,"CWE-787 static int gtStripSeparate ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileSeparateRoutine put = img -> put . separate ; unsigned char * buf = NULL ; unsigned char * p0 = NULL , * p1 = NULL , * p2 = NULL , * pa = NULL ; uint32 row , y , nrow , rowstoread ; tmsize_t pos ; tmsize_t scanline ; uint32 rowsperstrip , offset_row ; uint32 imagewidth = img -> width ; tmsize_t stripsize ; tmsize_t bufsize ; int32 fromskew , toskew ; int alpha = img -> alpha ; int ret = 1 , flip ; uint16 colorchannels ; stripsize = TIFFStripSize ( tif ) ; bufsize = _TIFFMultiplySSize ( tif , alpha ? 4 : 3 , stripsize , ""gtStripSeparate"" ) ; if ( bufsize == 0 ) { return ( 0 ) ; } flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } switch ( img -> photometric ) { case PHOTOMETRIC_MINISWHITE : case PHOTOMETRIC_MINISBLACK : case PHOTOMETRIC_PALETTE : colorchannels = 1 ; break ; default : colorchannels = 3 ; break ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) { <S2SV_StartBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; <S2SV_EndBug> nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; offset_row = row + img -> row_offset ; <S2SV_StartBug> if ( buf == NULL ) <S2SV_EndBug> { if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , ( void * * ) & buf , bufsize , <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && ( buf == NULL || img -> stoponerr ) ) { ret = 0 ; break ; } p0 = buf ; if ( colorchannels == 1 ) { p2 = p1 = p0 ; pa = ( alpha ? ( p0 + 3 * stripsize ) : NULL ) ; } else { p1 = p0 + stripsize ; p2 = p1 + stripsize ; pa = ( alpha ? ( p2 + stripsize ) : NULL ) ; } } else if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , <S2SV_StartBug> p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 1 ) , <S2SV_StartBug> p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 2 ) , <S2SV_StartBug> p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( alpha ) { if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , <S2SV_StartBug> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } } pos = ( ( row + img -> row_offset ) % rowsperstrip ) * scanline + ( ( tmsize_t ) img -> col_offset * img -> samplesperpixel ) ; ( * put ) ( img , raster + y * w , 0 , y , w , nrow , fromskew , toskew , p0 + pos , p1 + pos , p2 + pos , ( alpha ? ( pa + pos ) : NULL ) ) ; y += ( ( flip & FLIP_VERTICALLY ) ? - ( int32 ) nrow : ( int32 ) nrow ) ; } if ( flip & FLIP_HORIZONTALLY ) { uint32 line ; for ( line = 0 ; line < h ; line ++ ) { uint32 * left = raster + ( line * w ) ; uint32 * right = left + w - 1 ; while ( left < right ) { uint32 temp = * left ; * left = * right ; * right = temp ; left ++ ; right -- ; } } } _TIFFfree ( buf ) ; return ( ret ) ; }
","<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ; return 0 ; } <S2SV_ModStart> , bufsize , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p0 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p1 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p2 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , pa , temp <S2SV_ModEnd> * scanline )
",OSGeo@gdal/21674033ee246f698887604c7af7ba1962a40ddf,CVE-2019-17546,https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf,2019-10-14T02:15Z,407,"<S2SV_ModStart> nrow ) { if ( row + rowsperstrip > h ) { TIFFErrorExt ( tif -> tif_clientdata, ""gtStripSeparate"", ""%s"", ""row <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug> <S2SV_EndBug>",0
1188,CWE-787,"CWE-787 void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = AF_INET ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } FD_ZERO ( & read_fd ) ; FD_SET ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , NULL , NULL , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?WATCH={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } while ( G . do_exit == 0 ) { usleep ( 500000 ) ; memset ( G . gps_loc , 0 , sizeof ( float ) * 5 ) ; if ( is_json ) { if ( pos == sizeof ( line ) ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } <S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug> return ; temp = strstr ( line , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { continue ; } if ( strchr ( temp , '}' ) == NULL ) { pos = strlen ( temp ) ; if ( temp != line ) { memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } temp = strstr ( temp , ""\\""lat\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 0 ] ) ; temp = strstr ( temp , ""\\""lon\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 1 ] ) ; temp = strstr ( temp , ""\\""alt\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 4 ] ) ; temp = strstr ( temp , ""\\""speed\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 2 ] ) ; temp = strstr ( temp , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } else { pos = strlen ( temp ) ; memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } else { memset ( line , 0 , sizeof ( line ) ) ; snprintf ( line , sizeof ( line ) - 1 , ""PVTAD\\r\\n"" ) ; if ( send ( gpsd_sock , line , 7 , 0 ) != 7 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( memcmp ( line , ""GPSD,P="" , 7 ) != 0 ) continue ; if ( line [ 7 ] == '?' ) continue ; ret = sscanf ( line + 7 , ""%f<S2SV_blank>%f"" , & G . gps_loc [ 0 ] , & G . gps_loc [ 1 ] ) ; if ( ( temp = strstr ( line , ""V="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 2 ] ) ; if ( ( temp = strstr ( line , ""T="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 3 ] ) ; if ( ( temp = strstr ( line , ""A="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 4 ] ) ; } if ( G . record_data ) fputs ( line , G . f_gps ) ; G . save_gps = 1 ; if ( G . do_exit == 0 ) { unused = write ( G . gc_pipe [ 1 ] , G . gps_loc , sizeof ( float ) * 5 ) ; kill ( getppid ( ) , SIGUSR2 ) ; } } }
","<S2SV_ModStart> line ) - pos -
",aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z,419,"<S2SV_ModStart> 0 ) { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" <S2SV_ModEnd>, 32 ) <S2SV_ModStart> 0 ) { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" <S2SV_ModEnd>, 32 ) <S2SV_ModStart> 0 ) { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } } else { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } } else { if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gps",0
1444,CWE-787,"CWE-787 static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; <S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }
","<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev )
",torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z,532,<S2SV_ModStart> ; if ( <S2SV_ModEnd> len < needed <S2SV_ModStart> needed ) { struct dm_dev * dev = dm_disk ( hc -> md ) ; if ( dev -> bd_dev < 0 || dev -> bd_dev >= huge_encode_dev ( dev -> bd_dev ) || dev -> bd_dev >= huge_encode_dev ( dev -> bd_dev ) ) { struct dm_dev * dev = dm_disk ( hc -> md ) ; if ( dev -> bd_dev >= huge_encode_dev ( dev -> bd_dev ) ) { struct dm_dev * dev = dm_disk ( hc -> md ) ; if ( dev -> bd_dev < 0 || dev -> bd_dev >= huge_encode_dev ( dev -> bd_dev ) || dev -> bd_dev >= huge_encode_dev ( dev -> bd_dev ) ) { struct dm_dev * dev = dm_disk ( hc -> md ) ; if ( dev -> bd_dev >= huge_encode_dev ( dev -> bd_dev ) ) { struct dm_dev * dev = huge_encode_dev ( dev -> bd_dev ) ; if ( dev -> bd_dev >= 0,0
1461,CWE-787,"CWE-787 MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; <S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }
","<S2SV_ModStart> = NULL ; reader . recursive_counter = 0 ;
",hoene@libmysofa/2e6fac6ab6156dae8e8c6f417741388084b70d6f,CVE-2019-20016,https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f,2019-12-27T02:15Z,539,"<S2SV_ModStart> = NULL ; if (! ( * err = SUPERBLOCK_READ ( & reader, & reader. superblock ) ) ||! ( * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ) ) * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ; if (! ( * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ) ||! ( * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ) ) * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ; if (! ( * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ) ) * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ; if (! ( * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ) ||! ( * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ) ) * err = SUPERBLOCK_READ_ERR ( & reader. superblock ) ; if (! ( * err = SUPERBLOCK_READ_ERR ( & reader.",0
1512,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,567,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if (! context ) { return FALSE ; } tempWidth = ROUND_UP_TO ( context -> width, 8 ) ; rw = ( context -> ChromaSubsamplingLevel? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; b_val = * src ++ ; r_val = * src ++ ;",0
1611,CWE-787,"CWE-787 void process_bitmap_updates ( STREAM s ) { <S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }
","<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,620,"<S2SV_ModStart> STREAM s ) { struct stream packet = * s ; <S2SV_ModStart> int i ; struct stream packet = * s ; <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> bitmap <S2SV_blank> data <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } else { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> bitmap <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> bitmap_updates(), <S2SV_blank> consume <S2SV_blank> bitmap <S2SV_blank> data <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } else { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> bitmap <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 ) ) { rdp_protocol_error ( ""process_bitmap_updates",0
