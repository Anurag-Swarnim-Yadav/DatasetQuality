Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0.1,raw_predictions,correctly_predicted
1,CWE-125,"CWE-125 void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : <S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) { <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_FAST : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }
","<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , ""unknown"" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
",the-tcpdump-group@tcpdump/985122081165753c7442bd7824c473eb9ff56308,CVE-2017-13015,https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308,2017-09-14T06:29Z,1,<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> case EAP_FRAME_TYPE_PACKET_V1 : ND_TCHECK_16BITS ( tptr + 2 ) ; <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> case EAP_TYPE_V1 : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> case EAP_TYPE_V1 : ND_TCHECK_8BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_V2 : ND_TCHECK_8BITS ( tptr + 7 ) ; <S2SV_ModStart> case EAP_TYPE_V2 : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> case EAP_TYPE_V12 : ND_TCHECK_8BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_V12 : ND_TCHECK_8BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_V12 : N,0
7,CWE-416,"CWE-416 void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) { <S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }
","<S2SV_ModStart> writers , 0 ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc
",gpac@gpac/5aba27604d957e960d8069d85ccaf868f8a7b07a,CVE-2020-35980,https://github.com/gpac/gpac/commit/5aba27604d957e960d8069d85ccaf868f8a7b07a,2021-04-21T16:15Z,7,<S2SV_ModStart> writer = ( TrackWriter <S2SV_ModEnd> * ) gf_list_get,0
8,CWE-20,"CWE-20 void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> u32 data ; <S2SV_EndBug> void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }
","<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z,8,"<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm, & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart>. apic -> vapic_cache, & data, sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr",1
9,CWE-20,"CWE-20 int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) { flush_fp_to_thread ( src ) ; flush_altivec_to_thread ( src ) ; flush_vsx_to_thread ( src ) ; flush_spe_to_thread ( src ) ; <S2SV_StartBug> * dst = * src ; <S2SV_EndBug> clear_task_ebb ( dst ) ; return 0 ; }
","<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
",torvalds@linux/621b5060e823301d0cba4cb52a7ee3491922d291,CVE-2014-2673,https://github.com/torvalds/linux/commit/621b5060e823301d0cba4cb52a7ee3491922d291,2014-04-01T06:35Z,9,<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;,1
11,CWE-20,"CWE-20 static ext3_fsblk_t get_sb_block ( void * * data , struct super_block * sb ) { ext3_fsblk_t sb_block ; char * options = ( char * ) * data ; if ( ! options || strncmp ( options , ""sb="" , 3 ) != 0 ) return 1 ; options += 3 ; sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ',' ) { <S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , <S2SV_EndBug> ( char * ) * data ) ; return 1 ; } if ( * options == ',' ) options ++ ; * data = ( void * ) options ; return sb_block ; }
","<S2SV_ModStart> ( sb , KERN_ERR ,
",torvalds@linux/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,CVE-2013-1848,https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,2013-03-22T11:59Z,11,"<S2SV_ModStart> ( sb, KERN_ERR,",1
16,CWE-20,"CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }
","<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
",torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z,16,<S2SV_ModStart> ; skip_full_check : kfree ( env -> insn_aux_data ) ;,0
18,CWE-787,"CWE-787 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
","<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
",torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe,CVE-2018-11506,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,2018-05-28T04:29Z,18,"<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] ; <S2SV_ModStart> cd -> device ; sense_buffer = kmalloc ( sizeof ( * cgc -> sense ), GFP_KERNEL ) ; if (! sense_buffer ) goto out ; <S2SV_ModStart>, & sshdr, cgc -> timeout, IOCTL_RETRIES, 0, 0, NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense, sense_buffer, sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if",0
21,CWE-787,"CWE-787 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
","<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,21,"<S2SV_ModStart>. left ; luaL_checkstack ( L, 1, ""in <S2SV_blank> function <S2SV_blank> mp_unpack_full"" ) ;",1
25,CWE-20,"CWE-20 error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }
","<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,25,<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; },1
28,CWE-125,"CWE-125 static void l2tp_ppp_discon_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , <S2SV_StartBug> ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 5 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) dat ; if ( length < 5 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , ""Direction-#%u"" , EXTRACT_8BITS ( ptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; ptr ++ ; length -- ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,28,"<S2SV_ModStart> ) dat ; if ( length < 6 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) dat ; if ( length < 6 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) ptr ++ ; length -= 6 ; if ( length < 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) ptr ++ ; if ( length == 0 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> if ( length == 6 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",0
29,CWE-125,"CWE-125 static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { <S2SV_StartBug> int alt ; <S2SV_EndBug> alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> return alt ; return usb_set_interface ( udev , <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
",torvalds@linux/786de92b3cb26012d3d0f00ee37adf14527f35c4,CVE-2017-16530,https://github.com/torvalds/linux/commit/786de92b3cb26012d3d0f00ee37adf14527f35c4,2017-11-04T01:29Z,29,"<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if (! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev, alt -> <S2SV_ModEnd> desc. bInterfaceNumber <S2SV_ModStart> bInterfaceNumber, alt -> desc. bAlternateSetting",1
37,CWE-416,"CWE-416 static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
","<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out
",torvalds@linux/32c231164b762dddefa13af5a0101032c70b50ef,CVE-2016-10200,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,2017-03-07T21:59Z,37,"<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family!= AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ; read_lock_bh ( & l2tp_ip_lock ) ; if (! sock_flag ( sk, SOCK_ZAPPED ) ) goto out ; if (",0
39,CWE-20,"CWE-20 static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( ""Untrusted<S2SV_blank>application<S2SV_blank>launcher"" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( ""The<S2SV_blank>application<S2SV_blank>launcher<S2SV_blank>“%s”<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>trusted.<S2SV_blank>"" ""If<S2SV_blank>you<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>the<S2SV_blank>source<S2SV_blank>of<S2SV_blank>this<S2SV_blank>file,<S2SV_blank>launching<S2SV_blank>it<S2SV_blank>may<S2SV_blank>be<S2SV_blank>unsafe."" ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , ""text"" , primary , ""secondary-text"" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> } <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; g_signal_connect ( dialog , ""response"" , G_CALLBACK ( untrusted_launcher_response_callback ) , parameters_desktop ) ; gtk_widget_show ( dialog ) ; g_free ( display_name ) ; g_free ( secondary ) ; return ; } uri = nautilus_file_get_uri ( file ) ; DEBUG ( ""Launching<S2SV_blank>trusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; }
","<S2SV_ModStart> , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> g_signal_connect ( dialog
",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z,39,"<S2SV_ModStart>, _ ( ""_Cancel"" ), GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ), GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ), GTK_RESPONSE_CANCEL ) ;",0
40,CWE-416,"CWE-416 char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; <S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
","<S2SV_ModStart> ( & t ) ; if ( tm == NULL ) return g_strdup ( ""???""
",irssi@irssi/5e26325317c72a04c1610ad952974e206384d291,CVE-2017-10966,https://github.com/irssi/irssi/commit/5e26325317c72a04c1610ad952974e206384d291,2017-07-07T14:29Z,40,<S2SV_ModStart> t ) ; if ( tm == NULL ) return NULL,0
41,CWE-787,"CWE-787 static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; <S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
","<S2SV_ModStart> , password , length <S2SV_ModEnd> ) ; attr
",FreeRADIUS@pam_radius/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,CVE-2015-9542,https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,2020-02-24T15:15Z,41,"<S2SV_ModStart> ; memcpy ( hashed + length, password, strlen ( password )",0
50,CWE-416,"CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z,50,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->,1
51,CWE-125,"CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%s<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%u<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z,51,"<S2SV_ModStart> case IV2_T_ENCR : cp = ikev2_encr_print ( ndo, cp, ep2, map, nmap ) ; break ; case IV2_T_INTEG : cp = ikev2_integ_print ( ndo, cp, ep2 ) ; break ; case IV2_T_DH : cp = ikev2_dh_print ( ndo, cp, ep2 ) ; break ; case IV2_T_ENCR : cp = ikev2_encr_print ( ndo, cp, ep2, map, nmap ) ; break ; case IV2_T_ESN : cp = ikev2_esn_print ( ndo, cp, ep2, map, nmap ) ; break ; case IV2_T_ENCR : cp = ikev2_prf_print ( ndo, cp, ep2 ) ; break ; case IV2_T_INTEG : cp = ikev2_integ_print ( ndo, cp, ep2 ) ; break ; default : ND_PRINT ( ( ndo, "" <S2SV_blank> #%u",0
56,CWE-416,"CWE-416 int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; } <S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> } <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> err = handle -> h_err ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }
","<S2SV_ModStart> 0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err ? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =
",torvalds@linux/6934da9238da947628be83635e365df41064b09b,CVE-2015-8961,https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b,2016-11-16T05:59Z,56,<S2SV_ModStart> 0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =,1
60,CWE-125,"CWE-125 static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) { <S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ; <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE : <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Path<S2SV_blank>Cost:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Prio:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>V:<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>SPSource-ID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>No<S2SV_blank>of<S2SV_blank>Trees:<S2SV_blank>%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> { <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>SPVID:<S2SV_blank>%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ; <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI : <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>VID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T:<S2SV_blank>%d,<S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>ISID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; } <S2SV_StartBug> } <S2SV_EndBug> return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }
","<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
",the-tcpdump-group@tcpdump/b20e1639dbac84b3fcb393858521c13ad47a9d70,CVE-2017-13026,https://github.com/the-tcpdump-group/tcpdump/commit/b20e1639dbac84b3fcb393858521c13ad47a9d70,2017-09-14T06:29Z,60,"<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr, 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ), stlv_len ) <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> tmp ) { ND_TCHECK2 ( * ( tptr ), tmp ) ; <S2SV_ModStart> tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; } <S2SV_ModStart> case ISIS_SUBTLV_SP",0
63,CWE-125,"CWE-125 static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""<S2SV_blank>csum"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }
","<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
",the-tcpdump-group@tcpdump/4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c,CVE-2017-13040,https://github.com/the-tcpdump-group/tcpdump/commit/4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c,2017-09-14T06:29Z,63,<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN ),1
65,CWE-125,"CWE-125 static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; <S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , ""invalid<S2SV_blank>packet<S2SV_blank>line"" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
","<S2SV_ModStart> = GIT_PKT_NG ; if ( len < 3 ) goto out_err ; <S2SV_ModStart> += 3 ; len -= 3 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '<S2SV_blank>' , len <S2SV_ModStart> = '\\0' ; if ( len < 1 ) goto out_err ; <S2SV_ModStart> + 1 ; len -= 1 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '\\n' , len
",libgit2@libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,CVE-2018-15501,https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,2018-08-18T02:29Z,65,"<S2SV_ModStart> = GIT_PKT_NG ; if ( strlen ( line ) > MAX_PKT_LINE_LEN ) goto out_err ; <S2SV_ModStart> = '\\0' ; if ( strlen ( line ) > MAX_PKT_LINE_LEN ) goto out_err ; <S2SV_ModStart> += 3 ; if ( strlen ( line ) > MAX_PKT_LINE_LEN ) goto out_err ; <S2SV_ModStart> += 1 ; if ( strlen ( line ) > MAX_PKT_LINE_LEN ) { if ( strlen ( line ) > MAX_PKT_LINE_LEN ) goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen, len, 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref, line, len ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg, line, len ) ; pkt -> msg [ len ] = '\\0' ; }",0
72,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; <S2SV_StartBug> UINT16 length ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> RequestedProtocols ) ; WLog_DBG ( TAG , ""RDP_NEG_REQ:<S2SV_blank>RequestedProtocol:<S2SV_blank>0x%08"" PRIX32 """" , nego -> RequestedProtocols ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> ; UINT16 length ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,72,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;,0
75,CWE-787,"CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }
","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z,75,<S2SV_ModStart> ; j ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; <S2SV_ModStart> ; j ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ;,0
76,CWE-125,"CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }
","<S2SV_ModStart> av_log ( mxf -> fc
",FFmpeg@FFmpeg/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,CVE-2018-1999014,https://github.com/FFmpeg/FFmpeg/commit/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,2018-07-23T15:29Z,76,<S2SV_ModStart> av_log ( mxf -> fc,1
79,CWE-125,"CWE-125 static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; ND_TCHECK ( p [ 0 ] ) ; while ( lp -> s != NULL ) { if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; <S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
",the-tcpdump-group@tcpdump/42073d54c53a496be40ae84152bbfe2c923ac7bc,CVE-2017-13004,https://github.com/the-tcpdump-group/tcpdump/commit/42073d54c53a496be40ae84152bbfe2c923ac7bc,2017-09-14T06:29Z,79,"<S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ;",0
80,CWE-787,"CWE-787 static unsigned int ipv6_defrag ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { int err ; # if IS_ENABLED ( CONFIG_NF_CONNTRACK ) if ( skb -> nfct && ! nf_ct_is_template ( ( struct nf_conn * ) skb -> nfct ) ) return NF_ACCEPT ; # endif err = nf_ct_frag6_gather ( state -> net , skb , nf_ct6_defrag_user ( state -> hook , skb ) ) ; if ( err == - EINPROGRESS ) return NF_STOLEN ; <S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> }
","<S2SV_ModStart> NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,CVE-2016-9755,https://github.com/torvalds/linux/commit/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,2016-12-28T07:59Z,80,<S2SV_ModStart> NF_STOLEN ; return err == 0? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>,1
82,CWE-416,"CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
",torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z,82,<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,0
84,CWE-20,"CWE-20 bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , ""LinkKeyType"" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , ""PinLength"" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , ""LinkKey"" , link_key , sizeof ( LINK_KEY ) ) ; <S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }
","<S2SV_ModStart> ) ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ; }
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,84,"<S2SV_ModStart> ) ) ; if ( ret ) { btif_storage_error ( BT_LOG_ERROR, ""BTIF_STORAGE_ADD_BONDED_DEVICE: <S2SV_blank> Failed <S2SV_blank> to <S2SV_blank> add <S2SV_blank> device <S2SV_blank> to <S2SV_blank> remote <S2SV_blank> bdaddr <S2SV_blank> %p\\n"", remote_bd_addr ) ; return BT_STATUS_FAIL ; } <S2SV_ModStart> ) ) ; if ( ret ) { btif_storage_error ( BT_LOG_ERROR, BT_LOG_ERROR, ""BT_STORAGE_ADD_BONDED_DEVICE: <S2SV_blank> Failed <S2SV_blank> to <S2SV_blank> add <S2SV_blank> bonded_device <S2SV_blank> to <S2SV_blank> remote_bdaddr <S2SV_blank> %p\\n"", remote_bd_addr ) ; return BT_STATUS_FAIL ; }",0
87,CWE-20,"CWE-20 static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }
","<S2SV_ModStart> size ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> gso . type ) ; netbk_fatal_tx_err ( vif
",torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z,87,"<S2SV_ModStart> size ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev, ""GSO <S2SV_blank> size <S2SV_blank> must <S2SV_blank> not <S2SV_blank> be <S2SV_blank> zero.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> gso. type ) ; netbk_fatal_tx_err ( vif",1
90,CWE-416,"CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) <S2SV_StartBug> { <S2SV_EndBug> kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }
","<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
",torvalds@linux/124751d5e63c823092060074bd0abaae61aaa9c4,CVE-2017-16527,https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4,2017-11-04T01:29Z,90,<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;,1
91,CWE-416,"CWE-416 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( po -> fanout ) <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
","<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
",torvalds@linux/d199fab63c11998a602205f7ee7ff7c05c97164b,CVE-2017-6346,https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b,2017-03-01T20:59Z,91,<S2SV_ModStart> type_flags ) { struct packet_rollover * rollover = NULL ; <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY ; if ( <S2SV_ModEnd> type == PACKET_FANOUT_ROLLOVER <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> if (! rollover ) goto out ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart>,0
95,CWE-416,"CWE-416 AV * dbd_st_fetch ( SV * sth , imp_sth_t * imp_sth ) { dTHX ; int num_fields , ChopBlanks , i , rc ; unsigned long * lengths ; AV * av ; int av_length , av_readonly ; MYSQL_ROW cols ; D_imp_dbh_from_sth ; MYSQL * svsock = imp_dbh -> pmysql ; imp_sth_fbh_t * fbh ; D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION MYSQL_BIND * buffer ; # endif MYSQL_FIELD * fields ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_fetch\\n"" ) ; # if MYSQL_ASYNC if ( imp_dbh -> async_query_in_flight ) { if ( mysql_db_async_result ( sth , & imp_sth -> result ) <= 0 ) { return Nullav ; } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( ! DBIc_ACTIVE ( imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""no<S2SV_blank>statement<S2SV_blank>executing\\n"" , NULL ) ; return Nullav ; } if ( imp_sth -> fetch_done ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>but<S2SV_blank>fetch<S2SV_blank>already<S2SV_blank>done"" , NULL ) ; return Nullav ; } if ( ! imp_sth -> done_desc ) { if ( ! dbd_describe ( sth , imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""Error<S2SV_blank>while<S2SV_blank>describe<S2SV_blank>result<S2SV_blank>set."" , NULL ) ; return Nullav ; } } } # endif ChopBlanks = DBIc_is ( imp_sth , DBIcf_ChopBlanks ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>chopblanks<S2SV_blank>%d\\n"" , sth , ChopBlanks ) ; if ( ! imp_sth -> result ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>without<S2SV_blank>execute()"" , NULL ) ; return Nullav ; } imp_dbh -> pmysql -> net . last_errno = 0 ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>calling<S2SV_blank>mysql_fetch\\n"" ) ; if ( ( rc = mysql_stmt_fetch ( imp_sth -> stmt ) ) ) { if ( rc == 1 ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; # if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 if ( rc == MYSQL_DATA_TRUNCATED ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>data<S2SV_blank>truncated\\n"" ) ; goto process ; } # endif if ( rc == MYSQL_NO_DATA ) { imp_sth -> row_num = mysql_stmt_affected_rows ( imp_sth -> stmt ) ; imp_sth -> fetch_done = 1 ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>no<S2SV_blank>data\\n"" ) ; } dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } process : imp_sth -> currow ++ ; av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; num_fields = mysql_stmt_field_count ( imp_sth -> stmt ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>called<S2SV_blank>mysql_fetch,<S2SV_blank>rc<S2SV_blank>%d<S2SV_blank>num_fields<S2SV_blank>%d\\n"" , rc , num_fields ) ; for ( buffer = imp_sth -> buffer , fbh = imp_sth -> fbh , i = 0 ; i < num_fields ; i ++ , fbh ++ , buffer ++ ) { SV * sv = AvARRAY ( av ) [ i ] ; STRLEN len ; if ( fbh -> is_null ) ( void ) SvOK_off ( sv ) ; else { if ( fbh -> length > buffer -> buffer_length || fbh -> error ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tRefetch<S2SV_blank>BLOB/TEXT<S2SV_blank>column:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%lu,<S2SV_blank>error:<S2SV_blank>%d\\n"" , i , fbh -> length , fbh -> error ) ; Renew ( fbh -> data , fbh -> length , char ) ; buffer -> buffer_length = fbh -> length ; <S2SV_StartBug> buffer -> buffer = ( char * ) fbh -> data ; <S2SV_EndBug> if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tbefore<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } if ( mysql_stmt_fetch_column ( imp_sth -> stmt , buffer , i , 0 ) ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tafter<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } } switch ( buffer -> buffer_type ) { case MYSQL_TYPE_DOUBLE : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>double<S2SV_blank>data<S2SV_blank>%f\\n"" , fbh -> ddata ) ; sv_setnv ( sv , fbh -> ddata ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>int<S2SV_blank>data<S2SV_blank>%"" IVdf "",<S2SV_blank>unsigned?<S2SV_blank>%d\\n"" , fbh -> ldata , buffer -> is_unsigned ) ; if ( buffer -> is_unsigned ) sv_setuv ( sv , fbh -> ldata ) ; else sv_setiv ( sv , fbh -> ldata ) ; break ; case MYSQL_TYPE_BIT : sv_setpvn ( sv , fbh -> data , fbh -> length ) ; break ; default : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tERROR<S2SV_blank>IN<S2SV_blank>st_fetch_string"" ) ; len = fbh -> length ; if ( ChopBlanks ) { if ( fbh -> charsetnr != 63 ) while ( len && fbh -> data [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , fbh -> data , len ) ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fbh -> charsetnr != 63 ) # else if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && ! ( fbh -> flags & BINARY_FLAG ) ) # endif sv_utf8_decode ( sv ) ; # endif break ; } } } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; } else { # endif imp_sth -> currow ++ ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>result<S2SV_blank>set<S2SV_blank>details\\n"" ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\timp_sth->result=%p\\n"" , imp_sth -> result ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_fields=%u\\n"" , mysql_num_fields ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_rows=%llu\\n"" , mysql_num_rows ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_affected_rows=%llu\\n"" , mysql_affected_rows ( imp_dbh -> pmysql ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>currow=<S2SV_blank>%d\\n"" , sth , imp_sth -> currow ) ; } if ( ! ( cols = mysql_fetch_row ( imp_sth -> result ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch,<S2SV_blank>no<S2SV_blank>more<S2SV_blank>rows<S2SV_blank>to<S2SV_blank>fetch"" ) ; } if ( mysql_errno ( imp_dbh -> pmysql ) ) do_error ( sth , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; # if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION if ( ! mysql_more_results ( svsock ) ) # endif dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } num_fields = mysql_num_fields ( imp_sth -> result ) ; fields = mysql_fetch_fields ( imp_sth -> result ) ; lengths = mysql_fetch_lengths ( imp_sth -> result ) ; if ( ( av = DBIc_FIELDS_AV ( imp_sth ) ) != Nullav ) { av_length = av_len ( av ) + 1 ; if ( av_length != num_fields ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>size<S2SV_blank>of<S2SV_blank>results<S2SV_blank>array(%d)<S2SV_blank>!=<S2SV_blank>num_fields(%d)\\n"" , av_length , num_fields ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>result<S2SV_blank>fields(%d)\\n"" , DBIc_NUM_FIELDS ( imp_sth ) ) ; av_readonly = SvREADONLY ( av ) ; if ( av_readonly ) SvREADONLY_off ( av ) ; while ( av_length < num_fields ) { av_store ( av , av_length ++ , newSV ( 0 ) ) ; } while ( av_length > num_fields ) { SvREFCNT_dec ( av_pop ( av ) ) ; av_length -- ; } if ( av_readonly ) SvREADONLY_on ( av ) ; } } av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; for ( i = 0 ; i < num_fields ; ++ i ) { char * col = cols [ i ] ; SV * sv = AvARRAY ( av ) [ i ] ; if ( col ) { STRLEN len = lengths [ i ] ; if ( ChopBlanks ) { while ( len && col [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , col , len ) ; switch ( mysql_to_perl_type ( fields [ i ] . type ) ) { case MYSQL_TYPE_DOUBLE : ( void ) SvNV ( sv ) ; SvNOK_only ( sv ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( fields [ i ] . flags & UNSIGNED_FLAG ) { ( void ) SvUV ( sv ) ; SvIOK_only_UV ( sv ) ; } else { ( void ) SvIV ( sv ) ; SvIOK_only ( sv ) ; } break ; # if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION case MYSQL_TYPE_BIT : break ; # endif default : # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fields [ i ] . charsetnr != 63 ) sv_utf8_decode ( sv ) ; # endif break ; } } else ( void ) SvOK_off ( sv ) ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION } # endif }
","<S2SV_ModStart> ; buffer -> buffer = ( char * ) fbh -> data ; imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ; imp_sth -> stmt -> bind [ i ] .
",perl5-dbi@DBD-mysql/3619c170461a3107a258d1fd2d00ed4832adb1b1,CVE-2016-1251,https://github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1,2016-11-29T20:59Z,95,"<S2SV_ModStart> -> num_cols ; if ( imp_sth -> num_cols < 1 ) { do_error ( sth, JW_ERR_INTERNAL, ""num_cols <S2SV_blank> must <S2SV_blank> be <S2SV_blank> 1 <S2SV_blank> or <S2SV_blank> greater\\n"" ) ; return Nullav ; } <S2SV_ModStart> -> num_cols ; if ( imp_sth -> num_cols < 1 ) { do_error ( sth, JW_ERR_INTERNAL, ""num_cols <S2SV_blank> must <S2SV_blank> be <S2SV_blank> 1\\n"" ) ; return Nullav ; } <S2SV_ModStart> -> num_rows ; if ( imp_sth -> num_cols < 1 ) { do_error ( sth, JW_ERR_INTERNAL, ""num_cols <S2SV_blank> must <S2SV_blank> be <S2SV_blank> 1 <S2SV_blank> or <S2SV_blank> greater\\n"" ) ; return Nullav ; }",0
96,CWE-20,"CWE-20 error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> enc28j60WriteBuffer ( interface , buffer , offset ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,96,"<S2SV_ModStart> ( interface, ENC28J60_ECON1, ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface, ENC28J60_EIR, ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF <S2SV_ModEnd> ) ; enc28j60WriteReg <S2SV_ModStart> ( interface, ENC28J60_EWRPTL <S2SV_ModEnd>, LSB ( <S2SV_ModStart> ( interface, ENC28J60_EWRPTH <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ( interface, ENC28J60_EWRPTH <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ( interface, ENC28J60_ECON1, ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; enc28j60WriteBuffer <S2SV_ModStart> ( interface, ENC28J60_ETXNDL, LSB ( ENC28J60_TX_BUFFER_START ) ) ; enc28j60WriteReg ( interface, ENC28J60_ETXNDH <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ( interface, ENC28J60_ECON1, ENC28J60_ECON1_TX",0
97,CWE-125,"CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> value = ast2obj_int ( o -> lineno ) ; <S2SV_EndBug> if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value =
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,97,"<S2SV_ModStart> value ) ; value = ast2obj_int ( o -> lineno ) ; if (! value ) goto failed ; if ( _PyObject_SetAttrId ( result, & PyId_lineno, value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if (! value ) goto failed ; if ( _PyObject_SetAttrId ( result, & PyId_col_offset, value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> start_lineno ) ; if (! value ) goto failed ; if ( _PyObject_SetAttrId ( result, & PyId_start_lineno, value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> start_col_offset ) ; if (! value ) goto failed ; if ( _PyObject_SetAttrId ( result, & PyId_start_col_offset, value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o ->",0
98,CWE-22,"CWE-22 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
",yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z,98,"<S2SV_ModStart> ; if ( page && ( access ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""error"" ) ; http_response_send ( res ) ; return ; } if ( <S2SV_ModStart> ; if ( page && ( file_access <S2SV_ModEnd> ( page, <S2SV_ModStart> ; if ( page && ( unlink ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""error"" ) ; http_response_send ( res ) ; return ; } if ( page && ( access ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""success"" ) ; http_response_send ( res ) ; return ; } if ( page && ( access ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""success"" ) ; http_response_send ( res ) ; return ; } } else if (! strcmp ( func, ""page/get"" ) ) { char * page = http_request_param_get ( req, ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && (",0
100,CWE-125,"CWE-125 static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)"" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u"" "",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u"" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_compproto_subopt_values , ""Unknown"" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ipcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z,100,<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;,1
106,CWE-78,"CWE-78 R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s\\r\\n"" ""Content-Length:<S2SV_blank>%i\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; <S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,106,"<S2SV_ModStart> ) ) ; if (! r_socket_http_answer ( s, code, rlen ) ) { free ( uri ) ; return NULL ; }",0
111,CWE-125,"CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,111,"<S2SV_ModStart> ( ndo, ""%s"", rpl_tstr <S2SV_ModEnd> ) ) ;",1
112,CWE-125,"CWE-125 <S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ; <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> hexdump = FALSE ; ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Serial:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_IPV6_PREFIX_PDU : { const rpki_rtr_pdu_ipv6_prefix * pdu ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_ERROR_REPORT_PDU : { const rpki_rtr_pdu_error_report * pdu ; u_int encapsulated_pdu_length , text_length , tlen , error_code ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> tlen = pdu_len ; error_code = EXTRACT_16BITS ( pdu -> pdu_header . u . error_code ) ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>code:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Encapsulated<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , tok2str ( rpki_rtr_error_codes , ""Unknown"" , error_code ) , error_code , encapsulated_pdu_length ) ) ; <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> tlen -= sizeof ( * pdu ) ; <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> ( encapsulated_pdu_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%s-----encapsulated<S2SV_blank>PDU-----"" , indent_string ( indent + 4 ) ) ) ; <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> goto trunc ; } tptr += encapsulated_pdu_length ; <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> if ( tlen > 4 ) { <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> } <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> if ( text_length && ( text_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : hexdump = TRUE ; } if ( ndo -> ndo_vflag > 1 || ( ndo -> ndo_vflag && hexdump ) ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , pdu_len ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> trunc : <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> length ) ; <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> encapsulated_pdu_length ) ; tlen += 4 <S2SV_ModEnd> ; error_code = <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( encapsulated_pdu_length <S2SV_ModStart> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ndo , tptr + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> + 2 ) ; } tlen <S2SV_ModEnd> += encapsulated_pdu_length ; <S2SV_ModStart> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> ; text_length = <S2SV_ModStart> ; text_length = <S2SV_ModEnd> EXTRACT_32BITS ( tptr <S2SV_ModStart> EXTRACT_32BITS ( tptr + tlen ) ; tlen <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> ND_TCHECK2 ( * <S2SV_ModStart> * tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = TRUE <S2SV_ModStart> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> ; trunc : <S2SV_ModStart> ; trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> ; } <S2SV_null>
",the-tcpdump-group@tcpdump/83c64fce3a5226b080e535f5131a8a318f30e79b,CVE-2017-13050,https://github.com/the-tcpdump-group/tcpdump/commit/83c64fce3a5226b080e535f5131a8a318f30e79b,2017-09-14T06:29Z,112,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * tptr, const u_int len, const <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; ND_TCHECK_16BITS ( tptr ) ; ND_TCHECK_32BITS ( tptr ) ; pdu_len = EXTRACT_16BITS ( tptr ) ; if ( pdu_len!= sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo, ""%sRPKI-RTRv%u <S2SV_blank> (unknown)"", indent_string ( 8 ), pdu_header -> version ) ) ; ND_TCHECK2 ( * tptr, pdu_len ) ; hexdump = FALSE ; switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_",0
113,CWE-20,"CWE-20 int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <S2SV_StartBug> int n , len ; <S2SV_EndBug> skb -> sk = NULL ; <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; make_rose -> neighbour = neigh ; make_rose -> device = dev ; make_rose -> facilities = facilities ; make_rose -> neighbour -> use ++ ; if ( rose_sk ( sk ) -> defer ) { make_rose -> state = ROSE_STATE_5 ; } else { rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; make_rose -> state = ROSE_STATE_3 ; rose_start_idletimer ( make ) ; } make_rose -> condition = 0x00 ; make_rose -> vs = 0 ; make_rose -> va = 0 ; make_rose -> vr = 0 ; make_rose -> vl = 0 ; sk -> sk_ack_backlog ++ ; rose_insert_socket ( make ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; rose_start_heartbeat ( make ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk , skb -> len ) ; return 1 ; }
","<S2SV_ModStart> ; int n <S2SV_ModEnd> ; skb -> <S2SV_ModStart> rose_facilities_struct ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> & facilities )
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z,113,"<S2SV_ModStart> ; int n <S2SV_ModEnd> ; skb -> <S2SV_ModStart> rose_facilities_struct ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> data + ROSE_CALL_REQ_FACILITIES_OFF, skb -> len - ROSE_CALL_REQ_FACILITIES_OFF, <S2SV_ModEnd> & facilities )",1
115,CWE-20,"CWE-20 static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) <S2SV_StartBug> { <S2SV_EndBug> errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) { <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }
","<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
",vim@vim/d0b5138ba4bccff8a744c99836041ef6322ed39a,CVE-2016-1248,https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a,2016-11-23T15:59Z,115,<S2SV_ModStart> } else { # ifdef HAVE_SANDBOX || sandbox!= 0 # endif if ( ( options [ opt_idx ]. flags & P_SANDBOX ) && ( sandbox!= 0 ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ]. flags & P_SECURE ) && ( secure # ifdef HAVE_SANDBOX || sandbox!= 0 # endif ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ]. flags & P_SECURE ) && ( sandbox!= 0 # endif ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ]. flags & P_SECURE ) && ( sandbox!= 0 ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ]. flags & P_SECURE ) && ( secure # ifdef HAVE_SANDBOX || ( sandbox!= 0 ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ]. flags & P_SECURE ) && ( options [ opt_idx ]. flags & P_SECURE ) ) { errmsg = e_secure ; } else,0
118,CWE-125,"CWE-125 u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO : <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,118,"<S2SV_ModStart> p, length <S2SV_ModEnd> ) ; break",1
119,CWE-22,"CWE-22 static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z,119,"<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive, ARCHIVE_ERRNO_MISC, ""Path <S2SV_blank> is <S2SV_blank> absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;",1
125,CWE-416,"CWE-416 struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }
","<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
",torvalds@linux/21b5944350052d2583e82dd59b19a9ba94a007f0,CVE-2017-15129,https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0,2018-01-09T19:29Z,125,<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer ),1
131,CWE-125,"CWE-125 void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; <S2SV_StartBug> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <S2SV_EndBug> readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ; <S2SV_StartBug> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <S2SV_EndBug> if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }
","<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z,131,"<S2SV_ModStart> + MIDQ_DATA_BUFF ; unsigned short head, tail ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; while ( head!= tail ) { u16 val ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRI",0
134,CWE-20,"CWE-20 static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI1outR1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>R1"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z,134,<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,1
135,CWE-79,"CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }
","<S2SV_ModStart> ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,
",zmartzone@mod_auth_openidc/132a4111bf3791e76437619a66336dce2ce4c79b,CVE-2019-1010247,https://github.com/zmartzone/mod_auth_openidc/commit/132a4111bf3791e76437619a66336dce2ce4c79b,2019-07-19T15:15Z,135,"<S2SV_ModStart> ""\\n"" "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> function <S2SV_blank> setTimer() <S2SV_blank> {\\n"" "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> checkSession();\\n"" "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> timerID <S2SV_blank> = <S2SV_blank> setInterval(\'checkSession()\', <S2SV_blank> %d);\\n"" <S2SV_ModEnd> "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> {\\n"" "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> setInterval(\'checkSession()\', <S2SV_blank> %d);\\n"" <S2SV_ModEnd> "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> }\\n"" ""\\n"" "" <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank> <S2SV_blank>",0
137,CWE-125,"CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,137,<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;,1
138,CWE-125,"CWE-125 GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; <S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }
","<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
",gpac@gpac/bceb03fd2be95097a7b409ea59914f332fb6bc86,CVE-2018-13006,https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86,2018-06-29T14:29Z,138,<S2SV_ModStart> ; while ( ( <S2SV_ModStart>!= 0 ) && ( i < to_read ),0
146,CWE-125,"CWE-125 void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; } <S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ; <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT : <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
",the-tcpdump-group@tcpdump/de981e6070d168b58ec1bb0713ded77ed4ad87f4,CVE-2017-12901,https://github.com/the-tcpdump-group/tcpdump/commit/de981e6070d168b58ec1bb0713ded77ed4ad87f4,2017-09-14T06:29Z,146,"<S2SV_ModStart> case EIGRP_COM_HDR_V1 : if ( eigrp_tlv_len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> case EIGRP_COM_HDR_V2 : if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> case EIGRP_COM_HDR_V1 : if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> case EIGRP_COM_HDR_V1 : if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> case EIGRP_COM_HDR",0
148,CWE-20,"CWE-20 static int parse_exports_table ( long long * table_start ) { int res ; <S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>export<S2SV_blank>index<S2SV_blank>table\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
","<S2SV_ModStart> = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> ; long long * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> ; res = <S2SV_ModStart> . lookup_table_start , length , <S2SV_ModEnd> export_index_table ) ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z,148,"<S2SV_ModStart> int res ; unsigned int * export_index_table ; int i ; <S2SV_ModStart> inodes ) ; export_index_table = kmalloc ( SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk. s. inodes ) + 1, GFP_NOFS ) ; if ( export_index_table == NULL ) { ERROR ( ""parse_exports_table: <S2SV_blank> allocating <S2SV_blank> empty <S2SV_blank> export <S2SV_blank> index <S2SV_blank> table\\n"" ) ; return FALSE ; } <S2SV_ModStart> ] ; res = read_fs_bytes ( fd, sBlk. s. lookup_table_start, SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk. s. inodes ), export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table: <S2SV_blank> failed <S2SV_blank> to <S2SV_blank> read <S2SV_blank> export <S2SV_blank> index <S2SV_blank> table\\n"" ) ; return FALSE ; }",0
153,CWE-416,"CWE-416 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,153,"<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6, rcu_dereference ( <S2SV_ModStart> np -> opt ), & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst",1
164,CWE-20,"CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }
","<S2SV_ModStart> c -> nreslevels <= <S2SV_ModEnd> s -> reduction_factor <S2SV_ModStart> -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c -> nreslevels2decode
",FFmpeg@FFmpeg/a1b9004b768bef606ee98d417bceb9392ceb788d,CVE-2013-7019,https://github.com/FFmpeg/FFmpeg/commit/a1b9004b768bef606ee98d417bceb9392ceb788d,2013-12-09T16:36Z,164,"<S2SV_ModStart> c -> nreslevels < <S2SV_ModEnd> s -> reduction_factor <S2SV_ModStart> -> reduction_factor ) { avpriv_request_sample ( s -> avctx, ""reduction_factor <S2SV_blank> too <S2SV_blank> large\\n"" ) ; return AVERROR_PATCHWELCOME ; } <S2SV_ModEnd> c -> nreslevels2decode <S2SV_ModStart> -> reduction_factor ; if ( c -> nreslevels2decode > c -> nreslevels ) { avpriv_request_sample ( s -> avctx, ""nreslevels <S2SV_blank> to <S2SV_blank> decode <S2SV_blank> too <S2SV_blank> large\\n"" ) ; return AVERROR_PATCHWELCOME ; }",0
182,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
",ImageMagick@ImageMagick/6b4aff0f117b978502ee5bcd6e753c17aec5a961,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/6b4aff0f117b978502ee5bcd6e753c17aec5a961,2017-04-20T18:59Z,182,"<S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ;",0
183,CWE-20,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } <S2SV_StartBug> colormap = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( number_colormaps != 0 ) { <S2SV_StartBug> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , <S2SV_EndBug> 3 * map_length * sizeof ( * colormap ) ) ; <S2SV_StartBug> if ( colormap == ( unsigned char * ) NULL ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , * p & mask , & index , exception ) ; <S2SV_EndBug> * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> colormap = ( <S2SV_ModStart> char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> ( unsigned char <S2SV_ModEnd> ) ScaleQuantumToChar ( <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( Quantum )
",ImageMagick@ImageMagick/f6240ee77847787f6d7618b669d3a2040a2d6d40,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/f6240ee77847787f6d7618b669d3a2040a2d6d40,2017-05-22T14:29Z,183,"<S2SV_ModStart> ReadBlob ( image, 2, ( <S2SV_ModEnd> unsigned char * <S2SV_ModStart> unsigned char * ) magick, 12 ) ; if ( ( count < 2 ) || ( memcmp ( magick, ""\\122\\314"", 2 )!= 0 ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> do { image -> rows = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; if ( flags & MagickStatusType ) LogMagickEvent ( TraceEvent, CorruptImageError, ""ImproperImageHeader"" ) ; else { pixel_info = ( MemoryInfo * ) RelinquishMagickMemory ( pixel_info ) ; pixel_info = ( MemoryInfo * ) RelinquishMagickMemory ( pixel_info ) ; pixel_info = ( MemoryInfo * ) RelinquishMagickMemory",0
191,CWE-20,"CWE-20 void init_util ( void ) { filegen_register ( statsdir , ""peerstats"" , & peerstats ) ; filegen_register ( statsdir , ""loopstats"" , & loopstats ) ; filegen_register ( statsdir , ""clockstats"" , & clockstats ) ; filegen_register ( statsdir , ""rawstats"" , & rawstats ) ; filegen_register ( statsdir , ""sysstats"" , & sysstats ) ; filegen_register ( statsdir , ""protostats"" , & protostats ) ; <S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }
","<S2SV_ModStart> protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> timingstats ) ; <S2SV_ModEnd> step_callback = &
",ntp-project@ntp/52e977d79a0c4ace997e5c74af429844da2f27be,CVE-2015-5195,https://github.com/ntp-project/ntp/commit/52e977d79a0c4ace997e5c74af429844da2f27be,2017-07-21T14:29Z,191,<S2SV_ModStart> protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> timingstats ) ; <S2SV_ModEnd> step_callback = &,1
198,CWE-125,"CWE-125 static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) { <S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> spacep = strchr ( temp , '<S2SV_blank>' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }
","<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> , sfsname , stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'
",the-tcpdump-group@tcpdump/7a923447fd49a069a0fd3b6c3547438ab5ee2123,CVE-2017-13001,https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123,2017-09-14T06:29Z,198,"<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart>, sfsname, stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'",1
208,CWE-20,"CWE-20 static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( ""sock=%p<S2SV_blank>sk=%p<S2SV_blank>len=%zu<S2SV_blank>flags=%d\\n"" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }
","<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,208,<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb,1
211,CWE-125,"CWE-125 static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ; <S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> if ( len >= 0 ) len += tested ; } return ( len ) ; }
","<S2SV_ModStart> ( * b + len , * avail - len <S2SV_ModEnd> , nl )
",libarchive@libarchive/eec077f52bfa2d3f7103b4b74d52572ba8a15aca,CVE-2016-8688,https://github.com/libarchive/libarchive/commit/eec077f52bfa2d3f7103b4b74d52572ba8a15aca,2017-02-15T19:59Z,211,"<S2SV_ModStart> ( * b + len, * avail - len <S2SV_ModEnd>, nl )",1
212,CWE-125,"CWE-125 static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { <S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> int kind ; void * data ; PyCompilerFlags cf ; <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> char * str ; <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
","<S2SV_ModStart> n ) { <S2SV_ModEnd> PyCompilerFlags cf ; <S2SV_ModStart> PyCompilerFlags cf ; node * mod_n ; <S2SV_ModStart> * str ; Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ':' ) ; for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> expr_end - expr_start <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; str = <S2SV_ModStart> == NULL ) { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> str [ 0 <S2SV_ModStart> = PyCF_ONLY_AST ; mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> PyMem_RawFree ( str ) ; Ta3Node_Free ( mod_n
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,212,"<S2SV_ModStart> ) { int all_whitespace = 1 ; int kind ; void * data <S2SV_ModEnd> ; PyCompilerFlags cf <S2SV_ModStart> * str ; <S2SV_ModEnd> PyObject * o <S2SV_ModStart> * o, * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_start >= expr_start ) ; o = PyUnicode_DecodeUTF8 ( expr_start, expr_end - expr_start, NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if (! Py_UNICODE_ISSPACE ( PyUnicode_READ ( PyUnicode_KIND ( o, data, i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; str [ 0 ] = '(' ; memcpy ( str + 1, expr_start, len ) ; str [ len + 1 ] = ')' ; Py_DECREF ( o ) ; <S2SV_ModStart> = PyCF_ONLY_AST ; fstring_name = PyUnicode",0
213,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> { WLog_DBG ( TAG , ""%s<S2SV_blank>(Len:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>MaxLen:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>BufferOffset:<S2SV_blank>%"" PRIu32 "")"" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,213,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
215,CWE-20,"CWE-20 static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }
","<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,215,"<S2SV_ModStart> == 0 ) mark_key_instantiated ( key, 0 <S2SV_ModEnd> ) ; up_write",1
216,CWE-20,"CWE-20 int net_get ( int s , void * arg , int * len ) { struct net_hdr nh ; int plen ; if ( net_read_exact ( s , & nh , sizeof ( nh ) ) == - 1 ) { return - 1 ; } plen = ntohl ( nh . nh_len ) ; if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\n"" , plen , nh . nh_type , * len ) ; <S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> * len = plen ; if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) ) { return - 1 ; } return nh . nh_type ; }
","<S2SV_ModStart> <= * len && plen > 0
",aircrack-ng@aircrack-ng/88702a3ce4c28a973bf69023cd0312f412f6193e,CVE-2014-8324,https://github.com/aircrack-ng/aircrack-ng/commit/88702a3ce4c28a973bf69023cd0312f412f6193e,2017-10-17T14:29Z,216,<S2SV_ModStart> <= * len && plen > 0,1
218,CWE-20,"CWE-20 asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ; <S2SV_StartBug> if ( COMPAT_USE_64BIT_TIME ) <S2SV_EndBug> return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ; <S2SV_StartBug> if ( get_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ; <S2SV_StartBug> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> datagrams = - EFAULT ; return datagrams ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> timeout == NULL <S2SV_ModStart> ; if ( compat_get_timespec <S2SV_ModEnd> ( & ktspec <S2SV_ModStart> > 0 && compat_put_timespec <S2SV_ModEnd> ( & ktspec
",torvalds@linux/2def2ef2ae5f3990aabdbe8a755911902707d268,CVE-2014-0038,https://github.com/torvalds/linux/commit/2def2ef2ae5f3990aabdbe8a755911902707d268,2014-02-06T22:55Z,218,<S2SV_ModStart> ; if ( <S2SV_ModEnd> timeout == NULL <S2SV_ModStart> ; if ( compat_get_timespec <S2SV_ModEnd> ( & ktspec <S2SV_ModStart> > 0 && compat_put_timespec <S2SV_ModEnd> ( & ktspec,1
220,CWE-416,"CWE-416 static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> & tx_ring_data ( priv , skb -> queue_mapping ) ) ; <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }
","<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,CVE-2017-18218,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,2018-03-05T20:29Z,220,<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,1
221,CWE-20,"CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
","<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,221,<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk,1
223,CWE-125,"CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,CVE-2018-11377,https://github.com/radare/radare2/commit/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,2018-05-22T19:29Z,223,<S2SV_ModStart> ; RAnalOp next_op = { 0 },1
228,CWE-125,"CWE-125 static VarLenData * * get_html_data ( MAPI_Attr * a ) { VarLenData * * body = XCALLOC ( VarLenData * , a -> num_values + 1 ) ; int j ; for ( j = 0 ; j < a -> num_values ; j ++ ) <S2SV_StartBug> { <S2SV_EndBug> body [ j ] = XMALLOC ( VarLenData , 1 ) ; body [ j ] -> len = a -> values [ j ] . len ; body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; } <S2SV_StartBug> return body ; <S2SV_EndBug> }
","<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } }
",verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z,228,<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } },1
230,CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,230,"<S2SV_ModStart> u_char * dat, u_int length <S2SV_ModStart>, val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( length",0
236,CWE-78,"CWE-78 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
","<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
",radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z,236,<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;,1
237,CWE-125,"CWE-125 static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>"" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>"" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { <S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z,237,"<S2SV_ModStart> case 1 : cp = ikev1_attrmap_print ( ndo, cp, map, nmap ) ; break ; case 2 : cp = ikev1_attrmap_print ( ndo, cp, map, nmap ) ; break ; case 3 : cp = ikev1_attr_print ( ndo, cp, map, nmap ) ; break ; case 4 : cp = ikev1_attr_print ( ndo, cp, map, nmap ) ; break ; case 5 : cp = ikev1_attr_print ( ndo, cp, map, nmap ) ; break ; case 6 : cp = ikev1_attr_print ( ndo, cp, map, nmap ) ; break ; case 8 : cp = ikev1_attr_print ( ndo, cp, map, nmap ) ; break ;",0
240,CWE-20,"CWE-20 void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( ""refs/heads/git_tilde1"" <S2SV_ModStart> "".git/foobar"" ) ; test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libgit2@libgit2/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,CVE-2020-12279,https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,2020-04-27T17:15Z,240,"<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( ""refs/heads/git_tilde1"" <S2SV_ModStart> "".git/foobar"" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",0
242,CWE-20,"CWE-20 int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { <S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> msg -> msg_namelen = 0 ; return 0 ; } return err ; } copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) { sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( bt_sk ( sk ) -> skb_msg_name ) bt_sk ( sk ) -> skb_msg_name ( skb , msg -> msg_name , & msg -> msg_namelen ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = 0 ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
","<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,242,<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (,1
248,CWE-20,"CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,248,<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0,0
249,CWE-125,"CWE-125 void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ; <S2SV_StartBug> register u_int amt ; <S2SV_EndBug> register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> if ( j == 1 <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>dump"" ) ) ; break ; } <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RIP6_RESPONSE : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d:"" , j ) ) ; <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , ni -> rip6_metric ) ; } <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-%d<S2SV_blank>??<S2SV_blank>%u"" , rp -> rip6_cmd , length ) ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ;
",the-tcpdump-group@tcpdump/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,CVE-2017-12992,https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,2017-09-14T06:29Z,249,"<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni )!= length_left ) ND_PRINT ( ( ndo, "" <S2SV_blank> ripng-req <S2SV_blank> %u[%u]:"", j, length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ni )!= length_left ) ND_PRINT ( ( ndo, "" <S2SV_blank> ripng-req <S2SV_blank> %u:"", j ) ) ; for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; i -= sizeof ( * ni ), ++ ni ) { if ( ndo -> ndo_vflag > 1",0
253,CWE-125,"CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
","<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
",libgd@libgd/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,CVE-2013-7456,https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,2016-08-07T10:59Z,253,<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ]. Left = iLeft ; res -> ContribRow [ u ]. Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ].,1
254,CWE-416,"CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
","<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
",torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z,254,<S2SV_ModStart> user ) { cleanup_srcu_struct ( & user -> release_barrier ) ;,0
259,CWE-125,"CWE-125 static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; <S2SV_StartBug> int is_async = 0 ; <S2SV_EndBug> REQ ( n , comp_for ) ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> is_async = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async<S2SV_blank>comprehensions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.6<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } <S2SV_StartBug> for_ch = CHILD ( n , 1 + is_async ) ; <S2SV_EndBug> t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; <S2SV_StartBug> expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; <S2SV_EndBug> if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> int j , n_ifs ; asdl_seq * ifs ; <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
","<S2SV_ModStart> * for_ch ; node * sync_n ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 <S2SV_ModEnd> ) { is_async <S2SV_ModStart> = 1 ; REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> if ( is_async <S2SV_ModStart> = CHILD ( sync_n , 1 <S2SV_ModEnd> ) ; t <S2SV_ModStart> , CHILD ( sync_n , 3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( NCH ( sync_n ) == 5 <S2SV_ModEnd> ) { int <S2SV_ModStart> = CHILD ( sync_n , 4 <S2SV_ModEnd> ) ; n_ifs
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,259,"<S2SV_ModStart> * for_ch ; bool is_async ; <S2SV_ModStart> comp_for ) ; is_async = 0 ; if ( TYPE ( CHILD ( n, 0 ) ) == TYPE_COMMENT ) { ast_error ( c, CHILD ( n, 0 ), ""Async <S2SV_blank> comprehensions <S2SV_blank> are <S2SV_blank> only <S2SV_blank> supported <S2SV_blank> in <S2SV_blank> Python <S2SV_blank> 3.6 <S2SV_blank> and <S2SV_blank> greater"" ) ; return NULL ; } <S2SV_ModStart> ; if ( <S2SV_ModEnd> c -> c_feature_version <S2SV_ModStart> < 6 ) { ast_error ( c, CHILD ( n, ""Async <S2SV_blank> comprehensions <S2SV_blank> are <S2SV_blank> only <S2SV_blank> supported <S2SV_blank> in <S2SV_blank> Python <S2SV_blank> 3.6 <S2SV_blank> and <S2SV_blank> greater"" ) ; return NULL ; } for_ch = CHILD ( n, 2 + is_async ) ; t = ast_for_exprlist ( c, for_ch, Store ) ; if (! t ) return NULL ; expression = ast_for_expr ( c, for_ch, Store ) ; if (! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t, 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension (",0
268,CWE-125,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z,268,<S2SV_ModStart> ; if ( <S2SV_ModEnd> len < sizeof <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS,0
274,CWE-125,"CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
","<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->
",radare@radare2/1f37c04f2a762500222dda2459e6a04646feeedf,CVE-2018-11376,https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf,2018-05-22T19:29Z,274,<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->,1
275,CWE-125,"CWE-125 static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( isis_ext_is_reach_subtlv_values , ""unknown"" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if ( subl >= 32 ) { for ( te_class = 0 ; te_class < 8 ; te_class ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TE-Class<S2SV_blank>%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ; tptr ++ ; for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) { <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Bandwidth<S2SV_blank>constraint<S2SV_blank>CT%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC : if ( subl >= 3 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE : if ( subl == 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]<S2SV_blank>(0x%04x)"" , bittok2str ( isis_subtlv_link_attribute_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) ) , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE : if ( subl >= 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , bittok2str ( gmpls_link_prot_values , ""none"" , * tptr ) , * ( tptr + 1 ) ) ) ; } break ; case ISIS_SUBTLV_SPB_METRIC : if ( subl >= 6 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>LM:<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; tptr = tptr + 3 ; ND_PRINT ( ( ndo , "",<S2SV_blank>P:<S2SV_blank>%u"" , * ( tptr ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>P-ID:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR : if ( subl >= 36 ) { gmpls_switch_cap = * tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>Switching<S2SV_blank>Capability:%s"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , gmpls_switch_cap ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>LSP<S2SV_blank>Encoding:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( tptr + 1 ) ) ) ) ; tptr += 4 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Max<S2SV_blank>LSP<S2SV_blank>Bandwidth:"" , ident ) ) ; for ( priority_level = 0 ; priority_level < 8 ; priority_level ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>priority<S2SV_blank>level<S2SV_blank>%d:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , priority_level , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } subl -= 36 ; switch ( gmpls_switch_cap ) { case GMPLS_PSC1 : case GMPLS_PSC2 : case GMPLS_PSC3 : case GMPLS_PSC4 : ND_TCHECK2 ( * tptr , 6 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>MTU:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case GMPLS_TSC : ND_TCHECK2 ( * tptr , 8 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Indication<S2SV_blank>%s"" , ident , tok2str ( gmpls_switch_cap_tsc_indication_values , ""Unknown<S2SV_blank>(%u)"" , * ( tptr + 4 ) ) ) ) ; break ; default : if ( subl > 0 ) { if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; } } } break ; default : if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; break ; } return ( 1 ) ; trunc : return ( 0 ) ; }
","<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> bw . i
",the-tcpdump-group@tcpdump/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,CVE-2017-13055,https://github.com/the-tcpdump-group/tcpdump/commit/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,2017-09-14T06:29Z,275,"<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 2 ) ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; else ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; <S2SV_ModStart> break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 2 ) ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; else if ( subl == 3 ) ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; else ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; else ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string",0
276,CWE-787,"CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
","<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,276,"<S2SV_ModStart> ] ; } if ( idx + HBE_OPER_WIN_LEN > ( TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ) { ptr_hbe_txposer -> j_input_buf [ idx + HBE_OPER_WIN_LEN - 1 ] = ptr_hbe_txposer -> ptr_input_buf [ idx + HBE_OPER_WIN_LEN - 1 ] ; memset ( ptr_hbe_txposer -> j_input_buf [ idx + HBE_OPER_WIN_LEN - 1 ], 0, TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; } else if ( idx + HBE_OPER_WIN_LEN - 1 > ( TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ) { ptr_hbe_txposer -> j_input_buf [ idx + HBE_OPER_WIN_LEN - 1 ] = ptr_hbe_txposer -> ptr_input_buf [ idx + HBE_OPER_WIN_LEN - 1 ] ; }",0
277,CWE-125,"CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
",kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z,277,"<S2SV_ModStart> -> dmin ; if ( p - str < enclen ( reg -> enc, p ) ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; else if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( high_prev ) * high_prev = onigenc_get_prev_char_head ( reg -> enc, str, * high ) ; else if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( high_prev ) * high_prev = onigenc_get_prev_char_",0
278,CWE-416,"CWE-416 <S2SV_StartBug> static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) <S2SV_EndBug> { <S2SV_StartBug> struct bfq_data * bfqd = bfqq -> bfqd ; <S2SV_EndBug> enum bfqq_expiration reason ; unsigned long flags ; <S2SV_StartBug> spin_lock_irqsave ( & bfqd -> lock , flags ) ; <S2SV_EndBug> bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
","<S2SV_ModStart> void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , <S2SV_ModStart> bfqq ) { <S2SV_ModEnd> enum bfqq_expiration reason <S2SV_ModStart> lock , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> return ; } bfq_clear_bfqq_wait_request ( bfqq ) ;
",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z,278,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static inline bool <S2SV_ModEnd> bfq_idle_slice_timer_body ( struct <S2SV_ModStart> ) { struct bfq_data <S2SV_ModEnd> * bfqd = <S2SV_ModStart> -> bfqd ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> flags ) ; if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfq_bfqq_queued ( bfqq ) == 0 ) return false ; spin_unlock_irqrestore ( & bfqd -> lock, flags ) ; return true ;",0
279,CWE-20,"CWE-20 void big_key_revoke ( struct key * key ) { struct path * path = ( struct path * ) & key -> payload . data [ big_key_path ] ; key_payload_reserve ( key , 0 ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,279,<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),1
280,CWE-20,"CWE-20 static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ; <S2SV_StartBug> RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; <S2SV_EndBug> if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ; <S2SV_StartBug> if ( unlikely ( work_to_do < 0 ) ) { <S2SV_EndBug> netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ; <S2SV_StartBug> if ( unlikely ( ret < 0 ) ) { <S2SV_EndBug> netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>packet<S2SV_blank>size:<S2SV_blank>%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ; <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>skb<S2SV_blank>in<S2SV_blank>start_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ; <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }
","<S2SV_ModStart> ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> } ret = <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> idx += ret <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> size ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; continue <S2SV_ModStart> skb ) ; <S2SV_ModEnd> continue ; }
",torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z,280,"<S2SV_ModStart> ) continue ; if ( vif -> tx. sring -> req_prod - vif -> tx. req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev, ""Impossible <S2SV_blank> number <S2SV_blank> of <S2SV_blank> requests. <S2SV_blank> "" ""req_cons <S2SV_blank> %d, <S2SV_blank> req_cons <S2SV_blank> %d\\n"", vif -> tx. sring -> req_cons, XEN_NETIF_TX_RING_SIZE - 1 ) ; continue ; } <S2SV_ModStart> 0 ) ) { netdev_err ( vif -> dev, ""Impossible <S2SV_blank> number <S2SV_blank> of <S2SV_blank> requests. <S2SV_blank> "" ""req_cons <S2SV_blank> %d, <S2SV_blank> size <S2SV_blank> %d\\n"", vif -> tx. req_cons, XEN_NETIF_TX_RING_SIZE ) ; continue ; } <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> < 0 ) ) { netdev_err ( vif -> dev, ""Impossible <S2SV_blank> number <S2SV_blank> of <S2SV_blank> requests. <S2SV_blank> "" ""req_cons <S2SV_blank> %d, <S2SV_blank> remaining_credit <S2SV_blank> %d\\n"", work_to_do, XEN_NETIF_TX_RING_SIZE ) ;",0
282,CWE-416,"CWE-416 static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }
","<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
",torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2,CVE-2017-16939,https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2,2017-11-24T10:29Z,282,<S2SV_ModStart> cb -> args [ 0 ] <S2SV_ModEnd> ; struct net <S2SV_ModStart> walk = ( <S2SV_ModEnd> struct xfrm_policy_walk *,0
290,CWE-787,"CWE-787 static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }
","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z,290,"<S2SV_ModStart> > newDataLength || ( <S2SV_ModStart> + x > diffBlock + diffBlockLength && ( <S2SV_ModStart> + y > extraBlock + extraBlockLength ) ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } if ( <S2SV_ModStart> + x > diffBlock + diffBlockLength && ( extraPtr + y > extraBlock + extraBlockLength ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } if ( ( <S2SV_ModStart> + y > extraBlock + extraBlockLength ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } <S2SV_ModStart> + x > diffBlock + diffBlockLength && ( extraPtr + y > extraBlock + extraBlockLength ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; }",0
297,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,297,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
308,CWE-125,"CWE-125 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> offset ) ; } return offset ; }
","<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,308,<S2SV_ModStart> nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> offset ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>,0
315,CWE-20,"CWE-20 struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { <S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> err_code = sctp_process_asconf_param ( asoc , asconf , <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> if ( SCTP_ERROR_NO_ERROR != err_code ) <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
","<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
",torvalds@linux/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,CVE-2014-3673,https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,2014-11-10T11:55Z,315,"<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param, addip, addip_hdr. params ) { if ( param. p -> type == SCTP_PARAM_IPV4_ADDRESS || param. p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart>, asconf, param. addip ) ; if ( err_code!= SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack, param. addip <S2SV_ModEnd> -> crr_id, <S2SV_ModStart> -> crr_id, err_code, param. addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done",1
317,CWE-20,"CWE-20 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
","<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,317,<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo,1
322,CWE-125,"CWE-125 void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) { sycc420_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc422_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc444_to_rgb ( img ) ; } else { fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> }
","<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z,322,<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,1
324,CWE-20,"CWE-20 int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { <S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
","<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,324,"<S2SV_ModStart> REDIS_OK ; } if ( server. replstate == REDIS_REPL_CONNECTED && cmd -> proc!= infoCommand && cmd -> proc!= slaveofCommand ) { addReplyError ( c, ""slave <S2SV_blank> of <S2SV_blank> command <S2SV_blank> is <S2SV_blank> down"" ) ; return REDIS_OK ; }",0
327,CWE-20,"CWE-20 static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) { <S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> { screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launching<S2SV_blank>untrusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; case RESPONSE_MARK_TRUSTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; g_object_unref ( file ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }
","<S2SV_ModStart> ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen <S2SV_ModStart> uri ) ; <S2SV_ModEnd> g_object_unref ( file
",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z,327,"<S2SV_ModStart> ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED, NULL, NULL ) ; nautilus_file_mark_desktop_file_untrusted ( file, parameters -> parent_window, TRUE, NULL, NULL ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen <S2SV_ModStart> uri ) ; <S2SV_ModEnd> g_object_unref ( file",0
335,CWE-416,"CWE-416 mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , ""o"" , & orig ) ; <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , ""@buf"" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , ""@buf"" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }
","<S2SV_ModStart> orig ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart> mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE
",mruby@mruby/b51b21fc63c9805862322551387d9036f2b63433,CVE-2018-10199,https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433,2018-04-18T15:29Z,335,"<S2SV_ModStart> orig ) ; fptr_orig = io_get_open_fptr ( mrb, orig ) ; <S2SV_ModStart> mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE",1
345,CWE-22,"CWE-22 <S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { <S2SV_StartBug> fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ; <S2SV_EndBug> return NULL ; } * name = '\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , ""/"" ) ; } <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do { <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) { <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> x |= * fname ++ & 0x3F ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= * fname ++ & 0x3F ; } else x = '?' ; } if ( x == sep ) x = '/' ; else if ( x == slash ) x = '\\\\' ; else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ; if ( x < 0x80 ) { * p ++ = ( unsigned char ) x ; } else if ( x < 0x800 ) { * p ++ = 0xC0 | ( x >> 6 ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } else { * p ++ = 0xE0 | ( x >> 12 ) ; * p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> } else { do { c = * fname ++ ; if ( c == sep ) c = '/' ; else if ( c == slash ) c = '\\\\' ; else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ; } while ( ( * p ++ = c ) ) ; } return ( char * ) name ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * create_output_name <S2SV_ModStart> * create_output_name ( <S2SV_ModEnd> char * fname <S2SV_ModStart> char * fname ) { char * out , * p <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> while ( * <S2SV_ModStart> * fname == '/' || * fname == '\\\\' <S2SV_ModEnd> ) fname ++ <S2SV_ModStart> fname ++ ; strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } } return out <S2SV_ModEnd> ; } <S2SV_null>
",kyz@libmspack/7cadd489698be117c47efcadd742651594429e6d,CVE-2018-18586,https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d,2018-10-23T02:29Z,345,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> char * create_output_name <S2SV_ModStart> * create_output_name ( <S2SV_ModEnd> char * fname <S2SV_ModStart> * fname, <S2SV_ModEnd> int lower, <S2SV_ModStart> ; if ( lower ) strcpy ( ( char * ) name, ( char * ) dir ) ; else strcpy ( ( char * ) name, ( char * ) fname ) ; <S2SV_ModEnd> p = & <S2SV_ModStart> { if ( ( c = * fname ++ ) < 0x80 ) x = c ; else if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) { x = ( c & 0xC0 ) ; x |= ( c & 0x1F ) << 6 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= ( * fname ++ & 0x3F ) ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= ( * fname ++ & 0x3F ) ; } else if ( x == slash ) x = '\\\\' ; else if",0
346,CWE-416,"CWE-416 PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; <S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>"" ZEND_LONG_FMT ""<S2SV_blank>of<S2SV_blank>%zd<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
","<S2SV_ModStart> classes = NULL ; zval * retval <S2SV_ModStart> ; } } retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY
",php@php-src/b2af4e8868726a040234de113436c6e4f6372d17,CVE-2016-9936,https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17,2017-01-04T20:59Z,346,"<S2SV_ModStart> classes = NULL ; zval * return_value = NULL <S2SV_ModStart> ; } } return_value = var_hash_to_var ( & var_hash ) ; <S2SV_ModStart>! php_var_unserialize_ex ( return_value <S2SV_ModEnd>, & p <S2SV_ModStart> ) ; } <S2SV_ModEnd> if (! <S2SV_ModStart> RETURN_FALSE ; } <S2SV_ModEnd> if (! <S2SV_ModStart> RETURN_FALSE ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",0
348,CWE-125,"CWE-125 GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }
","<S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; tmp_str =
",gpac@gpac/8e05648d6b4459facbc783025c5c42d301fef5c3,CVE-2020-23928,https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3,2021-04-21T18:15Z,348,<S2SV_ModStart> return GF_ISOM_INVALID_FILE ; if ( ( <S2SV_ModStart> ) ptr -> size < tmp_strsize ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) tmp_strsize - 8 ; if (! tmp_strsize ) return GF_OUT_OF_MEM ;,0
353,CWE-125,"CWE-125 static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z,353,"<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw, maxh <S2SV_ModStart> maxh, max, offset, upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t ) img -> comps [ 0 ]. w ; maxh = ( size_t ) img -> comps [ 0 ]. h ; max = maxw * maxh ; y = img -> comps [ 0 ]. data ; cb = img -> comps [ 1 ]. data ; cr = img -> comps [ 2 ]. data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; <S2SV_ModEnd> for ( i <S2SV_ModStart> i ) { size_t j ; for ( j = 0U ; j < maxw ; ++ j ) { sycc_to_rgb ( offset, upb, * y, * cb, * cr, r, g, b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < maxh ) { sycc_to_rgb ( offset, upb",0
357,CWE-416,"CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
",ImageMagick@ImageMagick/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,CVE-2016-10051,https://github.com/ImageMagick/ImageMagick/commit/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,2017-03-23T17:59Z,357,"<S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart>, file )!= c ) break",0
364,CWE-125,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,364,"<S2SV_ModStart> } isoclns_print ( ndo <S2SV_ModEnd>, p +",0
375,CWE-20,"CWE-20 error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ; tja1100WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,375,"<S2SV_ModStart> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; tja1100WritePhyReg ( interface, TJA1100_CONFIG1, value ) ; value = tja1100ReadPhyReg ( interface, TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP_LOW ; tja1100WritePhyReg ( interface, TJA1100_CONFIG1, value ) ; value |= TJA1100_CONFIG1_AUTO_OP_HIGH ; tja1100WritePhyReg ( interface, TJA1100_CONFIG1, value ) ; value = tja1100ReadPhyReg ( interface, TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP_LOW ; tja1100WritePhyReg ( interface, TJA1100_CONFIG1, value ) ; value = tja1100ReadPhyReg ( interface, TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP_HIGH ;",0
377,CWE-125,"CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z,377,<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT,1
381,CWE-20,"CWE-20 static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
","<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,381,<S2SV_ModStart> = nlogs ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; },0
385,CWE-20,"CWE-20 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
","<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,385,<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0,1
388,CWE-125,"CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,388,"<S2SV_ModStart> bp, len ) ; break ; case ETHERTYPE_TEB : ND_TCHECK_8BITS ( bp ) ;",0
394,CWE-125,"CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
","<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
",radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z,394,<S2SV_ModStart> : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x16 : case <S2SV_ModStart> : case 0x1e : case 0x1f : case 0x8a : case 0x8b : case 0x8c : case 0x8f :,0
396,CWE-20,"CWE-20 error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { connection -> request . version = HTTP_VERSION_1_1 ; connection -> request . keepAlive = TRUE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }
","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,396,"<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token,",1
397,CWE-125,"CWE-125 int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL ) <S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , ""Can\'t<S2SV_blank>create<S2SV_blank>file<S2SV_blank>%s"" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , ""<S2SV_blank>Writing<S2SV_blank>output<S2SV_blank>to<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; fprintf ( stdout , ""<S2SV_blank>-><S2SV_blank>Script<S2SV_blank>encoded<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>instructions.\\n\\n"" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }
","<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
",LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z,397,<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID,1
398,CWE-125,"CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/e01c9bf76740802025c9328901b55ee4a0c49ed6,CVE-2018-14880,https://github.com/the-tcpdump-group/tcpdump/commit/e01c9bf76740802025c9328901b55ee4a0c49ed6,2019-10-03T16:15Z,398,<S2SV_ModStart> goto trunc ; ND_TCHECK_32BITS ( & lshp -> ls_length ) ;,0
400,CWE-125,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> offset += tim . length - 3 ; <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> , p + offset + 3 , <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ) ; offset += <S2SV_ModEnd> tim . length <S2SV_ModStart> length - 3 ; length -= <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ; <S2SV_ModEnd> if ( !
",the-tcpdump-group@tcpdump/99798bd9a41bd3d03fdc1e949810a38967f20ed3,CVE-2017-12987,https://github.com/the-tcpdump-group/tcpdump/commit/99798bd9a41bd3d03fdc1e949810a38967f20ed3,2017-09-14T06:29Z,400,"<S2SV_ModStart> ; if (! ND_TTEST2 ( * p + offset, 0 ) ) return 0 ; if ( <S2SV_ModStart> ; if (! ND_TTEST2 ( * p + offset + 4, 0 ) ) return 0 ; if ( <S2SV_ModStart> ; if (! ND_TTEST2 ( * p + offset + 5, 0 ) ) return 0 ; if ( <S2SV_ModStart> ; if (! ND_TTEST2 ( * p + offset + 6, 0 ) ) return 0 ; if ( <S2SV_ModStart> ; if (! ND_TTEST2 ( * p + offset + 4, 0 ) ) return 0 ; if ( <S2SV_ModStart> ; if (! ND_TTEST2 ( * p + offset + 5, 0 ) ) return 0 ; if (! ND_TTEST2 ( * p + offset + 6, 0 ) ) return 0 ; if (! ND_TTEST2 ( * p + offset + 7, 0 ) ) return 0 ; if ( pbody -> tim = tim ; if (! ND_TTEST2 ( * p + offset + 5, 0 ) ) return 0 ; if (! ND_TTEST2 ( * p + offset + 6, 0",0
401,CWE-416,"CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z,401,"<S2SV_ModStart> } else { if (! <S2SV_ModStart>, ibuf ) ) { if ( ret ) break ; ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf -> flags",0
405,CWE-20,"CWE-20 stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""<S2SV_blank>with<S2SV_blank>policy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>\\""%s\\""<S2SV_blank>forbids<S2SV_blank>connection"" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( ""found<S2SV_blank>connection:<S2SV_blank>%s\\n"" , c ? c -> name : ""<none>"" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( ""received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it"" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( ""dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet"" , blob ) ; DBG_dump ( ""dcookie<S2SV_blank>computed"" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( ""mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one"" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( ""dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one"" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie"" ) ; DBG_log ( ""send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state"" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie"" ) ) ; } { struct ikev2_ke * ke ; <S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ; <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , ""ikev2_inI1outR1<S2SV_blank>KE"" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , ""system<S2SV_blank>too<S2SV_blank>busy"" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }
","<S2SV_ModStart> * ke ; <S2SV_ModEnd> char fromname [ <S2SV_ModStart> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname <S2SV_ModStart> ) ; return STF_FAIL +
",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z,405,"<S2SV_ModStart> ""initial <S2SV_blank> parent <S2SV_blank> SA <S2SV_blank> message <S2SV_blank> received <S2SV_blank> on <S2SV_blank> %s:%u"" ""but <S2SV_blank> no <S2SV_blank> connection <S2SV_blank> has <S2SV_blank> been <S2SV_blank> authorized"", ip_str ( & md -> iface -> ip_addr ), ntohs ( portof ( & md -> iface -> ip_addr ) ), <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> sender_port ) ) ; } else if ( addrinsubnet ( & md -> sender, & d -> spd. that. client ) && ( c == NULL ||! subnetinsubnet ( & c -> spd. that. client, & d -> spd. that. client ) ) { loglog ( RC_LOG_SERIOUS, ""initial <S2SV_blank> parent <S2SV_blank> SA <S2SV_blank> message <S2SV_blank> received <S2SV_blank> on <S2SV_blank> %s:%u"", ip_str ( & md -> iface -> ip_addr ), ntohs ( portof ( & md -> iface -> ip_addr ) ), ( policy!= LEMPTY )? "" <S2SV_blank> with <S2SV_blank> policy="" : """", ( policy!= LEMPTY )? bitnamesof ( sa_policy_bit_names, policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL <S2SV_ModEnd>",0
406,CWE-787,"CWE-787 <S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> { <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> if ( context -> ChromaSubsamplingLevel ) { <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> , rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if ( ! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,406,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if (! context ) return FALSE ; if (! <S2SV_ModStart>, rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if (! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",0
409,CWE-125,"CWE-125 static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
","<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
",ImageMagick@ImageMagick/5f16640725b1225e6337c62526e6577f0f88edb8,CVE-2016-7525,https://github.com/ImageMagick/ImageMagick/commit/5f16640725b1225e6337c62526e6577f0f88edb8,2017-04-20T18:59Z,409,<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image ),1
413,CWE-125,"CWE-125 static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
","<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,413,"<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t, 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t, 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t, 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t, 1 ) <S2SV_ModEnd> << rpy )",0
414,CWE-416,"CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }
","<S2SV_ModStart> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else
",kkos@oniguruma/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,CVE-2019-13224,https://github.com/kkos/oniguruma/commit/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,2019-07-10T14:15Z,414,<S2SV_ModStart> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else,1
415,CWE-787,"CWE-787 <S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> ExceptionInfo * exception ) { <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> Quantum index ; index = 0 ; <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> break ; } case 2 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( Image <S2SV_ModStart> image , ssize_t bpp <S2SV_ModEnd> , unsigned char <S2SV_ModStart> exception ) { int bit ; Quantum index <S2SV_ModEnd> ; register Quantum <S2SV_ModStart> ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> ; switch ( bpp <S2SV_ModEnd> ) { case <S2SV_ModStart> 1 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> bit < ( ssize_t ) ( <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ++ ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 2 : { for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> * p >> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ( * p ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> ( image ) <S2SV_ModEnd> ; } if <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> image ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 8 : { for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x <S2SV_ModStart> ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> , exception ) <S2SV_ModStart> , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",ImageMagick@ImageMagick/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,CVE-2018-16642,https://github.com/ImageMagick/ImageMagick/commit/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,2018-09-06T22:29Z,415,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( Image <S2SV_ModStart> exception ) { MagickBooleanType <S2SV_ModEnd> bit ; ssize_t <S2SV_ModStart> x ; register <S2SV_ModEnd> Quantum * q <S2SV_ModStart> index = 0 <S2SV_ModEnd> ; switch ( <S2SV_ModStart> : { q = QueueAuthenticPixels ( image, 0, y, image -> columns, 1, exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { index = ( Quantum ) ( ( ( * p ) & 0x80 )? 0x01 : 0x00 ) ; SetPixel ( image, index, q ) ; <S2SV_ModStart> bit ++ ) { index = ( Quantum ) ( ( ( * p ) & 0x80 )? 0x01 : 0x00 ) ; SetPixel ( image, index, q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> % 8 )!= 0 ) { index = ( Quantum ) ( ( ( ( * p ) & 0x80 )? 0x01 : 0x00 ) ; SetPixel ( image, index, q ) ;",0
416,CWE-125,"CWE-125 static int cfm_network_addr_print ( netdissect_options * ndo , <S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> { u_int network_addr_type ; <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> network_addr_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown"" , network_addr_type ) , network_addr_type ) ) ; switch ( network_addr_type ) { case AFNUM_INET : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; case AFNUM_INET6 : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }
","<S2SV_ModStart> u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; }
",the-tcpdump-group@tcpdump/5d340a5ca6e420a70297cdbdf777333f18bfdab7,CVE-2017-13052,https://github.com/the-tcpdump-group/tcpdump/commit/5d340a5ca6e420a70297cdbdf777333f18bfdab7,2017-09-14T06:29Z,416,"<S2SV_ModStart> u_char * tptr, u_int length <S2SV_ModStart> network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> address <S2SV_blank> length)"" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv4 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv6 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv4 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv6 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; }",0
423,CWE-125,"CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = ""?"" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp"" : ""tcp"" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , ""]"" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp6"" : ""tcp6"" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = ""unix"" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , ""<AF<S2SV_blank>%d>"" , af ) ; } if ( port ) { sprintf ( addr , ""%s:%s:%u"" , protoname , addr_text , port ) ; } else { sprintf ( addr , ""%s:%s"" , protoname , addr_text ) ; } }
","<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'
",memcached@memcached/554b56687a19300a75ec24184746b5512580c819,CVE-2019-15026,https://github.com/memcached/memcached/commit/554b56687a19300a75ec24184746b5512580c819,2019-08-30T15:15Z,423,"<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( pathlen >= MAXPATHLEN ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text, ( ( struct sockaddr_un * ) sock_addr ) -> sun_path, pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'",0
427,CWE-20,"CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
","<S2SV_ModStart> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; }
",ntp-project@ntp/52e977d79a0c4ace997e5c74af429844da2f27be,CVE-2015-5195,https://github.com/ntp-project/ntp/commit/52e977d79a0c4ace997e5c74af429844da2f27be,2017-07-21T14:29Z,427,<S2SV_ModStart> filegen_string ) ; NTP_ASSERT ( filegen!= NULL ) ; <S2SV_ModStart> filegen_file ) ; NTP_ASSERT ( filegen!= NULL ) ;,0
433,CWE-416,"CWE-416 struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; <S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,433,"<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt, 1 ) ;",1
440,CWE-20,"CWE-20 static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( ""AirPDcapScanForKeys"" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>EAPOL-Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; <S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; if ( pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 1 ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_REQ_DATA ; } if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; # ifdef _DEBUG g_snprintf ( msgbuf , MSGBUF_LEN , ""ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\t"" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""SA<S2SV_blank>not<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_5 ) ; return AIRPDCAP_RET_REQ_DATA ; } sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sta_sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; } else { memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; } sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( sa -> validKey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } else { AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; sa -> validKey = FALSE ; } } if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == AIRPDCAP_RET_SUCCESS ) { AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; } AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
","<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
",wireshark@wireshark/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,CVE-2016-5351,https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,2016-08-07T16:59Z,440,"<S2SV_ModStart> if ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"", ""Malformed <S2SV_blank> EAPOL-Key"", AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_INVALID_HANDSHAKE ; } if ( <S2SV_ModStart> 2 ) ; if ( bodyLength > sizeof ( EAPOL_RSN_KEY ) ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"", ""Malformed <S2SV_blank> EAPOL-Key"", AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_INVALID_HANDSHAKE ; }",0
442,CWE-125,"CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>attr:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>EOF"" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>from:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>to:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>file<S2SV_blank>POST:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>dir:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z,442,"<S2SV_ModStart>! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo, ""%s"", tok2str ( nfsproc_str, ""proc-%u"", proc ) ) ) ; } <S2SV_ModEnd> if ( er <S2SV_ModStart> er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo, ""%s"", tok2str ( nfsproc_str, ""dattr-%u"", dp [ 1 ] ) ) ; ND_PRINT ( ( ndo, ""%s"", tok2str ( nfsproc_str, ""dattr-%u"", tok2str ( nfsproc_str, ""dattr-%u"", proc ) ) ) ; } <S2SV_ModEnd> if ( er <S2SV_ModStart> er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo, ""%s"", tok2str ( nfsproc_str, ""dattr-%u"", dp [ 0 ] ) ) ; ND_PRINT ( ( ndo, ""%s"", tok2str ( nfsproc_str, ""dattr",0
451,CWE-20,"CWE-20 void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; <S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,451,"<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token, <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token,",1
455,CWE-125,"CWE-125 mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }
","<S2SV_ModStart> asdl_seq * body , asdl_seq * type_ignores <S2SV_ModStart> = body ; p -> v . Module . type_ignores = type_ignores ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,455,"<S2SV_ModStart> asdl_seq * body <S2SV_ModEnd>, PyArena * <S2SV_ModStart> ; return p <S2SV_ModEnd> ; } <S2SV_null>",0
464,CWE-20,"CWE-20 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ret = - ENOKEY ; goto error2 ; } ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
","<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,464,<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission,1
465,CWE-125,"CWE-125 int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> hlen += 1 ; hlen += 1 ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( - 1 ) ; }
","<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> & 0xf0 ) { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( mh -> <S2SV_ModStart> [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ;
",the-tcpdump-group@tcpdump/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,CVE-2017-13009,https://github.com/the-tcpdump-group/tcpdump/commit/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,2017-09-14T06:29Z,465,<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 8 ; ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ],0
467,CWE-125,"CWE-125 struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ; <S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ; <S2SV_StartBug> } * note ; <S2SV_EndBug> UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ; <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ; <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> hmi_data += 4 ; hmi_track_offset [ i ] += 4 ; <S2SV_StartBug> } <S2SV_EndBug> hmi_data += 4 ; hmi_track_offset [ i ] += 4 ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ; <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ; <S2SV_StartBug> } <S2SV_EndBug> } if ( * hmi_data > 0x7f ) { do { <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> } while ( * hmi_data > 0x7F ) ; } <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }
","<S2SV_ModStart> = hmi_data ; uint32_t data_siz ; <S2SV_ModStart> } * note <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> += hmi_tmp ; hmi_tmp += 4 ; <S2SV_ModStart> += 4 ; hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> hmi_mdi , hmi_data , data_siz <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; <S2SV_ModStart> ; if ( data_siz && <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> > 0x7F ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> * hmi_data > <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; hmi_data ++ ; data_siz --
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z,467,"<S2SV_ModStart> = hmi_data ; if ( hmi_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> to <S2SV_blank> parse\\n"" ) ; return NULL ; } <S2SV_ModStart> channel ; } if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> to <S2SV_blank> parse\\n"" ) ; return NULL ; } <S2SV_ModStart> += hmi_tmp ; if ( hmi_tmp > hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> to <S2SV_blank> parse\\n"" ) ; return NULL ; } <S2SV_ModStart> += hmi_tmp ; if ( hmi_tmp > hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> to <S2SV_blank> parse\\n",0
482,CWE-20,"CWE-20 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }
","<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z,482,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int isofs_read_inode (,0
484,CWE-125,"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\n\\t%s<S2SV_blank>(%u)"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type:<S2SV_blank>%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; <S2SV_StartBug> if ( netal == 0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ; <S2SV_EndBug> else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>opts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(bad<S2SV_blank>length)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; pptr += opli ; } trunc : return ; }
","<S2SV_ModStart> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> 0 ) ND_PRINT <S2SV_ModStart> ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , <S2SV_ModEnd> isonsap_string ( ndo
",the-tcpdump-group@tcpdump/c177cb3800a9a68d79b2812f0ffcb9479abd6eb8,CVE-2017-13016,https://github.com/the-tcpdump-group/tcpdump/commit/c177cb3800a9a68d79b2812f0ffcb9479abd6eb8,2017-09-14T06:29Z,484,"<S2SV_ModStart> ndo_snapend ) { ND_TCHECK ( * optr ) ; while ( * optr == NLPID_ESIS ) { ND_TCHECK ( * optr ) ; optr ++ ; } if ( <S2SV_ModStart> ndo_snapend ) { ND_TCHECK ( * optr ) ; while ( * optr == NLPID_ESIS ) { ND_TCHECK ( * optr ) ; optr ++ ; } if ( * optr!= NLPID_ESIS ) { ND_TCHECK ( * optr ) ; if ( * optr!= NLPID_SNAP ) ND_PRINT ( ( ndo, "" <S2SV_blank> SNAP <S2SV_blank> packet <S2SV_blank> not <S2SV_blank> supported"" ) ) ; break ; } ND_TCHECK ( * optr ) ; while ( * optr == NLPID_SNAP ) ND_TCHECK ( * optr ++ ) ; if ( * optr!= NLPID_ESIS ) { ND_TCHECK ( * optr ++ ) ; if ( * optr!= NLPID_SNAP ) ND_PRINT ( ( ndo, "" <S2SV_blank> SNAP <S2SV_blank> packet",0
485,CWE-20,"CWE-20 void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,485,"<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd>, "" <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> K"", <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd>, "" <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> K"", <S2SV_ModStart> } else { sendClean ( outputbuffer ) ; }",0
488,CWE-125,"CWE-125 static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
","<S2SV_ModStart> self ) { PyObject_GC_UnTrack ( self ) ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,488,<S2SV_ModStart> self ) { if ( self -> dict ) Py_CLEAR ( self -> dict ) ;,0
490,CWE-20,"CWE-20 int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; <S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> if ( r ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data ,
",torvalds@linux/fa3d315a4ce2c0891cdde262562e710d95fba19e,CVE-2013-1943,https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e,2013-07-16T14:08Z,490,"<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data,",1
492,CWE-416,"CWE-416 static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>USB<S2SV_blank>console<S2SV_blank>port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <S2SV_StartBug> usb_autopm_put_interface ( serial -> interface ) ; <S2SV_EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
","<S2SV_ModStart> = 0 ; info -> port = NULL ;
",torvalds@linux/299d7572e46f98534033a9e65973f13ad1ce9047,CVE-2017-16525,https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047,2017-11-04T01:29Z,492,<S2SV_ModStart> = 0 ; info -> port = NULL ;,1
500,CWE-125,"CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
","<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z,500,<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size ),1
503,CWE-20,"CWE-20 int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> m -> msg_name = address ; <S2SV_EndBug> } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }
","<S2SV_ModStart> err ; } if ( m -> msg_name )
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,503,<S2SV_ModStart> err ; } if ( m -> msg_name ),1
504,CWE-125,"CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> type_ignore_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( type_ignores , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( argtypes , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; <S2SV_EndBug> return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; <S2SV_EndBug> return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { type_ignore_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,504,"<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_body, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""body\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""body\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } tmp = _PyObject_GetAttrId ( obj, & PyId_type_ignores ) ; if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""type_ignores\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } if ( lookup_attr_id ( obj, & PyId_type_ignores, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""type_ignores\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } if ( tmp == NULL ) { Py",0
511,CWE-20,"CWE-20 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; <S2SV_StartBug> int copied , err ; <S2SV_EndBug> struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } aux . tp_padding = 0 ; put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
","<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,511,"<S2SV_ModStart> copied, err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } copied += skb -> len ; err = skb_copy_datagram_iovec ( skb, 0, copied, msg -> msg_iov, copied ) ; if ( err ) goto out_free ;",0
515,CWE-20,"CWE-20 static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; <S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; <S2SV_StartBug> } else <S2SV_EndBug> err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }
","<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,515,"<S2SV_ModStart> ( msg ) ; msg_sys -> msg_name = NULL ; <S2SV_ModStart>, & addr, msg_sys -> msg_flags <S2SV_ModStart>, & addr, msg_sys -> msg_control <S2SV_ModStart> msg_flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; if ( msg_sys -> msg_flags & MSG_CMSG_COMPAT ) msg_sys -> msg_flags |= MSG_CMSG_COMPAT ; else if ( msg_sys -> msg_flags & MSG_CMSG_COMPAT ) msg_sys -> msg_flags &= ~ MSG_CMSG_COMPAT ;",0
518,CWE-787,"CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
","<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,518,<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if (! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if (! rc ) return FALSE ; },1
528,CWE-20,"CWE-20 bool_t ksz8851IrqHandler ( NetInterface * interface ) { bool_t flag ; size_t n ; uint16_t ier ; uint16_t isr ; flag = FALSE ; <S2SV_StartBug> ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> if ( ( isr & ISR_LCIS ) != 0 ) { <S2SV_StartBug> ier &= ~ IER_LCIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( isr & ISR_TXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } } <S2SV_StartBug> if ( ( isr & ISR_RXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ier &= ~ IER_RXIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ; <S2SV_EndBug> return flag ; }
","<S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> ) ; ksz8851WriteReg <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_LCIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( isr & KSZ8851_ISR_TXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( isr & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_RXIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , ier )
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,528,"<S2SV_ModStart> = FALSE ; if ( interface -> nicEvent ) return flag ; <S2SV_ModStart> ( interface, KSZ8851_IER, KSZ8851_IER_LCIE <S2SV_ModEnd> ) ; isr <S2SV_ModStart> ( interface, KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> )!= 0 <S2SV_ModStart> { ier |= KSZ8851_IER_LCIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> } if ( ( isr & KSZ8851_ISR_TXIS <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_ISR, KSZ8851_ISR_TXIS <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface, KSZ8851_TXMIR ) & TXMIR_TXMA_MASK ; if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } } if ( ( isr & KSZ8851_ISR_RXIS <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_ISR, KSZ8851_ISR_RXIS ) ; if ( n >= (",0
534,CWE-416,"CWE-416 static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) <S2SV_StartBug> { <S2SV_EndBug> if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; } <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> timerfd_remove_cancel ( ctx ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> } } else { __timerfd_remove_cancel <S2SV_ModEnd> ( ctx ) <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;
",torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6,CVE-2017-10661,https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6,2017-08-19T18:29Z,534,<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;,0
536,CWE-20,"CWE-20 static int tomoyo_mount_acl ( struct tomoyo_request_info * r , char * dev_name , struct path * dir , char * type , unsigned long flags ) { struct path path ; struct file_system_type * fstype = NULL ; const char * requested_type = NULL ; const char * requested_dir_name = NULL ; const char * requested_dev_name = NULL ; struct tomoyo_path_info rtype ; struct tomoyo_path_info rdev ; struct tomoyo_path_info rdir ; int need_dev = 0 ; int error = - ENOMEM ; requested_type = tomoyo_encode ( type ) ; if ( ! requested_type ) goto out ; rtype . name = requested_type ; tomoyo_fill_path_info ( & rtype ) ; requested_dir_name = tomoyo_realpath_from_path ( dir ) ; if ( ! requested_dir_name ) { error = - ENOMEM ; goto out ; } rdir . name = requested_dir_name ; tomoyo_fill_path_info ( & rdir ) ; if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) ) { need_dev = - 1 ; } else { fstype = get_fs_type ( type ) ; if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { <S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; path_put ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else { if ( ! dev_name ) dev_name = ""<NULL>"" ; requested_dev_name = tomoyo_encode ( dev_name ) ; if ( ! requested_dev_name ) { error = - ENOMEM ; goto out ; } } rdev . name = requested_dev_name ; tomoyo_fill_path_info ( & rdev ) ; r -> param_type = TOMOYO_TYPE_MOUNT_ACL ; r -> param . mount . need_dev = need_dev ; r -> param . mount . dev = & rdev ; r -> param . mount . dir = & rdir ; r -> param . mount . type = & rtype ; r -> param . mount . flags = flags ; do { tomoyo_check_acl ( r , tomoyo_check_mount_acl ) ; error = tomoyo_audit_mount_log ( r ) ; } while ( error == TOMOYO_RETRY_REQUEST ) ; out : kfree ( requested_dev_name ) ; kfree ( requested_dir_name ) ; if ( fstype ) put_filesystem ( fstype ) ; kfree ( requested_type ) ; return error ; }
","<S2SV_ModStart> { if ( ! dev_name ||
",torvalds@linux/4e78c724d47e2342aa8fde61f6b8536f662f795f,CVE-2011-2518,https://github.com/torvalds/linux/commit/4e78c724d47e2342aa8fde61f6b8536f662f795f,2012-05-24T23:55Z,536,<S2SV_ModStart> { if (! dev_name ||,1
537,CWE-125,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,537,"<S2SV_ModStart> } isoclns_print ( ndo <S2SV_ModEnd>, p +",0
538,CWE-125,"CWE-125 int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; <S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) { <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> if ( buf ) <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> space_rem , buf_size ) ; <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }
","<S2SV_ModStart> controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus
",stoth68000@media-tree/354dd3924a2e43806774953de536257548b5002c,CVE-2017-8831,https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c,2017-05-08T06:29Z,538,"<S2SV_ModStart> ) ) ; memcpy ( msg, & msg_tmp, sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem, buf_size ) ; } else { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + space_rem, buf_size ) ; } }",0
543,CWE-20,"CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;
",git@git/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,CVE-2018-17456,https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,2018-10-06T14:29Z,543,"<S2SV_ModStart> name ) ; if (! strcmp ( key, ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options, data -> obj, FSCK_MSG_GITMODULES_URL, ""disallowed <S2SV_blank> submodule <S2SV_blank> url: <S2SV_blank> %s"", value ) ;",1
562,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; } <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> out += len ; left -= len ; } else { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out , UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; } <S2SV_null>
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,562,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out, UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) { return FALSE ; } <S2SV_ModStart> 4 ; } if ( outSize < len ) { return FALSE ; } <S2SV_ModStart> } else { if ( outSize < 1 ) { return FALSE ; }",0
564,CWE-125,"CWE-125 static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { <S2SV_StartBug> const char * literal_start = * str ; <S2SV_EndBug> const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; <S2SV_StartBug> for ( ; * str < end ; ( * str ) ++ ) { <S2SV_EndBug> char ch = * * str ; <S2SV_StartBug> if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && <S2SV_EndBug> * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { <S2SV_StartBug> in_named_escape = 0 ; <S2SV_EndBug> } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { <S2SV_StartBug> if ( * str + 1 < end && * ( * str + 1 ) == ch ) { <S2SV_EndBug> literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { <S2SV_StartBug> ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ; <S2SV_EndBug> return - 1 ; } } <S2SV_StartBug> break ; <S2SV_EndBug> } } <S2SV_StartBug> literal_end = * str ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str <= end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str == end || * * str == '{' || * * str == '}' ) ; <S2SV_EndBug> done : <S2SV_StartBug> if ( literal_start != literal_end ) { <S2SV_EndBug> if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , <S2SV_StartBug> literal_end - literal_start , <S2SV_EndBug> NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , <S2SV_StartBug> literal_end - literal_start ) ; <S2SV_EndBug> if ( ! * literal ) return - 1 ; } return result ; }
","<S2SV_ModStart> const char * s = * str ; const char * literal_start = s <S2SV_ModEnd> ; int result <S2SV_ModStart> NULL ) ; while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> '}' ) { <S2SV_ModStart> '}' ) { } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> if ( ch <S2SV_ModStart> { if ( s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> ; result = <S2SV_ModStart> '}' ) { * str = s - 1 ; <S2SV_ModStart> ; } } s -- ; <S2SV_ModStart> ; } } * str = s <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> <= end ) <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> == end || <S2SV_ModStart> end || * s <S2SV_ModEnd> == '{' || <S2SV_ModStart> '{' || * s <S2SV_ModEnd> == '}' ) <S2SV_ModStart> ( literal_start != s <S2SV_ModEnd> ) { if <S2SV_ModStart> ( literal_start , s <S2SV_ModEnd> - literal_start , <S2SV_ModStart> , literal_start , s <S2SV_ModEnd> - literal_start )
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,564,<S2SV_ModStart> ) { const <S2SV_ModEnd> char * literal_start <S2SV_ModStart> = 0 ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if ( <S2SV_ModEnd> * str < <S2SV_ModStart> str < end && * ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 0 ; } else if ( ch == '{' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_,0
570,CWE-125,"CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; ( void ) count ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if (
",ImageMagick@ImageMagick/7afcf9f71043df15508e46f079387bd4689a738d,CVE-2016-7101,https://github.com/ImageMagick/ImageMagick/commit/7afcf9f71043df15508e46f079387bd4689a738d,2017-01-18T17:59Z,570,"<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info. name ) ; if ( count!= sizeof ( iris_info. name ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> filler ) ; if ( count!= sizeof ( iris_info. filler ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> filler ) ; if ( count!= sizeof ( iris_info. filler ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModEnd> ) ; image",0
572,CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,572,"<S2SV_ModStart> u_char * dat, u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; }",1
576,CWE-125,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> ) ) ; }
",uclouvain@openjpeg/c16bc057ba3f125051c9966cf1f5b68a05681de4,CVE-2016-7163,https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4,2016-09-21T14:25Z,576,<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l,0
580,CWE-416,"CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
","<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z,580,"<S2SV_ModStart> 1 ) ; if (! <S2SV_ModStart>, ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe",1
581,CWE-20,"CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,581,"<S2SV_ModStart> ), & _dh <S2SV_ModEnd> ) ; BUG_ON",1
587,CWE-20,"CWE-20 static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; <S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
","<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
",torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z,587,<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;,1
593,CWE-20,"CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed"" ""<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device."" , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> * findalldevs_if ; uint32 replylen ; <S2SV_ModStart> 0 ; } replylen = 0 ; <S2SV_ModStart> -> description ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> -> name ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> name ) ; replylen <S2SV_ModEnd> += sizeof ( <S2SV_ModStart> : # endif replylen <S2SV_ModEnd> += ( sizeof <S2SV_ModStart> , nif , replylen <S2SV_ModEnd> ) ; for
",the-tcpdump-group@libpcap/617b12c0339db4891d117b661982126c495439ea,CVE-2019-15161,https://github.com/the-tcpdump-group/libpcap/commit/617b12c0339db4891d117b661982126c495439ea,2019-10-03T19:15Z,593,"<S2SV_ModStart> uint16 nif = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } if ( plen < sizeof ( struct rpcap_findalldevs_if ) ) { return - 1 ; } <S2SV_ModStart> -> description ) { if ( strlen ( d -> description ) > plen ) { rpcapd_discard ( pars -> sockctrl, plen ) ; return - 1 ; } <S2SV_ModStart> -> name ) { if ( strlen ( d -> name ) > plen ) { return - 1 ; } <S2SV_ModStart> -> description ) { if ( strlen ( d -> name ) > plen ) { rpcapd_discard ( pars -> sockctrl, plen ) ; return - 1 ; } nif ++ ; } if ( d -> name ) { if ( strlen ( d -> name ) > plen ) { rpcapd_discard ( pars -> sockctrl, plen ) ; return - 1 ; } <S2SV_ModStart> -> name ) { if ( strlen ( d -> name ) > plen ) { return - 1 ; } <S2SV_ModStart> -> addresses ) { if ( address -> addr -> sa_family!= AF_INET ) { rpcapd_discard ( pars -> sockctrl, plen ) ; return - 1 ; }",0
595,CWE-787,"CWE-787 static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b6ae2f9e0ab13343c0281732d479757a8e8979c7,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7,2017-04-20T18:59Z,595,"<S2SV_ModStart> -> columns - 3 <S2SV_ModEnd> ) ; x <S2SV_ModStart> % 2 ; bit < ( ssize_t ) <S2SV_ModEnd> ( image -> <S2SV_ModStart> % 2 ; bit ++ ) { index = ( ( * p ) & 0x3 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; p ++ ; } if ( ( image -> columns % 4 )!= 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 4 ) ; bit ++ ) { index = ( ( * p ) & 0x80 >> bit )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 4 )!= 0 ) { for ( x = 0 ; x < ( ( ssize_t ) ( image -> columns % 4 ) ; bit ++ ) { index = ( ( * p ) & 0x80 >> bit )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; p ++ ;",0
597,CWE-125,"CWE-125 static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> int tstype ) <S2SV_EndBug> { struct sock_exterr_skb * serr ; <S2SV_StartBug> int err ; <S2SV_EndBug> serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
","<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,597,"<S2SV_ModStart>, int tstype, bool opt_id <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_id = opt_id ; if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee. ee_data = skb_shinfo ( skb ) -> opt_id ; } else if ( opt_id && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee. ee_data = skb_shinfo ( skb ) -> opt_id ; } err = sock_queue_err_skb ( sk, skb ) ; if ( err ) { kfree_skb ( skb ) ; return ; }",0
599,CWE-125,"CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u,<S2SV_blank>%s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "",<S2SV_blank>(ttl<S2SV_blank>%u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>authtype<S2SV_blank>%s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>auth<S2SV_blank>\\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
","<S2SV_ModStart> 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> ) ) ; }
",the-tcpdump-group@tcpdump/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,CVE-2018-14463,https://github.com/the-tcpdump-group/tcpdump/commit/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,2019-10-03T16:15Z,599,"<S2SV_ModStart> = len ; ND_TCHECK2 ( bp [ 0 ], len ) ;",0
608,CWE-416,"CWE-416 static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
",torvalds@linux/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,CVE-2017-16528,https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,2017-11-04T01:29Z,608,<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;,1
619,CWE-125,"CWE-125 size_t compile_tree ( struct filter_op * * fop ) { int i = 1 ; struct filter_op * array = NULL ; struct unfold_elm * ue ; <S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ; fflush ( stdout ) ; unfold_blk ( & tree_root ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; labels_to_offsets ( ) ; TAILQ_FOREACH ( ue , & unfolded_tree , next ) { if ( ue -> label == 0 ) { SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ; i ++ ; } } SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; array [ i - 1 ] . opcode = FOP_EXIT ; * fop = array ; return ( i ) ; }
","<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0
",LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z,619,<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0,1
622,CWE-125,"CWE-125 void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { <S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ( dp [ 4 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) ) )
",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z,622,"<S2SV_ModStart> return ; } if ( EXTRACT_32BITS ( & rp -> rm_call. cb_vers ) == NFS_VER3 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_str, ""vers-%u"", EXTRACT_32BITS ( & rp -> rm_call. cb_vers ) ) ) ; } else if ( EXTRACT_32BITS ( & rp -> rm_call. cb_proc ) == NFSPROC_GETATTR ) { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_str, ""proc-%u"", proc ) ) ) ; } else if ( EXTRACT_32BITS ( & rp -> rm_call. cb_vers ) == NFS_VER3 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_str, ""vers-%u"", EXTRACT_32BITS ( & rp -> rm_call. cb_proc ) ) ) ; } else { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( n",0
623,CWE-125,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; <S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> while ( len > 0 ) { <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> return ; } <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z,623,<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;,0
626,CWE-125,"CWE-125 void rpki_rtr_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { <S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> const u_char * tptr ; const rpki_rtr_pdu * pdu_header ; tptr = pptr ; tlen = len ; if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>RPKI-RTR"" ) ) ; return ; } <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; pdu_header = ( const rpki_rtr_pdu * ) tptr ; pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; ND_TCHECK2 ( * tptr , pdu_len ) ; if ( ! pdu_type || ! pdu_len ) { break ; } if ( tlen < pdu_len ) { goto trunc ; } <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> goto trunc ; tlen -= pdu_len ; <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> } <S2SV_StartBug> return ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; }
","<S2SV_ModStart> len ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo , pptr , len , 1 <S2SV_ModEnd> , 8 ) <S2SV_ModStart> , 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",the-tcpdump-group@tcpdump/83c64fce3a5226b080e535f5131a8a318f30e79b,CVE-2017-13050,https://github.com/the-tcpdump-group/tcpdump/commit/83c64fce3a5226b080e535f5131a8a318f30e79b,2017-09-14T06:29Z,626,"<S2SV_ModStart> len ) { <S2SV_ModEnd> if (! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo, pptr, len, 1 <S2SV_ModEnd>, 8 ) <S2SV_ModStart>, 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",1
630,CWE-352,"CWE-352 static void _send ( Socket_T S , const char * request , StringBuffer_T data ) { _argument ( data , ""format"" , ""text"" ) ; char * _auth = _getBasicAuthHeader ( ) ; <S2SV_StartBug> int rv = Socket_print ( S , <S2SV_EndBug> ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" <S2SV_StartBug> ""Content-Length:<S2SV_blank>%d\\r\\n"" <S2SV_EndBug> ""%s"" ""\\r\\n"" ""%s"" , <S2SV_StartBug> request , <S2SV_EndBug> StringBuffer_length ( data ) , _auth ? _auth : """" , StringBuffer_toString ( data ) ) ; FREE ( _auth ) ; if ( rv < 0 ) THROW ( IOException , ""Monit:<S2SV_blank>cannot<S2SV_blank>send<S2SV_blank>command<S2SV_blank>to<S2SV_blank>the<S2SV_blank>monit<S2SV_blank>daemon<S2SV_blank>--<S2SV_blank>%s"" , STRERROR ) ; }
","<S2SV_ModStart> ( ) ; MD_T token ; StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ; <S2SV_ModStart> , ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""Cookie:<S2SV_blank>securitytoken=%s\\r\\n"" <S2SV_ModStart> ""%s"" , request , token
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,630,"<S2SV_ModStart> ( S, ""POST <S2SV_blank> %s <S2SV_blank> HTTP/1.0\\r\\n"" ""Content-Type: <S2SV_blank> application/x-www-form-urlencoded\\r\\n"" <S2SV_ModEnd> ""Content-Length: <S2SV_blank> %d\\r\\n"" ""Content-Length: <S2SV_blank> %d\\r\\n"" ""%s"" ""\\r\\n"" ""%s"" <S2SV_ModEnd>, request, <S2SV_ModStart> ( S, ""POST <S2SV_blank> %s <S2SV_blank> HTTP/1.0\\r\\n"" <S2SV_ModEnd> ""Content-Length: <S2SV_blank> %d\\r\\n"" ""Content-Length: <S2SV_blank> %d\\r\\n"" <S2SV_ModEnd> ""Content-Length: <S2SV_blank> %d\\r\\n"" ""%s"",",0
633,CWE-20,"CWE-20 static inline void VectorClamp3 ( DDSVector3 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,633,"<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f, <S2SV_ModStart> ( 1.0f, MagickMax <S2SV_ModEnd> ( 0.0f, <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f, <S2SV_ModStart> ( 1.0f, MagickMax <S2SV_ModEnd> ( 0.0f, <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f, <S2SV_ModStart> ( 1.0f, MagickMax <S2SV_ModEnd> ( 0.0f,",1
635,CWE-20,"CWE-20 static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ; <S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> return VM_FAULT_SIGSEGV ; if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) goto oom_free_page ; __SetPageUptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & VM_WRITE ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache_add_active_or_unevictable ( page , vma ) ; setpte : set_pte_at ( mm , address , page_table , entry ) ; update_mmu_cache ( vma , address , page_table ) ; unlock : pte_unmap_unlock ( page_table , ptl ) ; return 0 ; release : mem_cgroup_cancel_charge ( page , memcg ) ; page_cache_release ( page ) ; goto unlock ; oom_free_page : page_cache_release ( page ) ; oom : return VM_FAULT_OOM ; }
","<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z,635,<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (,1
636,CWE-416,"CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }
","<S2SV_ModStart> -> sasl_username = g_strdup ( <S2SV_ModStart> src -> sasl_username ) <S2SV_ModStart> -> sasl_password = g_strdup ( <S2SV_ModStart> src -> sasl_password )
",irssi@irssi/d23b0d22cc611e43c88d99192a59f413f951a955,CVE-2019-13045,https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955,2019-06-29T14:15Z,636,<S2SV_ModStart> -> sasl_mechanism ; rec -> sasl_username = g_strdup ( src -> sasl_username ) ; rec -> sasl_password = g_strdup ( src -> sasl_password ) ;,0
637,CWE-20,"CWE-20 static int adjust_insn_aux_data ( struct bpf_verifier_env * env , u32 prog_len , u32 off , u32 cnt ) { <S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> if ( cnt == 1 ) return 0 ; new_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * prog_len ) ; if ( ! new_data ) return - ENOMEM ; memcpy ( new_data , old_data , sizeof ( struct bpf_insn_aux_data ) * off ) ; memcpy ( new_data + off + cnt - 1 , old_data + off , sizeof ( struct bpf_insn_aux_data ) * ( prog_len - off - cnt + 1 ) ) ; <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> vfree ( old_data ) ; return 0 ; }
","<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
",torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z,637,<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ]. seen = true ;,1
638,CWE-125,"CWE-125 int frag6_print ( netdissect_options * ndo , register const u_char * bp , register const u_char * bp2 ) { register const struct ip6_frag * dp ; register const struct ip6_hdr * ip6 ; dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ; <S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(0x%08x:%d|%ld)"" , EXTRACT_32BITS ( & dp -> ip6f_ident ) , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } else { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(%d|%ld)"" , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } if ( ( EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK ) != 0 ) return - 1 ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; return sizeof ( struct ip6_frag ) ; } trunc : ND_PRINT ( ( ndo , ""[|frag]"" ) ) ; return - 1 ; }
","<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if
",the-tcpdump-group@tcpdump/2d669862df7cd17f539129049f6fb70d17174125,CVE-2017-13031,https://github.com/the-tcpdump-group/tcpdump/commit/2d669862df7cd17f539129049f6fb70d17174125,2017-09-14T06:29Z,638,<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if,1
639,CWE-125,"CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
","<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
",the-tcpdump-group@tcpdump/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,CVE-2017-13023,https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,2017-09-14T06:29Z,639,<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;,1
646,CWE-89,"CWE-89 char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,646,<S2SV_ModStart> len ) { size_t <S2SV_ModEnd> alloc = ( <S2SV_ModStart> int alloc = ( length < 0 )? length : ( int ) strlen ( string ) ; char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; CURLcode <S2SV_ModEnd> res ; if <S2SV_ModStart> ( res ) { free ( ns ) ; return NULL ; } ns [ strindex ++ ] = in <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( olen ) <S2SV_ModEnd> * olen = <S2SV_ModStart> strindex ; return ns <S2SV_ModEnd> ; } <S2SV_null>,0
647,CWE-416,"CWE-416 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z,647,<S2SV_ModStart> ; RAnalOp next_op = { 0 },1
648,CWE-20,"CWE-20 static ssize_t generic_perform_write ( struct file * file , struct iov_iter * i , loff_t pos ) { struct address_space * mapping = file -> f_mapping ; const struct address_space_operations * a_ops = mapping -> a_ops ; long status = 0 ; ssize_t written = 0 ; unsigned int flags = 0 ; if ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) flags |= AOP_FLAG_UNINTERRUPTIBLE ; do { struct page * page ; pgoff_t index ; unsigned long offset ; unsigned long bytes ; size_t copied ; void * fsdata ; offset = ( pos & ( PAGE_CACHE_SIZE - 1 ) ) ; index = pos >> PAGE_CACHE_SHIFT ; bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_count ( i ) ) ; again : if ( unlikely ( iov_iter_fault_in_readable ( i , bytes ) ) ) { status = - EFAULT ; break ; } status = a_ops -> write_begin ( file , mapping , pos , bytes , flags , & page , & fsdata ) ; if ( unlikely ( status ) ) break ; pagefault_disable ( ) ; copied = iov_iter_copy_from_user_atomic ( page , i , offset , bytes ) ; pagefault_enable ( ) ; flush_dcache_page ( page ) ; status = a_ops -> write_end ( file , mapping , pos , bytes , copied , page , fsdata ) ; if ( unlikely ( status < 0 ) ) break ; copied = status ; cond_resched ( ) ; <S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ; goto again ; } <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> pos += copied ; written += copied ; balance_dirty_pages_ratelimited ( mapping ) ; } while ( iov_iter_count ( i ) ) ; return written ? written : status ; }
","<S2SV_ModStart> ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> again ; } <S2SV_ModEnd> pos += copied
",torvalds@linux/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5,CVE-2008-7316,https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5,2016-05-02T10:59Z,648,"<S2SV_ModStart> ( ) ; iov_iter_advance ( i, copied ) ; <S2SV_ModStart> again ; } <S2SV_ModEnd> pos += copied",1
656,CWE-125,"CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
",ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z,656,<S2SV_ModStart> 255U ; } for ( j = 0 ; j < length ; j ++ ) { CheckNumberPixels ( 8 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 1 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ; break ; } case 3 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 1 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; break ; } case 4 : { CheckNumberPixels ( 5 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; break ; } case 5 : { CheckNumberPixels ( 6 ) ; * pixels ++ = ( pixel >>,0
657,CWE-20,"CWE-20 int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,657,"<S2SV_ModStart> timer ) ; spin_lock ( & timeri -> timer_active_lock ) ; _snd_timer_stop ( timer, 1, SNDRV_TIMER_EVENT_RESOLUTION ) ; mutex_unlock ( & timeri -> timer_active_lock ) ; <S2SV_ModStart> NULL ; } spin_unlock ( & timeri -> timer_active_lock ) ; mutex_unlock ( & timeri -> timer_active_lock ) ;",0
658,CWE-125,"CWE-125 static int print_ccp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case CCPOPT_BSDCOMP : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ; case CCPOPT_MVRCA : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ; break ; case CCPOPT_DEFLATE : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ; break ; # if 0 case CCPOPT_OUI : case CCPOPT_PRED1 : case CCPOPT_PRED2 : case CCPOPT_PJUMP : case CCPOPT_HPPPC : case CCPOPT_STACLZS : case CCPOPT_MPPC : case CCPOPT_GFZA : case CCPOPT_V42BIS : case CCPOPT_LZSDCP : case CCPOPT_DEC : case CCPOPT_RESV : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ccp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z,658,<S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ;,0
659,CWE-416,"CWE-416 R_API int r_core_bin_set_env ( RCore * r , RBinFile * binfile ) { RBinObject * binobj = binfile ? binfile -> o : NULL ; RBinInfo * info = binobj ? binobj -> info : NULL ; if ( info ) { int va = info -> has_va ; <S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> ut16 bits = info -> bits ; ut64 baseaddr = r_bin_get_baddr ( r -> bin ) ; r_config_set_i ( r -> config , ""io.va"" , ( binobj -> info ) ? binobj -> info -> has_va : 0 ) ; r_config_set_i ( r -> config , ""bin.baddr"" , baseaddr ) ; r_config_set ( r -> config , ""asm.arch"" , arch ) ; r_config_set_i ( r -> config , ""asm.bits"" , bits ) ; r_config_set ( r -> config , ""anal.arch"" , arch ) ; <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> } else { r_config_set ( r -> config , ""anal.cpu"" , arch ) ; } r_asm_use ( r -> assembler , arch ) ; r_core_bin_info ( r , R_CORE_BIN_ACC_ALL , R_CORE_BIN_SET , va , NULL , NULL ) ; <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> return true ; } return false ; }
","<S2SV_ModStart> -> has_va ; <S2SV_ModEnd> char * arch <S2SV_ModStart> * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpu && * <S2SV_ModStart> cpu && * <S2SV_ModEnd> cpu ) { <S2SV_ModStart> , ""anal.cpu"" , <S2SV_ModEnd> cpu ) ; <S2SV_ModStart> r , binfile ) ; free ( cpu ) ; free ( arch
",radare@radare2/f85bc674b2a2256a364fe796351bc1971e106005,CVE-2017-9520,https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005,2017-06-08T14:29Z,659,"<S2SV_ModStart> -> has_va ; <S2SV_ModEnd> char * arch <S2SV_ModStart> * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpu && * <S2SV_ModStart> cpu && * <S2SV_ModEnd> cpu ) { <S2SV_ModStart>, ""anal.cpu"", <S2SV_ModEnd> cpu ) ; <S2SV_ModStart> r, binfile ) ; free ( cpu ) ; free ( arch",1
662,CWE-20,"CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line
",wireshark@wireshark/6a140eca7b78b230f1f90a739a32257476513c78,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78,2016-08-07T16:59Z,662,"<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if (! <S2SV_ModStart> if (! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd>, & wth <S2SV_ModStart> wth -> frame_buffer, line",1
671,CWE-20,"CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,671,"<S2SV_ModStart>, timeo ) ; msg -> msg_namelen = sizeof ( * sin ) ;",0
672,CWE-22,"CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , ""w"" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , ""%u"" , val ) ; fclose ( fp ) ; return 0 ; }
","<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/'
",reubenhwk@radvd/92e22ca23e52066da2258df8c76a2dca8a428bcc,CVE-2011-3602,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,2014-04-27T21:55Z,672,"<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name, "".."" ) || strchr ( name, '/'",1
674,CWE-22,"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z,674,"<S2SV_ModStart> -> bcache, cache_id ( <S2SV_ModStart> ] -> data )",1
708,CWE-125,"CWE-125 static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,708,"<S2SV_ModStart>, end_col_offset ; string type_comment ; <S2SV_ModStart> += 2 ; type_comment = NEW_TYPE_COMMENT ( CHILD ( n, name_i ) ) ; if (! TYPE ( CHILD ( n, name_i + 1 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n, name_i + 2 ) ) ; if (! type_comment ) return NULL ; } <S2SV_ModStart> += 3 ; type_comment = NEW_TYPE_COMMENT ( CHILD ( n, name_i + 3 ) ) ; if (! type_comment ) return NULL ; <S2SV_ModStart>, returns, type_comment, <S2SV_ModStart> ; if ( TYPE ( CHILD ( n, name_i + 4 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n, name_i + 4 ) ) ; if (! type_comment ) return NULL ; } <S2SV_ModStart>, decorator_seq, type_comment, <S2SV_ModStart>, returns, type_comment, <S2SV_ModStart> ; if ( TYPE ( CHILD ( n, name_i + 5 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD",0
709,CWE-416,"CWE-416 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
","<S2SV_ModStart> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL
",torvalds@linux/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,CVE-2017-15115,https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,2017-11-15T21:29Z,709,"<S2SV_ModStart> err = 0 ; if (! net_eq ( current -> nsproxy -> net_ns, sock_net ( sk ) ) ) return - EINVAL",1
710,CWE-20,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
","<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
",torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e,CVE-2017-17805,https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e,2017-12-20T23:29Z,710,<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk,1
713,CWE-787,"CWE-787 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; <S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
",ImageMagick@ImageMagick/998c687fb83993c13fa711d75f59a95b38ceab77,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77,2017-04-20T18:59Z,713,"<S2SV_ModStart> Rec. RecordLength ) ; if ( Rec. RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader""",0
719,CWE-125,"CWE-125 struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ; <S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> uint8_t * * tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 4 ; if ( tmp_val != 6 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , NULL , 0 ) ; return ( NULL ) ; } tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val > 2 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } midi_type = tmp_val ; tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val < 1 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(no<S2SV_blank>tracks)"" , 0 ) ; return ( NULL ) ; } no_tracks = tmp_val ; if ( ( midi_type == 0 ) && ( no_tracks > 1 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , ""(expected<S2SV_blank>1<S2SV_blank>track<S2SV_blank>for<S2SV_blank>type<S2SV_blank>0<S2SV_blank>midi<S2SV_blank>file,<S2SV_blank>found<S2SV_blank>more)"" , 0 ) ; return ( NULL ) ; } divisions = * midi_data ++ << 8 ; divisions |= * midi_data ++ ; midi_size -= 2 ; if ( divisions & 0x00008000 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mdi , divisions ) ; tracks = malloc ( sizeof ( uint8_t * ) * no_tracks ) ; <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ; running_event = malloc ( sizeof ( uint8_t ) * no_tracks ) ; smallest_delta = 0xffffffff ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( midi_size < 8 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ; goto _end ; } midi_data += 4 ; midi_size -= 4 ; <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> midi_size -= 4 ; <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ; goto _end ; } tracks [ i ] = midi_data ; <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> track_end [ i ] = 0 ; running_event [ i ] = 0 ; track_delta [ i ] = 0 ; while ( * tracks [ i ] > 0x7F ) { track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; tracks [ i ] ++ ; <S2SV_StartBug> } <S2SV_EndBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> if ( midi_type == 1 ) { if ( track_delta [ i ] < smallest_delta ) { smallest_delta = track_delta [ i ] ; } } else { if ( i == 0 ) smallest_delta = track_delta [ i ] ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; if ( midi_type == 1 ) { while ( end_of_tracks != no_tracks ) { smallest_delta = 0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( track_end [ i ] ) continue ; if ( track_delta [ i ] ) { track_delta [ i ] -= subtract_delta ; if ( track_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } continue ; } } do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { end_of_tracks ++ ; track_end [ i ] = 1 ; tracks [ i ] += 3 ; <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> } while ( ! track_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } NEXT_TRACK : continue ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; } } else { if ( midi_type == 2 ) { mdi -> is_type2 = 1 ; } sample_remainder = 0.0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { track_end [ i ] = 1 ; goto NEXT_TRACK2 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> if ( * tracks [ i ] > 0x7f ) { do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; NEXT_TRACK2 : smallest_delta = track_delta [ i ] ; UNUSED ( smallest_delta ) ; } while ( track_end [ i ] == 0 ) ; } } if ( ( mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _end ; } mdi -> extra_info . current_sample = 0 ; mdi -> current_event = & mdi -> events [ 0 ] ; mdi -> samples_to_mix = 0 ; mdi -> note = NULL ; _WM_ResetToStart ( mdi ) ; _end : free ( sysex_store ) ; free ( track_end ) ; free ( track_delta ) ; free ( running_event ) ; free ( tracks ) ; <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> _WM_freeMDI ( mdi ) ; return ( NULL ) ; }
","<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z,719,<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = midi_data ; track_delta = midi_data ; track_end = midi_data + tmp_val ; midi_size -= tmp_val <S2SV_ModEnd> ; <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug>,0
723,CWE-125,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z,723,"<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ), func <S2SV_ModEnd>, line, <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]: <S2SV_blank> %pV"", func <S2SV_ModEnd>, line,",1
728,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , <S2SV_StartBug> height , <S2SV_EndBug> length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> extent , height <S2SV_ModEnd> ; ssize_t count <S2SV_ModStart> PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> image -> columns <S2SV_ModStart> % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> * p ++ <S2SV_ModStart> * p ++ ) <S2SV_ModStart> q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart> if ( ( <S2SV_ModEnd> ( bytes_per_pixel *
",ImageMagick@ImageMagick/8ea44b48a182dd46d018f4b4f09a5e2ee9638105,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/8ea44b48a182dd46d018f4b4f09a5e2ee9638105,2017-04-20T18:59Z,728,"<S2SV_ModStart>, extent, width, <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; height = sun_info. height * sun_info. depth ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""MemoryAllocationFailed"" ) ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""MemoryAllocationFailed"" ) ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""MemoryAllocationFailed"" ) ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""MemoryAllocationFailed"" ) ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; if ( width > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""MemoryAllocationFailed"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""MemoryAllocationFailed"" ) ;",0
733,CWE-125,"CWE-125 static void ip_cmsg_recv_checksum ( struct msghdr * msg , struct sk_buff * skb , int tlen , int offset ) { __wsum csum = skb -> csum ; if ( skb -> ip_summed != CHECKSUM_COMPLETE ) return ; <S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> csum = csum_sub ( csum , <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; }
","<S2SV_ModStart> != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum , skb_checksum ( skb , tend_off , <S2SV_ModEnd> offset , 0 <S2SV_ModStart> ) ) ; }
",torvalds@linux/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32,CVE-2017-6347,https://github.com/torvalds/linux/commit/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32,2017-03-01T20:59Z,733,"<S2SV_ModStart>!= 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum, skb_checksum ( skb, tend_off, <S2SV_ModEnd> offset, 0 <S2SV_ModStart>, csum_partial ( skb_transport_header ( skb ) + tend_off <S2SV_ModEnd>, offset,",0
737,CWE-125,"CWE-125 static inline unsigned int ReadPropertyUnsignedLong ( const EndianType endian , const unsigned char * buffer ) { unsigned int value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] ; return <S2SV_ModEnd> ( value & <S2SV_ModStart> & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,737,<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] ; return <S2SV_ModEnd> ( value & <S2SV_ModStart> & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null>,1
740,CWE-20,"CWE-20 static int xen_netbk_get_extras ( struct xenvif * vif , struct xen_netif_extra_info * extras , int work_to_do ) { struct xen_netif_extra_info extra ; RING_IDX cons = vif -> tx . req_cons ; do { if ( unlikely ( work_to_do -- <= 0 ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; <S2SV_EndBug> return - EBADR ; } memcpy ( & extra , RING_GET_REQUEST ( & vif -> tx , cons ) , sizeof ( extra ) ) ; if ( unlikely ( ! extra . type || extra . type >= XEN_NETIF_EXTRA_TYPE_MAX ) ) { vif -> tx . req_cons = ++ cons ; <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n"" , extra . type ) ; <S2SV_EndBug> return - EINVAL ; } memcpy ( & extras [ extra . type - 1 ] , & extra , sizeof ( extra ) ) ; vif -> tx . req_cons = ++ cons ; } while ( extra . flags & XEN_NETIF_EXTRA_FLAG_MORE ) ; return work_to_do ; }
","<S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> extra . type ) ; netbk_fatal_tx_err ( vif
",torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z,740,"<S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev, ""Missing <S2SV_blank> extra <S2SV_blank> info\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> extra. type ) ; netbk_fatal_tx_err ( vif",1
744,CWE-125,"CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else <S2SV_StartBug> { <S2SV_EndBug> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : { <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }
","<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z,744,"<S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg6 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; }",0
748,CWE-20,"CWE-20 static void cmd_parse_status ( struct ImapData * idata , char * s ) { char * value = NULL ; struct Buffy * inc = NULL ; struct ImapMbox mx ; struct ImapStatus * status = NULL ; unsigned int olduv , oldun ; unsigned int litlen ; short new = 0 ; short new_msg_count = 0 ; char * mailbox = imap_next_word ( s ) ; if ( imap_get_literal_count ( mailbox , & litlen ) == 0 ) { if ( imap_cmd_step ( idata ) != IMAP_CMD_CONTINUE ) { <S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> return ; } mailbox = idata -> buf ; s = mailbox + litlen ; * s = '\\0' ; s ++ ; SKIPWS ( s ) ; } else { s = imap_next_word ( mailbox ) ; * ( s - 1 ) = '\\0' ; imap_unmunge_mbox_name ( idata , mailbox ) ; } status = imap_mboxcache_get ( idata , mailbox , 1 ) ; olduv = status -> uidvalidity ; oldun = status -> uidnext ; if ( * s ++ != '(' ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS\\n"" ) ; return ; } while ( * s && * s != ')' ) { value = imap_next_word ( s ) ; errno = 0 ; const unsigned long ulcount = strtoul ( value , & value , 10 ) ; if ( ( ( errno == ERANGE ) && ( ulcount == ULONG_MAX ) ) || ( ( unsigned int ) ulcount != ulcount ) ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>number\\n"" ) ; return ; } const unsigned int count = ( unsigned int ) ulcount ; if ( mutt_str_strncmp ( ""MESSAGES"" , s , 8 ) == 0 ) { status -> messages = count ; new_msg_count = 1 ; } else if ( mutt_str_strncmp ( ""RECENT"" , s , 6 ) == 0 ) status -> recent = count ; else if ( mutt_str_strncmp ( ""UIDNEXT"" , s , 7 ) == 0 ) status -> uidnext = count ; else if ( mutt_str_strncmp ( ""UIDVALIDITY"" , s , 11 ) == 0 ) status -> uidvalidity = count ; else if ( mutt_str_strncmp ( ""UNSEEN"" , s , 6 ) == 0 ) status -> unseen = count ; s = value ; if ( * s && * s != ')' ) s = imap_next_word ( s ) ; } mutt_debug ( 3 , ""%s<S2SV_blank>(UIDVALIDITY:<S2SV_blank>%u,<S2SV_blank>UIDNEXT:<S2SV_blank>%u)<S2SV_blank>%d<S2SV_blank>messages,<S2SV_blank>%d<S2SV_blank>recent,<S2SV_blank>%d<S2SV_blank>unseen\\n"" , status -> name , status -> uidvalidity , status -> uidnext , status -> messages , status -> recent , status -> unseen ) ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_STATUS ) { memcpy ( idata -> cmddata , status , sizeof ( struct ImapStatus ) ) ; return ; } mutt_debug ( 3 , ""Running<S2SV_blank>default<S2SV_blank>STATUS<S2SV_blank>handler\\n"" ) ; for ( inc = Incoming ; inc ; inc = inc -> next ) { if ( inc -> magic != MUTT_IMAP ) continue ; if ( imap_parse_path ( inc -> path , & mx ) < 0 ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>mailbox<S2SV_blank>%s,<S2SV_blank>skipping\\n"" , inc -> path ) ; continue ; } if ( imap_account_match ( & idata -> conn -> account , & mx . account ) ) { if ( mx . mbox ) { value = mutt_str_strdup ( mx . mbox ) ; imap_fix_path ( idata , mx . mbox , value , mutt_str_strlen ( value ) + 1 ) ; FREE ( & mx . mbox ) ; } else value = mutt_str_strdup ( ""INBOX"" ) ; if ( value && ( imap_mxcmp ( mailbox , value ) == 0 ) ) { mutt_debug ( 3 , ""Found<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>buffy<S2SV_blank>list<S2SV_blank>(OV:<S2SV_blank>%u<S2SV_blank>ON:<S2SV_blank>%u<S2SV_blank>U:<S2SV_blank>%d)\\n"" , mailbox , olduv , oldun , status -> unseen ) ; if ( MailCheckRecent ) { if ( olduv && olduv == status -> uidvalidity ) { if ( oldun < status -> uidnext ) new = ( status -> unseen > 0 ) ; } else if ( ! olduv && ! oldun ) { new = ( status -> recent > 0 ) ; } else new = ( status -> unseen > 0 ) ; } else new = ( status -> unseen > 0 ) ; # ifdef USE_SIDEBAR if ( ( inc -> new != new ) || ( inc -> msg_count != status -> messages ) || ( inc -> msg_unread != status -> unseen ) ) { mutt_menu_set_current_redraw ( REDRAW_SIDEBAR ) ; } # endif inc -> new = new ; if ( new_msg_count ) inc -> msg_count = status -> messages ; inc -> msg_unread = status -> unseen ; if ( inc -> new ) { status -> uidnext = oldun ; } FREE ( & value ) ; return ; } FREE ( & value ) ; } FREE ( & mx . mbox ) ; } }
","<S2SV_ModStart> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" )
",neomutt@neomutt/3c49c44be9b459d9c616bcaef6eb5d51298c1741,CVE-2018-14351,https://github.com/neomutt/neomutt/commit/3c49c44be9b459d9c616bcaef6eb5d51298c1741,2018-07-17T17:29Z,748,<S2SV_ModStart> IMAP_FATAL ; return ; } if ( imap_cmd_step ( idata )!= IMAP_CMD_CONTINUE ) { idata -> status = IMAP_FATAL ; return,0
751,CWE-787,"CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ; break ; <S2SV_ModEnd> } } if <S2SV_ModStart> 1 ; } }
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,751,<S2SV_ModStart> = 0 ; if ( ptr_hbe_txposer -> band_type == IXHEAACD_BAND_4_0 ) { ptr_hbe_txposer -> band_type = IXHEAACD_BAND_4_0 ; } else if ( ptr_hbe_txposer -> band_type == IXHEAACD_BAND_4_1 ) { if ( ptr_hbe_txposer -> band_type == IXHEAACD_BAND_4_0 ) { if ( ptr_hbe_txposer -> band_type == IXHEAACD_BAND_4_0 ) ptr_hbe_txposer -> band_type = IXHEAACD_BAND_4_1 ; } else if ( ptr_hbe_txposer -> band_type == IXHEAACD_BAND_4_0 ) { ptr_hbe_txposer -> band_type = IXHEAACD_BAND_4_1 ; } else if ( ptr_hbe_txposer -> band_type == IXHEAACD_B,0
752,CWE-787,"CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
","<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
",uclouvain@openjpeg/2cd30c2b06ce332dede81cccad8b334cde997281,CVE-2017-14040,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2017-08-30T22:29Z,752,<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; cmap_entry_size = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> if 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga,0
755,CWE-125,"CWE-125 uint32 TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; <S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> if ( td -> td_nstrips ) return td -> td_nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , ""TIFFNumberOfStrips"" ) ; return ( nstrips ) ; }
","<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =
",vadz@libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018,CVE-2016-10270,https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018,2017-03-24T19:59Z,755,<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =,1
756,CWE-20,"CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,756,"<S2SV_ModStart>, timeo ) ; msg -> msg_namelen = sizeof ( * sin ) ;",0
765,CWE-416,"CWE-416 static void ffs_user_copy_worker ( struct work_struct * work ) { struct ffs_io_data * io_data = container_of ( work , struct ffs_io_data , work ) ; int ret = io_data -> req -> status ? io_data -> req -> status : io_data -> req -> actual ; <S2SV_StartBug> if ( io_data -> read && ret > 0 ) { <S2SV_EndBug> use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && <S2SV_StartBug> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <S2SV_EndBug> eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ; <S2SV_StartBug> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <S2SV_EndBug> io_data -> kiocb -> private = NULL ; if ( io_data -> read ) kfree ( io_data -> to_free ) ; kfree ( io_data -> buf ) ; kfree ( io_data ) ; }
","<S2SV_ModStart> -> actual ; bool kiocb_has_eventfd = <S2SV_ModEnd> io_data -> kiocb <S2SV_ModStart> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> ) eventfd_signal ( <S2SV_ModStart> -> req ) <S2SV_ModEnd> ; if (
",torvalds@linux/38740a5b87d53ceb89eb2c970150f6e94e00373a,CVE-2016-7912,https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a,2016-11-16T05:59Z,765,"<S2SV_ModStart> -> actual ; bool kiocb_has_eventfd = <S2SV_ModEnd> io_data -> kiocb <S2SV_ModStart> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf, ret, & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb, ret, ret ) ; if ( io_data -> ffs -> ffs_eventfd &&! kiocb_has_eventfd <S2SV_ModEnd> ) eventfd_signal ( <S2SV_ModStart> -> req ) <S2SV_ModEnd> ; if (",1
767,CWE-20,"CWE-20 static void ikev2_parent_inR1outI2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inR1outI2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>I2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inR1outI2_tail ( pcrc , r ) ; if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z,767,<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,1
770,CWE-20,"CWE-20 static void rose_loopback_timer ( unsigned long param ) { struct sk_buff * skb ; struct net_device * dev ; rose_address * dest ; struct sock * sk ; unsigned short frametype ; unsigned int lci_i , lci_o ; <S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ; frametype = skb -> data [ 2 ] ; <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ; skb_reset_transport_header ( skb ) ; sk = rose_find_socket ( lci_o , rose_loopback_neigh ) ; if ( sk ) { if ( rose_process_rx_frame ( sk , skb ) == 0 ) kfree_skb ( skb ) ; continue ; } if ( frametype == ROSE_CALL_REQUEST ) { if ( ( dev = rose_dev_get ( dest ) ) != NULL ) { if ( rose_rx_call_request ( skb , dev , rose_loopback_neigh , lci_o ) == 0 ) kfree_skb ( skb ) ; } else { kfree_skb ( skb ) ; } } else { kfree_skb ( skb ) ; } } }
","<S2SV_ModStart> NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z,770,<S2SV_ModStart> NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ]!= ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o,1
774,CWE-787,"CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
",dbry@WavPack/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,CVE-2018-10540,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,2018-04-29T15:29Z,774,"<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s <S2SV_blank> is <S2SV_blank> not <S2SV_blank> a <S2SV_blank> valid <S2SV_blank>.DFF <S2SV_blank> file!"", infilename ) ; return WAVPACK_SOFT_ERROR ; } buff",1
776,CWE-20,"CWE-20 int serverCron ( struct aeEventLoop * eventLoop , long long id , void * clientData ) { int j , loops = server . cronloops ++ ; REDIS_NOTUSED ( eventLoop ) ; REDIS_NOTUSED ( id ) ; REDIS_NOTUSED ( clientData ) ; server . unixtime = time ( NULL ) ; updateLRUClock ( ) ; if ( server . shutdown_asap ) { if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ; redisLog ( REDIS_WARNING , ""SIGTERM<S2SV_blank>received<S2SV_blank>but<S2SV_blank>errors<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>shut<S2SV_blank>down<S2SV_blank>the<S2SV_blank>server,<S2SV_blank>check<S2SV_blank>the<S2SV_blank>logs<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information"" ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long size , used , vkeys ; size = dictSlots ( server . db [ j ] . dict ) ; used = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( ! ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE , ""DB<S2SV_blank>%d:<S2SV_blank>%lld<S2SV_blank>keys<S2SV_blank>(%lld<S2SV_blank>volatile)<S2SV_blank>in<S2SV_blank>%lld<S2SV_blank>slots<S2SV_blank>HT."" , j , used , vkeys , size ) ; } } if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) { if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ; if ( server . activerehashing ) incrementallyRehash ( ) ; } if ( ! ( loops % 50 ) ) { redisLog ( REDIS_VERBOSE , ""%d<S2SV_blank>clients<S2SV_blank>connected<S2SV_blank>(%d<S2SV_blank>slaves),<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>use"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ; } if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ; if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) { int statloc ; pid_t pid ; if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) != 0 ) { if ( pid == server . bgsavechildpid ) { backgroundSaveDoneHandler ( statloc ) ; } else { backgroundRewriteDoneHandler ( statloc ) ; } updateDictResizePolicy ( ) ; } } else { time_t now = time ( NULL ) ; for ( j = 0 ; j < server . saveparamslen ; j ++ ) { struct saveparam * sp = server . saveparams + j ; if ( server . dirty >= sp -> changes && now - server . lastsave > sp -> seconds ) { redisLog ( REDIS_NOTICE , ""%d<S2SV_blank>changes<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>seconds.<S2SV_blank>Saving..."" , sp -> changes , sp -> seconds ) ; rdbSaveBackground ( server . dbfilename ) ; break ; } } } if ( server . masterhost == NULL ) activeExpireCycle ( ) ; <S2SV_StartBug> if ( vmCanSwapOut ( ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( server . vm_enabled && zmalloc_used_memory ( ) > <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory ) <S2SV_EndBug> { int retval = ( server . vm_max_threads == 0 ) ? vmSwapOneObjectBlocking ( ) : vmSwapOneObjectThreaded ( ) ; if ( retval == REDIS_ERR && ! ( loops % 300 ) && zmalloc_used_memory ( ) > ( server . vm_max_memory + server . vm_max_memory / 10 ) ) { redisLog ( REDIS_WARNING , ""WARNING:<S2SV_blank>vm-max-memory<S2SV_blank>limit<S2SV_blank>exceeded<S2SV_blank>by<S2SV_blank>more<S2SV_blank>than<S2SV_blank>10%%<S2SV_blank>but<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>swap<S2SV_blank>more<S2SV_blank>objects<S2SV_blank>out!"" ) ; } if ( retval == REDIS_ERR || server . vm_max_threads > 0 ) break ; } } if ( ! ( loops % 10 ) ) replicationCron ( ) ; return 100 ; }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> while ( server <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && zmalloc_used_memory ( <S2SV_ModStart> > server . cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> } if (
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,776,"<S2SV_ModStart> ) ; } if ( server. bgsavechildpid!= - 1 && server. bgrewritechildpid!= - 1 ) { if ( ( loops % 50 ) && ( listLength ( server. clients ) > listLength ( server. slaves ) && listLength ( server. clients ) > listLength ( server. slaves ) ) ) { redisLog ( REDIS_VERBOSE, ""%d <S2SV_blank> clients <S2SV_blank> connected <S2SV_blank> (%d <S2SV_blank> slaves), <S2SV_blank> %zu <S2SV_blank> bytes <S2SV_blank> in <S2SV_blank> use"", ( listLength ( server. clients ) - listLength ( server. slaves ), zmalloc_used_memory ( ) ) ; } else { if ( ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE, ""DB <S2SV_blank> %d <S2SV_blank> keys <S2SV_blank> (%lld <S2SV_blank> volatile) <S2SV_blank> in <S2SV_blank> %lld <S2SV_blank> slots <S2SV_blank> HT <S2SV_blank> not <S2SV_blank> in <S2SV_blank> %lld <S2SV_blank> slots <S2SV_blank> HT."", j, used, vkeys ) ; } if (! ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE, ""DB <S2SV_blank> %d <S2SV_blank> keys <S2SV_blank> (%lld <S2SV_blank> volatile) <S2SV_blank> in <S2SV_blank> %lld <S2SV_blank>",0
781,CWE-20,"CWE-20 void BezierCircle ( double r , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - r , - r , r * BzK , - r * BzK , r , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , r * BzK , r , r , r * BzK , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , r , - r * BzK , r * BzK , - r , - r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - r * BzK , - r , - r , - r * BzK , - r , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,781,"<S2SV_ModStart> action ) { sprintf ( outputbuffer <S2SV_ModEnd>, "" <S2SV_blank> %12.3f <S2SV_blank> 0 <S2SV_blank> m <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> 0 <S2SV_blank> %12.3f <S2SV_blank> c\\n"", <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;",0
786,CWE-787,"CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
","<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z,786,<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->,1
789,CWE-787,"CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>"" ""This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n"" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
","<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,789,<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t,1
791,CWE-416,"CWE-416 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,791,"<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len, & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }",1
793,CWE-416,"CWE-416 static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen , unsigned int flags ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; int len ; int val ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; switch ( optname ) { case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; val = sk -> sk_family ; break ; case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ; if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ; if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ; lock_sock ( sk ) ; err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IPV6_2292PKTOPTIONS : { struct msghdr msg ; struct sk_buff * skb ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = flags ; lock_sock ( sk ) ; skb = np -> pktoptions ; if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ; release_sock ( sk ) ; if ( ! skb ) { if ( np -> rxopt . bits . rxinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxhlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxtclass ) { int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ; put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ; } if ( np -> rxopt . bits . rxoinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxohlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxflow ) { __be32 flowinfo = np -> rcv_flowinfo ; put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ; } } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IPV6_MTU : { struct dst_entry * dst ; val = 0 ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! val ) return - ENOTCONN ; break ; } case IPV6_V6ONLY : val = sk -> sk_ipv6only ; break ; case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ; break ; case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ; break ; case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ; break ; case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ; break ; case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ; break ; case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> optname , optval , len ) ; release_sock ( sk ) ; if ( len < 0 ) return len ; return put_user ( len , optlen ) ; } case IPV6_RECVHOPOPTS : val = np -> rxopt . bits . hopopts ; break ; case IPV6_2292HOPOPTS : val = np -> rxopt . bits . ohopopts ; break ; case IPV6_RECVDSTOPTS : val = np -> rxopt . bits . dstopts ; break ; case IPV6_2292DSTOPTS : val = np -> rxopt . bits . odstopts ; break ; case IPV6_TCLASS : val = np -> tclass ; break ; case IPV6_RECVTCLASS : val = np -> rxopt . bits . rxtclass ; break ; case IPV6_FLOWINFO : val = np -> rxopt . bits . rxflow ; break ; case IPV6_RECVPATHMTU : val = np -> rxopt . bits . rxpmtu ; break ; case IPV6_PATHMTU : { struct dst_entry * dst ; struct ip6_mtuinfo mtuinfo ; if ( len < sizeof ( mtuinfo ) ) return - EINVAL ; len = sizeof ( mtuinfo ) ; memset ( & mtuinfo , 0 , sizeof ( mtuinfo ) ) ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) mtuinfo . ip6m_mtu = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! mtuinfo . ip6m_mtu ) return - ENOTCONN ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & mtuinfo , len ) ) return - EFAULT ; return 0 ; } case IPV6_TRANSPARENT : val = inet_sk ( sk ) -> transparent ; break ; case IPV6_RECVORIGDSTADDR : val = np -> rxopt . bits . rxorigdstaddr ; break ; case IPV6_UNICAST_HOPS : case IPV6_MULTICAST_HOPS : { struct dst_entry * dst ; if ( optname == IPV6_UNICAST_HOPS ) val = np -> hop_limit ; else val = np -> mcast_hops ; if ( val < 0 ) { rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = ip6_dst_hoplimit ( dst ) ; rcu_read_unlock ( ) ; } if ( val < 0 ) val = sock_net ( sk ) -> ipv6 . devconf_all -> hop_limit ; break ; } case IPV6_MULTICAST_LOOP : val = np -> mc_loop ; break ; case IPV6_MULTICAST_IF : val = np -> mcast_oif ; break ; case IPV6_UNICAST_IF : val = ( __force int ) htonl ( ( __u32 ) np -> ucast_oif ) ; break ; case IPV6_MTU_DISCOVER : val = np -> pmtudisc ; break ; case IPV6_RECVERR : val = np -> recverr ; break ; case IPV6_FLOWINFO_SEND : val = np -> sndflow ; break ; case IPV6_FLOWLABEL_MGR : { struct in6_flowlabel_req freq ; int flags ; if ( len < sizeof ( freq ) ) return - EINVAL ; if ( copy_from_user ( & freq , optval , sizeof ( freq ) ) ) return - EFAULT ; if ( freq . flr_action != IPV6_FL_A_GET ) return - EINVAL ; len = sizeof ( freq ) ; flags = freq . flr_flags ; memset ( & freq , 0 , sizeof ( freq ) ) ; val = ipv6_flowlabel_opt_get ( sk , & freq , flags ) ; if ( val < 0 ) return val ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & freq , len ) ) return - EFAULT ; return 0 ; } case IPV6_ADDR_PREFERENCES : val = 0 ; if ( np -> srcprefs & IPV6_PREFER_SRC_TMP ) val |= IPV6_PREFER_SRC_TMP ; else if ( np -> srcprefs & IPV6_PREFER_SRC_PUBLIC ) val |= IPV6_PREFER_SRC_PUBLIC ; else { val |= IPV6_PREFER_SRC_PUBTMP_DEFAULT ; } if ( np -> srcprefs & IPV6_PREFER_SRC_COA ) val |= IPV6_PREFER_SRC_COA ; else val |= IPV6_PREFER_SRC_HOME ; break ; case IPV6_MINHOPCOUNT : val = np -> min_hopcount ; break ; case IPV6_DONTFRAG : val = np -> dontfrag ; break ; case IPV6_AUTOFLOWLABEL : val = np -> autoflowlabel ; break ; default : return - ENOPROTOOPT ; } len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; <S2SV_ModStart> sk ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,793,"<S2SV_ModStart> ; if ( rcu_dereference_protected ( <S2SV_ModStart> np -> opt, sock_owned_by_user ( sk ) ) ) goto done ; val = rcu_dereference_protected ( sk -> sk_omem_cache, sock_owned_by_user ( sk ) ) ; if ( copy_to_user ( optval, & rcu, sizeof ( * rcu ) ) ) return - EFAULT ; rcu_assign_pointer ( sk -> sk_omem_cache, optval ) ;",0
801,CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,801,"<S2SV_ModStart> name ) { size_t size = sizeof ( char ) * 2 + 16 ; if ( size < 2 ) { ERR ( ""Memory <S2SV_blank> allocation <S2SV_blank> error: <S2SV_blank> %d <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", size, ( unsigned int ) strlen ( name ) ) ; return ; } <S2SV_ModEnd> dst_name = malloc <S2SV_ModStart> 2 + 16 ) ; if (! ( dst = fopen ( dst_name, ""w"" ) ) ) { ERR ( ""Could <S2SV_blank> not <S2SV_blank> open <S2SV_blank> file <S2SV_blank> \'%s\' <S2SV_blank> for <S2SV_blank> writing\\n"", dst_name ) ; return ; } size = strlen ( dst_name ) ; if ( size < 4 ) { ERR ( ""Memory <S2SV_blank> allocation <S2SV_blank> error: <S2SV_blank> %d <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", dst_name, ( unsigned int ) ( unsigned int ) sizeof ( char ) ) ; if (! ( dst = fopen ( dst_name, ""w"" ) ) { ERR ( ""Could <S2SV_blank> not <S2SV_blank> open <S2SV_blank> file <S2SV_blank> \'%s\' <S2SV_blank> for <S2SV_blank> writing\\n"", dst_name ) ; return ; }",0
803,CWE-787,"CWE-787 static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; } <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }
","<S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> , __func__ )
",libimobiledevice@libplist/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,CVE-2017-6439,https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,2017-03-15T14:59Z,803,"<S2SV_ModStart> case BPLIST_DICT : if ( * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> plist <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__ ) ; return NULL ; } <S2SV_ModStart> case BPLIST_UINT : if ( * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> plist <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__ ) ; return NULL ; } <S2SV_ModStart> case BPLIST_UINT : if ( * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> plist <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__ ) ; return NULL ; } <S2SV_ModStart> case BPLIST_UINT : if ( * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> size <S2SV_blank> node <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__ ) ; return",0
804,CWE-20,"CWE-20 error_t ksz8851Init ( NetInterface * interface ) { Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; TRACE_INFO ( ""Initializing<S2SV_blank>KSZ8851<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; # if ( KSZ8851_SPI_SUPPORT == ENABLED ) interface -> spiDriver -> init ( ) ; # endif interface -> extIntDriver -> init ( ) ; <S2SV_StartBug> TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1ILR ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1IHR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID ) <S2SV_EndBug> { return ERROR_WRONG_IDENTIFIER ; } ksz8851DumpReg ( interface ) ; context -> frameId = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> txBuffer == NULL || context -> rxBuffer == NULL ) { memPoolFree ( context -> txBuffer ) ; memPoolFree ( context -> rxBuffer ) ; return ERROR_OUT_OF_MEMORY ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ; <S2SV_EndBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXFDPR , TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXPAFMA | RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXME | RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR2 , RXCR2_SRDBL2 | RXCR2_IUFFP | RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXQCR , RXQCR_RXFCTE | RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFCTR , 1 ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS | <S2SV_EndBug> ISR_RXIS | ISR_RXOIS | ISR_TXPSIS | ISR_RXPSIS | ISR_TXSAIS | ISR_RXWFDIS | ISR_RXMPDIS | ISR_LDIS | ISR_EDIS | ISR_SPIBEIS ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ; <S2SV_EndBug> osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_CIDER <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1ILR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1IHR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , KSZ8851_MARH <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARM <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARL <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> ) ; osSetEvent
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,804,"<S2SV_ModStart> ( ) ; TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"", ksz8851ReadReg ( interface, KSZ8851_CIDER ) ) ; TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"", ksz8851ReadReg ( interface, KSZ8851_PHY1ILR ) ) ; TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"", ksz8851ReadReg ( interface, KSZ8851_PHY1IHR ) ) ; <S2SV_ModStart> ( interface, KSZ8851_CIDER )!= KSZ8851_REV_A3_ID ) { return ERROR_WRONG_IDENTIFIER ; } if ( ksz8851ReadReg ( interface, KSZ8851_CIDER )!= KSZ8851_REV_A3_ID ) { return ERROR_WRONG_IDENTIFIER ; } ksz8851DumpReg ( interface ) ; context -> frameId = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ;",0
805,CWE-416,"CWE-416 void ppp_unregister_channel ( struct ppp_channel * chan ) { struct channel * pch = chan -> ppp ; struct ppp_net * pn ; if ( ! pch ) return ; chan -> ppp = NULL ; down_write ( & pch -> chan_sem ) ; spin_lock_bh ( & pch -> downl ) ; pch -> chan = NULL ; spin_unlock_bh ( & pch -> downl ) ; up_write ( & pch -> chan_sem ) ; ppp_disconnect_channel ( pch ) ; pn = ppp_pernet ( pch -> chan_net ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; list_del ( & pch -> list ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; <S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> wake_up_interruptible ( & pch -> file . rwait ) ; if ( atomic_dec_and_test ( & pch -> file . refcnt ) ) ppp_destroy_channel ( pch ) ; }
","<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;
",torvalds@linux/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,CVE-2016-4805,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,2016-05-23T10:59Z,805,<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;,1
807,CWE-125,"CWE-125 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; <S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> } snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , ""%d<S2SV_blank>"" ,
",radare@radare2/52b1526443c1f433087928291d1c3d37a5600515,CVE-2017-15368,https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515,2017-10-16T01:29Z,807,<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto error ; } <S2SV_ModStart> goto error ; },0
810,CWE-20,"CWE-20 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kzfree ( datablob ) ; kzfree ( new_o ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,810,<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return,1
819,CWE-125,"CWE-125 PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Suite_kind : result = PyType_GenericNew ( Suite_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,819,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,1
825,CWE-20,"CWE-20 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * zap = NULL ; int ret ; ret = key_payload_reserve ( key , prep -> datalen ) ; if ( ret < 0 ) return ret ; key -> expiry = prep -> expiry ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> zap = dereference_key_locked ( key ) ; rcu_assign_keypointer ( key , prep -> payload . data [ 0 ] ) ; prep -> payload . data [ 0 ] = NULL ; if ( zap ) call_rcu ( & zap -> rcu , user_free_payload_rcu ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,825,<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap,1
830,CWE-20,"CWE-20 static int aac_send_raw_srb ( struct aac_dev * dev , void __user * arg ) { struct fib * srbfib ; int status ; struct aac_srb * srbcmd = NULL ; struct user_aac_srb * user_srbcmd = NULL ; struct user_aac_srb __user * user_srb = arg ; struct aac_srb_reply __user * user_reply ; struct aac_srb_reply * reply ; u32 fibsize = 0 ; u32 flags = 0 ; s32 rcode = 0 ; u32 data_dir ; void __user * sg_user [ 32 ] ; void * sg_list [ 32 ] ; u32 sg_indx = 0 ; u32 byte_count = 0 ; u32 actual_fibsize64 , actual_fibsize = 0 ; int i ; if ( dev -> in_reset ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb<S2SV_blank>-EBUSY\\n"" ) ) ; return - EBUSY ; } if ( ! capable ( CAP_SYS_ADMIN ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>No<S2SV_blank>permission<S2SV_blank>to<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb\\n"" ) ) ; return - EPERM ; } if ( ! ( srbfib = aac_fib_alloc ( dev ) ) ) { return - ENOMEM ; } aac_fib_init ( srbfib ) ; srbfib -> hw_fib_va -> header . XferState &= ~ cpu_to_le32 ( FastResponseCapable ) ; srbcmd = ( struct aac_srb * ) fib_data ( srbfib ) ; memset ( sg_list , 0 , sizeof ( sg_list ) ) ; if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>data<S2SV_blank>size<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } <S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> rcode = - EINVAL ; goto cleanup ; } user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ) ; if ( ! user_srbcmd ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>make<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>srb\\n"" ) ) ; rcode = - ENOMEM ; goto cleanup ; } if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>srb<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } user_reply = arg + fibsize ; flags = user_srbcmd -> flags ; srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ) ; srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ) ; srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ) ; srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ) ; srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ) ; srbcmd -> flags = cpu_to_le32 ( flags ) ; srbcmd -> retry_limit = 0 ; srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ) ; memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ) ; switch ( flags & ( SRB_DataIn | SRB_DataOut ) ) { case SRB_DataOut : data_dir = DMA_TO_DEVICE ; break ; case ( SRB_DataIn | SRB_DataOut ) : data_dir = DMA_BIDIRECTIONAL ; break ; case SRB_DataIn : data_dir = DMA_FROM_DEVICE ; break ; default : data_dir = DMA_NONE ; } if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>sg<S2SV_blank>entries<S2SV_blank>%d\\n"" , le32_to_cpu ( srbcmd -> sg . count ) ) ) ; rcode = - EINVAL ; goto cleanup ; } actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ) ; actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ) ; if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Bad<S2SV_blank>Size<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>"" ""Raw<S2SV_blank>SRB<S2SV_blank>command<S2SV_blank>calculated<S2SV_blank>fibsize=%lu;%lu<S2SV_blank>"" ""user_srbcmd->sg.count=%d<S2SV_blank>aac_srb=%lu<S2SV_blank>sgentry=%lu;%lu<S2SV_blank>"" ""issued<S2SV_blank>fibsize=%d\\n"" , actual_fibsize , actual_fibsize64 , user_srbcmd -> sg . count , sizeof ( struct aac_srb ) , sizeof ( struct sgentry ) , sizeof ( struct sgentry64 ) , fibsize ) ) ; rcode = - EINVAL ; goto cleanup ; } if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>SG<S2SV_blank>with<S2SV_blank>no<S2SV_blank>direction<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>Raw<S2SV_blank>SRB<S2SV_blank>command\\n"" ) ) ; rcode = - EINVAL ; goto cleanup ; } byte_count = 0 ; if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) { struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; struct sgmap64 * psg = ( struct sgmap64 * ) & srbcmd -> sg ; if ( actual_fibsize64 == fibsize ) { actual_fibsize = actual_fibsize64 ; for ( i = 0 ; i < upsg -> count ; i ++ ) { u64 addr ; void * p ; if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , upsg -> sg [ i ] . count , i , upsg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ] ; addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32 ; sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ) ; psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ) ; byte_count += upsg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ) ; } } else { struct user_sgmap * usg ; usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ) ; if ( ! usg ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Allocation<S2SV_blank>error<S2SV_blank>in<S2SV_blank>Raw<S2SV_blank>SRB<S2SV_blank>command\\n"" ) ) ; rcode = - ENOMEM ; goto cleanup ; } memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ) ; actual_fibsize = actual_fibsize64 ; for ( i = 0 ; i < usg -> count ; i ++ ) { u64 addr ; void * p ; if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { kfree ( usg ) ; rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , usg -> sg [ i ] . count , i , usg -> count ) ) ; kfree ( usg ) ; rcode = - ENOMEM ; goto cleanup ; } sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { kfree ( usg ) ; dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ) ; psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ) ; byte_count += usg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ) ; } kfree ( usg ) ; } srbcmd -> count = cpu_to_le32 ( byte_count ) ; psg -> count = cpu_to_le32 ( sg_indx + 1 ) ; status = aac_fib_send ( ScsiPortCommand64 , srbfib , actual_fibsize , FsaNormal , 1 , 1 , NULL , NULL ) ; } else { struct user_sgmap * upsg = & user_srbcmd -> sg ; struct sgmap * psg = & srbcmd -> sg ; if ( actual_fibsize64 == fibsize ) { struct user_sgmap64 * usg = ( struct user_sgmap64 * ) upsg ; for ( i = 0 ; i < upsg -> count ; i ++ ) { uintptr_t addr ; void * p ; if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , usg -> sg [ i ] . count , i , usg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ] ; addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32 ; sg_user [ i ] = ( void __user * ) addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ) ; byte_count += usg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ) ; } } else { for ( i = 0 ; i < upsg -> count ; i ++ ) { dma_addr_t addr ; void * p ; if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , upsg -> sg [ i ] . count , i , upsg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr = cpu_to_le32 ( addr ) ; byte_count += upsg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ) ; } } srbcmd -> count = cpu_to_le32 ( byte_count ) ; psg -> count = cpu_to_le32 ( sg_indx + 1 ) ; status = aac_fib_send ( ScsiPortCommand , srbfib , actual_fibsize , FsaNormal , 1 , 1 , NULL , NULL ) ; } if ( status == - ERESTARTSYS ) { rcode = - ERESTARTSYS ; goto cleanup ; } if ( status != 0 ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb<S2SV_blank>fib<S2SV_blank>to<S2SV_blank>hba\\n"" ) ) ; rcode = - ENXIO ; goto cleanup ; } if ( flags & SRB_DataIn ) { for ( i = 0 ; i <= sg_indx ; i ++ ) { byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ) ; if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>to<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } } reply = ( struct aac_srb_reply * ) fib_data ( srbfib ) ; if ( copy_to_user ( user_reply , reply , sizeof ( struct aac_srb_reply ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } cleanup : kfree ( user_srbcmd ) ; for ( i = 0 ; i <= sg_indx ; i ++ ) { kfree ( sg_list [ i ] ) ; } if ( rcode != - ERESTARTSYS ) { aac_fib_complete ( srbfib ) ; aac_fib_free ( srbfib ) ; } return rcode ; }
","<S2SV_ModStart> } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( struct aac_fibhdr )
",torvalds@linux/b4789b8e6be3151a955ade74872822f30e8cd914,CVE-2013-6380,https://github.com/torvalds/linux/commit/b4789b8e6be3151a955ade74872822f30e8cd914,2013-11-27T04:43Z,830,"<S2SV_ModStart> cleanup ; } if ( fibsize > dev -> max_fibsize || actual_fibsize64 > fibsize ) { dprintk ( ( KERN_DEBUG ""aacraid: <S2SV_blank> Fib <S2SV_blank> size <S2SV_blank> too <S2SV_blank> large: <S2SV_blank> %u <S2SV_blank> bytes\\n"", dev -> max_fibsize ) ) ; rcode = - EINVAL ; goto cleanup ; } <S2SV_ModStart> -> count ; if ( copy_from_user ( & byte_count, & user_srb -> count, sizeof ( u32 ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid: <S2SV_blank> Not <S2SV_blank> enough <S2SV_blank> bytes <S2SV_blank> to <S2SV_blank> copy <S2SV_blank> data <S2SV_blank> size <S2SV_blank> from <S2SV_blank> user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; }",0
833,CWE-125,"CWE-125 int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { uint8_t * ip ; uint8_t * input ; uint8_t mask ; uint8_t value ; RE_FIBER_LIST fibers ; RE_THREAD_STORAGE * storage ; RE_FIBER * fiber ; RE_FIBER * next_fiber ; int error ; int bytes_matched ; int max_bytes_matched ; int match ; int character_size ; int input_incr ; int kill ; int action ; int result = - 1 ; # define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ; if ( flags & RE_FLAGS_WIDE ) character_size = 2 ; else character_size = 1 ; input = input_data ; input_incr = character_size ; if ( flags & RE_FLAGS_BACKWARDS ) { <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> input_incr = - input_incr ; } <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; bytes_matched = 0 ; error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; fibers . head = fiber ; fibers . tail = fiber ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; while ( fibers . head != NULL ) { fiber = fibers . head ; while ( fiber != NULL ) { ip = fiber -> ip ; action = ACTION_NONE ; switch ( * ip ) { case RE_OPCODE_ANY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_GREEDY : case RE_OPCODE_REPEAT_ANY_UNGREEDY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; break ; case RE_OPCODE_LITERAL : prolog ; if ( flags & RE_FLAGS_NO_CASE ) match = yr_lowercase [ * input ] == yr_lowercase [ * ( ip + 1 ) ] ; else match = ( * input == * ( ip + 1 ) ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 2 ; break ; case RE_OPCODE_MASKED_LITERAL : prolog ; value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; match = ( ( * input & mask ) == value ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 3 ; break ; case RE_OPCODE_CLASS : prolog ; match = CHAR_IN_CLASS ( * input , ip + 1 ) ; if ( ! match && ( flags & RE_FLAGS_NO_CASE ) ) match = CHAR_IN_CLASS ( yr_altercase [ * input ] , ip + 1 ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 33 ; break ; case RE_OPCODE_WORD_CHAR : prolog ; <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_WORD_CHAR : prolog ; <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_SPACE : case RE_OPCODE_NON_SPACE : prolog ; switch ( * input ) { case '<S2SV_blank>' : case '\\t' : case '\\r' : case '\\n' : case '\\v' : case '\\f' : match = TRUE ; break ; default : match = FALSE ; } if ( * ip == RE_OPCODE_NON_SPACE ) match = ! match ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_DIGIT : prolog ; match = isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_DIGIT : prolog ; match = ! isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> ! ( flags & RE_FLAGS_BACKWARDS ) ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> else if ( bytes_matched >= max_bytes_matched ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> match = TRUE ; else match = FALSE ; if ( * ip == RE_OPCODE_NON_WORD_BOUNDARY ) match = ! match ; action = match ? ACTION_CONTINUE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> else <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH : result = bytes_matched ; if ( flags & RE_FLAGS_EXHAUSTIVE ) { if ( callback != NULL ) { int cb_result ; if ( flags & RE_FLAGS_BACKWARDS ) cb_result = callback ( input + character_size , bytes_matched , flags , callback_args ) ; else cb_result = callback ( input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } } action = ACTION_KILL ; } else { action = ACTION_KILL_TAIL ; } break ; default : assert ( FALSE ) ; } switch ( action ) { case ACTION_KILL : fiber = _yr_re_fiber_kill ( & fibers , & storage -> fiber_pool , fiber ) ; break ; case ACTION_KILL_TAIL : _yr_re_fiber_kill_tail ( & fibers , & storage -> fiber_pool , fiber ) ; fiber = NULL ; break ; case ACTION_CONTINUE : error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; break ; default : next_fiber = fiber -> next ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; fiber = next_fiber ; } <S2SV_StartBug> } <S2SV_EndBug> if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) { _yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ; } input += input_incr ; bytes_matched += character_size ; if ( flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched ) { error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; _yr_re_fiber_append ( & fibers , fiber ) ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; } } return result ; }
","<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> ( bytes_matched >= <S2SV_ModStart> >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ( e ) { <S2SV_ModStart> 4 ; } } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } else { <S2SV_ModStart> ) yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT ) <S2SV_ModStart> RE_SCAN_LIMIT ) ; } <S2SV_ModStart> ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> == 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = TRUE <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> >= max_bytes_matched ) { <S2SV_ModStart> = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input - <S2SV_ModStart> input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched <S2SV_ModStart> & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> next_fiber ; } <S2SV_ModEnd> } input +=
",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z,833,"<S2SV_ModStart> input_data, size_t input_forwards_size, size_t input_backwards_size <S2SV_ModEnd>, int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> bytes_matched >= max_bytes_matched <S2SV_ModStart> >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_ModStart> ) yr_min ( input_backwards_size <S2SV_ModEnd>, RE_SCAN_LIMIT ) <S2SV_ModStart> } max_bytes_matched = ( int ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> } max_bytes_matched = ( int ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> } max_bytes_matched = ( int ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> } max_bytes_matched = ( int ) yr_min ( input_backwards_size,",0
843,CWE-20,"CWE-20 static int check_symlinks ( struct archive_write_disk * a ) { <S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; <S2SV_StartBug> } <S2SV_EndBug> a -> pst = NULL ; <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>remove<S2SV_blank>intervening<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> ( a -> <S2SV_ModStart> name , & error_number , & error_string , a -> flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string ) ; <S2SV_ModStart> = NULL ; return rc ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9,CVE-2016-5418,https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9,2016-09-21T14:25Z,843,"<S2SV_ModStart> a ) { if (! ( a -> flags & ARCHIVE_EXTRACT_SYMLINKS ) ) { archive_set_error ( & a -> archive, 0, ""Symlinks <S2SV_blank> are <S2SV_blank> not <S2SV_blank> supported"" ) ; return ( ARCHIVE_FAILED ) ; } <S2SV_ModStart> = '\\0' ; if ( lstat ( a -> name, & st ) < 0 ) { archive_set_error ( & a -> archive, errno, ""File <S2SV_blank> does <S2SV_blank> not <S2SV_blank> exist"" ) ; return ( ARCHIVE_FAILED ) ; } else if ( S_ISLNK ( st. st_mode ) ) { if ( unlink ( a -> name )!= 0 ) { archive_set_error ( & a -> archive, 0, ""Could <S2SV_blank> not <S2SV_blank> remove <S2SV_blank> symlink <S2SV_blank> %s"", a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st. st_mode ) ) { if ( unlink ( a -> name )!= 0 ) { archive_set_error ( & a -> archive, 0, ""Cannot <S2SV_blank> remove <S2SV_blank> intervening <S2SV_blank> symlink <S2SV_blank> %s"",",0
847,CWE-20,"CWE-20 int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { <S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; <S2SV_StartBug> data ++ ; <S2SV_EndBug> for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
","<S2SV_ModStart> dst_size ) { GetByteContext gb <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> data ) ; <S2SV_ModStart> data ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name , <S2SV_ModStart> , name , <S2SV_ModEnd> dst , dst_size <S2SV_ModStart> dst , dst_size ) <S2SV_ModEnd> ; } <S2SV_null>
",FFmpeg@FFmpeg/ffcc82219cef0928bed2d558b19ef6ea35634130,CVE-2017-11665,https://github.com/FFmpeg/FFmpeg/commit/ffcc82219cef0928bed2d558b19ef6ea35634130,2017-07-27T12:29Z,847,"<S2SV_ModStart> dst_size ) { uint16_t namelen ; <S2SV_ModStart> data < data_end && data < data_end <S2SV_ModStart> - 1 ; namelen = strlen ( name ) ; <S2SV_ModStart> += len ; <S2SV_ModEnd> for ( ; <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; if (! memcmp ( data, name, namelen ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst, dst_size, ""%g"", av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst, dst_size, ""%s"", * data? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst, data, ff_amf_tag_size ( data, data_end ) ) ; if ( len < 0 || len >= data_end -",0
855,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,855,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
863,CWE-787,"CWE-787 static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d<S2SV_blank>PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; <S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
","<S2SV_ModStart> 0x02 ) ; if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;
",OpenSC@OpenSC/9d294de90d1cc66956389856e60b6944b27b4817,CVE-2020-26572,https://github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817,2020-10-06T02:15Z,863,"<S2SV_ModStart> 0x02 ) ; if ( crgram_len > 0 ) { <S2SV_ModStart>, crgram, crgram_len - 1 <S2SV_ModEnd> ) ; }",0
864,CWE-787,"CWE-787 static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , ""mcs_recv_connect_response(),<S2SV_blank>result=%d"" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
","<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,864,"<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if (! s_check_rem ( s, length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(), <S2SV_blank> consume <S2SV_blank> connect <S2SV_blank> id <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; }",1
869,CWE-20,"CWE-20 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
",torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z,869,<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;,1
870,CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; } } return - 1 ;
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,870,<S2SV_ModStart> } } } <S2SV_null> <S2SV_null>,0
875,CWE-20,"CWE-20 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; <S2SV_StartBug> if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) ) <S2SV_EndBug> goto out ; if ( mem -> slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = & kvm -> memslots -> memslots [ mem -> slot ] ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; # ifndef CONFIG_S390 if ( npages && ! new . rmap ) { new . rmap = vzalloc ( npages * sizeof ( * new . rmap ) ) ; if ( ! new . rmap ) goto out_free ; new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; } if ( ! npages ) goto skip_lpage ; for ( i = 0 ; i < KVM_NR_PAGE_SIZES - 1 ; ++ i ) { unsigned long ugfn ; unsigned long j ; int lpages ; int level = i + 2 ; ( void ) level ; if ( new . lpage_info [ i ] ) continue ; lpages = 1 + ( ( base_gfn + npages - 1 ) >> KVM_HPAGE_GFN_SHIFT ( level ) ) ; lpages -= base_gfn >> KVM_HPAGE_GFN_SHIFT ( level ) ; new . lpage_info [ i ] = vzalloc ( lpages * sizeof ( * new . lpage_info [ i ] ) ) ; if ( ! new . lpage_info [ i ] ) goto out_free ; if ( base_gfn & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) ) new . lpage_info [ i ] [ 0 ] . write_count = 1 ; if ( ( base_gfn + npages ) & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) ) new . lpage_info [ i ] [ lpages - 1 ] . write_count = 1 ; ugfn = new . userspace_addr >> PAGE_SHIFT ; if ( ( base_gfn ^ ugfn ) & ( KVM_PAGES_PER_HPAGE ( level ) - 1 ) || ! largepages_enabled ) for ( j = 0 ; j < lpages ; ++ j ) new . lpage_info [ i ] [ j ] . write_count = 1 ; } skip_lpage : if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } # else new . user_alloc = user_alloc ; if ( user_alloc ) new . userspace_addr = mem -> userspace_addr ; # endif if ( ! npages ) { r = - ENOMEM ; slots = kzalloc ( sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; memcpy ( slots , kvm -> memslots , sizeof ( struct kvm_memslots ) ) ; if ( mem -> slot >= slots -> nmemslots ) slots -> nmemslots = mem -> slot + 1 ; slots -> generation ++ ; slots -> memslots [ mem -> slot ] . flags |= KVM_MEMSLOT_INVALID ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow ( kvm ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } r = - ENOMEM ; slots = kzalloc ( sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; memcpy ( slots , kvm -> memslots , sizeof ( struct kvm_memslots ) ) ; if ( mem -> slot >= slots -> nmemslots ) slots -> nmemslots = mem -> slot + 1 ; slots -> generation ++ ; if ( ! npages ) { new . rmap = NULL ; new . dirty_bitmap = NULL ; for ( i = 0 ; i < KVM_NR_PAGE_SIZES - 1 ; ++ i ) new . lpage_info [ i ] = NULL ; } slots -> memslots [ mem -> slot ] = new ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
","<S2SV_ModStart> ( user_alloc && ( <S2SV_ModStart> PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size
",torvalds@linux/fa3d315a4ce2c0891cdde262562e710d95fba19e,CVE-2013-1943,https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e,2013-07-16T14:08Z,875,"<S2SV_ModStart> ( user_alloc && ( <S2SV_ModStart> PAGE_SIZE - 1 ) ) ||! access_ok ( VERIFY_WRITE, mem -> userspace_addr, mem -> memory_size",1
878,CWE-125,"CWE-125 static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { <S2SV_StartBug> PyObject * u ; <S2SV_EndBug> char * buf ; char * p ; <S2SV_StartBug> const char * end ; <S2SV_EndBug> if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; <S2SV_StartBug> if ( * s & 0x80 ) { <S2SV_EndBug> strcpy ( p , ""u005c"" ) ; <S2SV_StartBug> p += 5 ; <S2SV_EndBug> } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } <S2SV_StartBug> assert ( p - buf <= Py_SIZE ( u ) ) ; <S2SV_EndBug> Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; <S2SV_StartBug> return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { PyObject * v , * <S2SV_ModStart> char * end ; const char * first_invalid_escape <S2SV_ModStart> ; if ( s >= end || <S2SV_ModStart> p += 5 ; if ( s >= end ) break <S2SV_ModStart> - buf <= PyBytes_GET_SIZE <S2SV_ModEnd> ( u ) <S2SV_ModStart> = buf ; v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ; if ( v != NULL && first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_XDECREF ( u ) ; Py_DECREF ( v ) ; return NULL ; } } Py_XDECREF ( u ) ; return v <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,878,"<S2SV_ModStart> len ) { PyObject <S2SV_ModEnd> * u ; <S2SV_ModStart> * p ; <S2SV_ModEnd> const char * <S2SV_ModStart> char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL, len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; if ( p == NULL ) return NULL ; p <S2SV_ModEnd> += 5 ; <S2SV_ModStart> & 0x80 ) { strcpy ( p, ""u005c"" ) ; p <S2SV_ModEnd> += 5 ; <S2SV_ModStart> } assert ( p - buf <= Py_SIZE ( u ) <S2SV_ModEnd> ) ; Py_DECREF <S2SV_ModStart> = buf ; <S2SV_ModEnd> return PyUnicode_DecodeUnicodeEscape ( <S2SV_ModStart>, NULL ) <S2SV_ModEnd> ; } <S2SV_null>",0
879,CWE-125,"CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = ""libevt_record_values_read_event"" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>values."" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data."" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>exceeds<S2SV_blank>maximum."" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ; byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ; # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>size\\t\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size ) ; libcnotify_printf ( ""%s:<S2SV_blank>signature\\t\\t\\t\\t:<S2SV_blank>%c%c%c%c\\n"" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ; libcnotify_printf ( ""%s:<S2SV_blank>record<S2SV_blank>number\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> number ) ; if ( libevt_debug_print_posix_time_value ( function , ""creation<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libevt_debug_print_posix_time_value ( function , ""written<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier\\t\\t\\t:<S2SV_blank>0x%08"" PRIx32 ""\\n"" , function , record_values -> event_identifier ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>code\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> event_identifier & 0x0000ffffUL ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>facility\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>reserved\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>customer<S2SV_blank>flags\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>severity\\t\\t:<S2SV_blank>%"" PRIu32 ""<S2SV_blank>("" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ; libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ; libcnotify_printf ( "")\\n"" ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>type\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>("" , function , record_values -> event_type ) ; libevt_debug_print_event_type ( record_values -> event_type ) ; libcnotify_printf ( "")\\n"" ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>strings\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>category\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , record_values -> event_category ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>flags\\t\\t\\t\\t:<S2SV_blank>0x%04"" PRIx16 ""\\n"" , function , value_16bit ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>closing<S2SV_blank>record<S2SV_blank>values<S2SV_blank>number\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , strings_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>size\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>offset\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>size\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_offset ) ; } # endif record_data_offset = sizeof ( evt_record_event_header_t ) ; if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>or<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_offset != 0 ) { if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_size != 0 ) { if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } } if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) { if ( data_size != 0 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } data_offset = ( uint32_t ) record_data_size - 4 ; } if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( strings_offset != 0 ) { if ( strings_offset < record_data_offset ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( user_sid_offset != 0 ) { members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ; } else if ( strings_offset != 0 ) { members_data_size = strings_offset - ( uint32_t ) record_data_offset ; } if ( strings_offset != 0 ) { strings_size = data_offset - strings_offset ; } if ( data_size != 0 ) { if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( members_data_size != 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>source<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>computer<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( members_data_size > 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>trailing<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif record_data_offset += members_data_size ; } } if ( user_sid_size != 0 ) { <S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += user_sid_size ; } if ( strings_size != 0 ) <S2SV_StartBug> { <S2SV_EndBug> # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( size_copy == 0 ) { strings_data_offset = strings_offset + strings_size - 2 ; while ( strings_data_offset > strings_offset ) { if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) { strings_size += 2 ; break ; } strings_data_offset -= 2 ; strings_size -= 2 ; } } if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } record_data_offset += strings_size ; } if ( data_size != 0 ) { <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ; # endif } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { if ( record_data_offset < ( record_data_size - 4 ) ) { libcnotify_printf ( ""%s:<S2SV_blank>padding:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } libcnotify_printf ( ""%s:<S2SV_blank>size<S2SV_blank>copy\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size_copy ) ; libcnotify_printf ( ""\\n"" ) ; } # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) { size_copy = size ; } if ( size != size_copy ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size<S2SV_blank>copy."" , function ) ; goto on_error ; } if ( record_data_size != ( size_t ) size ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>record_values<S2SV_blank>data<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size."" , function ) ; goto on_error ; } return ( 1 ) ; on_error : if ( record_values -> data != NULL ) { libfvalue_value_free ( & ( record_values -> data ) , NULL ) ; } if ( record_values -> strings != NULL ) { libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ; } if ( record_values -> user_security_identifier != NULL ) { libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ; } if ( record_values -> computer_name != NULL ) { libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ; } if ( record_values -> source_name != NULL ) { libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - record_data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> ( record_data [ record_data_offset <S2SV_ModEnd> ] ) ,
",libyal@libevt/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e,CVE-2018-8754,https://github.com/libyal/libevt/commit/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e,2018-03-18T03:29Z,879,"<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS, ""%s: <S2SV_blank> user <S2SV_blank> SID <S2SV_blank> data <S2SV_blank> size <S2SV_blank> value <S2SV_blank> out <S2SV_blank> of <S2SV_blank> bounds."", function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS, ""%s: <S2SV_blank> strings <S2SV_blank> size <S2SV_blank> value <S2SV_blank> out <S2SV_blank> of <S2SV_blank> bounds."", function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_VALUE_OUT",0
882,CWE-125,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; <S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> while ( len > 0 ) { <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> return ; } <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z,882,<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;,0
883,CWE-20,"CWE-20 static int _snd_timer_stop ( struct snd_timer_instance * timeri , int keep_flag , int event ) { struct snd_timer * timer ; unsigned long flags ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { if ( ! keep_flag ) { spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> } goto __end ; } timer = timeri -> timer ; if ( ! timer ) return - EINVAL ; spin_lock_irqsave ( & timer -> lock , flags ) ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; if ( ( timeri -> flags & SNDRV_TIMER_IFLG_RUNNING ) && ! ( -- timer -> running ) ) { timer -> hw . stop ( timer ) ; if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) { timer -> flags &= ~ SNDRV_TIMER_FLG_RESCHED ; snd_timer_reschedule ( timer , 0 ) ; if ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } } if ( ! keep_flag ) timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; __end : if ( event != SNDRV_TIMER_EVENT_RESOLUTION ) snd_timer_notify1 ( timeri , event ) ; return 0 ; }
","<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,883,<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;,1
884,CWE-20,"CWE-20 void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; <S2SV_StartBug> struct stat stb ; <S2SV_EndBug> enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; <S2SV_StartBug> int setimes , targisdir , wrerrno = 0 ; <S2SV_EndBug> char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; if ( src != NULL && ! iamrecursive && ! Tflag ) { if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>expand<S2SV_blank>pattern"" , __func__ ) ; } for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; goto done ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; size = ( off_t ) ull ; if ( * cp == '\\0' || strchr ( cp , '/' ) != NULL || strcmp ( cp , ""."" ) == 0 || strcmp ( cp , "".."" ) == 0 ) { run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( npatterns > 0 ) { for ( n = 0 ; n < npatterns ; n ++ ) { if ( fnmatch ( patterns [ n ] , cp , 0 ) == 0 ) break ; } if ( n >= npatterns ) SCREWUP ( ""filename<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>request"" ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) == - 1 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect , src ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) == - 1 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) == - 1 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; <S2SV_StartBug> wrerr = NO ; <S2SV_EndBug> statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( ""%s"" , j != EPIPE ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { <S2SV_StartBug> if ( wrerr == NO ) { <S2SV_EndBug> if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; <S2SV_StartBug> if ( count != 0 && wrerr == NO && <S2SV_EndBug> atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && <S2SV_StartBug> ftruncate ( ofd , size ) != 0 ) { <S2SV_EndBug> run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> wrerr = DISPLAYED ; } } <S2SV_StartBug> if ( close ( ofd ) == - 1 ) { <S2SV_EndBug> wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; <S2SV_StartBug> if ( setimes && wrerr == NO ) { <S2SV_EndBug> setimes = 0 ; if ( utimes ( np , tv ) == - 1 ) { <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_EndBug> np , strerror ( errno ) ) ; <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case DISPLAYED : break ; } } done : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; return ; screwup : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> struct stat stb <S2SV_ModEnd> ; BUF * <S2SV_ModStart> , targisdir , wrerr <S2SV_ModEnd> ; char ch <S2SV_ModStart> ; wrerr = 0 <S2SV_ModEnd> ; statbytes = <S2SV_ModStart> { if ( ! wrerr <S2SV_ModEnd> ) { if <S2SV_ModStart> count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> != 0 && ! wrerr <S2SV_ModEnd> && atomicio ( <S2SV_ModStart> count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr <S2SV_ModEnd> && ( ! <S2SV_ModStart> != 0 ) note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( pflag <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> - 1 ) note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( setimes && ! wrerr <S2SV_ModEnd> ) { setimes <S2SV_ModStart> 1 ) { note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_ModStart> ) ) ; } } if ( note_err ( NULL ) == 0 ) <S2SV_ModEnd> ( void ) <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> } done :
",openssh@openssh-portable/aad87b88fc2536b1ea023213729aaf4eaabe1894,CVE-2020-12062,https://github.com/openssh/openssh-portable/commit/aad87b88fc2536b1ea023213729aaf4eaabe1894,2020-06-01T16:15Z,884,"<S2SV_ModStart> BUF buffer ; <S2SV_ModEnd> enum { YES <S2SV_ModStart> ; int setimes <S2SV_ModEnd>, targisdir, <S2SV_ModStart> ; if ( stat ( targ, & stb )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 ) fatal ( ""%s: <S2SV_blank> could <S2SV_blank> not <S2SV_blank> be <S2SV_blank> a <S2SV_blank> directory"", __func__ ) ; if ( stat ( targ, & stb )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_mode )!= 0 ) fatal ( ""%s: <S2SV_blank> could <S2SV_blank> not <S2SV_blank> be <S2SV_blank> a <S2SV_blank> directory"", __func__ ) ; if ( stat ( targ, & stb )!= 0 || <S2SV_ModEnd> S_ISDIR ( stb <S2SV_ModStart>. st_",0
891,CWE-20,"CWE-20 void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; <S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE:<S2SV_blank>rose_write_internal<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>frametype<S2SV_blank>%02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
","<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z,891,<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (,1
894,CWE-416,"CWE-416 static PHP_MINIT_FUNCTION ( zip ) { # ifdef PHP_ZIP_USE_OO zend_class_entry ce ; memcpy ( & zip_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; zip_object_handlers . clone_obj = NULL ; zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ; <S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> zip_object_handlers . read_property = php_zip_read_property ; zip_object_handlers . has_property = php_zip_has_property ; INIT_CLASS_ENTRY ( ce , ""ZipArchive"" , zip_class_functions ) ; ce . create_object = php_zip_object_new ; zip_class_entry = zend_register_internal_class ( & ce TSRMLS_CC ) ; zend_hash_init ( & zip_prop_handlers , 0 , NULL , NULL , 1 ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""status"" , php_zip_status , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""statusSys"" , php_zip_status_sys , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""numFiles"" , php_zip_get_num_files , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""filename"" , NULL , NULL , php_zipobj_get_filename , IS_STRING TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""comment"" , NULL , php_zipobj_get_zip_comment , NULL , IS_STRING TSRMLS_CC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CREATE"" , ZIP_CREATE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""EXCL"" , ZIP_EXCL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CHECKCONS"" , ZIP_CHECKCONS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""OVERWRITE"" , ZIP_OVERWRITE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_NOCASE"" , ZIP_FL_NOCASE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_NODIR"" , ZIP_FL_NODIR ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_COMPRESSED"" , ZIP_FL_COMPRESSED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_UNCHANGED"" , ZIP_FL_UNCHANGED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_DEFAULT"" , ZIP_CM_DEFAULT ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_STORE"" , ZIP_CM_STORE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_SHRINK"" , ZIP_CM_SHRINK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_1"" , ZIP_CM_REDUCE_1 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_2"" , ZIP_CM_REDUCE_2 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_3"" , ZIP_CM_REDUCE_3 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_4"" , ZIP_CM_REDUCE_4 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_IMPLODE"" , ZIP_CM_IMPLODE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_DEFLATE"" , ZIP_CM_DEFLATE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_DEFLATE64"" , ZIP_CM_DEFLATE64 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_PKWARE_IMPLODE"" , ZIP_CM_PKWARE_IMPLODE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_BZIP2"" , ZIP_CM_BZIP2 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_LZMA"" , ZIP_CM_LZMA ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_TERSE"" , ZIP_CM_TERSE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_LZ77"" , ZIP_CM_LZ77 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_WAVPACK"" , ZIP_CM_WAVPACK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_PPMD"" , ZIP_CM_PPMD ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_OK"" , ZIP_ER_OK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_MULTIDISK"" , ZIP_ER_MULTIDISK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_RENAME"" , ZIP_ER_RENAME ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_CLOSE"" , ZIP_ER_CLOSE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_SEEK"" , ZIP_ER_SEEK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_READ"" , ZIP_ER_READ ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_WRITE"" , ZIP_ER_WRITE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_CRC"" , ZIP_ER_CRC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_ZIPCLOSED"" , ZIP_ER_ZIPCLOSED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_NOENT"" , ZIP_ER_NOENT ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_EXISTS"" , ZIP_ER_EXISTS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_OPEN"" , ZIP_ER_OPEN ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_TMPOPEN"" , ZIP_ER_TMPOPEN ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_ZLIB"" , ZIP_ER_ZLIB ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_MEMORY"" , ZIP_ER_MEMORY ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_CHANGED"" , ZIP_ER_CHANGED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_COMPNOTSUPP"" , ZIP_ER_COMPNOTSUPP ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_EOF"" , ZIP_ER_EOF ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_INVAL"" , ZIP_ER_INVAL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_NOZIP"" , ZIP_ER_NOZIP ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_INTERNAL"" , ZIP_ER_INTERNAL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_INCONS"" , ZIP_ER_INCONS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_REMOVE"" , ZIP_ER_REMOVE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_DELETED"" , ZIP_ER_DELETED ) ; php_register_url_stream_wrapper ( ""zip"" , & php_stream_zip_wrapper TSRMLS_CC ) ; # endif le_zip_dir = zend_register_list_destructors_ex ( php_zip_free_dir , NULL , le_zip_dir_name , module_number ) ; le_zip_entry = zend_register_list_destructors_ex ( php_zip_free_entry , NULL , le_zip_entry_name , module_number ) ; return SUCCESS ; }
","<S2SV_ModStart> ; zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
",php@php-src/f6aef68089221c5ea047d4a74224ee3deead99a6,CVE-2016-5773,https://github.com/php/php-src/commit/f6aef68089221c5ea047d4a74224ee3deead99a6?w=1,2016-08-07T10:59Z,894,<S2SV_ModStart> ; zip_object_handlers. get_gc = php_zip_get_gc ; zip_object_handlers.,1
896,CWE-125,"CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>who-are-you<S2SV_blank>request"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" ) ) ; break ; default : ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>len"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , "",<S2SV_blank>subject=DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>subject"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , ""[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]"" ) ) ; break ; } needcomma = 0 ; <S2SV_StartBug> ni6 = ( const struct icmp6_nodeinfo * ) dp ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""success"" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , ""refused"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , ""unknown"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""noop"" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; <S2SV_StartBug> cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; <S2SV_EndBug> if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[TTL=%u]"" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""(%d)"" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? ""T"" : """" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }
","<S2SV_ModStart> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ) + 4 ; ND_TCHECK ( cp [ 0 ] )
",the-tcpdump-group@tcpdump/f4b9e24c7384d882a7f434cc7413925bf871d63e,CVE-2017-13041,https://github.com/the-tcpdump-group/tcpdump/commit/f4b9e24c7384d882a7f434cc7413925bf871d63e,2017-09-14T06:29Z,896,"<S2SV_ModStart> ( ndo, ""%s"", icmp6_tstr <S2SV_ModEnd> ) ) ;",0
899,CWE-416,"CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z,899,<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;,1
903,CWE-20,"CWE-20 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;
",external@libavc/d4841f1161bdb5e13cb19e81af42437a634dd6ef,CVE-2016-3755,https://android.googlesource.com/platform/external/libavc/+/d4841f1161bdb5e13cb19e81af42437a634dd6ef,2016-07-11T01:59Z,903,<S2SV_ModStart> } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; <S2SV_ModStart> ; } } ps_dec -> i2_total_mbs_coded += u1_num_mbs ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec,0
905,CWE-20,"CWE-20 <S2SV_StartBug> int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode ) <S2SV_EndBug> { <S2SV_StartBug> int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ; <S2SV_EndBug> if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) { <S2SV_StartBug> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <S2SV_EndBug> } return result ; }
","<S2SV_ModStart> inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> int result = <S2SV_ModStart> , inode , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> , inode , flags | RR_REGARD_XA <S2SV_ModEnd> ) ; }
",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z,905,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static inline bool <S2SV_ModEnd> parse_rock_ridge_inode ( struct <S2SV_ModStart> inode, 0, NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; result = <S2SV_ModEnd> parse_rock_ridge_inode_internal ( de <S2SV_ModStart>, inode, 14, NULL <S2SV_ModEnd> ) ; }",0
912,CWE-125,"CWE-125 static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) { const size_t base_len = strlen ( base_name ) ; <S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> for ( dom = state -> head ; dom ; dom = dom -> next ) { if ( ! n -- ) { const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ; const int postfix_len = dom -> len ; char * const newname = ( char * ) mm_malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ; if ( ! newname ) return NULL ; memcpy ( newname , base_name , base_len ) ; if ( need_to_append_dot ) newname [ base_len ] = '.' ; memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ; newname [ base_len + need_to_append_dot + postfix_len ] = 0 ; return newname ; } } EVUTIL_ASSERT ( 0 ) ; return NULL ; }
","<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom
",libevent@libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,CVE-2016-10197,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,2017-03-15T15:59Z,912,<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if (! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom,1
914,CWE-20,"CWE-20 static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int copied = 0 ; int target ; int err = 0 ; long timeo ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> err = - EAGAIN ; if ( sk -> sk_state == CAIF_CONNECTING ) goto out ; caif_read_lock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { int chunk ; struct sk_buff * skb ; lock_sock ( sk ) ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; caif_check_flow_release ( sk ) ; if ( skb == NULL ) { if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; err = - ECONNRESET ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; err = - EPIPE ; if ( sk -> sk_state != CAIF_CONNECTED ) goto unlock ; if ( sock_flag ( sk , SOCK_DEAD ) ) goto unlock ; release_sock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; caif_read_unlock ( sk ) ; timeo = caif_stream_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } caif_read_lock ( sk ) ; continue ; unlock : release_sock ( sk ) ; break ; } release_sock ( sk ) ; chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; caif_read_unlock ( sk ) ; out : return copied ? : err ; }
","<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,914,<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -,1
916,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,916,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if (! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if (! <S2SV_ModStart> i ], context -> priv -> PlaneBuffersLength, originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;",1
925,CWE-125,"CWE-125 static PyObject * ast_type_reduce ( PyObject * self , PyObject * unused ) { <S2SV_StartBug> PyObject * res ; <S2SV_EndBug> _Py_IDENTIFIER ( __dict__ ) ; <S2SV_StartBug> PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ ) ; <S2SV_EndBug> if ( dict == NULL ) { if ( PyErr_ExceptionMatches ( PyExc_AttributeError ) ) PyErr_Clear ( ) ; else return NULL ; } if ( dict ) { <S2SV_StartBug> res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ; <S2SV_EndBug> Py_DECREF ( dict ) ; return res ; } return Py_BuildValue ( ""O()"" , Py_TYPE ( self ) ) ; }
","<S2SV_ModStart> unused ) { <S2SV_ModEnd> _Py_IDENTIFIER ( __dict__ <S2SV_ModStart> PyObject * dict ; if ( lookup_attr_id <S2SV_ModEnd> ( self , <S2SV_ModStart> , & PyId___dict__ , & dict ) < 0 ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> dict ) { return Py_BuildValue ( ""O()N"" <S2SV_ModEnd> , Py_TYPE ( <S2SV_ModStart> , dict ) <S2SV_ModEnd> ; } return
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,925,"<S2SV_ModStart> unused ) { <S2SV_ModEnd> _Py_IDENTIFIER ( __dict__ <S2SV_ModStart> * res ; _Py_IDENTIFIER ( __dict__ ) ; <S2SV_ModStart> * dict = _PyObject_GetAttrId <S2SV_ModEnd> ( self, <S2SV_ModStart> ( self, & PyId___dict__ ) ; if ( dict == NULL ) { if ( PyErr_ExceptionMatches ( PyExc_AttributeError ) ) PyErr_Clear ( ) ; else return NULL ; } <S2SV_ModStart> ) { res = _Py_BuildValue ( ""O()O"", Py_TYPE ( self ), dict ) ; Py_DECREF ( dict ) ; return res ; } <S2SV_ModEnd> return Py_BuildValue (",0
936,CWE-125,"CWE-125 u_int chdlc_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , register const u_char * p ) { <S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> register u_int caplen = h -> caplen ; if ( caplen < CHDLC_HDRLEN ) { ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ( caplen ) ; } <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> p ) { return <S2SV_ModEnd> chdlc_print ( ndo <S2SV_ModStart> , p , h -> len <S2SV_ModEnd> ) ; }
",the-tcpdump-group@tcpdump/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d,CVE-2017-13687,https://github.com/the-tcpdump-group/tcpdump/commit/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d,2017-09-14T06:29Z,936,"<S2SV_ModStart> p ) { return <S2SV_ModEnd> chdlc_print ( ndo <S2SV_ModStart>, p, h -> len <S2SV_ModEnd> ) ; }",1
937,CWE-20,"CWE-20 int cifs_mount ( struct super_block * sb , struct cifs_sb_info * cifs_sb , char * mount_data_global , const char * devname ) { int rc ; int xid ; struct smb_vol * volume_info ; struct cifsSesInfo * pSesInfo ; struct cifsTconInfo * tcon ; struct TCP_Server_Info * srvTcp ; char * full_path ; char * mount_data = mount_data_global ; struct tcon_link * tlink ; # ifdef CONFIG_CIFS_DFS_UPCALL struct dfs_info3_param * referrals = NULL ; unsigned int num_referrals = 0 ; int referral_walks_count = 0 ; try_mount_again : # endif rc = 0 ; tcon = NULL ; pSesInfo = NULL ; srvTcp = NULL ; full_path = NULL ; tlink = NULL ; xid = GetXid ( ) ; volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ) ; if ( ! volume_info ) { rc = - ENOMEM ; goto out ; } if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) ) { rc = - EINVAL ; goto out ; } if ( volume_info -> nullauth ) { cFYI ( 1 , ""null<S2SV_blank>user"" ) ; volume_info -> username = """" ; } else if ( volume_info -> username ) { cFYI ( 1 , ""Username:<S2SV_blank>%s"" , volume_info -> username ) ; } else { cifserror ( ""No<S2SV_blank>username<S2SV_blank>specified"" ) ; rc = - EINVAL ; goto out ; } if ( volume_info -> iocharset == NULL ) { volume_info -> local_nls = load_nls_default ( ) ; } else { volume_info -> local_nls = load_nls ( volume_info -> iocharset ) ; if ( volume_info -> local_nls == NULL ) { cERROR ( 1 , ""CIFS<S2SV_blank>mount<S2SV_blank>error:<S2SV_blank>iocharset<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found"" , volume_info -> iocharset ) ; rc = - ELIBACC ; goto out ; } } cifs_sb -> local_nls = volume_info -> local_nls ; srvTcp = cifs_get_tcp_session ( volume_info ) ; if ( IS_ERR ( srvTcp ) ) { rc = PTR_ERR ( srvTcp ) ; goto out ; } pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ) ; if ( IS_ERR ( pSesInfo ) ) { rc = PTR_ERR ( pSesInfo ) ; pSesInfo = NULL ; goto mount_fail_check ; } setup_cifs_sb ( volume_info , cifs_sb ) ; if ( pSesInfo -> capabilities & CAP_LARGE_FILES ) sb -> s_maxbytes = MAX_LFS_FILESIZE ; else sb -> s_maxbytes = MAX_NON_LFS ; sb -> s_time_gran = 100 ; tcon = cifs_get_tcon ( pSesInfo , volume_info ) ; if ( IS_ERR ( tcon ) ) { rc = PTR_ERR ( tcon ) ; tcon = NULL ; goto remote_path_check ; } if ( ! tcon -> ipc ) { CIFSSMBQFSDeviceInfo ( xid , tcon ) ; CIFSSMBQFSAttributeInfo ( xid , tcon ) ; } if ( tcon -> ses -> capabilities & CAP_UNIX ) reset_cifs_unix_caps ( xid , tcon , sb , volume_info ) ; else tcon -> unix_ext = 0 ; if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) ) { cifs_sb -> rsize = 1024 * 127 ; cFYI ( DBG2 , ""no<S2SV_blank>very<S2SV_blank>large<S2SV_blank>read<S2SV_blank>support,<S2SV_blank>rsize<S2SV_blank>now<S2SV_blank>127K"" ) ; } if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) ) cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) ) cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; remote_path_check : <S2SV_StartBug> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <S2SV_EndBug> full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto mount_fail_check ; } rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ) ; if ( rc != 0 && rc != - EREMOTE ) { kfree ( full_path ) ; goto mount_fail_check ; } kfree ( full_path ) ; } if ( rc == - EREMOTE ) { # ifdef CONFIG_CIFS_DFS_UPCALL if ( referral_walks_count > MAX_NESTED_LINKS ) { rc = - ELOOP ; goto mount_fail_check ; } if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; full_path = build_unc_path_to_root ( volume_info , cifs_sb ) ; if ( IS_ERR ( full_path ) ) { rc = PTR_ERR ( full_path ) ; goto mount_fail_check ; } cFYI ( 1 , ""Getting<S2SV_blank>referral<S2SV_blank>for:<S2SV_blank>%s"" , full_path ) ; rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ) ; if ( ! rc && num_referrals > 0 ) { char * fake_devname = NULL ; if ( mount_data != mount_data_global ) kfree ( mount_data ) ; mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ) ; free_dfs_info_array ( referrals , num_referrals ) ; kfree ( fake_devname ) ; kfree ( full_path ) ; if ( IS_ERR ( mount_data ) ) { rc = PTR_ERR ( mount_data ) ; mount_data = NULL ; goto mount_fail_check ; } if ( tcon ) cifs_put_tcon ( tcon ) ; else if ( pSesInfo ) cifs_put_smb_ses ( pSesInfo ) ; cleanup_volume_info ( & volume_info ) ; referral_walks_count ++ ; FreeXid ( xid ) ; goto try_mount_again ; } # else rc = - EOPNOTSUPP ; # endif } if ( rc ) goto mount_fail_check ; tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ) ; if ( tlink == NULL ) { rc = - ENOMEM ; goto mount_fail_check ; } tlink -> tl_uid = pSesInfo -> linux_uid ; tlink -> tl_tcon = tcon ; tlink -> tl_time = jiffies ; set_bit ( TCON_LINK_MASTER , & tlink -> tl_flags ) ; set_bit ( TCON_LINK_IN_TREE , & tlink -> tl_flags ) ; cifs_sb -> master_tlink = tlink ; spin_lock ( & cifs_sb -> tlink_tree_lock ) ; tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ) ; spin_unlock ( & cifs_sb -> tlink_tree_lock ) ; queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ) ; mount_fail_check : if ( rc ) { if ( mount_data != mount_data_global ) kfree ( mount_data ) ; if ( tcon ) cifs_put_tcon ( tcon ) ; else if ( pSesInfo ) cifs_put_smb_ses ( pSesInfo ) ; else cifs_put_tcp_session ( srvTcp ) ; goto out ; } out : cleanup_volume_info ( & volume_info ) ; FreeXid ( xid ) ; return rc ; }
","<S2SV_ModStart> ( ! rc <S2SV_ModEnd> && tcon )
",torvalds@linux/70945643722ffeac779d2529a348f99567fa5c33,CVE-2011-3363,https://github.com/torvalds/linux/commit/70945643722ffeac779d2529a348f99567fa5c33,2012-05-24T23:55Z,937,"<S2SV_ModStart> = 0 ; rc = cifs_read_sb_info ( cifs_sb, xid, & cifs_smb_cache, & cifs_sb -> smb_cache ) ; if ( rc ) goto out ;",0
938,CWE-125,"CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && <S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }
","<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,938,<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (,1
944,CWE-416,"CWE-416 struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; <S2SV_StartBug> } <S2SV_EndBug> return opt2 ; }
","<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,944,"<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt, 1 ) ;",1
945,CWE-20,"CWE-20 __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_arch_events_quirk ) ; switch ( boot_cpu_data . x86_model ) { case 14 : pr_cont ( ""Core<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 15 : x86_add_quirk ( intel_clovertown_quirk ) ; case 22 : case 23 : case 29 : memcpy ( hw_cache_event_ids , core2_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_core ( ) ; x86_pmu . event_constraints = intel_core2_event_constraints ; x86_pmu . pebs_constraints = intel_core2_pebs_event_constraints ; pr_cont ( ""Core2<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 26 : case 30 : case 46 : memcpy ( hw_cache_event_ids , nehalem_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_nehalem_event_constraints ; x86_pmu . pebs_constraints = intel_nehalem_pebs_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . extra_regs = intel_nehalem_extra_regs ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; x86_add_quirk ( intel_nehalem_quirk ) ; pr_cont ( ""Nehalem<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 28 : case 38 : case 39 : case 53 : case 54 : memcpy ( hw_cache_event_ids , atom_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_atom ( ) ; x86_pmu . event_constraints = intel_gen_event_constraints ; x86_pmu . pebs_constraints = intel_atom_pebs_event_constraints ; pr_cont ( ""Atom<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 37 : case 44 : case 47 : memcpy ( hw_cache_event_ids , westmere_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_westmere_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . pebs_constraints = intel_westmere_pebs_event_constraints ; x86_pmu . extra_regs = intel_westmere_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""Westmere<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 42 : case 45 : x86_add_quirk ( intel_sandybridge_quirk ) ; memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_snb_event_constraints ; x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""SandyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 58 : case 62 : memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_ivb_event_constraints ; x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ; <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> x86_pmu . extra_regs = intel_snb_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""IvyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; default : switch ( x86_pmu . version ) { case 1 : x86_pmu . event_constraints = intel_v1_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon<S2SV_blank>v1,<S2SV_blank>"" ) ; break ; default : x86_pmu . event_constraints = intel_gen_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon,<S2SV_blank>"" ) ; break ; } } if ( x86_pmu . num_counters > INTEL_PMC_MAX_GENERIC ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters , INTEL_PMC_MAX_GENERIC ) ; x86_pmu . num_counters = INTEL_PMC_MAX_GENERIC ; } x86_pmu . intel_ctrl = ( 1 << x86_pmu . num_counters ) - 1 ; if ( x86_pmu . num_counters_fixed > INTEL_PMC_MAX_FIXED ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>fixed<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters_fixed , INTEL_PMC_MAX_FIXED ) ; x86_pmu . num_counters_fixed = INTEL_PMC_MAX_FIXED ; } x86_pmu . intel_ctrl |= ( ( 1LL << x86_pmu . num_counters_fixed ) - 1 ) << INTEL_PMC_IDX_FIXED ; if ( x86_pmu . event_constraints ) { for_each_event_constraint ( c , x86_pmu . event_constraints ) { if ( c -> cmask != X86_RAW_EVENT_MASK || c -> idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES ) { continue ; } c -> idxmsk64 |= ( 1ULL << x86_pmu . num_counters ) - 1 ; c -> weight += x86_pmu . num_counters ; } } return 0 ; }
","<S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
",torvalds@linux/f1923820c447e986a9da0fc6bf60c1dccdf0408e,CVE-2013-2146,https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e,2013-06-07T14:03Z,945,"<S2SV_ModStart> ; if ( cpu_has ( & boot_cpu_data, X86_FEATURE_ARCH_PERFMON ) ) { if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask |= ( 1ULL << eax. split. bit_width ) - 1 ; if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask |= ( 1ULL << eax. split. bit_width ) - 1 ; } else if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask &= ( 1ULL << eax. split. bit_width ) - 1 ; if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask |= ( 1ULL << eax. split. bit_width ) - 1 ;",0
952,CWE-125,"CWE-125 static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; <S2SV_StartBug> int ret , n ; <S2SV_EndBug> quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class<S2SV_blank>descriptor<S2SV_blank>not<S2SV_blank>present\\n"" ) ; return - ENODEV ; } <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird<S2SV_blank>size<S2SV_blank>of<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>(%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
","<S2SV_ModStart> ret , n ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> hdesc -> bCountryCode ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> ; n < num_descriptors <S2SV_ModEnd> ; n ++
",torvalds@linux/f043bfc98c193c284e2cd768fefabe18ac2fed9b,CVE-2017-16533,https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b,2017-11-04T01:29Z,952,"<S2SV_ModStart> ret, n ; if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid <S2SV_blank> descriptor <S2SV_blank> is <S2SV_blank> too <S2SV_blank> short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid <S2SV_blank> descriptor <S2SV_blank> is <S2SV_blank> too <S2SV_blank> short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> bCountryCode ; for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ]. bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ]. wDescriptorLength ) ; if ( rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird <S2SV_blank> size <S2SV_blank> of <S2SV_blank> report <S2SV_blank> descriptor <S2SV_blank> (%u)\\n"", rsize ) ; return - EINVAL ; }",0
953,CWE-125,"CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z,953,"<S2SV_ModStart> ) { struct ikev2_id id ; unsigned int <S2SV_ModEnd> id_len, idtype_len <S2SV_ModStart> * typedata ; ND_TCHECK2 ( * ext ) ; UNALIGNED_MEMCPY ( & id, ext, sizeof ( id ) ) ; ikev2_pay_print ( ndo, NPSTR ( tpay ), id. h. critical ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo, "" <S2SV_blank> "" ) ) ; if (! rawprint ( ndo, ( const uint8_t * ) ( ext + 1 ), id_len - 4 ) ) goto trunc ; } <S2SV_ModStart> case ID_VPN_ADDR : ND_PRINT ( ( ndo, "" <S2SV_blank> vpx:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo, "" <S2SV_blank> rfc822:"" ) ) ; dumphex = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo, "" <S2SV_blank> ipv6:"" ) ) ; dumpascii = 1 ; break ; case ID",0
956,CWE-416,"CWE-416 static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } <S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
","<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
",mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z,956,"<S2SV_ModStart> data ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_cmpt_t ) ) ; goto error ; } <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_cmpt_t ) ) ; goto error ; } <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_data_t ) ) ; goto error ; } <S2SV_ModStart> ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_data_t ) ) ; goto error ; }",0
958,CWE-787,"CWE-787 VOID ixheaacd_esbr_radix4bfly ( const WORD32 * w , WORD32 * x , WORD32 index1 , WORD32 index ) { int i ; WORD32 l1 , l2 , h2 , fft_jmp ; <S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; WORD32 x_h2_0 , x_h2_1 ; WORD32 si10 , si20 , si30 , co10 , co20 , co30 ; WORD64 mul_1 , mul_2 , mul_3 , mul_4 , mul_5 , mul_6 ; WORD64 mul_7 , mul_8 , mul_9 , mul_10 , mul_11 , mul_12 ; WORD32 * x_l1 ; WORD32 * x_l2 ; WORD32 * x_h2 ; const WORD32 * w_ptr = w ; WORD32 i1 ; h2 = index << 1 ; l1 = index << 2 ; l2 = ( index << 2 ) + ( index << 1 ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; fft_jmp = 6 * ( index ) ; for ( i1 = 0 ; i1 < index1 ; i1 ++ ) { for ( i = 0 ; i < index ; i ++ ) { si10 = ( * w_ptr ++ ) ; co10 = ( * w_ptr ++ ) ; si20 = ( * w_ptr ++ ) ; co20 = ( * w_ptr ++ ) ; si30 = ( * w_ptr ++ ) ; co30 = ( * w_ptr ++ ) ; x_0 = x [ 0 ] ; x_h2_0 = x [ h2 ] ; x_l1_0 = x [ l1 ] ; x_l2_0 = x [ l2 ] ; <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> x_1 = x [ 1 ] ; x_h2_1 = x [ h2 + 1 ] ; x_l1_1 = x [ l1 + 1 ] ; x_l2_1 = x [ l2 + 1 ] ; <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ; mul_3 = ixheaacd_mult64 ( yt2_0 , si30 ) ; x [ l2 ] = ( WORD32 ) ( ( mul_3 + mul_11 ) >> 32 ) << RADIXSHIFT ; mul_5 = ixheaacd_mult64 ( xt2_0 , si30 ) ; mul_9 = ixheaacd_mult64 ( yt2_0 , co30 ) ; x [ l2 + 1 ] = ( WORD32 ) ( ( mul_9 - mul_5 ) >> 32 ) << RADIXSHIFT ; mul_12 = ixheaacd_mult64 ( xt0_0 , co20 ) ; mul_2 = ixheaacd_mult64 ( yt0_0 , si20 ) ; x [ l1 ] = ( WORD32 ) ( ( mul_2 + mul_12 ) >> 32 ) << RADIXSHIFT ; mul_6 = ixheaacd_mult64 ( xt0_0 , si20 ) ; mul_8 = ixheaacd_mult64 ( yt0_0 , co20 ) ; x [ l1 + 1 ] = ( WORD32 ) ( ( mul_8 - mul_6 ) >> 32 ) << RADIXSHIFT ; mul_4 = ixheaacd_mult64 ( xt1_0 , co10 ) ; mul_1 = ixheaacd_mult64 ( yt1_0 , si10 ) ; x [ h2 ] = ( WORD32 ) ( ( mul_1 + mul_4 ) >> 32 ) << RADIXSHIFT ; mul_10 = ixheaacd_mult64 ( xt1_0 , si10 ) ; mul_7 = ixheaacd_mult64 ( yt1_0 , co10 ) ; x [ h2 + 1 ] = ( WORD32 ) ( ( mul_7 - mul_10 ) >> 32 ) << RADIXSHIFT ; x += 2 ; } x += fft_jmp ; w_ptr = w_ptr - fft_jmp ; } }
","<S2SV_ModStart> , fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , yt0_0 <S2SV_ModStart> , yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , xh1_0 <S2SV_ModStart> ; xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xl0_0 <S2SV_ModStart> ; xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xh20_0 <S2SV_ModStart> ; xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; xl20_0 <S2SV_ModStart> ; xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; x <S2SV_ModStart> 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> ; xt0_0 = <S2SV_ModStart> ; xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> xh20_0 ; x_1 <S2SV_ModStart> ; xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xl1_0 <S2SV_ModStart> ; xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xh21_0 <S2SV_ModStart> ; xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; xl21_0 <S2SV_ModStart> ; xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; x <S2SV_ModStart> 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> ; yt0_0 = <S2SV_ModStart> ; yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> xh21_0 ; xt1_0 <S2SV_ModStart> ; xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> xl21_0 ; xt2_0 <S2SV_ModStart> ; xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> xl21_0 ; yt2_0 <S2SV_ModStart> ; yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> xl20_0 ; yt1_0 <S2SV_ModStart> ; yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> xl20_0 ; mul_11
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,958,"<S2SV_ModStart>, fft_jmp ; WORD32 xt0_0, yt1_0, yt1_0, xt2_0, yt2_0 ; WORD32 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0 ; WORD32 x_0, x_1, x_l1_0, x_l1_1, x_l2_0, x_l2_0, x_l2_1 ; WORD32 x_h2_0, x_h2_1 ; WORD32 x_l1_0, x_l1_1, x_l2_0, x_l2_1 ; WORD32 x_l1_0, x_l1_1, x_l2_1 ; WORD32 x_l2_0, x_l2_1 ; WORD32 x_h2_0, x_h2_1 ; WORD32 x_l1_0, x_l1_1 ; WORD32 x_l2_0, x",0
963,CWE-125,"CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }
","<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&
",torvalds@linux/50220dead1650609206efe91f0cc116132d59b3f,CVE-2016-7915,https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f,2016-11-16T05:59Z,963,<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&,1
969,CWE-125,"CWE-125 int dbd_st_prepare ( SV * sth , imp_sth_t * imp_sth , char * statement , SV * attribs ) { int i ; SV * * svp ; dTHX ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION char * str_ptr , * str_last_ptr ; # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION int limit_flag = 0 ; # endif # endif <S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> MYSQL_BIND * bind , * bind_end ; imp_sth_phb_t * fbind ; # endif D_imp_xxh ( sth ) ; D_imp_dbh_from_sth ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_prepare<S2SV_blank>MYSQL_VERSION_ID<S2SV_blank>%d,<S2SV_blank>SQL<S2SV_blank>statement:<S2SV_blank>%s\\n"" , MYSQL_VERSION_ID , statement ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_sth -> use_server_side_prepare = imp_dbh -> use_server_side_prepare ; if ( attribs ) { svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_server_prepare"" , 20 ) ; imp_sth -> use_server_side_prepare = ( svp ) ? SvTRUE ( * svp ) : imp_dbh -> use_server_side_prepare ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""async"" , 5 ) ; if ( svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth , 2000 , ""Async<S2SV_blank>support<S2SV_blank>was<S2SV_blank>not<S2SV_blank>built<S2SV_blank>into<S2SV_blank>this<S2SV_blank>version<S2SV_blank>of<S2SV_blank>DBD::mysql"" , ""HY000"" ) ; return 0 ; # endif } } imp_sth -> fetch_done = 0 ; # endif imp_sth -> done_desc = 0 ; imp_sth -> result = NULL ; imp_sth -> currow = 0 ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_use_result"" , 16 ) ; imp_sth -> use_mysql_use_result = svp ? SvTRUE ( * svp ) : imp_dbh -> use_mysql_use_result ; for ( i = 0 ; i < AV_ATTRIB_LAST ; i ++ ) imp_sth -> av_attr [ i ] = Nullav ; mysql_st_free_result_sets ( sth , imp_sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set,<S2SV_blank>check<S2SV_blank>restrictions\\n"" ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>LIMIT<S2SV_blank>&<S2SV_blank>CALL\\n"" ) ; # else ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>restrictions\\n"" ) ; # endif str_last_ptr = statement + strlen ( statement ) ; for ( str_ptr = statement ; str_ptr < str_last_ptr ; str_ptr ++ ) { # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION if ( limit_flag ) { if ( * str_ptr == '?' ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tLIMIT<S2SV_blank>and<S2SV_blank>?<S2SV_blank>found,<S2SV_blank>set<S2SV_blank>to<S2SV_blank>use_server_side_prepare=0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } else if ( str_ptr < str_last_ptr - 6 && isspace ( * ( str_ptr + 0 ) ) && tolower ( * ( str_ptr + 1 ) ) == 'l' && tolower ( * ( str_ptr + 2 ) ) == 'i' && tolower ( * ( str_ptr + 3 ) ) == 'm' && tolower ( * ( str_ptr + 4 ) ) == 'i' && tolower ( * ( str_ptr + 5 ) ) == 't' && isspace ( * ( str_ptr + 6 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""LIMIT<S2SV_blank>set<S2SV_blank>limit<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>1\\n"" ) ; limit_flag = 1 ; } # endif if ( str_ptr < str_last_ptr - 4 && tolower ( * ( str_ptr + 0 ) ) == 'c' && tolower ( * ( str_ptr + 1 ) ) == 'a' && tolower ( * ( str_ptr + 2 ) ) == 'l' && tolower ( * ( str_ptr + 3 ) ) == 'l' && isspace ( * ( str_ptr + 4 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""Disable<S2SV_blank>PS<S2SV_blank>mode<S2SV_blank>for<S2SV_blank>CALL()\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set\\n"" ) ; if ( imp_sth -> stmt ) fprintf ( stderr , <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ; if ( ! imp_sth -> stmt ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) ) ; } prepare_retval = mysql_stmt_prepare ( imp_sth -> stmt , statement , strlen ( statement ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>returned<S2SV_blank>%d\\n"" , prepare_retval ) ; if ( prepare_retval ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>%d<S2SV_blank>%s\\n"" , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) ) ; if ( mysql_stmt_errno ( imp_sth -> stmt ) == ER_UNSUPPORTED_PS ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tSETTING<S2SV_blank>imp_sth->use_server_side_prepare<S2SV_blank>to<S2SV_blank>0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; } else { do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; mysql_stmt_close ( imp_sth -> stmt ) ; imp_sth -> stmt = NULL ; return FALSE ; } } else { DBIc_NUM_PARAMS ( imp_sth ) = mysql_stmt_param_count ( imp_sth -> stmt ) ; if ( DBIc_NUM_PARAMS ( imp_sth ) > 0 ) { <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> imp_sth -> bind = alloc_bind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> fbind = alloc_fbind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> has_been_bound = 0 ; for ( i = 0 , bind = imp_sth -> bind , fbind = imp_sth -> fbind , bind_end = bind + DBIc_NUM_PARAMS ( imp_sth ) ; bind < bind_end ; bind ++ , fbind ++ , i ++ ) { <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug> imp_sth -> stmt -> fields [ i ] . type : MYSQL_TYPE_STRING ) ; bind -> buffer_type = mysql_to_perl_type ( col_type ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_to_perl_type<S2SV_blank>returned<S2SV_blank>%d\\n"" , col_type ) ; bind -> buffer = NULL ; bind -> length = & ( fbind -> length ) ; bind -> is_null = ( char * ) & ( fbind -> is_null ) ; fbind -> is_null = 1 ; fbind -> length = 0 ; } } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare == 0 ) DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # else DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # endif imp_sth -> params = alloc_param ( DBIc_NUM_PARAMS ( imp_sth ) ) ; DBIc_IMPSET_on ( imp_sth ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_prepare\\n"" ) ; return 1 ; }
","<S2SV_ModStart> # endif int <S2SV_ModEnd> prepare_retval ; MYSQL_BIND <S2SV_ModStart> ( stderr , ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> ) ; imp_sth <S2SV_ModStart> imp_xxh ) , ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> , mysql_errno ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> imp_sth -> bind <S2SV_ModStart> ++ ) { bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ; bind ->
",perl5-dbi@DBD-mysql/793b72b1a0baa5070adacaac0e12fd995a6fbabe,CVE-2016-1249,https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe,2017-02-17T02:59Z,969,<S2SV_ModStart> endif # endif # if defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_MYSQL_BIND ) && defined ( SUPPORT_,0
970,CWE-20,"CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; list_del ( & key -> graveyard_link ) ; kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ; key_check ( key ) ; <S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; # ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC_X ; # endif kmem_cache_free ( key_jar , key ) ; } }
","<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
",torvalds@linux/ce1fad2740c648a4340f6f6c391a8a83769d2e8c,CVE-2015-7872,https://github.com/torvalds/linux/commit/ce1fad2740c648a4340f6f6c391a8a83769d2e8c,2015-11-16T11:59Z,970,"<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_INSTANTIATED, & key -> flags ) &&! test_bit ( KEY_FLAG_NEGATIVE, & key -> flags ) &&",1
973,CWE-20,"CWE-20 int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; <S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }
","<S2SV_ModStart> ; if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> ! handle )
",torvalds@linux/c9b92530a723ac5ef8e352885a1862b18f31b2f5,CVE-2015-7509,https://github.com/torvalds/linux/commit/c9b92530a723ac5ef8e352885a1862b18f31b2f5,2015-12-28T11:59Z,973,<S2SV_ModStart> ; if (! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd>! handle ),1
975,CWE-787,"CWE-787 opj_image_t * pgxtoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f = NULL ; int w , h , prec ; int i , numcomps , max ; OPJ_COLOR_SPACE color_space ; opj_image_cmptparm_t cmptparm ; opj_image_t * image = NULL ; int adjustS , ushift , dshift , force8 ; char endian1 , endian2 , sign ; char signtmp [ 32 ] ; char temp [ 32 ] ; int bigendian ; opj_image_comp_t * comp = NULL ; numcomps = 1 ; color_space = OPJ_CLRSPC_GRAY ; memset ( & cmptparm , 0 , sizeof ( opj_image_cmptparm_t ) ) ; max = 0 ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!\\n"" , filename ) ; return NULL ; } fseek ( f , 0 , SEEK_SET ) ; <S2SV_StartBug> if ( fscanf ( f , ""PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d"" , temp , & endian1 , <S2SV_EndBug> & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose ( f ) ; fprintf ( stderr , ""ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>right<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>from<S2SV_blank>the<S2SV_blank>fscanf()<S2SV_blank>function!\\n"" ) ; return NULL ; } i = 0 ; sign = '+' ; while ( signtmp [ i ] != '\\0' ) { if ( signtmp [ i ] == '-' ) { sign = '-' ; } i ++ ; } fgetc ( f ) ; if ( endian1 == 'M' && endian2 == 'L' ) { bigendian = 1 ; } else if ( endian2 == 'M' && endian1 == 'L' ) { bigendian = 0 ; } else { fclose ( f ) ; fprintf ( stderr , ""Bad<S2SV_blank>pgx<S2SV_blank>header,<S2SV_blank>please<S2SV_blank>check<S2SV_blank>input<S2SV_blank>file\\n"" ) ; return NULL ; } cmptparm . x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; cmptparm . y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; cmptparm . w = ! cmptparm . x0 ? ( OPJ_UINT32 ) ( ( w - 1 ) * parameters -> subsampling_dx + 1 ) : cmptparm . x0 + ( OPJ_UINT32 ) ( w - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1 ; cmptparm . h = ! cmptparm . y0 ? ( OPJ_UINT32 ) ( ( h - 1 ) * parameters -> subsampling_dy + 1 ) : cmptparm . y0 + ( OPJ_UINT32 ) ( h - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1 ; if ( sign == '-' ) { cmptparm . sgnd = 1 ; } else { cmptparm . sgnd = 0 ; } if ( prec < 8 ) { force8 = 1 ; ushift = 8 - prec ; dshift = prec - ushift ; if ( cmptparm . sgnd ) { adjustS = ( 1 << ( prec - 1 ) ) ; } else { adjustS = 0 ; } cmptparm . sgnd = 0 ; prec = 8 ; } else { ushift = dshift = force8 = adjustS = 0 ; } cmptparm . prec = ( OPJ_UINT32 ) prec ; cmptparm . bpp = ( OPJ_UINT32 ) prec ; cmptparm . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = cmptparm . x0 ; image -> y0 = cmptparm . x0 ; image -> x1 = cmptparm . w ; image -> y1 = cmptparm . h ; comp = & image -> comps [ 0 ] ; for ( i = 0 ; i < w * h ; i ++ ) { int v ; if ( force8 ) { v = readuchar ( f ) + adjustS ; v = ( v << ushift ) + ( v >> dshift ) ; comp -> data [ i ] = ( unsigned char ) v ; if ( v > max ) { max = v ; } continue ; } if ( comp -> prec == 8 ) { if ( ! comp -> sgnd ) { v = readuchar ( f ) ; } else { v = ( char ) readuchar ( f ) ; } } else if ( comp -> prec <= 16 ) { if ( ! comp -> sgnd ) { v = readushort ( f , bigendian ) ; } else { v = ( short ) readushort ( f , bigendian ) ; } } else { if ( ! comp -> sgnd ) { v = ( int ) readuint ( f , bigendian ) ; } else { v = ( int ) readuint ( f , bigendian ) ; } } if ( v > max ) { max = v ; } comp -> data [ i ] = v ; } fclose ( f ) ; comp -> bpp = ( OPJ_UINT32 ) int_floorlog2 ( max ) + 1 ; return image ; }
","<S2SV_ModStart> ( f , ""PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d"" <S2SV_ModEnd> , temp ,
",uclouvain@openjpeg/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,CVE-2017-14041,https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,2017-08-30T22:29Z,975,"<S2SV_ModStart> ( f, ""PG%31[ <S2SV_blank> \\t]%c%c%31[ <S2SV_blank> \\t+-]%d%31[ <S2SV_blank> \\t]%d%31[ <S2SV_blank> \\t]%d"" <S2SV_ModEnd>, temp,",1
976,CWE-787,"CWE-787 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; <S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
",coreutils@gnulib/278b4175c9d7dd47c1a3071554aac02add3b3c35,CVE-2018-17942,https://github.com/coreutils/gnulib/commit/278b4175c9d7dd47c1a3071554aac02add3b3c35,2018-10-03T08:29Z,976,"<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf, ""DEADBEEF"", 8 ) ; length = size ; result = my_asnprintf ( buf, & length, ""%d"", 12345 ) ; ASSERT ( result!= NULL ) ; ASSERT ( strcmp ( result, ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; if ( size < 6 + 1 ) ASSERT ( result!= buf ) ; ASSERT ( memcmp ( buf + size, & ""DEADBEEF"" [ size ], 8 - size ) == 0 ) ; if ( result!= buf ) free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf, ""DEADBEEF"", 8 ) ; length = size ; result = my_asnprintf ( buf, & length, ""%d"", 12345 ) ; ASSERT ( result!= NULL ) ; ASSERT ( strcmp ( result, ""12345"" ) == 0 )",0
979,CWE-22,"CWE-22 local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , ""<S2SV_blank>too<S2SV_blank>large<S2SV_blank>--<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>large<S2SV_blank>file<S2SV_blank>support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>special<S2SV_blank>file<S2SV_blank>or<S2SV_blank>device<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>directory<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path<S2SV_blank>too<S2SV_blank>long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s<S2SV_blank>ends<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>compressed<S2SV_blank>suffix<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>compressed<S2SV_blank>--<S2SV_blank>skipping"" : ""%s<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>data<S2SV_blank>to<S2SV_blank>a<S2SV_blank>terminal"" , ""<S2SV_blank>(use<S2SV_blank>-f<S2SV_blank>to<S2SV_blank>force)"" ) ; } else { <S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> to = g . inf ; <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> } <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>overwrite<S2SV_blank>(y/n)?<S2SV_blank>"" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != '<S2SV_blank>' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
","<S2SV_ModStart> char * to = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> g . decode ) { if ( <S2SV_ModEnd> ( g . <S2SV_ModStart> NULL ) { pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> g . hname <S2SV_ModStart> g . hname ) <S2SV_ModStart> = strlen ( to ) ; } else if ( <S2SV_ModEnd> strcmp ( to <S2SV_ModStart> , "".tgz"" ) == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> g . outf <S2SV_ModStart> = MALLOC ( pre + len + strlen ( sufx ) <S2SV_ModEnd> + 1 ) <S2SV_ModStart> . outf , g . inf , pre ) ; memcpy <S2SV_ModEnd> ( g . <S2SV_ModStart> . outf + pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> sufx ) ;
",madler@pigz/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,CVE-2015-1191,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,2015-01-21T18:59Z,979,"<S2SV_ModStart> = "".tgz"" ; if ( ( st. st_mode & S_IFMT ) == S_IFREG ) { complain ( ""%s <S2SV_blank> is <S2SV_blank> a <S2SV_blank> special <S2SV_blank> file <S2SV_blank> or <S2SV_blank> device <S2SV_blank> directory"", g. inf ) ; } else if ( ( st. st_mode & S_IFMT ) == S_IFLNK ) { complain ( ""%s <S2SV_blank> is <S2SV_blank> a <S2SV_blank> special <S2SV_blank> file <S2SV_blank> or <S2SV_blank> device <S2SV_blank> directory"", g. inf ) ; } else if ( ( st. st_mode & S_IFMT ) == S_IFREG ) { complain ( ""%s <S2SV_blank> is <S2SV_blank> a <S2SV_blank> special <S2SV_blank> file <S2SV_blank> or <S2SV_blank> device <S2SV_blank> directory"", g. inf ) ; } else if ( ( st. st_mode & S_IFMT ) == S_IFLNK ) { complain ( ""%s <S2SV_blank> is <S2SV_blank> a <S2SV_blank> special <S2SV_blank> file <S2SV_blank> or <S2SV_blank> device <S2SV_blank> directory"", g. inf ) ; } else if ( ( st. st_mode & S_IFMT ) == S_IFDIR ) { complain ( ""%s <S2SV_blank> is <S2SV_blank> a <S2SV_blank> special <S2SV_blank> file <S2SV_blank> or <S2SV_blank> device <S2SV_blank> directory"", g. inf ) ;",0
983,CWE-20,"CWE-20 static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : <S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }
","<S2SV_ModStart> ( sb , KERN_ERR ,
",torvalds@linux/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,CVE-2013-1848,https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,2013-03-22T11:59Z,983,"<S2SV_ModStart> ; fail : blkdev_put ( bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL ) ;",0
986,CWE-125,"CWE-125 int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }
","<S2SV_ModStart> s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> , s2 , len + 1 <S2SV_ModEnd> ) ; }
",jedisct1@pure-ftpd/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,CVE-2020-9365,https://github.com/jedisct1/pure-ftpd/commit/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,2020-02-24T16:15Z,986,"<S2SV_ModStart> s2 ) { const size_t len = strlen ( s1 ) ; return memcmp <S2SV_ModEnd> ( s1, <S2SV_ModStart> 1U ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",0
991,CWE-20,"CWE-20 int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu"" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,991,<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (,1
992,CWE-125,"CWE-125 PyObject * ast2obj_excepthandler ( void * _o ) { excepthandler_ty o = ( excepthandler_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case ExceptHandler_kind : result = PyType_GenericNew ( ExceptHandler_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . ExceptHandler . type ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> v . ExceptHandler . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ExceptHandler . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,992,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,1
993,CWE-125,"CWE-125 void process_packet_tail ( struct msg_digest * md ) { struct state * st = md -> st ; enum state_kind from_state = md -> v1_from_state ; const struct state_v1_microcode * smc = md -> smc ; bool new_iv_set = md -> new_iv_set ; bool self_delete = FALSE ; if ( md -> hdr . isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION ) { endpoint_buf b ; dbg ( ""received<S2SV_blank>encrypted<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>%s"" , str_endpoint ( & md -> sender , & b ) ) ; if ( st == NULL ) { libreswan_log ( ""discarding<S2SV_blank>encrypted<S2SV_blank>message<S2SV_blank>for<S2SV_blank>an<S2SV_blank>unknown<S2SV_blank>ISAKMP<S2SV_blank>SA"" ) ; return ; } if ( st -> st_skeyid_e_nss == NULL ) { loglog ( RC_LOG_SERIOUS , ""discarding<S2SV_blank>encrypted<S2SV_blank>message<S2SV_blank>because<S2SV_blank>we<S2SV_blank>haven\'t<S2SV_blank>yet<S2SV_blank>negotiated<S2SV_blank>keying<S2SV_blank>material"" ) ; return ; } md -> encrypted = TRUE ; const struct encrypt_desc * e = st -> st_oakley . ta_encrypt ; if ( pbs_left ( & md -> message_pbs ) % e -> enc_blocksize != 0 ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>message:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>encryption<S2SV_blank>blocksize"" ) ; return ; } md -> raw_packet = clone_bytes_as_chunk ( md -> packet_pbs . start , pbs_room ( & md -> packet_pbs ) , ""raw<S2SV_blank>packet"" ) ; if ( ! new_iv_set ) { if ( st -> st_v1_iv . len == 0 ) { init_phase2_iv ( st , & md -> hdr . isa_msgid ) ; } else { restore_new_iv ( st , st -> st_v1_iv ) ; } } passert ( st -> st_v1_new_iv . len >= e -> enc_blocksize ) ; st -> st_v1_new_iv . len = e -> enc_blocksize ; if ( DBGP ( DBG_CRYPT ) ) { DBG_log ( ""decrypting<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>using<S2SV_blank>algorithm<S2SV_blank>%s"" , ( unsigned ) pbs_left ( & md -> message_pbs ) , st -> st_oakley . ta_encrypt -> common . fqn ) ; DBG_dump_hunk ( ""IV<S2SV_blank>before:"" , st -> st_v1_new_iv ) ; } e -> encrypt_ops -> do_crypt ( e , md -> message_pbs . cur , pbs_left ( & md -> message_pbs ) , st -> st_enc_key_nss , st -> st_v1_new_iv . ptr , FALSE ) ; if ( DBGP ( DBG_CRYPT ) ) { DBG_dump_hunk ( ""IV<S2SV_blank>after:"" , st -> st_v1_new_iv ) ; DBG_log ( ""decrypted<S2SV_blank>payload<S2SV_blank>(starts<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%td):"" , md -> message_pbs . cur - md -> message_pbs . roof ) ; DBG_dump ( NULL , md -> message_pbs . start , md -> message_pbs . roof - md -> message_pbs . start ) ; } } else { if ( smc -> flags & SMF_INPUT_ENCRYPTED ) { loglog ( RC_LOG_SERIOUS , ""packet<S2SV_blank>rejected:<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>encrypted"" ) ; SEND_NOTIFICATION ( INVALID_FLAGS ) ; return ; } } { enum next_payload_types_ikev1 np = md -> hdr . isa_np ; lset_t needed = smc -> req_payloads ; const char * excuse = LIN ( SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT , smc -> flags ) ? ""probable<S2SV_blank>authentication<S2SV_blank>failure<S2SV_blank>(mismatch<S2SV_blank>of<S2SV_blank>preshared<S2SV_blank>secrets?):<S2SV_blank>"" : """" ; while ( np != ISAKMP_NEXT_NONE ) { struct_desc * sd = v1_payload_desc ( np ) ; if ( md -> digest_roof >= elemsof ( md -> digest ) ) { loglog ( RC_LOG_SERIOUS , ""more<S2SV_blank>than<S2SV_blank>%zu<S2SV_blank>payloads<S2SV_blank>in<S2SV_blank>message;<S2SV_blank>ignored"" , elemsof ( md -> digest ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } struct payload_digest * const pd = md -> digest + md -> digest_roof ; if ( st != NULL && st -> st_connection != NULL && ( st -> st_connection -> policy & POLICY_AGGRESSIVE ) == LEMPTY ) { switch ( np ) { case ISAKMP_NEXT_NATD_RFC : case ISAKMP_NEXT_NATOA_RFC : if ( ( st -> hidden_variables . st_nat_traversal & NAT_T_WITH_RFC_VALUES ) == LEMPTY ) { DBG ( DBG_NATT , DBG_log ( ""st_nat_traversal<S2SV_blank>was:<S2SV_blank>%s"" , bitnamesof ( natt_bit_names , st -> hidden_variables . st_nat_traversal ) ) ) ; sd = NULL ; } break ; default : break ; } } if ( sd == NULL ) { switch ( np ) { case ISAKMP_NEXT_ID : sd = ( IS_PHASE1 ( from_state ) || IS_PHASE15 ( from_state ) ) ? & isakmp_identification_desc : & isakmp_ipsec_identification_desc ; break ; case ISAKMP_NEXT_NATD_DRAFTS : np = ISAKMP_NEXT_NATD_RFC ; sd = & isakmp_nat_d_drafts ; break ; case ISAKMP_NEXT_NATOA_DRAFTS : np = ISAKMP_NEXT_NATOA_RFC ; sd = & isakmp_nat_oa_drafts ; break ; case ISAKMP_NEXT_SAK : loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>with<S2SV_blank>unsupported<S2SV_blank>payload<S2SV_blank>ISAKMP_NEXT_SAK<S2SV_blank>(or<S2SV_blank>ISAKMP_NEXT_NATD_BADDRAFTS)<S2SV_blank>ignored"" , excuse ) ; if ( ! in_struct ( & pd -> payload , & isakmp_ignore_desc , & md -> message_pbs , & pd -> pbs ) ) { loglog ( RC_LOG_SERIOUS , ""%smalformed<S2SV_blank>payload<S2SV_blank>in<S2SV_blank>packet"" , excuse ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } np = pd -> payload . generic . isag_np ; continue ; default : loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unknown<S2SV_blank>or<S2SV_blank>unexpected<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>at<S2SV_blank>the<S2SV_blank>outermost<S2SV_blank>level"" , excuse , enum_show ( & ikev1_payload_names , np ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( INVALID_PAYLOAD_TYPE ) ; } return ; } passert ( sd != NULL ) ; } passert ( np < LELEM_ROOF ) ; { lset_t s = LELEM ( np ) ; if ( LDISJOINT ( s , needed | smc -> opt_payloads | LELEM ( ISAKMP_NEXT_VID ) | LELEM ( ISAKMP_NEXT_N ) | LELEM ( ISAKMP_NEXT_D ) | LELEM ( ISAKMP_NEXT_CR ) | LELEM ( ISAKMP_NEXT_CERT ) ) ) { loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>unexpected<S2SV_blank>by<S2SV_blank>state<S2SV_blank>%s"" , excuse , enum_show ( & ikev1_payload_names , np ) , <S2SV_StartBug> st -> st_state -> name ) ; <S2SV_EndBug> if ( ! md -> encrypted ) { SEND_NOTIFICATION ( INVALID_PAYLOAD_TYPE ) ; } return ; } DBG ( DBG_PARSING , DBG_log ( ""got<S2SV_blank>payload<S2SV_blank>0x%"" PRIxLSET ""<S2SV_blank><S2SV_blank>(%s)<S2SV_blank>needed:<S2SV_blank>0x%"" PRIxLSET ""<S2SV_blank>opt:<S2SV_blank>0x%"" PRIxLSET , s , enum_show ( & ikev1_payload_names , np ) , needed , smc -> opt_payloads ) ) ; needed &= ~ s ; } pd -> payload_type = np ; if ( ! in_struct ( & pd -> payload , sd , & md -> message_pbs , & pd -> pbs ) ) { loglog ( RC_LOG_SERIOUS , ""%smalformed<S2SV_blank>payload<S2SV_blank>in<S2SV_blank>packet"" , excuse ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } switch ( np ) { case ISAKMP_NEXT_ID : case ISAKMP_NEXT_NATOA_RFC : DBG ( DBG_PARSING , DBG_dump ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>obj:<S2SV_blank>"" , pd -> pbs . cur , pbs_left ( & pd -> pbs ) ) ) ; break ; default : break ; } { passert ( np < elemsof ( md -> chain ) ) ; struct payload_digest * * p = & md -> chain [ np ] ; while ( * p != NULL ) p = & ( * p ) -> next ; * p = pd ; pd -> next = NULL ; } np = pd -> payload . generic . isag_np ; md -> digest_roof ++ ; excuse = """" ; } DBG ( DBG_PARSING , { if ( pbs_left ( & md -> message_pbs ) != 0 ) DBG_log ( ""removing<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>padding"" , ( int ) pbs_left ( & md -> message_pbs ) ) ; } ) ; md -> message_pbs . roof = md -> message_pbs . cur ; if ( needed != 0 ) { loglog ( RC_LOG_SERIOUS , ""message<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>missing<S2SV_blank>payloads<S2SV_blank>%s"" , finite_states [ from_state ] -> name , bitnamesof ( payload_name_ikev1 , needed ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } } if ( ! check_v1_HASH ( smc -> hash_type , smc -> message , st , md ) ) { return ; } if ( IS_PHASE1 ( from_state ) || IS_PHASE15 ( from_state ) ) { if ( md -> chain [ ISAKMP_NEXT_SA ] != NULL && md -> hdr . isa_np != ISAKMP_NEXT_SA ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Phase<S2SV_blank>1<S2SV_blank>message:<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>an<S2SV_blank>SA<S2SV_blank>payload"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } } else if ( IS_QUICK ( from_state ) ) { if ( md -> hdr . isa_np != ISAKMP_NEXT_HASH ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>HASH<S2SV_blank>payload"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } { struct payload_digest * p ; int i ; p = md -> chain [ ISAKMP_NEXT_SA ] ; i = 1 ; while ( p != NULL ) { if ( p != & md -> digest [ i ] ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>SA<S2SV_blank>payload<S2SV_blank>is<S2SV_blank>in<S2SV_blank>wrong<S2SV_blank>position"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } p = p -> next ; i ++ ; } } { struct payload_digest * id = md -> chain [ ISAKMP_NEXT_ID ] ; if ( id != NULL ) { if ( id -> next == NULL || id -> next -> next != NULL ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>if<S2SV_blank>any<S2SV_blank>ID<S2SV_blank>payload<S2SV_blank>is<S2SV_blank>present,<S2SV_blank>there<S2SV_blank>must<S2SV_blank>be<S2SV_blank>exactly<S2SV_blank>two"" ) ; SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; return ; } if ( id + 1 != id -> next ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>the<S2SV_blank>ID<S2SV_blank>payloads<S2SV_blank>are<S2SV_blank>not<S2SV_blank>adjacent"" ) ; SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; return ; } } } } { struct payload_digest * p = md -> chain [ ISAKMP_NEXT_N ] ; while ( p != NULL ) { switch ( p -> payload . notification . isan_type ) { case R_U_THERE : case R_U_THERE_ACK : case ISAKMP_N_CISCO_LOAD_BALANCE : case PAYLOAD_MALFORMED : case INVALID_MESSAGE_ID : case IPSEC_RESPONDER_LIFETIME : if ( md -> hdr . isa_xchg == ISAKMP_XCHG_INFO ) { break ; } default : if ( st == NULL ) { DBG ( DBG_CONTROL , DBG_log ( ""ignoring<S2SV_blank>informational<S2SV_blank>payload<S2SV_blank>%s,<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>state"" , enum_show ( & ikev1_notify_names , p -> payload . notification . isan_type ) ) ) ; } else { loglog ( RC_LOG_SERIOUS , ""ignoring<S2SV_blank>informational<S2SV_blank>payload<S2SV_blank>%s,<S2SV_blank>msgid=%08"" PRIx32 "",<S2SV_blank>length=%d"" , enum_show ( & ikev1_notify_names , p -> payload . notification . isan_type ) , st -> st_v1_msgid . id , p -> payload . notification . isan_length ) ; DBG_dump_pbs ( & p -> pbs ) ; } } if ( DBGP ( DBG_BASE ) ) { DBG_dump ( ""info:"" , p -> pbs . cur , pbs_left ( & p -> pbs ) ) ; } p = p -> next ; } p = md -> chain [ ISAKMP_NEXT_D ] ; while ( p != NULL ) { self_delete |= accept_delete ( md , p ) ; if ( DBGP ( DBG_BASE ) ) { DBG_dump ( ""del:"" , p -> pbs . cur , pbs_left ( & p -> pbs ) ) ; } if ( md -> st != st ) { pexpect ( md -> st == NULL ) ; dbg ( ""zapping<S2SV_blank>ST<S2SV_blank>as<S2SV_blank>accept_delete()<S2SV_blank>zapped<S2SV_blank>MD.ST"" ) ; st = md -> st ; } p = p -> next ; } p = md -> chain [ ISAKMP_NEXT_VID ] ; while ( p != NULL ) { handle_vendorid ( md , ( char * ) p -> pbs . cur , pbs_left ( & p -> pbs ) , FALSE ) ; p = p -> next ; } } if ( self_delete ) { accept_self_delete ( md ) ; st = md -> st ; } pexpect ( st == md -> st ) ; statetime_t start = statetime_start ( md -> st ) ; complete_v1_state_transition ( md , smc -> processor ( st , md ) ) ; statetime_stop ( & start , ""%s()"" , __func__ ) ; }
","<S2SV_ModStart> np ) , finite_states [ smc -> state ] <S2SV_ModEnd> -> name )
",libreswan@libreswan/471a3e41a449d7c753bc4edbba4239501bb62ba8,CVE-2020-1763,https://github.com/libreswan/libreswan/commit/471a3e41a449d7c753bc4edbba4239501bb62ba8,2020-05-12T14:15Z,993,"<S2SV_ModStart> md -> raw_packet, <S2SV_ModEnd> st -> st_v1_new_iv <S2SV_ModStart> md -> raw_packet, <S2SV_ModEnd> st -> st_v1_new_iv <S2SV_ModStart> md -> raw_packet, <S2SV_ModEnd> st -> st_v1_new_iv",0
994,CWE-787,"CWE-787 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; <S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> } }
","<S2SV_ModStart> = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
",external@libmpeg2/bef16671c891e16f25a7b174bc528eea109357be,CVE-2018-9497,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be,2018-10-02T19:29Z,994,<S2SV_ModStart> ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t. u4_num_bytes_consumed = 0 ; ps_op -> s_ivd_video_decode_op_t. u4_ip_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_ip_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_ip_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_ip_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; },0
996,CWE-125,"CWE-125 <S2SV_StartBug> static void <S2SV_EndBug> ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } if ( ( length + 1 ) & 3 ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_EndBug> ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>ptr<S2SV_blank>%u]"" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <S2SV_EndBug> if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> , length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;
",the-tcpdump-group@tcpdump/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,CVE-2017-13022,https://github.com/the-tcpdump-group/tcpdump/commit/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,2017-09-14T06:29Z,996,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart>, length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> 4 ) { ND_TCHECK2 ( cp [ len ], 4 ) ; <S2SV_ModStart> ) ; } ND_TCHECK2 ( cp [ len ], 4 ) ; <S2SV_ModStart> ) ; return ( 0 ) ; ND_TCHECK2 ( cp [ len ], 4 ) ; <S2SV_ModStart> ) ; } return ( 0 ) ;",0
1000,CWE-20,"CWE-20 static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; <S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
","<S2SV_ModStart> if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks
",kyz@libmspack/72e70a921f0f07fee748aec2274b30784e1d312a,CVE-2018-14680,https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a,2018-07-28T23:29Z,1000,<S2SV_ModStart> if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks,1
1006,CWE-787,"CWE-787 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { # ifndef _MSC_VER char buf [ EXT2_BLOCK_SIZE ( data ) ] ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return fileblock + start ; } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; return - 1 ; } } <S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> < INDIRECT_BLOCKS ) { <S2SV_ModStart> ] ) ; }
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,1006,"<S2SV_ModStart> ] ) ; if ( fileblock < inode -> i_sb -> s_blocksize - blksz ) { grub_error ( GRUB_ERR_BAD_FS, ""file <S2SV_blank> block <S2SV_blank> out <S2SV_blank> of <S2SV_blank> range"" ) ; return - 1 ; } <S2SV_ModStart> ] ) ; if ( fileblock < inode -> i_sb -> s_blocksize - blksz ) { grub_error ( GRUB_ERR_BAD_FS, ""file <S2SV_blank> block <S2SV_blank> out <S2SV_blank> of <S2SV_blank> range"" ) ; return - 1 ; }",0
1008,CWE-20,"CWE-20 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_EndBug> q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> ) { size_t tail = <S2SV_ModEnd> ( i << <S2SV_ModStart> ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail
",file@file/93e063ee374b6a75729df9e7201fb511e47e259d,CVE-2014-3487,https://github.com/file/file/commit/93e063ee374b6a75729df9e7201fb511e47e259d,2014-07-09T11:07Z,1008,"<S2SV_ModStart> if ( q < p ) { DPRINTF ( ( ""Wrapped <S2SV_blank> around <S2SV_blank> %p <S2SV_blank> < <S2SV_blank> %p\\n"", q, p ) ) ; goto out ; } if ( q",0
1009,CWE-125,"CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { <S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> if ( bytes_matched + i >= max_bytes_matched ) <S2SV_StartBug> break ; <S2SV_EndBug> if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z,1009,"<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> > max_bytes_matched ) { FAIL_ON_ERROR ( callback ( 0x12345678, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e4554, 0x534e",0
1010,CWE-787,"CWE-787 <S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
","<S2SV_ModStart> len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>COMMENT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str
",espruino@Espruino/bed844f109b6c222816740555068de2e101e8018,CVE-2018-11593,https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018,2018-05-31T16:29Z,1010,"<S2SV_ModStart> len ) { assert ( len > 0 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""TEMPLATE <S2SV_blank> LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""UNFINISHED <S2SV_blank> STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""TEMPLATE <S2SV_blank> LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""UNFINISHED <S2SV_blank> TEMPLATE <S2SV_blank> LITERAL"" <S2SV_ModEnd> ) ;",0
1013,CWE-125,"CWE-125 int jpc_dec_decodepkts ( jpc_dec_t * dec , jas_stream_t * pkthdrstream , jas_stream_t * in ) { jpc_dec_tile_t * tile ; jpc_pi_t * pi ; int ret ; tile = dec -> curtile ; pi = tile -> pi ; for ( ; ; ) { if ( ! tile -> pkthdrstream || jas_stream_peekc ( tile -> pkthdrstream ) == EOF ) { switch ( jpc_dec_lookahead ( in ) ) { case JPC_MS_EOC : case JPC_MS_SOT : return 0 ; break ; case JPC_MS_SOP : case JPC_MS_EPH : case 0 : break ; default : return - 1 ; break ; } } if ( ( ret = jpc_pi_next ( pi ) ) ) { return ret ; } if ( dec -> maxpkts >= 0 && dec -> numpkts >= dec -> maxpkts ) { jas_eprintf ( ""warning:<S2SV_blank>stopping<S2SV_blank>decode<S2SV_blank>prematurely<S2SV_blank>as<S2SV_blank>requested\\n"" ) ; return 0 ; } if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""packet<S2SV_blank>offset=%08ld<S2SV_blank>prg=%d<S2SV_blank>cmptno=%02d<S2SV_blank>"" ""rlvlno=%02d<S2SV_blank>prcno=%03d<S2SV_blank>lyrno=%02d\\n"" , ( long ) jas_stream_getrwcount ( in ) , jpc_pi_prg ( pi ) , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ; } if ( jpc_dec_decodepkt ( dec , pkthdrstream , in , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ) { return - 1 ; } ++ dec -> numpkts ; } return 0 ; }
","
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,1013,,1
1021,CWE-125,"CWE-125 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO ""0x%02x"" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO "",<S2SV_blank>"" ) ; } printk ( "")<S2SV_blank>toneburst=%d\\n"" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( ""%s<S2SV_blank>burst=%d\\n"" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }
","<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i
",torvalds@linux/1fa2337a315a2448c5434f41e00d56b01a22283c,CVE-2015-9289,https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c,2019-07-27T22:15Z,1021,<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i,1
1023,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
",ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z,1023,"<S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" ) ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" ) ;",0
1025,CWE-20,"CWE-20 static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , ""%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s"" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid"" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , ""OFFSET<S2SV_blank>0001-0203"" ) != 0 ) ; <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ; <S2SV_EndBug> if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; <S2SV_StartBug> * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; <S2SV_EndBug> return FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; } ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid"" ) ; return FALSE ; } } return TRUE ; }
","<S2SV_ModStart> int num_items_scanned ; int pkt_len , <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , ""LEN=%9d"" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length""
",wireshark@wireshark/3270dfac43da861c714df76513456b46765ff47f,CVE-2016-5355,https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f,2016-08-07T16:59Z,1025,"<S2SV_ModStart> int num_items_scanned ; int pkt_len ; int <S2SV_ModEnd> pktnum, hr <S2SV_ModStart> + 64, ""LEN=%9u"" <S2SV_ModEnd>, & pkt_len <S2SV_ModStart> g_strdup ( ""toshiba: <S2SV_blank> OFFSET <S2SV_blank> line <S2SV_blank> doesn\'t <S2SV_blank> have <S2SV_blank> valid <S2SV_blank> LEN <S2SV_blank> item"" ) ; return FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba: <S2SV_blank> File <S2SV_blank> has <S2SV_blank> a <S2SV_blank> maximum <S2SV_blank> of <S2SV_blank> %u"", pkt_len, WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba: <S2SV_blank> Packet <S2SV_blank> header <S2SV_blank> has <S2SV_blank> a <S2SV_blank> negative <S2SV_blank> packet <S2SV_blank> length""",0
1029,CWE-416,"CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
",torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z,1029,<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,0
1030,CWE-416,"CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z,1030,"<S2SV_ModStart> } else { if (! <S2SV_ModStart>, ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf -> flags",0
1039,CWE-22,"CWE-22 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
",yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z,1039,"<S2SV_ModStart> ; if ( page && ( access ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""error"" ) ; http_response_send ( res ) ; return ; } if ( <S2SV_ModStart> ; if ( page && ( file_access <S2SV_ModEnd> ( page, <S2SV_ModStart> ; if ( page && ( unlink ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""error"" ) ; http_response_send ( res ) ; return ; } if ( page && ( access ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""success"" ) ; http_response_send ( res ) ; return ; } if ( page && ( access ( page, R_OK ) == 0 ) ) { http_response_printf ( res, ""success"" ) ; http_response_send ( res ) ; return ; } } else if (! strcmp ( func, ""page/get"" ) ) { char * page = http_request_param_get ( req, ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && (",0
1046,CWE-125,"CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
","<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
",the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94,CVE-2018-14466,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,2019-10-03T16:15Z,1046,<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh,1
1051,CWE-20,"CWE-20 static int snd_hrtimer_start ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; <S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set ( & stime -> running , 1 ) ; return 0 ; }
","<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime
",torvalds@linux/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,CVE-2016-2549,https://github.com/torvalds/linux/commit/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,2016-04-27T17:59Z,1051,<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime,1
1052,CWE-125,"CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
",kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z,1052,"<S2SV_ModStart> -> dmin ; if ( p - str < enclen ( reg -> enc, p ) ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; else if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( high_prev ) * high_prev = onigenc_get_prev_char_head ( reg -> enc, str, * high ) ; else if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; if ( high_prev ) * high_prev = onigenc_get_prev_char_",0
1053,CWE-787,"CWE-787 static int l2cap_build_conf_req ( struct sock * sk , void * data ) { struct l2cap_pinfo * pi = l2cap_pi ( sk ) ; struct l2cap_conf_req * req = data ; <S2SV_StartBug> struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; <S2SV_EndBug> void * ptr = req -> data ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; <S2SV_StartBug> switch ( pi -> mode ) { <S2SV_EndBug> case L2CAP_MODE_BASIC : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ; break ; case L2CAP_MODE_ERTM : rfc . mode = L2CAP_MODE_ERTM ; <S2SV_StartBug> rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; <S2SV_EndBug> rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ; <S2SV_StartBug> rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; <S2SV_EndBug> <S2SV_StartBug> rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; <S2SV_EndBug> rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; } req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> flags = cpu_to_le16 ( 0 ) ; return ptr - data ; }
","<S2SV_ModStart> . mode = L2CAP_MODE_ERTM <S2SV_ModEnd> } ; void <S2SV_ModStart> sk ) ; if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> . txwin_size = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . retrans_timeout = 0 <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . monitor_timeout = 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ; rfc .
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,1053,"<S2SV_ModStart> ; struct l2cap_conf_rfc rfc <S2SV_ModEnd> ; void * <S2SV_ModStart> = data ; BT_DBG ( ""sk <S2SV_blank> %p"", sk ) ; rfc. <S2SV_ModEnd> max_transmit = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModStart> = L2CAP_MODE_ERTM ; rfc. <S2SV_ModEnd> retrans_timeout = cpu_to_le16 <S2SV_ModStart> retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; rfc. monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; rfc. max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr, L2CAP_CONF_RFC, sizeof ( rfc ), ( unsigned long ) & rfc ) ; break ; } req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> flags = cpu_to_le16 ( 0 ) <S2SV_ModEnd> ; return ptr",0
1059,CWE-416,"CWE-416 static struct ucounts * get_ucounts ( struct user_namespace * ns , kuid_t uid ) { struct hlist_head * hashent = ucounts_hashentry ( ns , uid ) ; struct ucounts * ucounts , * new ; spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ! ucounts ) { spin_unlock_irq ( & ucounts_lock ) ; new = kzalloc ( sizeof ( * new ) , GFP_KERNEL ) ; if ( ! new ) return NULL ; new -> ns = ns ; new -> uid = uid ; <S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ucounts ) { kfree ( new ) ; } else { hlist_add_head ( & new -> node , hashent ) ; ucounts = new ; } } <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ucounts = NULL ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts ; }
","<S2SV_ModStart> = uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (
",torvalds@linux/040757f738e13caaa9c5078bca79aa97e11dde88,CVE-2017-6874,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,2017-03-14T09:59Z,1059,<S2SV_ModStart> = uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (,1
1061,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,1061,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
1070,CWE-125,"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\n\\t%s<S2SV_blank>(%u)"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type:<S2SV_blank>%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>opts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(bad<S2SV_blank>length)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { <S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; pptr += opli ; } trunc : <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> ND_TCHECK ( * tptr <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> } trunc : ND_PRINT ( ( ndo , ""[|esis]"" ) ) <S2SV_ModEnd> ; } <S2SV_null>
",the-tcpdump-group@tcpdump/331530a4076c69bbd2e3214db6ccbe834fb75640,CVE-2017-13047,https://github.com/the-tcpdump-group/tcpdump/commit/331530a4076c69bbd2e3214db6ccbe834fb75640,2017-09-14T06:29Z,1070,"<S2SV_ModStart> ndo_snapend ) { ND_TCHECK ( * optr ) ; while ( * optr == NLPID_ESIS ) { ND_TCHECK ( * optr ) ; optr ++ ; } if ( <S2SV_ModStart> ndo_snapend ) { ND_TCHECK ( * optr ) ; while ( * optr == NLPID_ESIS ) { ND_TCHECK ( * optr ) ; optr ++ ; } if ( * optr!= NLPID_ESIS ) { ND_TCHECK ( * optr ) ; if ( * optr!= NLPID_SNAP ) ND_PRINT ( ( ndo, "" <S2SV_blank> SNAP <S2SV_blank> packet <S2SV_blank> not <S2SV_blank> supported"" ) ) ; break ; } ND_TCHECK ( * optr ) ; while ( * optr == NLPID_SNAP ) ND_TCHECK ( * optr ++ ) ; if ( * optr!= NLPID_ESIS ) { ND_TCHECK ( * optr ++ ) ; if ( * optr!= NLPID_SNAP ) ND_PRINT ( ( ndo, "" <S2SV_blank> SNAP <S2SV_blank> packet",0
1080,CWE-20,"CWE-20 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; <S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ; <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( struct pgstate * ) io ; } return ( ( u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> >= 0 && <S2SV_ModEnd> ND_TTEST ( * <S2SV_ModStart> < ie && <S2SV_ModEnd> ND_TTEST ( *
",the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70,CVE-2015-3138,https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70,2017-09-28T01:29Z,1080,<S2SV_ModStart> >= 0 && <S2SV_ModEnd> ND_TTEST ( * <S2SV_ModStart> < ie && <S2SV_ModEnd> ND_TTEST ( *,1
1081,CWE-20,"CWE-20 error_t ksz8851SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t n ; size_t length ; Ksz8851TxHeader header ; Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; length = netBufferGetLength ( buffer ) - offset ; if ( length > ETH_MAX_FRAME_SIZE ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n < ( length + 8 ) ) { return ERROR_FAILURE ; } netBufferRead ( context -> txBuffer , buffer , offset , length ) ; <S2SV_StartBug> header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; <S2SV_EndBug> header . byteCount = htole16 ( length ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851WriteFifo ( interface , ( uint8_t * ) & header , sizeof ( Ksz8851TxHeader ) ) ; ksz8851WriteFifo ( interface , context -> txBuffer , length ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { osSetEvent ( & interface -> nicTxEvent ) ; } return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> = htole16 ( KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> | ( context <S2SV_ModStart> frameId ++ & KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851WriteFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1081,"<S2SV_ModStart> = ksz8851ReadReg ( interface, KSZ8851_TXMIR ) & TXMIR_TXMA_MASK ; if ( n < ( length + 8 ) ) { return ERROR_FAILURE ; } <S2SV_ModStart> ( interface, KSZ8851_TXMIR ) & TXMIR_TXMA_MASK <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface, KSZ8851_RXQCR, KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface, KSZ8851_TXQCR, KSZ8851_TXQCR_METFE <S2SV_ModEnd> ) ; netBufferRead <S2SV_ModStart> ; n = ksz8851ReadReg ( interface, KSZ8851_TXMIR ) & TXMIR_TXMA_MASK ; if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_FAILURE ; } netBufferRead ( context -> txBuffer, buffer, offset, length ) ; header. controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID",0
1084,CWE-20,"CWE-20 static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings . logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE ; settings . logger_buf_size = LOGGER_BUF_SIZE ; settings . drop_privileges = true ; # ifdef MEMCACHED_DEBUG settings . relaxed_privileges = false ; # endif }
","<S2SV_ModStart> . udpport = 0 <S2SV_ModEnd> ; settings .
",memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z,1084,<S2SV_ModStart>. udpport = 0 <S2SV_ModEnd> ; settings.,1
1086,CWE-787,"CWE-787 VOID ixheaacd_esbr_postradixcompute2 ( WORD32 * ptr_y , WORD32 * ptr_x , const WORD32 * pdig_rev_tbl , WORD32 npoints ) { WORD32 i , k ; WORD32 h2 ; WORD32 x_0 , x_1 , x_2 , x_3 ; WORD32 x_4 , x_5 , x_6 , x_7 ; <S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ; WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ; WORD32 n0 , j0 ; WORD32 * x2 , * x0 ; WORD32 * y0 , * y1 , * y2 , * y3 ; y0 = ptr_y ; y2 = ptr_y + ( WORD32 ) npoints ; x0 = ptr_x ; x2 = ptr_x + ( WORD32 ) ( npoints >> 1 ) ; y1 = y0 + ( WORD32 ) ( npoints >> 2 ) ; y3 = y2 + ( WORD32 ) ( npoints >> 2 ) ; j0 = 8 ; n0 = npoints >> 1 ; for ( k = 0 ; k < 2 ; k ++ ) { for ( i = 0 ; i < npoints >> 1 ; i += 8 ) { h2 = * pdig_rev_tbl ++ >> 2 ; x_0 = * x0 ++ ; x_1 = * x0 ++ ; x_2 = * x0 ++ ; x_3 = * x0 ++ ; x_4 = * x0 ++ ; x_5 = * x0 ++ ; x_6 = * x0 ++ ; x_7 = * x0 ++ ; <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> n01 = x_1 + x_3 ; n20 = x_0 - x_2 ; n21 = x_1 - x_3 ; n10 = x_4 + x_6 ; n11 = x_5 + x_7 ; n30 = x_4 - x_6 ; n31 = x_5 - x_7 ; y0 [ h2 ] = n00 ; y0 [ h2 + 1 ] = n01 ; <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> y2 [ h2 ] = n20 ; y2 [ h2 + 1 ] = n21 ; <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; n02 = x_8 + x_a ; n03 = x_9 + x_b ; n22 = x_8 - x_a ; n23 = x_9 - x_b ; n12 = x_c + x_e ; n13 = x_d + x_f ; n32 = x_c - x_e ; n33 = x_d - x_f ; y0 [ h2 + 2 ] = n02 ; y0 [ h2 + 3 ] = n03 ; y1 [ h2 + 2 ] = n12 ; y1 [ h2 + 3 ] = n13 ; y2 [ h2 + 2 ] = n22 ; y2 [ h2 + 3 ] = n23 ; y3 [ h2 + 2 ] = n32 ; y3 [ h2 + 3 ] = n33 ; } x0 += ( WORD32 ) npoints >> 1 ; x2 += ( WORD32 ) npoints >> 1 ; } }
","<S2SV_ModStart> x_e , x_f <S2SV_ModEnd> ; WORD32 n0 <S2SV_ModStart> x0 ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; } x0
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,1086,"<S2SV_ModStart>, x_7 ; WORD32 x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f ; WORD32 n00, n10, n20, n30, n01, n12, n22, n32, n03, n13, n23, n33 ; WORD32 n0, j0 ; WORD32 n1, n2, n4, n5 ; WORD32 n6 ; x_7 = * x0 ++ ; x_8 = * x0 ++ ; x_9 = * x0 ++ ; x_a = * x0 ++ ; x_b = * x0 ++ ; x_c = * x0 ++ ; x_d = * x0 ++ ; x_e = * x0 ++ ; x_f = * x0 ++ ; n0 = x_0 + x_2 ; n1 = x_1 + x_3 ; n2 = x_0 - x_2 ; n3 = x_1 - x_3 ; n4 = x_4 + x_6 ; n5 = x_5 + x_7 ; n6",0
1090,CWE-125,"CWE-125 static void core_anal_bytes ( RCore * core , const ut8 * buf , int len , int nops , int fmt ) { int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; bool iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; bool romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; bool stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; bool be = core -> print -> big_endian ; bool use_color = core -> print -> flags & R_PRINT_FLAGS_COLOR ; core -> parser -> relsub = r_config_get_i ( core -> config , ""asm.relsub"" ) ; int ret , i , j , idx , size ; const char * color = """" ; const char * esilstr ; const char * opexstr ; RAnalHint * hint ; RAnalEsil * esil = NULL ; RAsmOp asmop ; RAnalOp op = { 0 } ; ut64 addr ; bool isFirst = true ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; int totalsize = 0 ; if ( use_color ) { color = core -> cons -> pal . label ; } switch ( fmt ) { case 'j' : r_cons_printf ( ""["" ) ; break ; case 'r' : esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; if ( ! esil ) { return ; } r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; break ; } for ( i = idx = ret = 0 ; idx < len && ( ! nops || ( nops && i < nops ) ) ; i ++ , idx += ret ) { addr = core -> offset + idx ; hint = r_anal_hint_get ( core -> anal , addr ) ; r_asm_set_pc ( core -> assembler , addr ) ; ( void ) r_asm_disassemble ( core -> assembler , & asmop , buf + idx , len - idx ) ; ret = r_anal_op ( core -> anal , & op , core -> offset + idx , buf + idx , len - idx , R_ANAL_OP_MASK_ESIL ) ; esilstr = R_STRBUF_SAFEGET ( & op . esil ) ; opexstr = R_STRBUF_SAFEGET ( & op . opex ) ; char * mnem = strdup ( r_asm_op_get_asm ( & asmop ) ) ; char * sp = strchr ( mnem , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; if ( op . prefix ) { char * arg = strdup ( sp + 1 ) ; char * sp = strchr ( arg , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; } free ( mnem ) ; mnem = arg ; } } if ( ret < 1 && fmt != 'd' ) { eprintf ( ""Oops<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""<S2SV_blank>("" , core -> offset + idx ) ; for ( i = idx , j = 0 ; i < core -> blocksize && j < 3 ; ++ i , ++ j ) { eprintf ( ""%02x<S2SV_blank>"" , buf [ i ] ) ; } eprintf ( ""...)\\n"" ) ; free ( mnem ) ; break ; } size = ( hint && hint -> size ) ? hint -> size : op . size ; if ( fmt == 'd' ) { char * opname = strdup ( r_asm_op_get_asm ( & asmop ) ) ; if ( opname ) { r_str_split ( opname , '<S2SV_blank>' ) ; char * d = r_asm_describe ( core -> assembler , opname ) ; if ( d && * d ) { r_cons_printf ( ""%s:<S2SV_blank>%s\\n"" , opname , d ) ; free ( d ) ; } else { eprintf ( ""Unknown<S2SV_blank>opcode\\n"" ) ; } free ( opname ) ; } } else if ( fmt == 'e' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( ""%s0x%"" PFMT64x Color_RESET ""<S2SV_blank>%s\\n"" , color , core -> offset + idx , esilstr ) ; } else { r_cons_printf ( ""0x%"" PFMT64x ""<S2SV_blank>%s\\n"" , core -> offset + idx , esilstr ) ; } } } else if ( fmt == 's' ) { totalsize += op . size ; } else if ( fmt == 'r' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( ""%s0x%"" PFMT64x Color_RESET ""\\n"" , color , core -> offset + idx ) ; } else { r_cons_printf ( ""0x%"" PFMT64x ""\\n"" , core -> offset + idx ) ; } r_anal_esil_parse ( esil , esilstr ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; } } else if ( fmt == 'j' ) { if ( isFirst ) { isFirst = false ; } else { r_cons_print ( "","" ) ; } r_cons_printf ( ""{\\""opcode\\"":\\""%s\\"","" , r_asm_op_get_asm ( & asmop ) ) ; { char strsub [ 128 ] = { 0 } ; r_parse_varsub ( core -> parser , NULL , core -> offset + idx , asmop . size , r_asm_op_get_asm ( & asmop ) , strsub , sizeof ( strsub ) ) ; { ut64 killme = UT64_MAX ; if ( r_io_read_i ( core -> io , op . ptr , & killme , op . refptr , be ) ) { core -> parser -> relsub_addr = killme ; } } char * p = strdup ( strsub ) ; if ( p ) { r_parse_filter ( core -> parser , addr , core -> flags , p , strsub , sizeof ( strsub ) , be ) ; free ( p ) ; } r_cons_printf ( ""\\""disasm\\"":\\""%s\\"","" , strsub ) ; } r_cons_printf ( ""\\""mnemonic\\"":\\""%s\\"","" , mnem ) ; if ( hint && hint -> opcode ) { r_cons_printf ( ""\\""ophint\\"":\\""%s\\"","" , hint -> opcode ) ; } r_cons_printf ( ""\\""sign\\"":%s,"" , r_str_bool ( op . sign ) ) ; r_cons_printf ( ""\\""prefix\\"":%"" PFMT64u "","" , op . prefix ) ; r_cons_printf ( ""\\""id\\"":%d,"" , op . id ) ; if ( opexstr && * opexstr ) { r_cons_printf ( ""\\""opex\\"":%s,"" , opexstr ) ; } r_cons_printf ( ""\\""addr\\"":%"" PFMT64u "","" , core -> offset + idx ) ; r_cons_printf ( ""\\""bytes\\"":\\"""" ) ; for ( j = 0 ; j < size ; j ++ ) { r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; } r_cons_printf ( ""\\"","" ) ; if ( op . val != UT64_MAX ) { r_cons_printf ( ""\\""val\\"":<S2SV_blank>%"" PFMT64u "","" , op . val ) ; } if ( op . ptr != UT64_MAX ) { r_cons_printf ( ""\\""ptr\\"":<S2SV_blank>%"" PFMT64u "","" , op . ptr ) ; } r_cons_printf ( ""\\""size\\"":<S2SV_blank>%d,"" , size ) ; r_cons_printf ( ""\\""type\\"":<S2SV_blank>\\""%s\\"","" , r_anal_optype_to_string ( op . type ) ) ; if ( op . reg ) { r_cons_printf ( ""\\""reg\\"":<S2SV_blank>\\""%s\\"","" , op . reg ) ; } if ( op . ireg ) { r_cons_printf ( ""\\""ireg\\"":<S2SV_blank>\\""%s\\"","" , op . ireg ) ; } if ( op . scale ) { r_cons_printf ( ""\\""scale\\"":%d,"" , op . scale ) ; } if ( hint && hint -> esil ) { r_cons_printf ( ""\\""esil\\"":<S2SV_blank>\\""%s\\"","" , hint -> esil ) ; } else if ( * esilstr ) { r_cons_printf ( ""\\""esil\\"":<S2SV_blank>\\""%s\\"","" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { r_cons_printf ( ""\\""jump\\"":%"" PFMT64u "","" , op . jump ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . refptr != - 1 ) { r_cons_printf ( ""\\""refptr\\"":%d,"" , op . refptr ) ; } if ( op . fail != UT64_MAX ) { r_cons_printf ( ""\\""fail\\"":%"" PFMT64u "","" , op . fail ) ; } r_cons_printf ( ""\\""cycles\\"":%d,"" , op . cycles ) ; if ( op . failcycles ) { r_cons_printf ( ""\\""failcycles\\"":%d,"" , op . failcycles ) ; } r_cons_printf ( ""\\""delay\\"":%d,"" , op . delay ) ; { const char * p = r_anal_stackop_tostring ( op . stackop ) ; if ( p && * p && strcmp ( p , ""null"" ) ) r_cons_printf ( ""\\""stack\\"":\\""%s\\"","" , p ) ; } if ( op . stackptr ) { r_cons_printf ( ""\\""stackptr\\"":%d,"" , op . stackptr ) ; } { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { r_cons_printf ( ""\\""cond\\"":\\""%s\\"","" , arg ) ; } } r_cons_printf ( ""\\""family\\"":\\""%s\\""}"" , r_anal_op_family_to_string ( op . family ) ) ; } else { # define printline ( k , fmt , arg ) { if ( use_color ) r_cons_printf ( ""%s%s:<S2SV_blank>"" Color_RESET , color , k ) ; else r_cons_printf ( ""%s:<S2SV_blank>"" , k ) ; if ( fmt ) r_cons_printf ( fmt , arg ) ; } printline ( ""address"" , ""0x%"" PFMT64x ""\\n"" , core -> offset + idx ) ; printline ( ""opcode"" , ""%s\\n"" , r_asm_op_get_asm ( & asmop ) ) ; printline ( ""mnemonic"" , ""%s\\n"" , mnem ) ; if ( hint ) { if ( hint -> opcode ) { printline ( ""ophint"" , ""%s\\n"" , hint -> opcode ) ; } # if 0 if ( hint -> addr != UT64_MAX ) { printline ( ""addr"" , ""0x%08"" PFMT64x ""\\n"" , ( hint -> addr + idx ) ) ; } # endif } printline ( ""prefix"" , ""%"" PFMT64u ""\\n"" , op . prefix ) ; printline ( ""id"" , ""%d\\n"" , op . id ) ; # if 0 if ( opexstr && * opexstr ) { printline ( ""opex"" , ""%s\\n"" , opexstr ) ; } # endif printline ( ""bytes"" , NULL , 0 ) ; <S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> } r_cons_newline ( ) ; <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> printline ( ""val"" , ""0x%08"" PFMT64x ""\\n"" , op . val ) ; <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug> printline ( ""size"" , ""%d\\n"" , size ) ; printline ( ""sign"" , ""%s\\n"" , r_str_bool ( op . sign ) ) ; printline ( ""type"" , ""%s\\n"" , r_anal_optype_to_string ( op . type ) ) ; printline ( ""cycles"" , ""%d\\n"" , op . cycles ) ; if ( op . failcycles ) { printline ( ""failcycles"" , ""%d\\n"" , op . failcycles ) ; } { const char * t2 = r_anal_optype_to_string ( op . type2 ) ; if ( t2 && strcmp ( t2 , ""null"" ) ) { printline ( ""type2"" , ""%s\\n"" , t2 ) ; } } if ( op . reg ) { printline ( ""reg"" , ""%s\\n"" , op . reg ) ; } if ( op . ireg ) { printline ( ""ireg"" , ""%s\\n"" , op . ireg ) ; } if ( op . scale ) { printline ( ""scale"" , ""%d\\n"" , op . scale ) ; } if ( hint && hint -> esil ) { printline ( ""esil"" , ""%s\\n"" , hint -> esil ) ; } else if ( * esilstr ) { printline ( ""esil"" , ""%s\\n"" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { printline ( ""jump"" , ""0x%08"" PFMT64x ""\\n"" , op . jump ) ; } if ( op . direction != 0 ) { const char * dir = op . direction == 1 ? ""read"" : op . direction == 2 ? ""write"" : op . direction == 4 ? ""exec"" : op . direction == 8 ? ""ref"" : ""none"" ; printline ( ""direction"" , ""%s\\n"" , dir ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . fail != UT64_MAX ) { printline ( ""fail"" , ""0x%08"" PFMT64x ""\\n"" , op . fail ) ; } if ( op . delay ) { printline ( ""delay"" , ""%d\\n"" , op . delay ) ; } printline ( ""stack"" , ""%s\\n"" , r_anal_stackop_tostring ( op . stackop ) ) ; { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { printline ( ""cond"" , ""%s\\n"" , arg ) ; } } printline ( ""family"" , ""%s\\n"" , r_anal_op_family_to_string ( op . family ) ) ; printline ( ""stackop"" , ""%s\\n"" , r_anal_stackop_tostring ( op . stackop ) ) ; if ( op . stackptr ) { printline ( ""stackptr"" , ""%"" PFMT64u ""\\n"" , op . stackptr ) ; } } free ( mnem ) ; r_anal_hint_free ( hint ) ; r_anal_op_fini ( & op ) ; } r_anal_op_fini ( & op ) ; if ( fmt == 'j' ) { r_cons_printf ( ""]"" ) ; r_cons_newline ( ) ; } else if ( fmt == 's' ) { r_cons_printf ( ""%d\\n"" , totalsize ) ; } r_anal_esil_free ( esil ) ; }
","<S2SV_ModStart> 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> ; j < minsz <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> buf [ j <S2SV_ModStart> + idx ] ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> val ) ; } <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> ptr ) ; } <S2SV_ModStart> - 1 ) { <S2SV_ModStart> refptr ) ; }
",radare@radare2/a1bc65c3db593530775823d6d7506a457ed95267,CVE-2018-20461,https://github.com/radare/radare2/commit/a1bc65c3db593530775823d6d7506a457ed95267,2018-12-25T19:29Z,1090,"<S2SV_ModStart> ; j < size <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ; j < size <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; } <S2SV_ModStart> ; j < size <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; } <S2SV_ModStart> ; j < size <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; } <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; } <S2SV_ModStart> ; j < size <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; } <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; } <S2SV_ModStart> ; j ++ ) { r_cons_printf ( ""%02x"", j ) ; }",0
1092,CWE-125,"CWE-125 static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ; <S2SV_StartBug> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <S2SV_EndBug> u16 wTmp ; snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ; <S2SV_StartBug> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <S2SV_EndBug> writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ; <S2SV_StartBug> } <S2SV_EndBug> inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }
","<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z,1092,"<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head, tail, size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head!= tail ) { snd_msnd_eval_dsp_msg ( chip, readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd>, chip -> <S2SV_ModStart> ) ; } out :",1
1093,CWE-125,"CWE-125 static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { <S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
","<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; }
",radare@radare2/b35530fa0681b27eba084de5527037ebfb397422,CVE-2018-11377,https://github.com/radare/radare2/commit/b35530fa0681b27eba084de5527037ebfb397422,2018-05-22T19:29Z,1093,<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; },1
1097,CWE-125,"CWE-125 static int add_attributes ( PyTypeObject * type , char * * attrs , int num_fields ) { <S2SV_StartBug> int i , result ; <S2SV_EndBug> _Py_IDENTIFIER ( _attributes ) ; PyObject * s , * l = PyTuple_New ( num_fields ) ; if ( ! l ) return 0 ; for ( i = 0 ; i < num_fields ; i ++ ) { s = PyUnicode_FromString ( attrs [ i ] ) ; if ( ! s ) { Py_DECREF ( l ) ; return 0 ; } PyTuple_SET_ITEM ( l , i , s ) ; } result = _PyObject_SetAttrId ( ( PyObject * ) type , & PyId__attributes , l ) >= 0 ; Py_DECREF ( l ) ; return result ; }
","<S2SV_ModStart> i , result <S2SV_ModEnd> ; PyObject *
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1097,"<S2SV_ModStart> { int i <S2SV_ModEnd>, result ; <S2SV_ModStart>, result ; if ( num_fields < 1 ) { return 0 ; } _Py_IDENTIFIER ( _attributes ) ; PyObject * s, * l = PyTuple_New ( num_fields ) ; if (! l ) return 0 ; for ( i = 0 ; i < num_fields ; i ++ ) { s = PyUnicode_FromString ( attrs [ i ] ) ; if (! s ) { Py_DECREF ( l ) ; return 0 ; } PyTuple_SET_ITEM ( l, i, PyUnicode_FromString ( attrs [ i ] ) ) ; Py_DECREF ( l ) ; result = _PyObject_SetAttrId ( ( PyObject * ) type, & PyId__attributes, l ) >= 0 ; Py_DECREF ( l ) ; return result <S2SV_ModEnd> ; } <S2SV_null>",0
1102,CWE-20,"CWE-20 int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,1102,"<S2SV_ModStart> timer ) ; spin_lock ( & timeri -> timer_active_lock ) ; _snd_timer_stop ( timer, 1, SNDRV_TIMER_EVENT_RESOLUTION ) ; mutex_unlock ( & timeri -> timer_active_lock ) ; <S2SV_ModStart> NULL ; } spin_unlock ( & timeri -> timer_active_lock ) ; mutex_unlock ( & timeri -> timer_active_lock ) ;",0
1106,CWE-125,"CWE-125 int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor<S2SV_blank>set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; <S2SV_StartBug> length = cap -> bLength ; <S2SV_EndBug> if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor<S2SV_blank>type<S2SV_blank>invalid,<S2SV_blank>skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
","<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=
",torvalds@linux/1c0edc3633b56000e18d82fc241e3995ca18a69e,CVE-2017-16535,https://github.com/torvalds/linux/commit/1c0edc3633b56000e18d82fc241e3995ca18a69e,2017-11-04T01:29Z,1106,<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=,1
1109,CWE-20,"CWE-20 void enc28j60WritePhyReg ( NetInterface * interface , uint16_t address , uint16_t data ) { <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> { } }
","<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MIWRL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_MIWRH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1109,"<S2SV_ModStart> data ) { uint16_t status ; <S2SV_ModStart> ( interface, ENC28J60_MIREGADR, ENC28J60_MIREGADR_DEFAULT <S2SV_ModEnd> ) ; enc28j60WriteReg <S2SV_ModStart> ( interface, ENC28J60_MIWRL <S2SV_ModEnd>, LSB ( <S2SV_ModStart> ( interface, ENC28J60_MIWRH <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ( interface, ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> )!= 0",0
1112,CWE-20,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
","<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
",torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e,CVE-2017-17805,https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e,2017-12-20T23:29Z,1112,<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk,1
1118,CWE-20,"CWE-20 error_t webSocketParseAuthenticateField ( WebSocket * webSocket , char_t * value ) { # if ( WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) size_t n ; char_t * p ; char_t * token ; char_t * separator ; char_t * name ; WebSocketAuthContext * authContext ; authContext = & webSocket -> authContext ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcasecmp ( token , ""Basic"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_BASIC ; } else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_DIGEST ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""realm"" ) ) { strSafeCopy ( authContext -> realm , value , WEB_SOCKET_REALM_MAX_LEN ) ; } # if ( WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { strSafeCopy ( authContext -> nonce , value , WEB_SOCKET_NONCE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { strSafeCopy ( authContext -> opaque , value , WEB_SOCKET_OPAQUE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""stale"" ) ) { if ( ! osStrcasecmp ( value , ""true"" ) ) authContext -> stale = TRUE ; else authContext -> stale = FALSE ; } # endif token = osStrtok_r ( NULL , "","" , & p ) ; } } # endif return NO_ERROR ; }
","<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1118,"<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token,",1
1119,CWE-125,"CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; <S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length ) return - 1 ; if ( ++ ptr_count > length ) return - 1 ; continue ; } if ( label_len > 63 ) return - 1 ; if ( cp != name_out ) { if ( cp + 1 >= end ) return - 1 ; * cp ++ = '.' ; } if ( cp + label_len >= end ) return - 1 ; <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> cp += label_len ; j += label_len ; } if ( cp >= end ) return - 1 ; * cp = '\\0' ; if ( name_end < 0 ) * idx = j ; else * idx = name_end ; return 0 ; err : return - 1 ; }
","<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;
",libevent@libevent/96f64a022014a208105ead6c8a7066018449d86d,CVE-2016-10195,https://github.com/libevent/libevent/commit/96f64a022014a208105ead6c8a7066018449d86d,2017-03-15T15:59Z,1119,<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;,1
1121,CWE-20,"CWE-20 static int handle_pte_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * pte , pmd_t * pmd , unsigned int flags ) { pte_t entry ; spinlock_t * ptl ; entry = * pte ; barrier ( ) ; if ( ! pte_present ( entry ) ) { if ( pte_none ( entry ) ) { <S2SV_StartBug> if ( vma -> vm_ops ) { <S2SV_EndBug> if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte , <S2SV_StartBug> pmd , flags , entry ) ; <S2SV_EndBug> } return do_anonymous_page ( mm , vma , address , <S2SV_StartBug> pte , pmd , flags ) ; <S2SV_EndBug> } return do_swap_page ( mm , vma , address , pte , pmd , flags , entry ) ; } if ( pte_protnone ( entry ) ) return do_numa_page ( mm , vma , address , entry , pte , pmd ) ; ptl = pte_lockptr ( mm , pmd ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pte_same ( * pte , entry ) ) ) goto unlock ; if ( flags & FAULT_FLAG_WRITE ) { if ( ! pte_write ( entry ) ) return do_wp_page ( mm , vma , address , pte , pmd , ptl , entry ) ; entry = pte_mkdirty ( entry ) ; } entry = pte_mkyoung ( entry ) ; if ( ptep_set_access_flags ( vma , address , pte , entry , flags & FAULT_FLAG_WRITE ) ) { update_mmu_cache ( vma , address , pte ) ; } else { if ( flags & FAULT_FLAG_WRITE ) flush_tlb_fix_spurious_fault ( vma , address ) ; } unlock : pte_unmap_unlock ( pte , ptl ) ; return 0 ; }
","<S2SV_ModStart> -> vm_ops ) <S2SV_ModEnd> return do_fault ( <S2SV_ModStart> , pte , pmd , flags , entry ) ; <S2SV_ModEnd> return do_anonymous_page ( <S2SV_ModStart> , address , pte , pmd , <S2SV_ModEnd> flags ) ;
",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z,1121,"<S2SV_ModStart> -> vm_ops ) <S2SV_ModEnd> return do_fault ( <S2SV_ModStart>, pte, pmd, flags, entry ) ; <S2SV_ModEnd> return do_anonymous_page ( <S2SV_ModStart>, address, pte, pmd, <S2SV_ModEnd> flags ) ;",1
1123,CWE-20,"CWE-20 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,1123,<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),1
1128,CWE-125,"CWE-125 void ip6_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { register const struct ip6_hdr * ip6 ; register int advance ; u_int len ; const u_char * ipend ; register const u_char * cp ; register u_int payload_len ; int nh ; int fragmented = 0 ; u_int flow ; ip6 = ( const struct ip6_hdr * ) bp ; ND_TCHECK ( * ip6 ) ; if ( length < sizeof ( struct ip6_hdr ) ) { ND_PRINT ( ( ndo , ""truncated-ip6<S2SV_blank>%u"" , length ) ) ; return ; } if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IP6<S2SV_blank>"" ) ) ; if ( IP6_VERSION ( ip6 ) != 6 ) { ND_PRINT ( ( ndo , ""version<S2SV_blank>error:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>6"" , IP6_VERSION ( ip6 ) ) ) ; return ; } payload_len = EXTRACT_16BITS ( & ip6 -> ip6_plen ) ; len = payload_len + sizeof ( struct ip6_hdr ) ; if ( length < len ) ND_PRINT ( ( ndo , ""truncated-ip6<S2SV_blank>-<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>missing!"" , len - length ) ) ; if ( ndo -> ndo_vflag ) { flow = EXTRACT_32BITS ( & ip6 -> ip6_flow ) ; ND_PRINT ( ( ndo , ""("" ) ) ; # if 0 if ( flow & 0x0f000000 ) ND_PRINT ( ( ndo , ""pri<S2SV_blank>0x%02x,<S2SV_blank>"" , ( flow & 0x0f000000 ) >> 24 ) ) ; if ( flow & 0x00ffffff ) ND_PRINT ( ( ndo , ""flowlabel<S2SV_blank>0x%06x,<S2SV_blank>"" , flow & 0x00ffffff ) ) ; # else if ( flow & 0x0ff00000 ) ND_PRINT ( ( ndo , ""class<S2SV_blank>0x%02x,<S2SV_blank>"" , ( flow & 0x0ff00000 ) >> 20 ) ) ; if ( flow & 0x000fffff ) ND_PRINT ( ( ndo , ""flowlabel<S2SV_blank>0x%05x,<S2SV_blank>"" , flow & 0x000fffff ) ) ; # endif ND_PRINT ( ( ndo , ""hlim<S2SV_blank>%u,<S2SV_blank>next-header<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>payload<S2SV_blank>length:<S2SV_blank>%u)<S2SV_blank>"" , ip6 -> ip6_hlim , tok2str ( ipproto_values , ""unknown"" , ip6 -> ip6_nxt ) , ip6 -> ip6_nxt , payload_len ) ) ; } ipend = bp + len ; if ( ipend < ndo -> ndo_snapend ) ndo -> ndo_snapend = ipend ; cp = ( const u_char * ) ip6 ; advance = sizeof ( struct ip6_hdr ) ; nh = ip6 -> ip6_nxt ; while ( cp < ndo -> ndo_snapend && advance > 0 ) { <S2SV_StartBug> cp += advance ; <S2SV_EndBug> len -= advance ; if ( cp == ( const u_char * ) ( ip6 + 1 ) && nh != IPPROTO_TCP && nh != IPPROTO_UDP && nh != IPPROTO_DCCP && nh != IPPROTO_SCTP ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; } switch ( nh ) { case IPPROTO_HOPOPTS : advance = hbhopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_DSTOPTS : advance = dstopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_FRAGMENT : advance = frag6_print ( ndo , cp , ( const u_char * ) ip6 ) ; if ( advance < 0 || ndo -> ndo_snapend <= cp + advance ) return ; nh = * cp ; fragmented = 1 ; break ; case IPPROTO_MOBILITY_OLD : case IPPROTO_MOBILITY : advance = mobility_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> return ; case IPPROTO_ROUTING : <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> break ; case IPPROTO_SCTP : sctp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_DCCP : dccp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_TCP : tcp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_UDP : udp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_ICMPV6 : icmp6_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_AH : <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> nh = * cp ; break ; case IPPROTO_ESP : { int enh , padlen ; advance = esp_print ( ndo , cp , len , ( const u_char * ) ip6 , & enh , & padlen ) ; <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> len -= padlen ; break ; } case IPPROTO_IPCOMP : { ipcomp_print ( ndo , cp ) ; advance = - 1 ; break ; } case IPPROTO_PIM : pim_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_OSPF : ospf6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV6 : ip6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV4 : ip_print ( ndo , cp , len ) ; return ; case IPPROTO_PGM : pgm_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_GRE : gre_print ( ndo , cp , len ) ; return ; case IPPROTO_RSVP : rsvp_print ( ndo , cp , len ) ; return ; case IPPROTO_NONE : ND_PRINT ( ( ndo , ""no<S2SV_blank>next<S2SV_blank>header"" ) ) ; return ; default : ND_PRINT ( ( ndo , ""ip-proto-%d<S2SV_blank>%d"" , nh , len ) ) ; return ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|ip6]"" ) ) ; }
","<S2SV_ModStart> 0 ) { if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> , cp ) ; if ( advance < 0 ) return <S2SV_ModStart> padlen ) ; if ( advance < 0 ) return ;
",the-tcpdump-group@tcpdump/66df248b49095c261138b5a5e34d341a6bf9ac7f,CVE-2017-12985,https://github.com/the-tcpdump-group/tcpdump/commit/66df248b49095c261138b5a5e34d341a6bf9ac7f,2017-09-14T06:29Z,1128,"<S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> case IPPROTO_ROUTING : if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> case IPPROTO_ROUTING : if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> case IPPROTO_ROUTING : if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> case IPPROTO_ROUTING : if ( advance",0
1129,CWE-125,"CWE-125 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z,1129,"<S2SV_ModStart> 4 ) ; if ( idx + 4 > len ) return NULL ; <S2SV_ModStart> ]. len ) ; CHECKINT16 ( idx, len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; a -> guid = CHECKED_XMALLOC ( GUID, 1 ) ; copy_guid_from_buf ( a -> guid, buf + idx, len ) ; idx += sizeof ( GUID ) ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID, 1 ) ; copy_guid_from_buf ( a -> guid, buf + idx, len ) ; idx += sizeof ( GUID ) ; } for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx, len ) ; a -> names [ i ]. data = CHECKED_XMALLOC ( unsigned char, a -> names [ i ]. len ) ; for ( j = 0 ; j < a -> num_names ; j ++ ) a -> names [ i ]. data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to",0
1136,CWE-787,"CWE-787 static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>"" ""beginning<S2SV_blank>of<S2SV_blank>image.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>SOI<S2SV_blank>marker<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>first<S2SV_blank>"" ""marker<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>SOI.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>image<S2SV_blank>content<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } length = AV_RB16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker<S2SV_blank>segment.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == JPEG_MARKER_SOS ) { length = AV_RB16 ( frag -> data + start ) ; <S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! data ) return AVERROR ( ENOMEM ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) return err ; if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }
","<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z,1136,"<S2SV_ModStart> + 1 ; if ( j + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> no <S2SV_blank> SOI <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> + 1 ; if ( j + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> no <S2SV_blank> SOS <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> + 1 ; if ( j + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> %02x, <S2SV_blank> should <S2SV_blank> be <S2SV_blank> SOS.\\n"", j ) ; return AVERROR_INVALIDDATA ; }",0
1137,CWE-125,"CWE-125 static stmt_ty ast_for_expr_stmt ( struct compiling * c , const node * n ) { REQ ( n , expr_stmt ) ; <S2SV_StartBug> if ( NCH ( n ) == 1 ) { <S2SV_EndBug> expr_ty e = ast_for_testlist ( c , CHILD ( n , 0 ) ) ; if ( ! e ) return NULL ; return Expr ( e , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == augassign ) { expr_ty expr1 , expr2 ; operator_ty newoperator ; node * ch = CHILD ( n , 0 ) ; expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) return NULL ; if ( ! set_context ( c , expr1 , Store , ch ) ) return NULL ; switch ( expr1 -> kind ) { case Name_kind : case Attribute_kind : case Subscript_kind : break ; default : ast_error ( c , ch , ""illegal<S2SV_blank>expression<S2SV_blank>for<S2SV_blank>augmented<S2SV_blank>assignment"" ) ; return NULL ; } ch = CHILD ( n , 2 ) ; if ( TYPE ( ch ) == testlist ) expr2 = ast_for_testlist ( c , ch ) ; else expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) return NULL ; newoperator = ast_for_augassign ( c , CHILD ( n , 1 ) ) ; if ( ! newoperator ) return NULL ; return AugAssign ( expr1 , newoperator , expr2 , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == annassign ) { expr_ty expr1 , expr2 , expr3 ; node * ch = CHILD ( n , 0 ) ; node * deep , * ann = CHILD ( n , 1 ) ; int simple = 1 ; deep = ch ; while ( NCH ( deep ) == 1 ) { deep = CHILD ( deep , 0 ) ; } if ( NCH ( deep ) > 0 && TYPE ( CHILD ( deep , 0 ) ) == LPAR ) { simple = 0 ; } expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) { return NULL ; } switch ( expr1 -> kind ) { case Name_kind : if ( forbidden_name ( c , expr1 -> v . Name . id , n , 0 ) ) { return NULL ; } expr1 -> v . Name . ctx = Store ; break ; case Attribute_kind : if ( forbidden_name ( c , expr1 -> v . Attribute . attr , n , 1 ) ) { return NULL ; } expr1 -> v . Attribute . ctx = Store ; break ; case Subscript_kind : expr1 -> v . Subscript . ctx = Store ; break ; case List_kind : ast_error ( c , ch , ""only<S2SV_blank>single<S2SV_blank>target<S2SV_blank>(not<S2SV_blank>list)<S2SV_blank>can<S2SV_blank>be<S2SV_blank>annotated"" ) ; return NULL ; case Tuple_kind : ast_error ( c , ch , ""only<S2SV_blank>single<S2SV_blank>target<S2SV_blank>(not<S2SV_blank>tuple)<S2SV_blank>can<S2SV_blank>be<S2SV_blank>annotated"" ) ; return NULL ; default : ast_error ( c , ch , ""illegal<S2SV_blank>target<S2SV_blank>for<S2SV_blank>annotation"" ) ; return NULL ; } if ( expr1 -> kind != Name_kind ) { simple = 0 ; } ch = CHILD ( ann , 1 ) ; expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) { return NULL ; } if ( NCH ( ann ) == 2 ) { return AnnAssign ( expr1 , expr2 , NULL , simple , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else { ch = CHILD ( ann , 3 ) ; if ( TYPE ( ch ) == testlist ) { expr3 = ast_for_testlist ( c , ch ) ; } else { expr3 = ast_for_expr ( c , ch ) ; } if ( ! expr3 ) { return NULL ; } return AnnAssign ( expr1 , expr2 , expr3 , simple , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } } else { <S2SV_StartBug> int i ; <S2SV_EndBug> asdl_seq * targets ; node * value ; expr_ty expression ; <S2SV_StartBug> REQ ( CHILD ( n , 1 ) , EQUAL ) ; <S2SV_EndBug> <S2SV_StartBug> targets = _Py_asdl_seq_new ( NCH ( n ) / 2 , c -> c_arena ) ; <S2SV_EndBug> if ( ! targets ) return NULL ; <S2SV_StartBug> for ( i = 0 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> expr_ty e ; node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == yield_expr ) { ast_error ( c , ch , ""assignment<S2SV_blank>to<S2SV_blank>yield<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>possible"" ) ; return NULL ; } e = ast_for_testlist ( c , ch ) ; if ( ! e ) return NULL ; if ( ! set_context ( c , e , Store , CHILD ( n , i ) ) ) return NULL ; asdl_seq_SET ( targets , i / 2 , e ) ; } <S2SV_StartBug> value = CHILD ( n , NCH ( n ) - 1 ) ; <S2SV_EndBug> if ( TYPE ( value ) == testlist_star_expr ) expression = ast_for_testlist ( c , value ) ; else expression = ast_for_expr ( c , value ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> return Assign ( targets , expression , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } }
","<S2SV_ModStart> expr_stmt ) ; int num = <S2SV_ModEnd> NCH ( n <S2SV_ModStart> ( n ) ; if ( num <S2SV_ModStart> { int i , nch_minus_type , has_type_comment <S2SV_ModStart> expr_ty expression ; string type_comment ; <S2SV_ModStart> EQUAL ) ; has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ; nch_minus_type = num - has_type_comment ; <S2SV_ModStart> = _Py_asdl_seq_new ( nch_minus_type <S2SV_ModEnd> / 2 , <S2SV_ModStart> ; i < nch_minus_type <S2SV_ModEnd> - 2 ; <S2SV_ModStart> ( n , nch_minus_type <S2SV_ModEnd> - 1 ) <S2SV_ModStart> return NULL ; if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; <S2SV_ModStart> , expression , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,1137,"<S2SV_ModStart> ; if ( TYPE ( CHILD ( n, 0 ) ) == expr_ty && TYPE ( CHILD ( n, 1 ) ) == testlist ) e = ast_for_testlist ( c, CHILD ( n, 0 ) ) ; if (! e ) return NULL ; if (! set_context ( c, e, Store, ch ) ) return NULL ; switch ( TYPE ( CHILD ( n, 2 ) ) { case Name_kind : case Attribute_kind : case Subscript_kind : break ; default : ast_error ( c, ch, ""illegal <S2SV_blank> expression <S2SV_blank> for <S2SV_blank> augmented <S2SV_blank> assignment"" ) ; return NULL ; } ch = CHILD ( n, 3 ) ; if (! set_context ( c, expr1, Store, ch ) ) return NULL ; switch ( expr1 -> kind ) { case AugAssign : expr1 = ast_for_augassign ( c, CHILD ( n, 2 ) ) ; newoperator = ast_for_augassign ( c, CHILD ( n, 1 ) ) ; if (! newoperator ) return NULL ; expr2 = ast_for_expr ( c, ch ) ; if (! expr2 )",0
1140,CWE-20,"CWE-20 int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z,1140,"<S2SV_ModStart> ; int ret = __copy_from_user ( & xtregs -> cp0, & xtregs -> cp0, sizeof ( xtregs -> cp0 ) ) ;",0
1141,CWE-20,"CWE-20 error_t rawSocketReceiveIpPacket ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } rawSocketUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }
","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1141,<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->,1
1142,CWE-22,"CWE-22 static void xcopy_pt_undepend_remotedev ( struct xcopy_op * xop ) { <S2SV_StartBug> struct se_device * remote_dev ; <S2SV_EndBug> if ( xop -> op_origin == XCOL_SOURCE_RECV_OP ) <S2SV_StartBug> remote_dev = xop -> dst_dev ; <S2SV_EndBug> else <S2SV_StartBug> remote_dev = xop -> src_dev ; <S2SV_EndBug> pr_debug ( ""Calling<S2SV_blank>configfs_undepend_item<S2SV_blank>for"" ""<S2SV_blank>remote_dev:<S2SV_blank>%p<S2SV_blank>remote_dev->dev_group:<S2SV_blank>%p\\n"" , remote_dev , & remote_dev -> dev_group . cg_item ) ; target_undepend_item ( & remote_dev -> dev_group . cg_item ) ; }
","<S2SV_ModStart> xop ) { <S2SV_ModEnd> if ( xop <S2SV_ModStart> == XCOL_SOURCE_RECV_OP ) pr_debug ( ""putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> dst_dev <S2SV_ModStart> xop -> dst_dev ) ; else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> src_dev <S2SV_ModStart> xop -> src_dev ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> ) ; }
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z,1142,"<S2SV_ModStart> xop ) { <S2SV_ModEnd> if ( xop <S2SV_ModStart> == XCOL_SOURCE_RECV_OP ) { struct se_device * <S2SV_ModEnd> remote_dev ; pr_debug <S2SV_ModStart> = xop -> src_dev ; pr_debug ( ""Calling <S2SV_blank> configfs_undepend_item <S2SV_blank> for"" "" <S2SV_blank> remote_dev: <S2SV_blank> %p <S2SV_blank> remote_dev->dev_group: <S2SV_blank> %p\\n"", remote_dev, & remote_dev -> dev_group. cg_item ) ; target_undepend_item ( & remote_dev -> dev_group. cg_item ) ; } <S2SV_ModEnd> pr_debug ( ""Calling <S2SV_blank> configfs_undepend_item <S2SV_blank> for""",0
1152,CWE-125,"CWE-125 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
","<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
",torvalds@linux/cef31d9af908243421258f1df35a4a644604efbe,CVE-2017-18344,https://github.com/torvalds/linux/commit/cef31d9af908243421258f1df35a4a644604efbe,2018-07-26T19:29Z,1152,<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;,1
1156,CWE-89,"CWE-89 static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
","<S2SV_ModStart> . path ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> , 0 , & <S2SV_ModEnd> pop3c -> mailbox <S2SV_ModStart> pop3c -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,1156,"<S2SV_ModStart>. path ; return Curl_urldecode <S2SV_ModEnd> ( data, <S2SV_ModStart>, 0, & <S2SV_ModEnd> pop3c -> mailbox <S2SV_ModStart> pop3c -> mailbox, NULL, TRUE ) <S2SV_ModEnd> ; } <S2SV_null>",1
1157,CWE-20,"CWE-20 int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> p += len + 1 ; break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }
","<S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ; <S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ;
",torvalds@linux/be20250c13f88375345ad99950190685eda51eb8,CVE-2011-4913,https://github.com/torvalds/linux/commit/be20250c13f88375345ad99950190685eda51eb8,2012-06-21T23:55Z,1157,<S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ; <S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ;,1
1159,CWE-20,"CWE-20 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { <S2SV_StartBug> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; <S2SV_EndBug> ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> -> ps_cur_slice -> <S2SV_ModEnd> u1_slice_type = P_SLICE
",external@libavc/cc676ebd95247646e67907ccab150fb77a847335,CVE-2016-3741,https://android.googlesource.com/platform/external/libavc/+/cc676ebd95247646e67907ccab150fb77a847335,2016-07-11T01:59Z,1159,<S2SV_ModStart> } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; <S2SV_ModStart> ; } } ps_dec -> i2_total_mbs_coded += u1_num_mbs ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec -> ps_cur_slice -> i2_prev_slice_mbx = 0 ; ps_dec,0
1167,CWE-787,"CWE-787 static int gtStripSeparate ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileSeparateRoutine put = img -> put . separate ; unsigned char * buf = NULL ; unsigned char * p0 = NULL , * p1 = NULL , * p2 = NULL , * pa = NULL ; uint32 row , y , nrow , rowstoread ; tmsize_t pos ; tmsize_t scanline ; uint32 rowsperstrip , offset_row ; uint32 imagewidth = img -> width ; tmsize_t stripsize ; tmsize_t bufsize ; int32 fromskew , toskew ; int alpha = img -> alpha ; int ret = 1 , flip ; uint16 colorchannels ; stripsize = TIFFStripSize ( tif ) ; bufsize = _TIFFMultiplySSize ( tif , alpha ? 4 : 3 , stripsize , ""gtStripSeparate"" ) ; if ( bufsize == 0 ) { return ( 0 ) ; } flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } switch ( img -> photometric ) { case PHOTOMETRIC_MINISWHITE : case PHOTOMETRIC_MINISBLACK : case PHOTOMETRIC_PALETTE : colorchannels = 1 ; break ; default : colorchannels = 3 ; break ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) { <S2SV_StartBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; <S2SV_EndBug> nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; offset_row = row + img -> row_offset ; <S2SV_StartBug> if ( buf == NULL ) <S2SV_EndBug> { if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , ( void * * ) & buf , bufsize , <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && ( buf == NULL || img -> stoponerr ) ) { ret = 0 ; break ; } p0 = buf ; if ( colorchannels == 1 ) { p2 = p1 = p0 ; pa = ( alpha ? ( p0 + 3 * stripsize ) : NULL ) ; } else { p1 = p0 + stripsize ; p2 = p1 + stripsize ; pa = ( alpha ? ( p2 + stripsize ) : NULL ) ; } } else if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , <S2SV_StartBug> p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 1 ) , <S2SV_StartBug> p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 2 ) , <S2SV_StartBug> p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( alpha ) { if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , <S2SV_StartBug> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } } pos = ( ( row + img -> row_offset ) % rowsperstrip ) * scanline + ( ( tmsize_t ) img -> col_offset * img -> samplesperpixel ) ; ( * put ) ( img , raster + y * w , 0 , y , w , nrow , fromskew , toskew , p0 + pos , p1 + pos , p2 + pos , ( alpha ? ( pa + pos ) : NULL ) ) ; y += ( ( flip & FLIP_VERTICALLY ) ? - ( int32 ) nrow : ( int32 ) nrow ) ; } if ( flip & FLIP_HORIZONTALLY ) { uint32 line ; for ( line = 0 ; line < h ; line ++ ) { uint32 * left = raster + ( line * w ) ; uint32 * right = left + w - 1 ; while ( left < right ) { uint32 temp = * left ; * left = * right ; * right = temp ; left ++ ; right -- ; } } } _TIFFfree ( buf ) ; return ( ret ) ; }
","<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ; return 0 ; } <S2SV_ModStart> , bufsize , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p0 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p1 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p2 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , pa , temp <S2SV_ModEnd> * scanline )
",OSGeo@gdal/21674033ee246f698887604c7af7ba1962a40ddf,CVE-2019-17546,https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf,2019-10-14T02:15Z,1167,"<S2SV_ModStart> nrow ) { if ( nrow > ( h - row ) ) { TIFFErrorExt ( tif -> tif_clientdata, ""gtStripSeparate"", ""%s"", ""(row%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", nrow, ( h - row ) ) ; return ( 0 ) ; } <S2SV_ModStart> % rowsperstrip ; nrow = ( row + rowstoread ) % rowsperstrip ; <S2SV_ModStart> NULL ) { if ( nrow > ( h - row ) ) { TIFFErrorExt ( tif -> tif_clientdata, ""gtStripSeparate"", ""%s"", ""(nrow%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", nrow, ( h - row ) ) ; return ( 0 ) ; } <S2SV_ModStart> % rowsperstrip ; if ( nrow > ( h - row ) ) { TIFFErrorExt ( tif -> tif_clientdata, ""gtStripSeparate"", ""(nrow%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", nrow, ( h - row ) ) ; return ( 0 ) ; }",0
1168,CWE-125,"CWE-125 static int num_stmts ( const node * n ) { int i , l ; node * ch ; switch ( TYPE ( n ) ) { case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) return 0 ; else return num_stmts ( CHILD ( n , 0 ) ) ; case file_input : l = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == stmt ) l += num_stmts ( ch ) ; } return l ; case stmt : return num_stmts ( CHILD ( n , 0 ) ) ; case compound_stmt : return 1 ; case simple_stmt : return NCH ( n ) / 2 ; case suite : if ( NCH ( n ) == 1 ) return num_stmts ( CHILD ( n , 0 ) ) ; else { i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 1 ) ; i ++ ) l += num_stmts ( CHILD ( n , i ) ) ; return l ; } default : { char buf [ 128 ] ; sprintf ( buf , ""Non-statement<S2SV_blank>found:<S2SV_blank>%d<S2SV_blank>%d"" , TYPE ( n ) , NCH ( n ) ) ; Py_FatalError ( buf ) ; } } <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ; } } abort ( ) <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1168,"<S2SV_ModStart> ; } } if ( TYPE ( CHILD ( n, 0 ) ) == TYPE_COMMENT ) { i += 2 ; l = 0 ; if ( TYPE ( CHILD ( n, 1 ) ) == TYPE_COMMENT ) i += 2 ; } <S2SV_ModEnd> return 0 ;",0
1170,CWE-20,"CWE-20 long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = NULL ; enum pid_type type ; long ret ; if ( options & ~ ( WNOHANG | WUNTRACED | WCONTINUED | __WNOTHREAD | __WCLONE | __WALL ) ) return - EINVAL ; <S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> type = PIDTYPE_MAX ; else if ( upid < 0 ) { type = PIDTYPE_PGID ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = PIDTYPE_PGID ; pid = get_task_pid ( current , PIDTYPE_PGID ) ; } else { type = PIDTYPE_PID ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | WEXITED ; wo . wo_info = NULL ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - EFAULT ; return ret ; }
","<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
",torvalds@linux/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,CVE-2018-10087,https://github.com/torvalds/linux/commit/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,2018-04-13T13:29Z,1170,<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==,1
1176,CWE-125,"CWE-125 static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) { EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; switch ( type ) { case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( actx == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; return 0 ; } actx -> len . aad = 0 ; actx -> len . text = 0 ; actx -> aad = 0 ; actx -> mac_inited = 0 ; actx -> tag_len = 0 ; actx -> nonce_len = 12 ; actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; return 1 ; case EVP_CTRL_COPY : if ( actx ) { EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( dst -> cipher_data == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; return 0 ; } } return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ; actx -> nonce_len = arg ; return 1 ; case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ; actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ; if ( ptr != NULL ) { memcpy ( actx -> tag , ptr , arg ) ; actx -> tag_len = arg ; } return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ; memcpy ( ptr , actx -> tag , arg ) ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; { unsigned int len ; unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ; len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ; if ( ! ctx -> encrypt ) { <S2SV_StartBug> len -= POLY1305_BLOCK_SIZE ; <S2SV_EndBug> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ; aad = temp ; temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ; temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ; } actx -> tls_payload_length = len ; actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ; actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ; actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ; actx -> mac_inited = 0 ; chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ; return POLY1305_BLOCK_SIZE ; } case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ; default : return - 1 ; } }
","<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
",openssl@openssl/00d965474b22b54e4275232bc71ee0c699c5cd21,CVE-2017-3731,https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21,2017-05-04T19:29Z,1176,"<S2SV_ModStart> ; if ( ( actx -> tag_len & 0x7 ) || ( actx -> tag_len & 0x7 ) ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_NO_TLS_PAYLOAD_LENGTH_ERROR ) ; return 0 ; } actx -> <S2SV_ModStart> ; if ( ( actx -> tag_len & 0x7 ) || ( actx -> tag_len & 0x7 ) ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_NO_TLS_PAYLOAD_ERROR ) ; return 0 ; }",0
1180,CWE-20,"CWE-20 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,1180,<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),1
1188,CWE-787,"CWE-787 void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = AF_INET ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } FD_ZERO ( & read_fd ) ; FD_SET ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , NULL , NULL , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?WATCH={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } while ( G . do_exit == 0 ) { usleep ( 500000 ) ; memset ( G . gps_loc , 0 , sizeof ( float ) * 5 ) ; if ( is_json ) { if ( pos == sizeof ( line ) ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } <S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug> return ; temp = strstr ( line , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { continue ; } if ( strchr ( temp , '}' ) == NULL ) { pos = strlen ( temp ) ; if ( temp != line ) { memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } temp = strstr ( temp , ""\\""lat\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 0 ] ) ; temp = strstr ( temp , ""\\""lon\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 1 ] ) ; temp = strstr ( temp , ""\\""alt\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 4 ] ) ; temp = strstr ( temp , ""\\""speed\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 2 ] ) ; temp = strstr ( temp , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } else { pos = strlen ( temp ) ; memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } else { memset ( line , 0 , sizeof ( line ) ) ; snprintf ( line , sizeof ( line ) - 1 , ""PVTAD\\r\\n"" ) ; if ( send ( gpsd_sock , line , 7 , 0 ) != 7 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( memcmp ( line , ""GPSD,P="" , 7 ) != 0 ) continue ; if ( line [ 7 ] == '?' ) continue ; ret = sscanf ( line + 7 , ""%f<S2SV_blank>%f"" , & G . gps_loc [ 0 ] , & G . gps_loc [ 1 ] ) ; if ( ( temp = strstr ( line , ""V="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 2 ] ) ; if ( ( temp = strstr ( line , ""T="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 3 ] ) ; if ( ( temp = strstr ( line , ""A="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 4 ] ) ; } if ( G . record_data ) fputs ( line , G . f_gps ) ; G . save_gps = 1 ; if ( G . do_exit == 0 ) { unused = write ( G . gc_pipe [ 1 ] , G . gps_loc , sizeof ( float ) * 5 ) ; kill ( getppid ( ) , SIGUSR2 ) ; } } }
","<S2SV_ModStart> line ) - pos -
",aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z,1188,"<S2SV_ModStart> } if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } if (",0
1192,CWE-125,"CWE-125 static int forbidden_name ( struct compiling * c , identifier name , const node * n , int full_checks ) { assert ( PyUnicode_Check ( name ) ) ; <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 ) { <S2SV_EndBug> ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ; return 1 ; } if ( full_checks ) { const char * const * p ; for ( p = FORBIDDEN ; * p ; p ++ ) { <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , * p ) == 0 ) { <S2SV_EndBug> ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ; return 1 ; } } } return 0 ; }
","<S2SV_ModStart> ; if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> , ""__debug__"" ) <S2SV_ModEnd> ) { ast_error <S2SV_ModStart> { if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> * p ) <S2SV_ModEnd> ) { ast_error
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1192,"<S2SV_ModStart> ; if ( _PyUnicode_CompareWithASCIIString <S2SV_ModEnd> ( name, <S2SV_ModStart> ) == 0 && _PyUnicode_CompareWithASCIIString <S2SV_ModEnd> ( name,",0
1195,CWE-89,"CWE-89 static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = ""localhost"" ; } <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
","<S2SV_ModStart> state . path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> ""localhost"" ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state (
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,1195,"<S2SV_ModStart> state. path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> ""localhost"" ; } result = Curl_urldecode ( conn -> data, path, 0, & <S2SV_ModStart> smtpc -> domain, NULL, TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state (",1
1197,CWE-125,"CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
","<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
",devnexen@radare2/88a8adf080a9f8ed5a4250a2507752e133ba54dd,CVE-2018-20459,https://github.com/devnexen/radare2/commit/88a8adf080a9f8ed5a4250a2507752e133ba54dd,2018-12-25T19:29Z,1197,<S2SV_ModStart> [ i ] && j < sizeof ( buf ),0
1202,CWE-125,"CWE-125 static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
","
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,1202,,1
1203,CWE-78,"CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , ""bin.demangle"" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , ""arm"" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , ""bin.lang"" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , ""bin"" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""["" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs<S2SV_blank>exports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Exports]\\n"" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fs<S2SV_blank>symbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Symbols]\\n"" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""Num<S2SV_blank>Paddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vaddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Bind<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Size<S2SV_blank>Name\\n"" ) ; } size_t count = 0 ; r_list_foreach ( symbols , iter , symbol ) { if ( ! symbol -> name ) { continue ; } char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ; ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ; int len = symbol -> size ? symbol -> size : 32 ; SymName sn = { 0 } ; if ( exponly && ! isAnExport ( symbol ) ) { free ( r_symbol_name ) ; continue ; } if ( name && strcmp ( r_symbol_name , name ) ) { free ( r_symbol_name ) ; continue ; } if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) { free ( r_symbol_name ) ; continue ; } if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) { free ( r_symbol_name ) ; continue ; } count ++ ; snInit ( r , & sn , symbol , lang ) ; if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) { } else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) { if ( is_arm ) { handle_arm_special_symbol ( r , symbol , va ) ; } } else if ( IS_MODE_SET ( mode ) ) { if ( is_arm ) { handle_arm_symbol ( r , symbol , info , va ) ; } select_flag_space ( r , symbol ) ; if ( sn . classname ) { RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ; if ( r -> bin -> prefix ) { char * prname = r_str_newf ( ""%s.%s"" , r -> bin -> prefix , sn . methflag ) ; r_name_filter ( sn . methflag , - 1 ) ; free ( sn . methflag ) ; sn . methflag = prname ; } if ( fi ) { r_flag_item_set_realname ( fi , sn . methname ) ; if ( ( fi -> offset - r -> flags -> base ) == addr ) { r_flag_unset ( r -> flags , fi ) ; } } else { fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ; char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ; if ( comment ) { r_flag_item_set_comment ( fi , comment ) ; R_FREE ( comment ) ; } } } else { const char * n = sn . demname ? sn . demname : sn . name ; const char * fn = sn . demflag ? sn . demflag : sn . nameflag ; char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( ""%s.%s"" , r -> bin -> prefix , fn ) : strdup ( fn ) ; RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ; if ( fi ) { r_flag_item_set_realname ( fi , n ) ; fi -> demangled = ( bool ) ( size_t ) sn . demname ; } else { if ( fn ) { eprintf ( ""[Warning]<S2SV_blank>Can\'t<S2SV_blank>find<S2SV_blank>flag<S2SV_blank>(%s)\\n"" , fn ) ; } } free ( fnp ) ; } if ( sn . demname ) { r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ; } r_flag_space_pop ( r -> flags ) ; } else if ( IS_MODE_JSON ( mode ) ) { char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ; r_cons_printf ( ""%s{\\""name\\"":\\""%s\\"","" ""\\""demname\\"":\\""%s\\"","" ""\\""flagname\\"":\\""%s\\"","" ""\\""ordinal\\"":%d,"" ""\\""bind\\"":\\""%s\\"","" ""\\""size\\"":%d,"" ""\\""type\\"":\\""%s\\"","" ""\\""vaddr\\"":%"" PFMT64d "","" ""\\""paddr\\"":%"" PFMT64d ""}"" , ( ( exponly && firstexp ) || printHere ) ? """" : ( iter -> p ? "","" : """" ) , str , sn . demname ? sn . demname : """" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ; free ( str ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( ""0x%08"" PFMT64x ""<S2SV_blank>%d<S2SV_blank>%s\\n"" , addr , ( int ) symbol -> size , name ) ; } else if ( IS_MODE_SIMPLEST ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( ""%s\\n"" , name ) ; } else if ( IS_MODE_RAD ( mode ) ) { if ( is_special_symbol ( symbol ) ) { goto next ; } RBinFile * binfile ; RBinPlugin * plugin ; const char * name = sn . demname ? sn . demname : r_symbol_name ; if ( ! name ) { goto next ; } if ( ! strncmp ( name , ""imp."" , 4 ) ) { if ( lastfs != 'i' ) { r_cons_printf ( ""fs<S2SV_blank>imports\\n"" ) ; } lastfs = 'i' ; } else { if ( lastfs != 's' ) { const char * fs = exponly ? ""exports"" : ""symbols"" ; r_cons_printf ( ""fs<S2SV_blank>%s\\n"" , fs ) ; } lastfs = 's' ; } if ( r -> bin -> prefix || * name ) { char * flagname = construct_symbol_flagname ( ""sym"" , name , MAXFLAG_LEN_DEFAULT ) ; if ( ! flagname ) { goto next ; } r_cons_printf ( ""\\""f<S2SV_blank>%s%s%s<S2SV_blank>%u<S2SV_blank>0x%08"" PFMT64x ""\\""\\n"" , r -> bin -> prefix ? r -> bin -> prefix : """" , r -> bin -> prefix ? ""."" : """" , flagname , symbol -> size , addr ) ; free ( flagname ) ; } binfile = r_bin_cur ( r -> bin ) ; plugin = r_bin_file_cur_plugin ( binfile ) ; if ( plugin && plugin -> name ) { if ( r_str_startswith ( plugin -> name , ""pe"" ) ) { char * module = strdup ( r_symbol_name ) ; char * p = strstr ( module , "".dll_"" ) ; if ( p && strstr ( module , ""imp."" ) ) { char * symname = __filterShell ( p + 5 ) ; char * m = __filterShell ( module ) ; * p = 0 ; if ( r -> bin -> prefix ) { <S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\n"" , <S2SV_EndBug> module , symbol -> ordinal , r -> bin -> prefix , symname ) ; } else { <S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\n"" , <S2SV_EndBug> module , symbol -> ordinal , symname ) ; } free ( symname ) ; free ( m ) ; } free ( module ) ; } } } else { const char * bind = symbol -> bind ? symbol -> bind : ""NONE"" ; const char * type = symbol -> type ? symbol -> type : ""NONE"" ; const char * name = r_str_get ( sn . demname ? sn . demname : r_symbol_name ) ; r_cons_printf ( ""%03u"" , symbol -> ordinal ) ; if ( symbol -> paddr == UT64_MAX ) { r_cons_printf ( ""<S2SV_blank>----------"" ) ; } else { r_cons_printf ( ""<S2SV_blank>0x%08"" PFMT64x , symbol -> paddr ) ; } r_cons_printf ( ""<S2SV_blank>0x%08"" PFMT64x ""<S2SV_blank>%6s<S2SV_blank>%6s<S2SV_blank>%4d%s%s\\n"" , addr , bind , type , symbol -> size , * name ? ""<S2SV_blank>"" : """" , name ) ; } next : snFini ( & sn ) ; i ++ ; free ( r_symbol_name ) ; if ( exponly && firstexp ) { firstexp = false ; } if ( printHere ) { break ; } } if ( count == 0 && IS_MODE_JSON ( mode ) ) { r_cons_printf ( ""{}"" ) ; } if ( is_arm ) { r_list_foreach ( entries , iter , entry ) { if ( IS_MODE_SET ( mode ) ) { handle_arm_entry ( r , entry , info , va ) ; } } } if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""]"" ) ; } r_spaces_pop ( & r -> anal -> meta_spaces ) ; return true ; }
","<S2SV_ModStart> { r_cons_printf ( ""\\""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\""\\n"" <S2SV_ModEnd> , module , <S2SV_ModStart> { r_cons_printf ( ""\\""k<S2SV_blank>bin/pe/%s/%d=%s\\""\\n"" <S2SV_ModEnd> , module ,
",radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z,1203,"<S2SV_ModStart> { r_cons_printf ( ""\\n"" ) ; } if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""\\nFS <S2SV_blank> exports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""\\nFS <S2SV_blank> symbols\\n"" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags, R_FLAGS_FS_SYMBOLS ) ; } else { r_spaces_push ( & r -> anal -> meta_spaces, ""bin"" ) ; } if (! at &&! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""\\nFS <S2SV_blank> symbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( ""\\nFS <S2SV_blank> exports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_spaces_push ( & r -> anal -> meta_spaces, ""bin"" ) ; }",0
1215,CWE-416,"CWE-416 static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ;
",libexif@libexif/ec412aa4583ad71ecabb967d3c77162760169d1f,CVE-2020-13113,https://github.com/libexif/libexif/commit/ec412aa4583ad71ecabb967d3c77162760169d1f,2020-05-21T17:15Z,1215,"<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ], 0, sizeof ( MnoteFujiEntry ) ) ;",1
1217,CWE-20,"CWE-20 static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
","<S2SV_ModStart> bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,1217,<S2SV_ModStart> bd_addr ) { if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ;,0
1218,CWE-416,"CWE-416 static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ; <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }
","<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
",torvalds@linux/2638fd0f92d4397884fd991d8f4925cb3f081901,CVE-2017-18017,https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901,2018-01-03T06:29Z,1218,<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (,1
1226,CWE-416,"CWE-416 static int xfrm_dump_policy ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net * net = sock_net ( skb -> sk ) ; <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ; info . in_skb = cb -> skb ; info . out_skb = skb ; info . nlmsg_seq = cb -> nlh -> nlmsg_seq ; info . nlmsg_flags = NLM_F_MULTI ; <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> cb -> args [ 0 ] = 1 ; xfrm_policy_walk_init ( walk , XFRM_POLICY_TYPE_ANY ) ; } ( void ) xfrm_policy_walk ( net , walk , dump_one_policy , & info ) ; return skb -> len ; }
","<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct xfrm_dump_info <S2SV_ModStart> struct xfrm_dump_info info <S2SV_ModEnd> ; info . <S2SV_ModStart> = NLM_F_MULTI ; <S2SV_ModEnd> ( void )
",torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2,CVE-2017-16939,https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2,2017-11-24T10:29Z,1226,<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct xfrm_dump_info <S2SV_ModStart> struct xfrm_dump_info info <S2SV_ModEnd> ; info. <S2SV_ModStart> = NLM_F_MULTI ; <S2SV_ModEnd> ( void ),1
1228,CWE-20,"CWE-20 static int ovl_remove_upper ( struct dentry * dentry , bool is_dir ) { struct dentry * upperdir = ovl_dentry_upper ( dentry -> d_parent ) ; struct inode * dir = upperdir -> d_inode ; <S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> int err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ; <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> dget ( upper ) ; if ( is_dir ) err = vfs_rmdir ( dir , upper ) ; else err = vfs_unlink ( dir , upper , NULL ) ; <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> ovl_dentry_version_inc ( dentry -> d_parent ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) d_drop ( dentry ) ; <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> return err ; }
","<S2SV_ModStart> dentry * upper <S2SV_ModEnd> ; int err <S2SV_ModStart> I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> ovl_dentry_version_inc ( dentry <S2SV_ModStart> ) ; } dput ( upper ) ; <S2SV_ModStart> dentry ) ; out_unlock :
",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z,1228,"<S2SV_ModStart> dentry * upper <S2SV_ModEnd> ; int err <S2SV_ModStart> I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name. name, upperdir, dentry -> d_name. len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> ovl_dentry_version_inc ( dentry <S2SV_ModStart> ) ; } dput ( upper ) ; <S2SV_ModStart> dentry ) ; out_unlock :",1
1231,CWE-125,"CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ; <S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; } <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , ""Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n"" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , ""all"" ) == 0 ) { all_flag = 1 ; body_pref = ""rht"" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }
","<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&
",verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z,1231,<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&,1
1232,CWE-787,"CWE-787 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; <S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
","<S2SV_ModStart> = act_code ; if ( npix > 0 ) <S2SV_ModStart> = casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - stackp <S2SV_ModStart> - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= (
",miniupnp@ngiflib/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,CVE-2018-10717,https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,2018-05-03T17:29Z,1232,"<S2SV_ModStart> ) ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log, ""*** <S2SV_blank> WARNING <S2SV_blank> *** <S2SV_blank> Image <S2SV_blank> bigger <S2SV_blank> than <S2SV_blank> global <S2SV_blank> GIF <S2SV_blank> canvas <S2SV_blank>!\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log, ""*** <S2SV_blank> WARNING <S2SV_blank> *** <S2SV_blank> Adjusting <S2SV_blank> Y <S2SV_blank> position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log, ""*** <S2SV_blank> WARNING <S2SV_blank> *** <S2SV_blank> Adjusting <S2SV_blank> X <S2SV_blank> position\\n""",0
1239,CWE-787,"CWE-787 <S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }
","<S2SV_ModStart> UINT32 nsc_rle_encode ( const
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,1239,<S2SV_ModStart> UINT32 nsc_rle_encode ( const,1
1244,CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b,CVE-2019-19275,https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b,2019-11-26T15:15Z,1244,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1245,CWE-20,"CWE-20 static void test_headers_bad ( Test * test , gconstpointer data ) { GHashTable * headers ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=1;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=2;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; <S2SV_StartBug> g_hash_table_destroy ( headers ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;
",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z,1245,"<S2SV_ModStart> ) ) g_hash_table_destroy ( headers ) ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers, g_strdup ( ""Cookie"" ), g_strdup ( ""CockpitAuth=v=3;k=blah"" ) ; if ( cockpit_auth_check_cookie ( test -> auth, ""/cockpit"", headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers, g_strdup ( ""CockpitAuth=v=4;k=blah"" ) ; if ( cockpit_auth_check_cookie ( test -> auth, ""/cockpit"", headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers, g_strdup ( ""Cookie"" ), g_strdup ( ""CockpitAuth=v=6;k=blah"" ) ) ; g_hash_",0
1252,CWE-125,"CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_StartBug> int hexdump ; <S2SV_EndBug> u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> ; int hexdump , ret <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
",the-tcpdump-group@tcpdump/d97e94223720684c6aa740ff219e0d19426c2220,CVE-2018-14464,https://github.com/the-tcpdump-group/tcpdump/commit/d97e94223720684c6aa740ff219e0d19426c2220,2019-10-03T16:15Z,1252,"<S2SV_ModStart>, obj_tlen ; u_int <S2SV_ModEnd> hexdump ; u_int <S2SV_ModStart> hexdump ) ; if ( tlen < 4 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> (too <S2SV_blank> short)"" ) ) ; return ; }",0
1273,CWE-20,"CWE-20 MonoReflectionMethod * mono_reflection_bind_generic_method_parameters ( MonoReflectionMethod * rmethod , MonoArray * types ) { MonoClass * klass ; MonoMethod * method , * inflated ; MonoMethodInflated * imethod ; MonoGenericContext tmp_context ; MonoGenericInst * ginst ; MonoType * * type_argv ; int count , i ; MONO_ARCH_SAVE_REGS ; if ( ! strcmp ( rmethod -> object . vtable -> klass -> name , ""MethodBuilder"" ) ) { # ifndef DISABLE_REFLECTION_EMIT MonoReflectionMethodBuilder * mb = NULL ; MonoReflectionTypeBuilder * tb ; MonoClass * klass ; mb = ( MonoReflectionMethodBuilder * ) rmethod ; tb = ( MonoReflectionTypeBuilder * ) mb -> type ; klass = mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) tb ) ) ; method = methodbuilder_to_mono_method ( klass , mb ) ; # else g_assert_not_reached ( ) ; method = NULL ; # endif } else { method = rmethod -> method ; } klass = method -> klass ; if ( method -> is_inflated ) method = ( ( MonoMethodInflated * ) method ) -> declaring ; count = mono_method_signature ( method ) -> generic_param_count ; if ( count != mono_array_length ( types ) ) return NULL ; type_argv = g_new0 ( MonoType * , count ) ; for ( i = 0 ; i < count ; i ++ ) { MonoReflectionType * garg = mono_array_get ( types , gpointer , i ) ; type_argv [ i ] = mono_reflection_type_get_handle ( garg ) ; } ginst = mono_metadata_get_generic_inst ( count , type_argv ) ; g_free ( type_argv ) ; tmp_context . class_inst = klass -> generic_class ? klass -> generic_class -> context . class_inst : NULL ; tmp_context . method_inst = ginst ; inflated = mono_class_inflate_generic_method ( method , & tmp_context ) ; imethod = ( MonoMethodInflated * ) inflated ; if ( method -> klass -> image -> dynamic ) { MonoDynamicImage * image = ( MonoDynamicImage * ) method -> klass -> image ; mono_loader_lock ( ) ; mono_g_hash_table_insert ( image -> generic_def_objects , imethod , rmethod ) ; mono_loader_unlock ( ) ; } <S2SV_StartBug> return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ;
",mono@mono/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,CVE-2010-4254,https://github.com/mono/mono/commit/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,2010-12-06T13:44Z,1273,<S2SV_ModStart> imethod ) ; if (! inflated ) { mono_context_reset ( & tmp_context ) ; mono_class_inflate_generic_method ( imethod ) ; return NULL ; },0
1279,CWE-416,"CWE-416 static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) <S2SV_StartBug> { <S2SV_EndBug> struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } if ( ! opt ) <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ; <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug> do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
","<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,1279,<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart>! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;,1
1291,CWE-125,"CWE-125 stmt_ty <S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>target<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>iter<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ; <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,1291,"<S2SV_ModStart> expr_ty iter, string type_comment, <S2SV_ModStart> orelse ; p -> v. AsyncFor. type_comment = type_comment ; p ->",0
1296,CWE-125,"CWE-125 static UINT rdpei_recv_pdu ( RDPEI_CHANNEL_CALLBACK * callback , wStream * s ) { UINT16 eventId ; UINT32 pduLength ; UINT error ; <S2SV_StartBug> Stream_Read_UINT16 ( s , eventId ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , pduLength ) ; # ifdef WITH_DEBUG_RDPEI WLog_DBG ( TAG , ""rdpei_recv_pdu:<S2SV_blank>eventId:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>(%s)<S2SV_blank>length:<S2SV_blank>%"" PRIu32 """" , eventId , rdpei_eventid_string ( eventId ) , pduLength ) ; # endif switch ( eventId ) { case EVENTID_SC_READY : if ( ( error = rdpei_recv_sc_ready_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_sc_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } if ( ( error = rdpei_send_cs_ready_pdu ( callback ) ) ) { WLog_ERR ( TAG , ""rdpei_send_cs_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_SUSPEND_TOUCH : if ( ( error = rdpei_recv_suspend_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_suspend_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_RESUME_TOUCH : if ( ( error = rdpei_recv_resume_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_resume_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; default : break ; } return CHANNEL_RC_OK ; }
","<S2SV_ModStart> UINT error ; if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1296,"<S2SV_ModStart> UINT error ; if (! Stream_SafeSeek ( s, 4 ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart>, pduLength ) ; if (! Stream_SafeSeek ( s, pduLength ) ) return ERROR_INVALID_DATA",0
1302,CWE-20,"CWE-20 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
",ImageMagick@ImageMagick/8a370f9ab120faf182aa160900ba692ba8e2bcf0,CVE-2016-10069,https://github.com/ImageMagick/ImageMagick/commit/8a370f9ab120faf182aa160900ba692ba8e2bcf0,2017-03-02T21:59Z,1302,"<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; }",0
1303,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; UINT16 length ; UINT32 failureCode ; <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> , ""RDP_NEG_FAILURE"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FAIL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1303,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> = NEGO_STATE_FAIL ; if ( Stream_GetRemainingLength ( s ) < 4 ) { return FALSE ; } <S2SV_ModStart> = NEGO_STATE_FAIL ; if ( Stream_GetRemainingLength ( s ) < 4 ) { return FALSE ; },0
1306,CWE-125,"CWE-125 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif break ; case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) { r1 . o = function -> return_obj ; push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , <S2SV_StartBug> r2 . re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> NULL , NULL ) >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } yr_modules_unload_all ( context ) ; yr_free ( stack ) ; return result ; }
","<S2SV_ModStart> -> length , 0 ,
",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z,1306,<S2SV_ModStart> == ERROR_SUCCESS ) { yr_free ( stack ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; } <S2SV_ModStart> ++ ) { yr_free ( stack ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == ( YR_VALUE * ) yr_malloc ( stack_size ) ) return ERROR_INSUFFICIENT_MEMORY ; } while ( stack!= ( YR_VALUE * ) yr_malloc ( stack_size ) ) { yr_free ( stack ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size ) ; if ( stack == ( YR_VALUE * ) yr_malloc ( stack_size ) ; if ( stack == ( YR_VALUE * ) yr_malloc ( stack_size ) ) return ERROR_INSUFFICIENT_MEMORY,0
1311,CWE-787,"CWE-787 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
","<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false
",radare@radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf,CVE-2018-20460,https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,2018-12-25T19:29Z,1311,"<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too <S2SV_blank> many <S2SV_blank> operands\\n"" ) ; return false",1
1313,CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,1313,"<S2SV_ModStart> name ) { size_t size = sizeof ( char ) * 2 + 16 ; if ( size < 2 ) { ERR ( ""Memory <S2SV_blank> allocation <S2SV_blank> error: <S2SV_blank> %d <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", size, ( unsigned int ) strlen ( name ) ) ; return ; } <S2SV_ModEnd> dst_name = malloc <S2SV_ModStart> 2 + 16 ) ; if (! ( dst = fopen ( dst_name, ""w"" ) ) ) { ERR ( ""Could <S2SV_blank> not <S2SV_blank> open <S2SV_blank> file <S2SV_blank> \'%s\' <S2SV_blank> for <S2SV_blank> writing\\n"", dst_name ) ; return ; } size = strlen ( dst_name ) ; if ( size < 4 ) { ERR ( ""Memory <S2SV_blank> allocation <S2SV_blank> error: <S2SV_blank> %d <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", dst_name, ( unsigned int ) ( unsigned int ) sizeof ( char ) ) ; if (! ( dst = fopen ( dst_name, ""w"" ) ) { ERR ( ""Could <S2SV_blank> not <S2SV_blank> open <S2SV_blank> file <S2SV_blank> \'%s\' <S2SV_blank> for <S2SV_blank> writing\\n"", dst_name ) ; return ; }",0
1315,CWE-20,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) <S2SV_StartBug> * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> colormap = ( <S2SV_ModStart> x ++ ) { <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t )
",ImageMagick@ImageMagick/7fdf9ea808caa3c81a0eb42656e5fafc59084198,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/7fdf9ea808caa3c81a0eb42656e5fafc59084198,2017-05-22T14:29Z,1315,"<S2SV_ModStart> ) ) ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_ModStart> image ) ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_ModStart> ""ImproperImageHeader"" ) ; do { pixel_info = ( PixelPacket * ) RelinquishMagickMemory ( pixel_info ) ; pixel_info = ( PixelPacket * ) RelinquishMagickMemory ( pixel_info ) ; if ( pixel_info!= ( MemoryInfo * ) NULL ) pixel_info = ( MemoryInfo * ) RelinquishMagickMemory ( pixel_info ) ; if ( pixel_info!= ( MemoryInfo * ) NULL ) pixel_info = ( MemoryInfo * ) RelinquishMagickMemory ( pixel_info ) ; if ( pixel_info!= ( MemoryInfo * ) NULL ) pixel_info = ( PixelPacket * ) Relinqu",0
1329,CWE-20,"CWE-20 static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; <S2SV_StartBug> if ( pkt_len == - 1 ) <S2SV_EndBug> return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }
","<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; if <S2SV_ModStart> FALSE ; } return parse_netscreen_packet ( wth -> random_fh , phdr , buf <S2SV_ModEnd> , line , <S2SV_ModStart> , line , <S2SV_ModEnd> err , err_info <S2SV_ModStart> err_info ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",wireshark@wireshark/6a140eca7b78b230f1f90a739a32257476513c78,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78,2016-08-07T16:59Z,1329,"<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; if <S2SV_ModStart> FALSE ; } return parse_netscreen_packet ( wth -> random_fh, phdr, buf <S2SV_ModEnd>, line, <S2SV_ModStart>, line, <S2SV_ModEnd> err, err_info <S2SV_ModStart> err_info ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>",1
1331,CWE-125,"CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
",ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z,1331,<S2SV_ModStart> 255U ; } for ( j = 0 ; j < length ; j ++ ) { CheckNumberPixels ( 8 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 1 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ; break ; } case 3 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 1 ) & 0x07 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; break ; } case 4 : { CheckNumberPixels ( 5 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 0 ) & 0x07 ) ; break ; } case 5 : { CheckNumberPixels ( 6 ) ; * pixels ++ = ( pixel >>,0
1335,CWE-125,"CWE-125 static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z,1335,"<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao, buf_size, 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o, buf_size, 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o, buf_size, 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o, buf_size, 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o, buf_size, 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( s > buf_size - 12 ) { exif_log ( en -> log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteFuji"", ""Short <S2SV_blank> MakerNote"" ) ; break ; } n -> entries [ tcount ]. entry_type = exif_get_short ( buf + o, EXIF_BYTE_ORDER_INTEL ) ; n -> entries [ tcount ]. entries = exif_mem_alloc ( en -> mem, sizeof ( MnoteFujiEntry ) * c ) ; if (! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log, ""ExifMnoteFuji"", sizeof ( MnoteF",0
1337,CWE-125,"CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; <S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }
","<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
",the-tcpdump-group@tcpdump/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,CVE-2017-13012,https://github.com/the-tcpdump-group/tcpdump/commit/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,2017-09-14T06:29Z,1337,"<S2SV_ModStart> ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res, plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res, hlen ) ) { <S2SV_ModStart> ) ) ; }",0
1338,CWE-416,"CWE-416 static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { <S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
","<S2SV_ModStart> dentry * dir <S2SV_ModEnd> ; int dir_has_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL )
",torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,CVE-2017-7374,https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,2017-03-31T20:59Z,1338,<S2SV_ModStart> dentry * dir <S2SV_ModEnd> ; int dir_has_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd>!= NULL ),1
1342,CWE-125,"CWE-125 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p )
",miniupnp@miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47,CVE-2016-3178,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,2017-03-24T15:59Z,1342,<S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > ( unsigned ) <S2SV_ModEnd> buf + n <S2SV_ModStart> ; if ( l > (,0
1344,CWE-20,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if (
",ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7,2018-09-06T22:29Z,1344,"<S2SV_ModStart>, message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart>, file )!= c ) break",0
1346,CWE-20,"CWE-20 error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1346,"<S2SV_ModStart> ( interface, ENC624J600_EHT1 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT2 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT5 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT6 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT7 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT8 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT9 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT10 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT11 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT12 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT13 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT14 <S2SV_ModEnd> )",0
1347,CWE-125,"CWE-125 static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MagickPathExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MagickPathExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
",ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z,1347,"<S2SV_ModStart> image ) ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",0
1348,CWE-416,"CWE-416 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } <S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
",miniupnp@miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a,CVE-2016-3179,https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a,2017-03-24T15:59Z,1348,"<S2SV_ModStart> ; } } DECODELENGTH_CHECKLIMIT ( l, p, buf + n ) ; if ( l > ( unsigned ) sizeof ( rbuf ) ) { syslog ( LOG_WARNING, ""bad <S2SV_blank> request <S2SV_blank> (length=0)"" ) ; goto error ; } n = read ( req -> socket, buf, sizeof ( buf ) ) ; if ( n < ( unsigned ) sizeof ( rbuf ) ) { syslog ( LOG_WARNING, ""bad <S2SV_blank> request <S2SV_blank> (length=0)"" ) ; goto error ; } if ( l > ( unsigned ) sizeof ( rbuf ) ) { syslog ( LOG_WARNING, ""bad <S2SV_blank> request <S2SV_blank> (length=0)"" ) ; goto error ; } if ( l > ( unsigned ) sizeof ( rbuf ) ) { syslog ( LOG_WARNING, ""bad <S2SV_blank> request <S2SV_blank> (length=0)"" ) ; goto error ; }",0
1353,CWE-125,"CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z,1353,"<S2SV_ModStart> ) { struct ikev2_id id ; unsigned int <S2SV_ModEnd> id_len, idtype_len <S2SV_ModStart> * typedata ; ND_TCHECK2 ( * ext ) ; UNALIGNED_MEMCPY ( & id, ext, sizeof ( id ) ) ; ikev2_pay_print ( ndo, NPSTR ( tpay ), id. h. critical ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo, "" <S2SV_blank> "" ) ) ; if (! rawprint ( ndo, ( const uint8_t * ) ( ext + 1 ), id_len - 4 ) ) goto trunc ; } <S2SV_ModStart> case ID_VPN_ADDR : ND_PRINT ( ( ndo, "" <S2SV_blank> vpx:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo, "" <S2SV_blank> rfc822:"" ) ) ; dumphex = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo, "" <S2SV_blank> ipv6:"" ) ) ; dumpascii = 1 ; break ; case ID",0
1354,CWE-787,"CWE-787 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
","<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,1354,"<S2SV_ModStart> int tagval, uint32 <S2SV_ModEnd> * length )",1
1356,CWE-125,"CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; <S2SV_StartBug> size_t <S2SV_EndBug> value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
","<S2SV_ModStart> 4 ] ; unsigned int <S2SV_ModEnd> value ; if <S2SV_ModStart> value = ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,1356,<S2SV_ModStart> 4 ] ; unsigned int <S2SV_ModEnd> value ; if <S2SV_ModStart> value = ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart>. unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (,1
1357,CWE-20,"CWE-20 void Rectangle ( double x , double y , double w , double h ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> h ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , <S2SV_ModStart> h ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,1357,"<S2SV_ModStart> h ) { sprintf ( outputbuffer <S2SV_ModEnd>, ""\\n <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> re"", <S2SV_ModStart> h ) ; sendClean ( outputbuffer ) ;",1
1359,CWE-20,"CWE-20 <S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> { struct io_context * ioc ; <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
","<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
",torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z,1359,<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if,1
1367,CWE-20,"CWE-20 int yyparse ( void ) # else int yyparse ( ) # endif # endif { int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yytoken = 0 ; yyss = yyssa ; yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; yyssp = yyss ; yyvsp = yyvs ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yyn == YYPACT_NINF ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = YYLEX ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yyn == 0 || yyn == YYTABLE_NINF ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; * ++ yyvsp = yylval ; goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 5 : # line 320 ""ntp_parser.y"" { msyslog ( LOG_ERR , ""syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d,<S2SV_blank>column<S2SV_blank>%d"" , ip_file -> fname , ip_file -> err_line_no , ip_file -> err_col_no ) ; } break ; case 19 : # line 354 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 20 : # line 360 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 27 : # line 377 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET ) ; } break ; case 28 : # line 378 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET6 ) ; } break ; case 29 : # line 382 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) , 0 ) ; } break ; case 30 : # line 386 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 31 : # line 387 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 32 : # line 391 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 33 : # line 392 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 34 : # line 393 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 35 : # line 394 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 36 : # line 395 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 37 : # line 396 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 38 : # line 397 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 39 : # line 398 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 40 : # line 399 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 41 : # line 400 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 42 : # line 401 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 43 : # line 402 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 44 : # line 403 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 45 : # line 404 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 46 : # line 405 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 47 : # line 415 ""ntp_parser.y"" { struct unpeer_node * my_node = create_unpeer_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; if ( my_node ) enqueue ( cfgt . unpeers , my_node ) ; } break ; case 50 : # line 434 ""ntp_parser.y"" { cfgt . broadcastclient = 1 ; } break ; case 51 : # line 436 ""ntp_parser.y"" { append_queue ( cfgt . manycastserver , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 52 : # line 438 ""ntp_parser.y"" { append_queue ( cfgt . multicastclient , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 53 : # line 449 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 54 : # line 451 ""ntp_parser.y"" { cfgt . auth . control_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 55 : # line 453 ""ntp_parser.y"" { cfgt . auth . cryptosw ++ ; append_queue ( cfgt . auth . crypto_cmd_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 56 : # line 458 ""ntp_parser.y"" { cfgt . auth . keys = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 57 : # line 460 ""ntp_parser.y"" { cfgt . auth . keysdir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 58 : # line 462 ""ntp_parser.y"" { cfgt . auth . request_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 59 : # line 464 ""ntp_parser.y"" { cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 60 : # line 466 ""ntp_parser.y"" { cfgt . auth . trusted_key_list = ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ; } break ; case 61 : # line 468 ""ntp_parser.y"" { cfgt . auth . ntp_signd_socket = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 63 : # line 474 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 64 : # line 479 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 65 : # line 486 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 66 : # line 496 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 67 : # line 498 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 68 : # line 500 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 69 : # line 502 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 70 : # line 504 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 71 : # line 506 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 72 : # line 508 ""ntp_parser.y"" { ( yyval . Attr_val ) = NULL ; cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; msyslog ( LOG_WARNING , ""\'crypto<S2SV_blank>revoke<S2SV_blank>%d\'<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>"" ""please<S2SV_blank>use<S2SV_blank>\'revoke<S2SV_blank>%d\'<S2SV_blank>instead."" , cfgt . auth . revoke , cfgt . auth . revoke ) ; } break ; case 73 : # line 525 ""ntp_parser.y"" { append_queue ( cfgt . orphan_cmds , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 74 : # line 529 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 75 : # line 530 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 76 : # line 535 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 77 : # line 537 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 78 : # line 539 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 79 : # line 541 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 80 : # line 543 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 81 : # line 545 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 82 : # line 547 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 83 : # line 549 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 84 : # line 551 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 85 : # line 553 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 86 : # line 555 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 87 : # line 565 ""ntp_parser.y"" { append_queue ( cfgt . stats_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 88 : # line 567 ""ntp_parser.y"" { if ( input_from_file ) cfgt . stats_dir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""statsdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 89 : # line 576 ""ntp_parser.y"" { enqueue ( cfgt . filegen_opts , create_filegen_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 90 : # line 583 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 91 : # line 584 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 100 : # line 600 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 101 : # line 607 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 102 : # line 617 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; else { ( yyval . Attr_val ) = NULL ; free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""filegen<S2SV_blank>file<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 103 : # line 627 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>type<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 104 : # line 636 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>link<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 105 : # line 645 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>nolink<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 106 : # line 653 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 107 : # line 654 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 115 : # line 674 ""ntp_parser.y"" { append_queue ( cfgt . discard_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 116 : # line 678 ""ntp_parser.y"" { append_queue ( cfgt . mru_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 117 : # line 682 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 118 : # line 687 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 5 ) - ( 5 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 119 : # line 692 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 120 : # line 697 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 121 : # line 710 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 122 : # line 723 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , enqueue ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) , ip_file -> line_no ) ) ; } break ; case 123 : # line 734 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 124 : # line 736 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 139 : # line 758 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 140 : # line 760 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 141 : # line 764 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 142 : # line 765 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 143 : # line 766 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 144 : # line 771 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 145 : # line 773 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 146 : # line 777 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 147 : # line 778 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 148 : # line 779 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 149 : # line 780 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 150 : # line 781 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 151 : # line 782 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 152 : # line 783 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 153 : # line 784 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 154 : # line 793 ""ntp_parser.y"" { enqueue ( cfgt . fudge , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 155 : # line 798 ""ntp_parser.y"" { enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 156 : # line 800 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 157 : # line 804 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 158 : # line 805 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 159 : # line 806 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 160 : # line 807 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 161 : # line 808 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 162 : # line 809 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 163 : # line 810 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 164 : # line 811 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 165 : # line 820 ""ntp_parser.y"" { append_queue ( cfgt . enable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 166 : # line 822 ""ntp_parser.y"" { append_queue ( cfgt . disable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 167 : # line 827 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 168 : # line 834 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 169 : # line 843 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 170 : # line 844 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 171 : # line 845 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 172 : # line 846 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 173 : # line 847 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 174 : # line 848 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 175 : # line 850 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""enable/disable<S2SV_blank>stats<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 176 : # line 865 ""ntp_parser.y"" { append_queue ( cfgt . tinker , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 177 : # line 869 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 178 : # line 870 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 179 : # line 874 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 180 : # line 875 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 181 : # line 876 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 182 : # line 877 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 183 : # line 878 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 184 : # line 879 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 185 : # line 880 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 187 : # line 891 ""ntp_parser.y"" { if ( curr_include_level >= MAXINCLUDELEVEL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded."" ) ; } else { fp [ curr_include_level + 1 ] = F_OPEN ( FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) , ""r"" ) ; if ( fp [ curr_include_level + 1 ] == NULL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>\\n"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; } else ip_file = fp [ ++ curr_include_level ] ; } } break ; case 188 : # line 907 ""ntp_parser.y"" { while ( curr_include_level != - 1 ) FCLOSE ( fp [ curr_include_level -- ] ) ; } break ; case 189 : # line 913 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 190 : # line 915 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 191 : # line 917 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 192 : # line 919 ""ntp_parser.y"" { } break ; case 193 : # line 921 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 194 : # line 924 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 195 : # line 926 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""logfile<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 196 : # line 937 ""ntp_parser.y"" { append_queue ( cfgt . logconfig , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 197 : # line 939 ""ntp_parser.y"" { append_queue ( cfgt . phone , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 198 : # line 941 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""saveconfigdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 199 : # line 951 ""ntp_parser.y"" { enqueue ( cfgt . setvar , ( yyvsp [ ( 2 ) - ( 2 ) ] . Set_var ) ) ; } break ; case 200 : # line 953 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ) ; } break ; case 201 : # line 955 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 202 : # line 957 ""ntp_parser.y"" { append_queue ( cfgt . ttl , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 203 : # line 959 ""ntp_parser.y"" { enqueue ( cfgt . qos , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 204 : # line 964 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 205 : # line 966 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( T_WanderThreshold , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 2 ) ] . String ) ) ) ; } break ; case 206 : # line 969 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ""\\0"" ) ) ; } break ; case 207 : # line 974 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Integer ) ) ; } break ; case 208 : # line 976 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , 0 ) ; } break ; case 209 : # line 981 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 210 : # line 982 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 211 : # line 986 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 212 : # line 987 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_pval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 213 : # line 991 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 214 : # line 992 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 215 : # line 997 ""ntp_parser.y"" { <S2SV_StartBug> char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( prefix != '+' && prefix != '-' && prefix != '=' ) { <S2SV_EndBug> yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\'+\',<S2SV_blank>\'-\'<S2SV_blank>or<S2SV_blank>\'=\'\\n"" ) ; } else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; <S2SV_StartBug> YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; <S2SV_EndBug> } break ; case 216 : # line 1012 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1017 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1048 ""ntp_parser.y"" <S2SV_StartBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } <S2SV_EndBug> break ; case 228 : # line 1049 ""ntp_parser.y"" <S2SV_StartBug> { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } <S2SV_EndBug> break ; case 229 : # line 1054 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1056 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1061 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1067 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1071 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 235 : # line 1072 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1076 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; <S2SV_StartBug> case 237 : <S2SV_EndBug> # line 1077 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ; } break ; case 238 : <S2SV_StartBug> # line 1082 ""ntp_parser.y"" <S2SV_EndBug> { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 0 && ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 1 ) { yyerror ( ""Integer<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>boolean<S2SV_blank>(0<S2SV_blank>or<S2SV_blank>1).<S2SV_blank>Assuming<S2SV_blank>1"" ) ; ( yyval . Integer ) = 1 ; } else ( yyval . Integer ) = ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 239 : <S2SV_StartBug> # line 1090 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Integer ) = 1 ; } break ; case 240 : <S2SV_StartBug> # line 1091 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Integer ) = 0 ; } break ; case 241 : <S2SV_StartBug> # line 1095 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Double ) = ( double ) ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 243 : <S2SV_StartBug> # line 1106 ""ntp_parser.y"" <S2SV_EndBug> { cfgt . sim_details = create_sim_node ( ( yyvsp [ ( 3 ) - ( 5 ) ] . Queue ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; old_config_style = 1 ; } break ; case 244 : <S2SV_StartBug> # line 1120 ""ntp_parser.y"" <S2SV_EndBug> { old_config_style = 0 ; } break ; case 245 : <S2SV_StartBug> # line 1124 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 246 : <S2SV_StartBug> # line 1125 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 247 : <S2SV_StartBug> # line 1129 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 248 : <S2SV_StartBug> # line 1130 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 249 : <S2SV_StartBug> # line 1134 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_server ) ) ; } break ; case 250 : <S2SV_StartBug> # line 1135 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_server ) ) ; } break ; case 251 : <S2SV_StartBug> # line 1140 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Sim_server ) = create_sim_server ( ( yyvsp [ ( 1 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 5 ) ] . Double ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; } break ; case 252 : <S2SV_StartBug> # line 1144 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Double ) = ( yyvsp [ ( 3 ) - ( 4 ) ] . Double ) ; } break ; case 253 : <S2SV_StartBug> # line 1148 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Address_node ) = ( yyvsp [ ( 3 ) - ( 3 ) ] . Address_node ) ; } break ; case 254 : <S2SV_StartBug> # line 1152 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_script ) ) ; } break ; case 255 : <S2SV_StartBug> # line 1153 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_script ) ) ; } break ; case 256 : <S2SV_StartBug> # line 1158 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Sim_script ) = create_sim_script_info ( ( yyvsp [ ( 3 ) - ( 6 ) ] . Double ) , ( yyvsp [ ( 5 ) - ( 6 ) ] . Queue ) ) ; } break ; case 257 : <S2SV_StartBug> # line 1162 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 258 : <S2SV_StartBug> # line 1163 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 259 : <S2SV_StartBug> # line 1168 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 260 : <S2SV_StartBug> # line 1170 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 261 : <S2SV_StartBug> # line 1172 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 262 : <S2SV_StartBug> # line 1174 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 263 : <S2SV_StartBug> # line 1176 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; <S2SV_StartBug> # line 3826 ""ntp_parser.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else { YYSIZE_T yysize = yysyntax_error ( 0 , yystate , yychar ) ; if ( yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM ) { YYSIZE_T yyalloc = 2 * yysize ; if ( ! ( yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM ) ) yyalloc = YYSTACK_ALLOC_MAXIMUM ; if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yyalloc ) ; if ( yymsg ) yymsg_alloc = yyalloc ; else { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; } } if ( 0 < yysize && yysize <= yymsg_alloc ) { ( void ) yysyntax_error ( yymsg , yystate , yychar ) ; yyerror ( yymsg ) ; } else { yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; if ( yysize != 0 ) goto yyexhaustedlab ; } } # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( yyn != YYPACT_NINF ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } * ++ yyvsp = yylval ; YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined ( yyoverflow ) || YYERROR_VERBOSE yyexhaustedlab : yyerror ( YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval ) ; YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return YYID ( yyresult ) ; }
","<S2SV_ModStart> { char prefix <S2SV_ModEnd> ; char * <S2SV_ModStart> char * type ; switch ( <S2SV_ModEnd> ( yyvsp [ <S2SV_ModStart> . String ) [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> + 1 ; break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> ) ] . <S2SV_ModStart> String ) ) ) ; } break ; case 235 : # line 1082 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 ""ntp_parser.y"" { ( yyval <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) <S2SV_ModEnd> = enqueue_in_new_queue ( <S2SV_ModStart> = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> ) ] . <S2SV_ModStart> break ; case <S2SV_ModEnd> 238 : # <S2SV_ModStart> : # line 1092 <S2SV_ModEnd> ""ntp_parser.y"" { if <S2SV_ModStart> : # line 1100 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1101 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1105 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1116 <S2SV_ModEnd> ""ntp_parser.y"" { cfgt <S2SV_ModStart> : # line 1130 <S2SV_ModEnd> ""ntp_parser.y"" { old_config_style <S2SV_ModStart> : # line 1134 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1135 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1139 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1140 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1144 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1145 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1150 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1154 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1158 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1162 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1163 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1168 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1172 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1173 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1178 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1180 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1182 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1184 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1186 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> ; # line 3836 <S2SV_ModEnd> ""ntp_parser.c"" default :
",ntp-project@ntp/553f2fa65865c31c5e3c48812cfd46176cffdd27,CVE-2015-5194,https://github.com/ntp-project/ntp/commit/553f2fa65865c31c5e3c48812cfd46176cffdd27,2017-07-21T14:29Z,1367,"<S2SV_ModStart> : # line 113 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd>",0
1371,CWE-125,"CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,1371,"<S2SV_ModStart> ( ndo, ""%s"", rpl_tstr <S2SV_ModEnd> ) ) ;",1
1379,CWE-125,"CWE-125 PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; <S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }
","<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1
",DanBloomberg@leptonica/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,CVE-2020-36281,https://github.com/DanBloomberg/leptonica/commit/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,2021-03-12T01:15Z,1379,"<S2SV_ModStart> * lined ; l_uint32 <S2SV_ModEnd> * pixc, <S2SV_ModStart>, * pixg, * pixd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if (! pixc ) return ( PIX * ) ERROR_PTR ( ""pixc <S2SV_blank> is <S2SV_blank> undefined <S2SV_blank> or <S2SV_blank> not <S2SV_blank> 32 <S2SV_blank> bpp"", procName, NULL ) ; if (! pixm ||! pixg ||! pixd ) return ( PIX * ) ERROR_PTR ( ""too <S2SV_blank> many <S2SV_blank> colors"", procName, NULL ) ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs, level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too <S2SV_blank> many <S2SV_blank> colors"", procName, NULL ) ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs, level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too <S2SV_blank> many <S2SV_blank> colors"", procName, NULL ) ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs, level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( """,0
1383,CWE-89,"CWE-89 char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; <S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , ""%%%02X"" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }
","<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,1383,<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0,1
1385,CWE-416,"CWE-416 int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; <S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
","<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
",torvalds@linux/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,CVE-2014-4653,https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,2014-07-03T04:22Z,1385,<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx,1
1389,CWE-20,"CWE-20 int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inet<S2SV_blank>check<S2SV_blank>by<S2SV_blank>%s<S2SV_blank>%d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; <S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Got<S2SV_blank>packet<S2SV_blank>%d<S2SV_blank>%d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( ""<S2SV_blank>(DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
","<S2SV_ModStart> - 2 ; if ( plen < 0 ) return 0 ;
",aircrack-ng@aircrack-ng/da087238963c1239fdabd47dc1b65279605aca70,CVE-2014-8323,https://github.com/aircrack-ng/aircrack-ng/commit/da087238963c1239fdabd47dc1b65279605aca70,2017-10-17T14:29Z,1389,<S2SV_ModStart> - 2 ; if ( plen > sizeof ( buf ) ) return 1 ;,0
1391,CWE-125,"CWE-125 static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( ""Invalid<S2SV_blank>strings<S2SV_blank>size\\n"" ) ; return false ; } if ( bin -> classes ) { ut64 amount = sizeof ( int ) * bin -> header . method_size ; if ( amount > UT32_MAX || amount < bin -> header . method_size ) { return false ; } methods = calloc ( 1 , amount + 1 ) ; for ( i = 0 ; i < bin -> header . class_size ; i ++ ) { char * super_name , * class_name ; struct dex_class_t * c = & bin -> classes [ i ] ; class_name = dex_class_name ( bin , c ) ; super_name = dex_class_super_name ( bin , c ) ; if ( dexdump ) { rbin -> cb_printf ( ""Class<S2SV_blank>#%d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-\\n"" , i ) ; } parse_class ( arch , bin , c , i , methods , & sym_count ) ; free ( class_name ) ; free ( super_name ) ; } } if ( methods ) { int import_count = 0 ; int sym_count = bin -> methods_list -> length ; for ( i = 0 ; i < bin -> header . method_size ; i ++ ) { int len = 0 ; if ( methods [ i ] ) { continue ; } <S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> continue ; } if ( is_class_idx_in_code_classes ( bin , bin -> methods [ i ] . class_id ) ) { continue ; } char * class_name = getstr ( bin , bin -> types [ bin -> methods [ i ] . class_id ] . descriptor_id ) ; if ( ! class_name ) { free ( class_name ) ; continue ; } len = strlen ( class_name ) ; if ( len < 1 ) { continue ; } class_name [ len - 1 ] = 0 ; char * method_name = dex_method_name ( bin , i ) ; char * signature = dex_method_signature ( bin , i ) ; if ( method_name && * method_name ) { RBinImport * imp = R_NEW0 ( RBinImport ) ; imp -> name = r_str_newf ( ""%s.method.%s%s"" , class_name , method_name , signature ) ; imp -> type = r_str_const ( ""FUNC"" ) ; imp -> bind = r_str_const ( ""NONE"" ) ; imp -> ordinal = import_count ++ ; r_list_append ( bin -> imports_list , imp ) ; RBinSymbol * sym = R_NEW0 ( RBinSymbol ) ; sym -> name = r_str_newf ( ""imp.%s"" , imp -> name ) ; sym -> type = r_str_const ( ""FUNC"" ) ; sym -> bind = r_str_const ( ""NONE"" ) ; sym -> paddr = sym -> vaddr = bin -> b -> base + bin -> header . method_offset + ( sizeof ( struct dex_method_t ) * i ) ; sym -> ordinal = sym_count ++ ; r_list_append ( bin -> methods_list , sym ) ; sdb_num_set ( mdb , sdb_fmt ( 0 , ""method.%d"" , i ) , sym -> paddr , 0 ) ; } free ( method_name ) ; free ( signature ) ; free ( class_name ) ; } free ( methods ) ; } return true ; }
","<S2SV_ModStart> header . types_size <S2SV_ModEnd> ) { continue
",radare@radare2/ead645853a63bf83d8386702cad0cf23b31d7eeb,CVE-2017-6387,https://github.com/radare/radare2/commit/ead645853a63bf83d8386702cad0cf23b31d7eeb,2017-03-02T01:59Z,1391,"<S2SV_ModStart> header. types_size ) { eprintf ( ""Invalid <S2SV_blank> types <S2SV_blank> size\\n"" ) ; return false ; } if (! bin -> classes ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; r_list_free ( bin -> classes_list ) ; r_list_free ( bin -> imports_list ) ; r_list_free ( bin -> classes_list ) ; r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; r_list_free ( bin -> classes_list ) ; r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; r_list_free ( bin -> classes_list ) ; r_list_free ( bin -> imports_list ) ; return false ; }",0
1393,CWE-89,"CWE-89 char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,1393,<S2SV_ModStart> len ) { size_t <S2SV_ModEnd> alloc = ( <S2SV_ModStart> int alloc = ( length < 0 )? length : ( int ) strlen ( string ) ; char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; CURLcode <S2SV_ModEnd> res ; if <S2SV_ModStart> ( res ) { free ( ns ) ; return NULL ; } ns [ strindex ++ ] = in <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( olen ) <S2SV_ModEnd> * olen = <S2SV_ModStart> strindex ; return ns <S2SV_ModEnd> ; } <S2SV_null>,0
1394,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { UINT16 length ; WLog_DBG ( TAG , ""RDP_NEG_RSP"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) { WLog_ERR ( TAG , ""Invalid<S2SV_blank>RDP_NEG_RSP"" ) ; nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> return ; <S2SV_EndBug> } Stream_Read_UINT8 ( s , nego -> flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> SelectedProtocol ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_response ( rdpNego <S2SV_ModStart> NEGO_STATE_FAIL ; return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1394,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_response ( rdpNego <S2SV_ModStart> state = NEGO_STATE_FAIL ; return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;,0
1396,CWE-20,"CWE-20 error_t tja1101Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1101...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1101_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1101WritePhyReg ( interface , TJA1101_BASIC_CTRL , TJA1101_BASIC_CTRL_RESET ) ; while ( tja1101ReadPhyReg ( interface , TJA1101_BASIC_CTRL ) & TJA1101_BASIC_CTRL_RESET ) { } tja1101DumpPhyReg ( interface ) ; value = tja1101ReadPhyReg ( interface , TJA1101_EXTENDED_CTRL ) ; value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ; tja1101WritePhyReg ( interface , TJA1101_EXTENDED_CTRL , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_CONFIG1 ) ; value &= ~ TJA1101_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_COMM_CTRL ) ; value |= TJA1101_COMM_CTRL_AUTO_OP ; tja1101WritePhyReg ( interface , TJA1101_COMM_CTRL , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> ; tja1101WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1396,<S2SV_ModStart> ; value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ <S2SV_ModEnd> ; tja1101WritePhyReg (,0
1398,CWE-125,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z,1398,<S2SV_ModStart> ; if ( <S2SV_ModEnd> len < sizeof <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS,0
1401,CWE-125,"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z,1401,"<S2SV_ModStart> ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == COMMA ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) )",0
1411,CWE-20,"CWE-20 error_t httpClientSetQueryString ( HttpClientContext * context , const char_t * queryString ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || queryString == NULL ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { <S2SV_StartBug> q = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; } else { q = p ; m = 0 ; } n = osStrlen ( queryString ) ; if ( n == 0 ) { osMemmove ( p , p + m , context -> buffer + context -> bufferLen + 1 - q ) ; } else { n ++ ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; p [ 0 ] = '?' ; osStrncpy ( p + 1 , queryString , n - 1 ) ; } context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { q = osStrchr <S2SV_ModEnd> ( p +
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1411,<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { q = osStrchr <S2SV_ModEnd> ( p +,1
1412,CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z,1412,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1414,CWE-20,"CWE-20 error_t enc624j600ReceivePacket ( NetInterface * interface ) { error_t error ; <S2SV_StartBug> uint16_t n ; <S2SV_EndBug> uint32_t status ; <S2SV_StartBug> Enc624j600Context * context ; <S2SV_EndBug> context = ( Enc624j600Context * ) interface -> nicContext ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ; <S2SV_EndBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , <S2SV_StartBug> ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> context -> nextPacket = letoh16 ( context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ; <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ; <S2SV_EndBug> error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC624J600_RX_BUFFER_START ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ; <S2SV_EndBug> } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> } return error ; }
","<S2SV_ModStart> error ; uint16_t length <S2SV_ModEnd> ; uint32_t status <S2SV_ModStart> uint32_t status ; uint8_t header [ 8 ] ; <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> ) { enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_ERXRDPT <S2SV_ModEnd> , context -> <S2SV_ModStart> , ENC624J600_CMD_RRXDATA , header <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> 0 ) { length <S2SV_ModEnd> = MIN ( <S2SV_ModStart> = MIN ( length <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> ) ; error <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> ENC624J600_RX_BUFFER_STOP ) ; <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> context -> nextPacket <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> , & ancillary
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1414,"<S2SV_ModStart> error ; uint16_t nextPacket ; uint16_t <S2SV_ModEnd> status ; Enc624j600Context <S2SV_ModStart> ( interface, ENC624J600_ESTAT ) ; if ( ( enc624j600ReadReg ( interface, ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT ) { enc624j600WriteReg ( interface, ENC624J600_ERXRDPT, context -> nextPacket ) ; enc624j600ReadBuffer ( interface, ENC624J600_CMD_RRXDATA, ( uint8_t * ) & n, sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface, ENC624J600_CMD_RRXDATA, ( uint8_t * ) & status, sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ; enc624j600ReadBuffer ( interface, ENC624J600_CMD_RRXDATA, ( uint8_t * ) & n, sizeof ( uint16_t ) ) ; context -> nextPacket =",0
1426,CWE-787,"CWE-787 static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) { <S2SV_StartBug> int v , i ; <S2SV_EndBug> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || <S2SV_StartBug> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }
","<S2SV_ModStart> , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> != 6 ) || s -> bit_depth == 1
",FFmpeg@FFmpeg/e477f09d0b3619f3d29173b2cd593e17e2d1978e,CVE-2017-7863,https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e,2017-04-14T04:59Z,1426,"<S2SV_ModStart>, i ; if (! ( s -> state & PNG_IHDR ) ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> before <S2SV_blank> IHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> after <S2SV_blank> IDAT\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart>!= 6 ) || s -> bit_depth == 1",1
1429,CWE-20,"CWE-20 error_t ksz8851ReceivePacket ( NetInterface * interface ) { size_t n ; uint16_t status ; Ksz8851Context * context ; NetRxAncillary ancillary ; context = ( Ksz8851Context * ) interface -> nicContext ; <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RXFHSR_RXFV ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ; <S2SV_EndBug> if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; return NO_ERROR ; } } } <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ; <S2SV_EndBug> return ERROR_INVALID_PACKET ; }
","<S2SV_ModStart> ( interface , KSZ8851_RXFHSR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> ) != 0 <S2SV_ModStart> status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> ) ) == <S2SV_ModStart> ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851ReadFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ancillary <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1429,"<S2SV_ModStart> = ksz8851ReadReg ( interface, KSZ8851_RXFHSR ) ; if ( ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( status & KSZ8851_RXFV_RXFV <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> )!= 0 <S2SV_ModStart>!= 0 ) { n = ksz8851ReadFifo ( interface, context -> rxBuffer, n ) ; ksz8851ClearBit ( interface, KSZ8851_RXQCR, KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851ReadFifo <S2SV_ModStart> ( interface, KSZ8851_RXFDPR, KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface, KSZ8851_RXFDPR, KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface, KSZ8851_RXQCR, KSZ8851_RXQCR",0
1430,CWE-125,"CWE-125 static stmt_ty <S2SV_StartBug> ast_for_funcdef_impl ( struct compiling * c , const node * n , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * decorator_seq , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>functions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_StartBug> type_comment , LINENO ( n ) , <S2SV_EndBug> n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> const node * n0 <S2SV_ModEnd> , asdl_seq * <S2SV_ModStart> * decorator_seq , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1430,"<S2SV_ModStart> const node * n0, asdl_seq * decorator_seq, bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async? CHILD ( n0, 1 ) : n0 ; <S2SV_ModStart> returns, type_comment, LINENO ( n0 ), n0 -> n_col_offset, c -> c_arena ) ; if ( TYPE ( CHILD ( n0, 0 ) )!= TYPE_COMMENT ) type_comment = NULL ; if ( NCH ( CHILD ( n0, 0 ) > 3 ) type_comment = NULL ; name_i += 4 ; if ( TYPE ( CHILD ( n0, 1 ) ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( CHILD ( n0, 2 ) ) ; if (! type_comment ) return NULL ; name_i += 4 ; } <S2SV_ModStart> body, decorator_seq, returns, type_comment, LINENO ( n0 ), n0 -> n_col_offset, c -> c_arena ) ; if (! <S2SV_ModStart> returns, type_comment, LINENO ( n0 ), n0 -> n_",0
1432,CWE-20,"CWE-20 static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if ( strcmp ( command , ""permipc"" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; COMMON_AUDIT_DATA_INIT ( & sa , NONE ) ; sa . aad . op = OP_SETPROCATTR ; sa . aad . info = name ; sa . aad . error = - EINVAL ; <S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> & sa , NULL ) ; } } else if ( strcmp ( name , ""exec"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; } else { return - EINVAL ; } if ( ! error ) error = size ; return error ; }
","<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; }
",torvalds@linux/a5b2c5b2ad5853591a6cac6134cd0f599a720865,CVE-2011-3619,https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865,2013-06-08T13:05Z,1432,"<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED, __aa_current_profile ( ), GFP_KERNEL, & sa, NULL <S2SV_ModEnd> ) ; }",1
1433,CWE-20,"CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; <S2SV_StartBug> cstate = 0 ; <S2SV_EndBug> if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <S2SV_EndBug> ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> uint_fast8_t tmp ; siz -> comps = 0 ; <S2SV_ModStart> ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",mdadams@jasper/f7038068550fba0e41e1d0c355787f1dcd5bf330,CVE-2016-9394,https://github.com/mdadams/jasper/commit/f7038068550fba0e41e1d0c355787f1dcd5bf330,2017-03-23T18:59Z,1433,"<S2SV_ModStart> uint_fast8_t tmp ; siz -> comps = 0 ; <S2SV_ModStart> ) ) { goto error ; } if (! siz -> width ||! siz -> height ) { jas_eprintf ( ""image <S2SV_blank> area <S2SV_blank> is <S2SV_blank> outside <S2SV_blank> the <S2SV_blank> image <S2SV_blank> area\\n"" ) ; goto error ; } if (! siz -> tilewidth ||! siz -> tileheight ) { jas_eprintf ( ""tile <S2SV_blank> is <S2SV_blank> outside <S2SV_blank> the <S2SV_blank> image <S2SV_blank> area\\n"" ) ; goto error ; } if (! siz -> numcomps ||! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( ""number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> is <S2SV_blank> outside <S2SV_blank> the <S2SV_blank> image <S2SV_blank> area\\n"" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( ""xoff <S2SV_blank> is <S2SV_blank> outside <S2SV_blank> the <S2SV_blank> image <S2SV_blank> area\\n"" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( ""yoff <S2SV_blank> is <S2SV_blank> outside <S2SV_blank> the <S2SV_blank> image <S2SV_blank> area\\n"" ) ;",0
1435,CWE-125,"CWE-125 struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XDIRINFO"" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_size -- ; xmi_tmpdata -= 13 ; xmi_data += xmi_tmpdata ; xmi_size -= xmi_tmpdata ; if ( memcmp ( xmi_data , ""CAT<S2SV_blank>"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_catlen = * xmi_data ++ << 24 ; xmi_catlen |= * xmi_data ++ << 16 ; xmi_catlen |= * xmi_data ++ << 8 ; xmi_catlen |= * xmi_data ++ ; xmi_size -= 4 ; UNUSED ( xmi_catlen ) ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( xmi_mdi , xmi_divisions ) ; _WM_midi_setup_tempo ( xmi_mdi , xmi_tempo ) ; xmi_samples_per_delta_f = _WM_GetSamplesPerTick ( xmi_divisions , xmi_tempo ) ; xmi_notelen = malloc ( sizeof ( uint32_t ) * 16 * 128 ) ; memset ( xmi_notelen , 0 , ( sizeof ( uint32_t ) * 16 * 128 ) ) ; for ( i = 0 ; i < xmi_formcnt ; i ++ ) { if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen = * xmi_data ++ << 24 ; xmi_subformlen |= * xmi_data ++ << 16 ; xmi_subformlen |= * xmi_data ++ << 8 ; xmi_subformlen |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen -= 4 ; do { if ( ! memcmp ( xmi_data , ""TIMB"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""RBRN"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""EVNT"" , 4 ) ) { xmi_data += 4 ; xmi_evnt_cnt ++ ; xmi_evntlen = * xmi_data ++ << 24 ; xmi_evntlen |= * xmi_data ++ << 16 ; xmi_evntlen |= * xmi_data ++ << 8 ; xmi_evntlen |= * xmi_data ++ ; xmi_size -= 8 ; xmi_subformlen -= 8 ; do { if ( * xmi_data < 0x80 ) { xmi_delta = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; do { if ( ( xmi_lowestdelta != 0 ) && ( xmi_lowestdelta <= xmi_delta ) ) { xmi_tmpdata = xmi_lowestdelta ; } else { xmi_tmpdata = xmi_delta ; } xmi_sample_count_f = ( ( ( float ) xmi_tmpdata * xmi_samples_per_delta_f ) + xmi_sample_remainder ) ; xmi_sample_count = ( uint32_t ) xmi_sample_count_f ; xmi_sample_remainder = xmi_sample_count_f - ( float ) xmi_sample_count ; xmi_mdi -> events [ xmi_mdi -> event_count - 1 ] . samples_to_next += xmi_sample_count ; xmi_mdi -> extra_info . approx_total_samples += xmi_sample_count ; xmi_lowestdelta = 0 ; for ( j = 0 ; j < ( 16 * 128 ) ; j ++ ) { if ( xmi_notelen [ j ] == 0 ) continue ; xmi_notelen [ j ] -= xmi_tmpdata ; if ( xmi_notelen [ j ] == 0 ) { xmi_ch = j / 128 ; xmi_note = j - ( xmi_ch * 128 ) ; _WM_midi_setup_noteoff ( xmi_mdi , xmi_ch , xmi_note , 0 ) ; } else { if ( ( xmi_lowestdelta == 0 ) || ( xmi_lowestdelta > xmi_notelen [ j ] ) ) { xmi_lowestdelta = xmi_notelen [ j ] ; } } } xmi_delta -= xmi_tmpdata ; } while ( xmi_delta ) ; } else { if ( ( xmi_data [ 0 ] == 0xff ) && ( xmi_data [ 1 ] == 0x51 ) && ( xmi_data [ 2 ] == 0x03 ) ) { setup_ret = 6 ; goto _XMI_Next_Event ; } <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <S2SV_EndBug> goto _xmi_end ; } if ( ( * xmi_data & 0xf0 ) == 0x90 ) { xmi_ch = * xmi_data & 0x0f ; xmi_note = xmi_data [ 1 ] ; xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; xmi_tmpdata = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; xmi_notelen [ 128 * xmi_ch + xmi_note ] = xmi_tmpdata ; if ( ( xmi_tmpdata > 0 ) && ( ( xmi_lowestdelta == 0 ) || ( xmi_tmpdata < xmi_lowestdelta ) ) ) { xmi_lowestdelta = xmi_tmpdata ; } } else { _XMI_Next_Event : xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; } } } while ( xmi_evntlen ) ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } } while ( xmi_subformlen ) ; } if ( ( xmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _xmi_end ; } xmi_mdi -> extra_info . current_sample = 0 ; xmi_mdi -> current_event = & xmi_mdi -> events [ 0 ] ; xmi_mdi -> samples_to_mix = 0 ; xmi_mdi -> note = NULL ; if ( xmi_evnt_cnt > 1 ) { xmi_mdi -> is_type2 = 1 ; } _WM_ResetToStart ( xmi_mdi ) ; _xmi_end : if ( xmi_notelen != NULL ) free ( xmi_notelen ) ; if ( xmi_mdi -> reverb ) return ( xmi_mdi ) ; _WM_freeMDI ( xmi_mdi ) ; return NULL ; }
","<S2SV_ModStart> , xmi_data , xmi_size ,
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z,1435,"<S2SV_ModStart> << 24 ; if ( xmi_tmpdata & 0xffff ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_XMI, ""Bad <S2SV_blank> XMI <S2SV_blank> data"", 0 ) ; return NULL ; } <S2SV_ModStart> << 16 ; if ( xmi_tmpdata & 0xffff ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_XMI, ""Bad <S2SV_blank> XMI <S2SV_blank> data"", 0 ) ; return NULL ; } <S2SV_ModStart> << 24 ; if ( xmi_tmpdata & 0xffff ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_XMI, ""Bad <S2SV_blank> XMI <S2SV_blank> data"", 0 ) ; return NULL ; } <S2SV_ModStart> << 16 ; if ( xmi_tmpdata & 0xffff ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_XMI, ""Bad <S2SV_blank> XMI <S2SV_blank> data"", 0 ) ; return NULL ; } <S2SV_ModStart> << 24 ; if ( xmi_tmpdata & 0xffff ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_",0
1437,CWE-787,"CWE-787 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
",ImageMagick@ImageMagick/19651f3db63fa1511ed83a348c4c82fa553f8d01,CVE-2019-13308,https://github.com/ImageMagick/ImageMagick/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01,2019-07-05T01:15Z,1437,<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (,1
1438,CWE-20,"CWE-20 static void ikev2_parent_inI2outR2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI2outR2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>R2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI2outR2_tail ( pcrc , r ) ; if ( e > STF_FAIL ) { int v2_notify_num = e - STF_FAIL ; DBG_log ( ""ikev2_parent_inI2outR2_tail<S2SV_blank>returned<S2SV_blank>STF_FAIL<S2SV_blank>with<S2SV_blank>%s"" , enum_name ( & ikev2_notify_names , v2_notify_num ) ) ; } else if ( e != STF_OK ) { DBG_log ( ""ikev2_parent_inI2outR2_tail<S2SV_blank>returned<S2SV_blank>%s"" , enum_name ( & stfstatus_name , e ) ) ; } if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z,1438,<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,1
1441,CWE-20,"CWE-20 int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n"" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n"" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n"" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n"" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = ""\\x1b[0m"" ; static const char * GREEN = ""\\x1b[0;32m"" ; static const char * RED = ""\\x1b[0;31m"" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = """" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( ""\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n"" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> if ( test_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( ""\\n"" ) ; if ( fail ) { printf ( ""%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n"" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( ""All<S2SV_blank>tests<S2SV_blank>passed!\\n"" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }
","<S2SV_ModStart> -> enable ( false
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,1441,"<S2SV_ModStart> } if ( bdaddr_is_zero ( & bt_remote_bdaddr ) ) { printf ( ""Error: <S2SV_blank> bdaddr <S2SV_blank> is <S2SV_blank> zero.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; }",0
1444,CWE-787,"CWE-787 static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; <S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }
","<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev )
",torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z,1444,<S2SV_ModStart> len < needed ||! nl,0
1445,CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
",ImageMagick@ImageMagick/b173a352397877775c51c9a0e9d59eb6ce24c455,CVE-2016-10070,https://github.com/ImageMagick/ImageMagick/commit/b173a352397877775c51c9a0e9d59eb6ce24c455,2017-03-03T18:59Z,1445,<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;,1
1446,CWE-20,"CWE-20 static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; <S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed<S2SV_blank>to<S2SV_blank>back<S2SV_blank>to<S2SV_blank>remapped<S2SV_blank>mode,<S2SV_blank>irq:<S2SV_blank>%u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>update<S2SV_blank>PI<S2SV_blank>IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
","<S2SV_ModStart> , ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> irq_srcu ) ; if <S2SV_ModEnd> ( guest_irq >= <S2SV_ModStart> irq_rt -> nr_rt_entries || hlist_empty ( <S2SV_ModEnd> & irq_rt -> <S2SV_ModStart> [ guest_irq ] ) ) { pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ]
",torvalds@linux/3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb,CVE-2017-1000252,https://github.com/torvalds/linux/commit/3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb,2017-09-26T05:29Z,1446,"<S2SV_ModStart> vcpu_info ; int nr_rt_entries, ret ; if ( guest_irq >= irq_rt -> nr_rt_entries || guest_irq >= nr_rt_entries ) return - EINVAL ; nr_rt_entries = irq_rt -> nr_rt_entries ; <S2SV_ModStart> ; BUG_ON ( guest_irq >= nr_rt_entries ) ; hlist_for_each_entry ( e, & irq_rt -> map [ guest_irq ], link ) { if ( e -> type!= KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm, e, & irq ) ; if (! set && kvm_intr_is_single_vcpu ( kvm, & irq, & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq, NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed <S2SV_blank> to <S2SV_blank> back <S2SV_blank> to <S2SV_blank> remapped <S2SV_blank> mode, <S2SV_blank> irq: <S2SV_blank> %u\\n"", host_irq ) ;",0
1447,CWE-416,"CWE-416 static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <S2SV_StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <S2SV_EndBug> return HRTIMER_NORESTART ; }
","<S2SV_ModStart> ) bfq_idle_slice_timer_body ( bfqd ,
",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z,1447,<S2SV_ModStart> ( bfqq ) { hrtimer_try_to_cancel ( timer ) ;,0
1451,CWE-125,"CWE-125 static int update_prepare_order_info ( rdpContext * context , ORDER_INFO * orderInfo , UINT32 orderType ) { int length = 1 ; orderInfo -> fieldFlags = 0 ; orderInfo -> orderType = orderType ; orderInfo -> controlFlags = ORDER_STANDARD ; orderInfo -> controlFlags |= ORDER_TYPE_CHANGE ; length += 1 ; <S2SV_StartBug> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; <S2SV_EndBug> length += update_prepare_bounds ( context , orderInfo ) ; return length ; }
","<S2SV_ModStart> ; length += get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ; length +=
",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z,1451,<S2SV_ModStart> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ <S2SV_ModEnd> orderInfo -> orderType,0
1452,CWE-20,"CWE-20 static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ; <S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ; <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> new -> d_name . len ) ; <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> goto out_unlock ; <S2SV_StartBug> } <S2SV_EndBug> err = - ESTALE ; <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> goto out_dput ; <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ; <S2SV_StartBug> out_unlock : <S2SV_EndBug> unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }
","<S2SV_ModStart> ; olddentry = lookup_one_len ( old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> . name , old_upperdir , old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> = PTR_ERR ( olddentry <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( IS_ERR ( olddentry <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto out_unlock ; <S2SV_ModEnd> err = - <S2SV_ModStart> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> newdentry ) ; out_dput_old : dput ( olddentry ) ;
",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z,1452,<S2SV_ModStart> ; if ( new -> d_inode && new -> d_inode -> i_uid == old -> d_inode -> i_uid ) { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid ) { err = - EPERM ; goto out ; } else { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid && new -> d_inode -> i_uid == old -> d_inode -> i_uid && new -> d_inode -> i_uid!= new -> d_inode -> i_uid ) { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid ) { err = - EPERM ; goto out ; } } else { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid && new -> d_inode -> i_uid!= old -> d_inode -> i_uid && new -> d_inode -> i_uid!= new -> d_inode -> i_uid ) { err = - EPER,0
1453,CWE-125,"CWE-125 static int match_at ( regex_t * reg , const UChar * str , const UChar * end , # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE const UChar * right_range , # endif const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) { static UChar FinishCode [ ] = { OP_FINISH } ; int i , n , num_mem , best_len , pop_level ; LengthType tlen , tlen2 ; MemNumType mem ; RelAddrType addr ; UChar * s , * q , * sbegin ; int is_alloca ; char * alloc_base ; OnigStackType * stk_base , * stk , * stk_end ; OnigStackType * stkp ; OnigStackIndex si ; OnigStackIndex * repeat_stk ; OnigStackIndex * mem_start_stk , * mem_end_stk ; # ifdef USE_COMBINATION_EXPLOSION_CHECK int scv ; unsigned char * state_check_buff = msa -> state_check_buff ; int num_comb_exp_check = reg -> num_comb_exp_check ; # endif UChar * p = reg -> p ; OnigOptionType option = reg -> options ; OnigEncoding encode = reg -> enc ; OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; pop_level = reg -> stack_pop_level ; num_mem = reg -> num_mem ; STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; UPDATE_FOR_STACK_REALLOC ; for ( i = 1 ; i <= num_mem ; i ++ ) { mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; } # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""match_at:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>start:<S2SV_blank>%d,<S2SV_blank>sprev:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; fprintf ( stderr , ""size:<S2SV_blank>%d,<S2SV_blank>start<S2SV_blank>offset:<S2SV_blank>%d\\n"" , ( int ) ( end - str ) , ( int ) ( sstart - str ) ) ; # endif STACK_PUSH_ENSURED ( STK_ALT , FinishCode ) ; best_len = ONIG_MISMATCH ; s = ( UChar * ) sstart ; while ( 1 ) { # ifdef ONIG_DEBUG_MATCH { UChar * q , * bp , buf [ 50 ] ; int len ; fprintf ( stderr , ""%4d><S2SV_blank>\\"""" , ( int ) ( s - str ) ) ; bp = buf ; for ( i = 0 , q = s ; i < 7 && q < end ; i ++ ) { len = enclen ( encode , q ) ; while ( len -- > 0 ) * bp ++ = * q ++ ; } if ( q < end ) { xmemcpy ( bp , ""...\\"""" , 4 ) ; bp += 4 ; } else { xmemcpy ( bp , ""\\"""" , 1 ) ; bp += 1 ; } * bp = 0 ; fputs ( ( char * ) buf , stderr ) ; for ( i = 0 ; i < 20 - ( bp - buf ) ; i ++ ) fputc ( '<S2SV_blank>' , stderr ) ; onig_print_compiled_byte_code ( stderr , p , NULL , encode ) ; fprintf ( stderr , ""\\n"" ) ; } # endif sbegin = s ; switch ( * p ++ ) { case OP_END : MOP_IN ( OP_END ) ; n = s - sstart ; if ( n > best_len ) { OnigRegion * region ; # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE if ( IS_FIND_LONGEST ( option ) ) { if ( n > msa -> best_len ) { msa -> best_len = n ; msa -> best_s = ( UChar * ) sstart ; } else goto end_best_len ; } # endif best_len = n ; region = msa -> region ; if ( region ) { # ifdef USE_POSIX_API_REGION_OPTION if ( IS_POSIX_REGION ( msa -> options ) ) { posix_regmatch_t * rmt = ( posix_regmatch_t * ) region ; rmt [ 0 ] . rm_so = sstart - str ; rmt [ 0 ] . rm_eo = s - str ; for ( i = 1 ; i <= num_mem ; i ++ ) { if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) rmt [ i ] . rm_so = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; else rmt [ i ] . rm_so = ( UChar * ) ( ( void * ) ( mem_start_stk [ i ] ) ) - str ; rmt [ i ] . rm_eo = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; } else { rmt [ i ] . rm_so = rmt [ i ] . rm_eo = ONIG_REGION_NOTPOS ; } } } else { # endif region -> beg [ 0 ] = sstart - str ; region -> end [ 0 ] = s - str ; for ( i = 1 ; i <= num_mem ; i ++ ) { if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) region -> beg [ i ] = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; else region -> beg [ i ] = ( UChar * ) ( ( void * ) mem_start_stk [ i ] ) - str ; region -> end [ i ] = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; } else { region -> beg [ i ] = region -> end [ i ] = ONIG_REGION_NOTPOS ; } } # ifdef USE_CAPTURE_HISTORY if ( reg -> capture_history != 0 ) { int r ; OnigCaptureTreeNode * node ; if ( IS_NULL ( region -> history_root ) ) { region -> history_root = node = history_node_new ( ) ; CHECK_NULL_RETURN_MEMERR ( node ) ; } else { node = region -> history_root ; history_tree_clear ( node ) ; } node -> group = 0 ; node -> beg = sstart - str ; node -> end = s - str ; stkp = stk_base ; r = make_capture_history_tree ( region -> history_root , & stkp , stk , ( UChar * ) str , reg ) ; if ( r < 0 ) { best_len = r ; goto finish ; } } # endif # ifdef USE_POSIX_API_REGION_OPTION } # endif } } # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE end_best_len : # endif MOP_OUT ; if ( IS_FIND_CONDITION ( option ) ) { if ( IS_FIND_NOT_EMPTY ( option ) && s == sstart ) { best_len = ONIG_MISMATCH ; goto fail ; } if ( IS_FIND_LONGEST ( option ) && DATA_ENSURE_CHECK1 ) { goto fail ; } } goto finish ; break ; case OP_EXACT1 : MOP_IN ( OP_EXACT1 ) ; <S2SV_StartBug> # if 0 <S2SV_EndBug> DATA_ENSURE ( 1 ) ; if ( * p != * s ) goto fail ; <S2SV_StartBug> p ++ ; s ++ ; <S2SV_EndBug> # endif if ( * p != * s ++ ) goto fail ; DATA_ENSURE ( 0 ) ; p ++ ; MOP_OUT ; break ; case OP_EXACT1_IC : MOP_IN ( OP_EXACT1_IC ) ; { int len ; UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; DATA_ENSURE ( 1 ) ; len = ONIGENC_MBC_CASE_FOLD ( encode , case_fold_flag , & s , end , lowbuf ) ; DATA_ENSURE ( 0 ) ; q = lowbuf ; while ( len -- > 0 ) { if ( * p != * q ) { goto fail ; } p ++ ; q ++ ; } } MOP_OUT ; break ; case OP_EXACT2 : MOP_IN ( OP_EXACT2 ) ; DATA_ENSURE ( 2 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT3 : MOP_IN ( OP_EXACT3 ) ; DATA_ENSURE ( 3 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT4 : MOP_IN ( OP_EXACT4 ) ; DATA_ENSURE ( 4 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT5 : MOP_IN ( OP_EXACT5 ) ; DATA_ENSURE ( 5 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTN : MOP_IN ( OP_EXACTN ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen ) ; while ( tlen -- > 0 ) { if ( * p ++ != * s ++ ) goto fail ; } sprev = s - 1 ; MOP_OUT ; continue ; break ; case OP_EXACTN_IC : MOP_IN ( OP_EXACTN_IC ) ; { int len ; UChar * q , * endp , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; GET_LENGTH_INC ( tlen , p ) ; endp = p + tlen ; while ( p < endp ) { sprev = s ; DATA_ENSURE ( 1 ) ; len = ONIGENC_MBC_CASE_FOLD ( encode , case_fold_flag , & s , end , lowbuf ) ; DATA_ENSURE ( 0 ) ; q = lowbuf ; while ( len -- > 0 ) { if ( * p != * q ) goto fail ; p ++ ; q ++ ; } } } MOP_OUT ; continue ; break ; case OP_EXACTMB2N1 : MOP_IN ( OP_EXACTMB2N1 ) ; DATA_ENSURE ( 2 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; break ; case OP_EXACTMB2N2 : MOP_IN ( OP_EXACTMB2N2 ) ; DATA_ENSURE ( 4 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; sprev = s ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTMB2N3 : MOP_IN ( OP_EXACTMB2N3 ) ; DATA_ENSURE ( 6 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; sprev = s ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTMB2N : MOP_IN ( OP_EXACTMB2N ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen * 2 ) ; while ( tlen -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - 2 ; MOP_OUT ; continue ; break ; case OP_EXACTMB3N : MOP_IN ( OP_EXACTMB3N ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen * 3 ) ; while ( tlen -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - 3 ; MOP_OUT ; continue ; break ; case OP_EXACTMBN : MOP_IN ( OP_EXACTMBN ) ; GET_LENGTH_INC ( tlen , p ) ; GET_LENGTH_INC ( tlen2 , p ) ; tlen2 *= tlen ; DATA_ENSURE ( tlen2 ) ; while ( tlen2 -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - tlen ; MOP_OUT ; continue ; break ; case OP_CCLASS : MOP_IN ( OP_CCLASS ) ; DATA_ENSURE ( 1 ) ; if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; p += SIZE_BITSET ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_CCLASS_MB : MOP_IN ( OP_CCLASS_MB ) ; if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) goto fail ; cclass_mb : GET_LENGTH_INC ( tlen , p ) ; { OnigCodePoint code ; UChar * ss ; int mb_len ; DATA_ENSURE ( 1 ) ; mb_len = enclen ( encode , s ) ; DATA_ENSURE ( mb_len ) ; ss = s ; s += mb_len ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; # ifdef PLATFORM_UNALIGNED_WORD_ACCESS if ( ! onig_is_in_code_range ( p , code ) ) goto fail ; # else q = p ; ALIGNMENT_RIGHT ( q ) ; if ( ! onig_is_in_code_range ( q , code ) ) goto fail ; # endif } p += tlen ; MOP_OUT ; break ; case OP_CCLASS_MIX : MOP_IN ( OP_CCLASS_MIX ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { p += SIZE_BITSET ; goto cclass_mb ; } else { if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; p += SIZE_BITSET ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; s ++ ; } MOP_OUT ; break ; case OP_CCLASS_NOT : MOP_IN ( OP_CCLASS_NOT ) ; DATA_ENSURE ( 1 ) ; if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; p += SIZE_BITSET ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_CCLASS_MB_NOT : MOP_IN ( OP_CCLASS_MB_NOT ) ; DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) { s ++ ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; goto cc_mb_not_success ; } cclass_mb_not : GET_LENGTH_INC ( tlen , p ) ; { OnigCodePoint code ; UChar * ss ; int mb_len = enclen ( encode , s ) ; if ( ! DATA_ENSURE_CHECK ( mb_len ) ) { DATA_ENSURE ( 1 ) ; s = ( UChar * ) end ; p += tlen ; goto cc_mb_not_success ; } ss = s ; s += mb_len ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; # ifdef PLATFORM_UNALIGNED_WORD_ACCESS if ( onig_is_in_code_range ( p , code ) ) goto fail ; # else q = p ; ALIGNMENT_RIGHT ( q ) ; if ( onig_is_in_code_range ( q , code ) ) goto fail ; # endif } p += tlen ; cc_mb_not_success : MOP_OUT ; break ; case OP_CCLASS_MIX_NOT : MOP_IN ( OP_CCLASS_MIX_NOT ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { p += SIZE_BITSET ; goto cclass_mb_not ; } else { if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; p += SIZE_BITSET ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; s ++ ; } MOP_OUT ; break ; case OP_CCLASS_NODE : MOP_IN ( OP_CCLASS_NODE ) ; { OnigCodePoint code ; void * node ; int mb_len ; UChar * ss ; DATA_ENSURE ( 1 ) ; GET_POINTER_INC ( node , p ) ; mb_len = enclen ( encode , s ) ; ss = s ; s += mb_len ; DATA_ENSURE ( 0 ) ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; if ( onig_is_code_in_cc_len ( mb_len , code , node ) == 0 ) goto fail ; } MOP_OUT ; break ; case OP_ANYCHAR : MOP_IN ( OP_ANYCHAR ) ; DATA_ENSURE ( 1 ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; s += n ; MOP_OUT ; break ; case OP_ANYCHAR_ML : MOP_IN ( OP_ANYCHAR_ML ) ; DATA_ENSURE ( 1 ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; s += n ; MOP_OUT ; break ; case OP_ANYCHAR_STAR : MOP_IN ( OP_ANYCHAR_STAR ) ; while ( DATA_ENSURE_CHECK1 ) { STACK_PUSH_ALT ( p , s , sprev ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } MOP_OUT ; break ; case OP_ANYCHAR_ML_STAR : MOP_IN ( OP_ANYCHAR_ML_STAR ) ; while ( DATA_ENSURE_CHECK1 ) { STACK_PUSH_ALT ( p , s , sprev ) ; n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } MOP_OUT ; break ; case OP_ANYCHAR_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_STAR_PEEK_NEXT ) ; while ( DATA_ENSURE_CHECK1 ) { if ( * p == * s ) { STACK_PUSH_ALT ( p + 1 , s , sprev ) ; } n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } p ++ ; MOP_OUT ; break ; case OP_ANYCHAR_ML_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_ML_STAR_PEEK_NEXT ) ; while ( DATA_ENSURE_CHECK1 ) { if ( * p == * s ) { STACK_PUSH_ALT ( p + 1 , s , sprev ) ; } n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } p ++ ; MOP_OUT ; break ; # ifdef USE_COMBINATION_EXPLOSION_CHECK case OP_STATE_CHECK_ANYCHAR_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_STAR ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; while ( DATA_ENSURE_CHECK1 ) { STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } MOP_OUT ; break ; case OP_STATE_CHECK_ANYCHAR_ML_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_ML_STAR ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; while ( DATA_ENSURE_CHECK1 ) { STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } MOP_OUT ; break ; # endif case OP_WORD : MOP_IN ( OP_WORD ) ; DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_NOT_WORD : MOP_IN ( OP_NOT_WORD ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_WORD_BOUND : MOP_IN ( OP_WORD_BOUND ) ; if ( ON_STR_BEGIN ( s ) ) { DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; } else if ( ON_STR_END ( s ) ) { if ( ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } else { if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) == ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } MOP_OUT ; continue ; break ; case OP_NOT_WORD_BOUND : MOP_IN ( OP_NOT_WORD_BOUND ) ; if ( ON_STR_BEGIN ( s ) ) { if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; } else if ( ON_STR_END ( s ) ) { if ( ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } else { if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) != ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } MOP_OUT ; continue ; break ; # ifdef USE_WORD_BEGIN_END case OP_WORD_BEGIN : MOP_IN ( OP_WORD_BEGIN ) ; if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { if ( ON_STR_BEGIN ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { MOP_OUT ; continue ; } } goto fail ; break ; case OP_WORD_END : MOP_IN ( OP_WORD_END ) ; if ( ! ON_STR_BEGIN ( s ) && ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { if ( ON_STR_END ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { MOP_OUT ; continue ; } } goto fail ; break ; # endif case OP_BEGIN_BUF : MOP_IN ( OP_BEGIN_BUF ) ; if ( ! ON_STR_BEGIN ( s ) ) goto fail ; MOP_OUT ; continue ; break ; case OP_END_BUF : MOP_IN ( OP_END_BUF ) ; if ( ! ON_STR_END ( s ) ) goto fail ; MOP_OUT ; continue ; break ; case OP_BEGIN_LINE : MOP_IN ( OP_BEGIN_LINE ) ; if ( ON_STR_BEGIN ( s ) ) { if ( IS_NOTBOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) && ! ON_STR_END ( s ) ) { MOP_OUT ; continue ; } goto fail ; break ; case OP_END_LINE : MOP_IN ( OP_END_LINE ) ; if ( ON_STR_END ( s ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { # endif if ( IS_NOTEOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE } # endif } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) { MOP_OUT ; continue ; } # ifdef USE_CRNL_AS_LINE_TERMINATOR else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { MOP_OUT ; continue ; } # endif goto fail ; break ; case OP_SEMI_END_BUF : MOP_IN ( OP_SEMI_END_BUF ) ; if ( ON_STR_END ( s ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { # endif if ( IS_NOTEOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE } # endif } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) && ON_STR_END ( s + enclen ( encode , s ) ) ) { MOP_OUT ; continue ; } # ifdef USE_CRNL_AS_LINE_TERMINATOR else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { UChar * ss = s + enclen ( encode , s ) ; ss += enclen ( encode , ss ) ; if ( ON_STR_END ( ss ) ) { MOP_OUT ; continue ; } } # endif goto fail ; break ; case OP_BEGIN_POSITION : MOP_IN ( OP_BEGIN_POSITION ) ; if ( s != msa -> start ) goto fail ; MOP_OUT ; continue ; break ; case OP_MEMORY_START_PUSH : MOP_IN ( OP_MEMORY_START_PUSH ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_MEM_START ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_START : MOP_IN ( OP_MEMORY_START ) ; GET_MEMNUM_INC ( mem , p ) ; mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END_PUSH : MOP_IN ( OP_MEMORY_END_PUSH ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_MEM_END ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END : MOP_IN ( OP_MEMORY_END ) ; GET_MEMNUM_INC ( mem , p ) ; mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; MOP_OUT ; continue ; break ; # ifdef USE_SUBEXP_CALL case OP_MEMORY_END_PUSH_REC : MOP_IN ( OP_MEMORY_END_PUSH_REC ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_MEM_START ( mem , stkp ) ; STACK_PUSH_MEM_END ( mem , s ) ; mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END_REC : MOP_IN ( OP_MEMORY_END_REC ) ; GET_MEMNUM_INC ( mem , p ) ; mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; STACK_GET_MEM_START ( mem , stkp ) ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; else mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) stkp -> u . mem . pstr ) ; STACK_PUSH_MEM_END_MARK ( mem ) ; MOP_OUT ; continue ; break ; # endif case OP_BACKREF1 : MOP_IN ( OP_BACKREF1 ) ; mem = 1 ; goto backref ; break ; case OP_BACKREF2 : MOP_IN ( OP_BACKREF2 ) ; mem = 2 ; goto backref ; break ; case OP_BACKREFN : MOP_IN ( OP_BACKREFN ) ; GET_MEMNUM_INC ( mem , p ) ; backref : { int len ; UChar * pstart , * pend ; if ( mem > num_mem ) goto fail ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; STRING_CMP ( pstart , s , n ) ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; MOP_OUT ; continue ; } break ; case OP_BACKREFN_IC : MOP_IN ( OP_BACKREFN_IC ) ; GET_MEMNUM_INC ( mem , p ) ; { int len ; UChar * pstart , * pend ; if ( mem > num_mem ) goto fail ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; STRING_CMP_IC ( case_fold_flag , pstart , & s , n ) ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; MOP_OUT ; continue ; } break ; case OP_BACKREF_MULTI : MOP_IN ( OP_BACKREF_MULTI ) ; { int len , is_fail ; UChar * pstart , * pend , * swork ; GET_LENGTH_INC ( tlen , p ) ; for ( i = 0 ; i < tlen ; i ++ ) { GET_MEMNUM_INC ( mem , p ) ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; swork = s ; STRING_CMP_VALUE ( pstart , swork , n , is_fail ) ; if ( is_fail ) continue ; s = swork ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; break ; } if ( i == tlen ) goto fail ; MOP_OUT ; continue ; } break ; case OP_BACKREF_MULTI_IC : MOP_IN ( OP_BACKREF_MULTI_IC ) ; { int len , is_fail ; UChar * pstart , * pend , * swork ; GET_LENGTH_INC ( tlen , p ) ; for ( i = 0 ; i < tlen ; i ++ ) { GET_MEMNUM_INC ( mem , p ) ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; swork = s ; STRING_CMP_VALUE_IC ( case_fold_flag , pstart , & swork , n , is_fail ) ; if ( is_fail ) continue ; s = swork ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; break ; } if ( i == tlen ) goto fail ; MOP_OUT ; continue ; } break ; # ifdef USE_BACKREF_WITH_LEVEL case OP_BACKREF_WITH_LEVEL : { int len ; OnigOptionType ic ; LengthType level ; GET_OPTION_INC ( ic , p ) ; GET_LENGTH_INC ( level , p ) ; GET_LENGTH_INC ( tlen , p ) ; sprev = s ; if ( backref_match_at_nested_level ( reg , stk , stk_base , ic , case_fold_flag , ( int ) level , ( int ) tlen , p , & s , end ) ) { while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * tlen ) ; } else goto fail ; MOP_OUT ; continue ; } break ; # endif # if 0 case OP_SET_OPTION_PUSH : MOP_IN ( OP_SET_OPTION_PUSH ) ; GET_OPTION_INC ( option , p ) ; STACK_PUSH_ALT ( p , s , sprev ) ; p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL ; MOP_OUT ; continue ; break ; case OP_SET_OPTION : MOP_IN ( OP_SET_OPTION ) ; GET_OPTION_INC ( option , p ) ; MOP_OUT ; continue ; break ; # endif case OP_NULL_CHECK_START : MOP_IN ( OP_NULL_CHECK_START ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_NULL_CHECK_START ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_NULL_CHECK_END : MOP_IN ( OP_NULL_CHECK_END ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; STACK_NULL_CHECK ( isnull , mem , s ) ; if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif null_check_found : switch ( * p ++ ) { case OP_JUMP : case OP_PUSH : p += SIZE_RELADDR ; break ; case OP_REPEAT_INC : case OP_REPEAT_INC_NG : case OP_REPEAT_INC_SG : case OP_REPEAT_INC_NG_SG : p += SIZE_MEMNUM ; break ; default : goto unexpected_bytecode_error ; break ; } } } MOP_OUT ; continue ; break ; # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT case OP_NULL_CHECK_END_MEMST : MOP_IN ( OP_NULL_CHECK_END_MEMST ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; STACK_NULL_CHECK_MEMST ( isnull , mem , s , reg ) ; if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END_MEMST:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif if ( isnull == - 1 ) goto fail ; goto null_check_found ; } } MOP_OUT ; continue ; break ; # endif # ifdef USE_SUBEXP_CALL case OP_NULL_CHECK_END_MEMST_PUSH : MOP_IN ( OP_NULL_CHECK_END_MEMST_PUSH ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT STACK_NULL_CHECK_MEMST_REC ( isnull , mem , s , reg ) ; # else STACK_NULL_CHECK_REC ( isnull , mem , s ) ; # endif if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END_MEMST_PUSH:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif if ( isnull == - 1 ) goto fail ; goto null_check_found ; } else { STACK_PUSH_NULL_CHECK_END ( mem ) ; } } MOP_OUT ; continue ; break ; # endif case OP_JUMP : MOP_IN ( OP_JUMP ) ; GET_RELADDR_INC ( addr , p ) ; p += addr ; MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_PUSH : MOP_IN ( OP_PUSH ) ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; break ; # ifdef USE_COMBINATION_EXPLOSION_CHECK case OP_STATE_CHECK_PUSH : MOP_IN ( OP_STATE_CHECK_PUSH ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; MOP_OUT ; continue ; break ; case OP_STATE_CHECK_PUSH_OR_JUMP : MOP_IN ( OP_STATE_CHECK_PUSH_OR_JUMP ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) { p += addr ; } else { STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; } MOP_OUT ; continue ; break ; case OP_STATE_CHECK : MOP_IN ( OP_STATE_CHECK ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_STATE_CHECK ( s , mem ) ; MOP_OUT ; continue ; break ; # endif case OP_POP : MOP_IN ( OP_POP ) ; STACK_POP_ONE ; MOP_OUT ; continue ; break ; case OP_PUSH_OR_JUMP_EXACT1 : MOP_IN ( OP_PUSH_OR_JUMP_EXACT1 ) ; GET_RELADDR_INC ( addr , p ) ; if ( * p == * s && DATA_ENSURE_CHECK1 ) { p ++ ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; } p += ( addr + 1 ) ; MOP_OUT ; continue ; break ; case OP_PUSH_IF_PEEK_NEXT : MOP_IN ( OP_PUSH_IF_PEEK_NEXT ) ; GET_RELADDR_INC ( addr , p ) ; if ( * p == * s ) { p ++ ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; } p ++ ; MOP_OUT ; continue ; break ; case OP_REPEAT : MOP_IN ( OP_REPEAT ) ; { GET_MEMNUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STACK_ENSURE ( 1 ) ; repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; STACK_PUSH_REPEAT ( mem , p ) ; if ( reg -> repeat_range [ mem ] . lower == 0 ) { STACK_PUSH_ALT ( p + addr , s , sprev ) ; } } MOP_OUT ; continue ; break ; case OP_REPEAT_NG : MOP_IN ( OP_REPEAT_NG ) ; { GET_MEMNUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STACK_ENSURE ( 1 ) ; repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; STACK_PUSH_REPEAT ( mem , p ) ; if ( reg -> repeat_range [ mem ] . lower == 0 ) { STACK_PUSH_ALT ( p , s , sprev ) ; p += addr ; } } MOP_OUT ; continue ; break ; case OP_REPEAT_INC : MOP_IN ( OP_REPEAT_INC ) ; GET_MEMNUM_INC ( mem , p ) ; si = repeat_stk [ mem ] ; stkp = STACK_AT ( si ) ; repeat_inc : stkp -> u . repeat . count ++ ; if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . upper ) { } else if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { STACK_PUSH_ALT ( p , s , sprev ) ; p = STACK_AT ( si ) -> u . repeat . pcode ; } else { p = stkp -> u . repeat . pcode ; } STACK_PUSH_REPEAT_INC ( si ) ; MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_REPEAT_INC_SG : MOP_IN ( OP_REPEAT_INC_SG ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_REPEAT ( mem , stkp ) ; si = GET_STACK_INDEX ( stkp ) ; goto repeat_inc ; break ; case OP_REPEAT_INC_NG : MOP_IN ( OP_REPEAT_INC_NG ) ; GET_MEMNUM_INC ( mem , p ) ; si = repeat_stk [ mem ] ; stkp = STACK_AT ( si ) ; repeat_inc_ng : stkp -> u . repeat . count ++ ; if ( stkp -> u . repeat . count < reg -> repeat_range [ mem ] . upper ) { if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { UChar * pcode = stkp -> u . repeat . pcode ; STACK_PUSH_REPEAT_INC ( si ) ; STACK_PUSH_ALT ( pcode , s , sprev ) ; } else { p = stkp -> u . repeat . pcode ; STACK_PUSH_REPEAT_INC ( si ) ; } } else if ( stkp -> u . repeat . count == reg -> repeat_range [ mem ] . upper ) { STACK_PUSH_REPEAT_INC ( si ) ; } MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_REPEAT_INC_NG_SG : MOP_IN ( OP_REPEAT_INC_NG_SG ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_REPEAT ( mem , stkp ) ; si = GET_STACK_INDEX ( stkp ) ; goto repeat_inc_ng ; break ; case OP_PUSH_POS : MOP_IN ( OP_PUSH_POS ) ; STACK_PUSH_POS ( s , sprev ) ; MOP_OUT ; continue ; break ; case OP_POP_POS : MOP_IN ( OP_POP_POS ) ; { STACK_POS_END ( stkp ) ; s = stkp -> u . state . pstr ; sprev = stkp -> u . state . pstr_prev ; } MOP_OUT ; continue ; break ; case OP_PUSH_POS_NOT : MOP_IN ( OP_PUSH_POS_NOT ) ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_POS_NOT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; break ; case OP_FAIL_POS : MOP_IN ( OP_FAIL_POS ) ; STACK_POP_TIL_POS_NOT ; goto fail ; break ; case OP_PUSH_STOP_BT : MOP_IN ( OP_PUSH_STOP_BT ) ; STACK_PUSH_STOP_BT ; MOP_OUT ; continue ; break ; case OP_POP_STOP_BT : MOP_IN ( OP_POP_STOP_BT ) ; STACK_STOP_BT_END ; MOP_OUT ; continue ; break ; case OP_LOOK_BEHIND : MOP_IN ( OP_LOOK_BEHIND ) ; GET_LENGTH_INC ( tlen , p ) ; s = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; if ( IS_NULL ( s ) ) goto fail ; sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; MOP_OUT ; continue ; break ; case OP_PUSH_LOOK_BEHIND_NOT : MOP_IN ( OP_PUSH_LOOK_BEHIND_NOT ) ; GET_RELADDR_INC ( addr , p ) ; GET_LENGTH_INC ( tlen , p ) ; q = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; if ( IS_NULL ( q ) ) { p += addr ; } else { STACK_PUSH_LOOK_BEHIND_NOT ( p + addr , s , sprev ) ; s = q ; sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; } MOP_OUT ; continue ; break ; case OP_FAIL_LOOK_BEHIND_NOT : MOP_IN ( OP_FAIL_LOOK_BEHIND_NOT ) ; STACK_POP_TIL_LOOK_BEHIND_NOT ; goto fail ; break ; # ifdef USE_SUBEXP_CALL case OP_CALL : MOP_IN ( OP_CALL ) ; GET_ABSADDR_INC ( addr , p ) ; STACK_PUSH_CALL_FRAME ( p ) ; p = reg -> p + addr ; MOP_OUT ; continue ; break ; case OP_RETURN : MOP_IN ( OP_RETURN ) ; STACK_RETURN ( p ) ; STACK_PUSH_RETURN ; MOP_OUT ; continue ; break ; # endif case OP_FINISH : goto finish ; break ; fail : MOP_OUT ; case OP_FAIL : MOP_IN ( OP_FAIL ) ; STACK_POP ; p = stk -> u . state . pcode ; s = stk -> u . state . pstr ; sprev = stk -> u . state . pstr_prev ; # ifdef USE_COMBINATION_EXPLOSION_CHECK if ( stk -> u . state . state_check != 0 ) { stk -> type = STK_STATE_CHECK_MARK ; stk ++ ; } # endif MOP_OUT ; continue ; break ; default : goto bytecode_error ; } sprev = sbegin ; } finish : STACK_SAVE ; return best_len ; # ifdef ONIG_DEBUG stack_error : STACK_SAVE ; return ONIGERR_STACK_BUG ; # endif bytecode_error : STACK_SAVE ; return ONIGERR_UNDEFINED_BYTECODE ; unexpected_bytecode_error : STACK_SAVE ; return ONIGERR_UNEXPECTED_BYTECODE ; }
","<S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_ENSURE ( 1 <S2SV_ModStart> ++ ; s <S2SV_ModEnd> ++ ; MOP_OUT
",kkos@oniguruma/690313a061f7a4fa614ec5cc8368b4f2284e059b,CVE-2017-9224,https://github.com/kkos/oniguruma/commit/690313a061f7a4fa614ec5cc8368b4f2284e059b,2017-05-24T15:29Z,1453,<S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> STACK_INIT ( INIT_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE <S2SV_ModStart> OP_EXACT2 ) ; <S2SV_ModEnd> DATA_INIT ( UPDATE_MATCH_STACK_SIZE,0
1455,CWE-20,"CWE-20 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d<S2SV_blank>-=<S2SV_blank>%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,1455,<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0,0
1457,CWE-20,"CWE-20 static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ; <S2SV_StartBug> return fd ; <S2SV_EndBug> } } return - 1 ; }
","<S2SV_ModStart> = hash ; sr -> fd_is_fdt = MK_TRUE ;
",monkey@monkey/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,CVE-2014-5336,https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,2014-08-26T14:55Z,1457,<S2SV_ModStart> = hash ; sr -> fd = fd ;,0
1461,CWE-787,"CWE-787 MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; <S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }
","<S2SV_ModStart> = NULL ; reader . recursive_counter = 0 ;
",hoene@libmysofa/2e6fac6ab6156dae8e8c6f417741388084b70d6f,CVE-2019-20016,https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f,2019-12-27T02:15Z,1461,"<S2SV_ModStart> = NULL ; if ( reader. superblock. magic!= MYSOFA_SUPERBLOCK_MAGIC ) { log ( ""superblock <S2SV_blank> magic <S2SV_blank> 0x%x <S2SV_blank> not <S2SV_blank> supported\\n"", MYSOFA_SUPERBLOCK_MAGIC ) ; reader. superblock. magic = MYSOFA_SUPERBLOCK_MAGIC ; }",0
1467,CWE-416,"CWE-416 static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } <S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
","<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
",mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z,1467,"<S2SV_ModStart> data ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_cmpt_t ) ) ; goto error ; } <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_cmpt_t ) ) ; goto error ; } <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_data_t ) ) ; goto error ; } <S2SV_ModStart> ) ) { jas_eprintf ( ""Bad <S2SV_blank> data <S2SV_blank> length: <S2SV_blank> %d\\n"", sizeof ( mif_data_t ) ) ; goto error ; }",0
1469,CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
",ImageMagick@ImageMagick/1bc1fd0ff8c555841c78829217ac81fa0598255d,CVE-2016-10071,https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d,2017-03-02T21:59Z,1469,"<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;",0
1472,CWE-352,"CWE-352 static void do_runtime ( HttpRequest req , HttpResponse res ) { int pid = exist_daemon ( ) ; char buf [ STRLEN ] ; do_head ( res , ""_runtime"" , ""Runtime"" , 1000 ) ; StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'status-table\'><tr>"" ""<th<S2SV_blank>width=\'40%%\'>Parameter</th>"" ""<th<S2SV_blank>width=\'60%%\'>Value</th></tr>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ; if ( Run . files . log ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Logfile</td><td>%s</td></tr>"" , Run . files . log ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Pidfile</td><td>%s</td></tr>"" , Run . files . pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>State<S2SV_blank>file</td><td>%s</td></tr>"" , Run . files . state ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ; if ( Run . eventlist_dir ) { if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ; else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ; } # ifdef HAVE_OPENSSL { const char * options = Ssl_printOptions ( & ( Run . ssl ) , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>SSL<S2SV_blank>options</td><td>%s</td></tr>"" , options ) ; } # endif if ( Run . mmonits ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>M/Monit<S2SV_blank>server(s)</td><td>"" ) ; for ( Mmonit_T c = Run . mmonits ; c ; c = c -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>with<S2SV_blank>timeout<S2SV_blank>%s"" , c -> url -> url , Str_milliToTime ( c -> timeout , ( char [ 23 ] ) { } ) ) ; # ifdef HAVE_OPENSSL if ( c -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & c -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( c -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ c -> ssl . checksumType ] , c -> ssl . checksum ) ; } # endif if ( c -> url -> user ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>credentials"" ) ; if ( c -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . mailservers ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Mail<S2SV_blank>server(s)</td><td>"" ) ; for ( MailServer_T mta = Run . mailservers ; mta ; mta = mta -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s:%d"" , mta -> host , mta -> port ) ; # ifdef HAVE_OPENSSL if ( mta -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & mta -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( mta -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ mta -> ssl . checksumType ] , mta -> ssl . checksum ) ; } # endif if ( mta -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . from ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>from</td><td>"" ) ; if ( Run . MailFormat . from -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . from -> name , Run . MailFormat . from -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . from -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . replyto ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>reply<S2SV_blank>to</td><td>"" ) ; if ( Run . MailFormat . replyto -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . replyto -> name , Run . MailFormat . replyto -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . replyto -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . subject ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>subject</td><td>%s</td></tr>"" , Run . MailFormat . subject ) ; if ( Run . MailFormat . message ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>message</td><td>%s</td></tr>"" , Run . MailFormat . message ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>Send/Expect<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . sendExpectBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>file<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . fileContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . httpContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>program<S2SV_blank>output</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . programOutput , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>network<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . networkTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>check<S2SV_blank>program<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . programTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>stop<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . stopTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>start<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . startTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>restart<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . restartTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>On<S2SV_blank>reboot</td><td>%s</td></tr>"" , onrebootnames [ Run . onreboot ] ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Poll<S2SV_blank>time</td><td>%d<S2SV_blank>seconds<S2SV_blank>with<S2SV_blank>start<S2SV_blank>delay<S2SV_blank>%d<S2SV_blank>seconds</td></tr>"" , Run . polltime , Run . startdelay ) ; if ( Run . httpd . flags & Httpd_Net ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>bind<S2SV_blank>address</td><td>%s</td></tr>"" , Run . httpd . socket . net . address ? Run . httpd . socket . net . address : ""Any/All"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>portnumber</td><td>%d</td></tr>"" , Run . httpd . socket . net . port ) ; } else if ( Run . httpd . flags & Httpd_Unix ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>unix<S2SV_blank>socket</td><td>%s</td></tr>"" , Run . httpd . socket . unix . path ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>signature</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Signature ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>ssl<S2SV_blank>encryption</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Ssl ? ""True"" : ""False"" ) ; if ( Run . httpd . flags & Httpd_Ssl ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>PEM<S2SV_blank>key/certificate<S2SV_blank>file</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . pem ) ; if ( Run . httpd . socket . net . ssl . clientpem != NULL ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Enabled"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certificate<S2SV_blank>file"" ""</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . clientpem ) ; } else { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Disabled"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>Allow<S2SV_blank>self<S2SV_blank>certified<S2SV_blank>certificates<S2SV_blank>"" ""</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_AllowSelfSignedCertificates ? ""True"" : ""False"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>auth.<S2SV_blank>style</td><td>%s</td></tr>"" , Run . httpd . credentials && Engine_hasAllow ( ) ? ""Basic<S2SV_blank>Authentication<S2SV_blank>and<S2SV_blank>Host/Net<S2SV_blank>allow<S2SV_blank>list"" : Run . httpd . credentials ? ""Basic<S2SV_blank>Authentication"" : Engine_hasAllow ( ) ? ""Host/Net<S2SV_blank>allow<S2SV_blank>list"" : ""No<S2SV_blank>authentication"" ) ; print_alerts ( res , Run . maillist ) ; StringBuffer_append ( res -> outputbuffer , ""</table>"" ) ; if ( ! is_readonly ( req ) ) { StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'buttons\'><tr>"" ) ; StringBuffer_append ( res -> outputbuffer , <S2SV_StartBug> ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" <S2SV_EndBug> ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank><input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { StringBuffer_append ( res -> outputbuffer , <S2SV_StartBug> ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; <S2SV_EndBug> } StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; } do_foot ( res ) ; }
","<S2SV_ModStart> -> outputbuffer , ""<td<S2SV_blank>style=\'color:red;\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ) ; }
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,1472,"<S2SV_ModStart> -> outputbuffer, ""<table <S2SV_blank> id=\'daemon-status-table\'><tr>"" ""<th <S2SV_blank> width=\'40%%\'>Parameter</th>"" ""<th <S2SV_blank> width=\'60%%\'>Value</th>"" ""</tr>"", ( Run. flags & Run_Debug )? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer, ""<tr><td>Hostfile</td><td>%s</td></tr>"", Run. system -> name ) ; StringBuffer_append ( res -> outputbuffer, ""<tr><td>Pidfile</td><td>%d</td></tr>"", Run. Env. pid ) ; if ( Run. files. control ) StringBuffer_append ( res -> outputbuffer, ""<tr><td>Controlfile</td><td>%s</td></tr>"", Run. files. control ) ; if ( Run. files. log ) StringBuffer_append ( res -> outputbuffer, ""<tr><td>Logfile</td><td>%s</td></tr>"", Run. files. log ) ; if ( Run. flags & Run_Log ) { StringBuffer_append ( res -> outputbuffer, ""<tr><td>Logfile</td><",0
1477,CWE-20,"CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>"" , c -> sfd ) ; } fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n"" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; <S2SV_StartBug> if ( ! el ) <S2SV_EndBug> return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
","<S2SV_ModStart> ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> cont = el
",memcached@memcached/75cc83685e103bc8ba380a57468c8f04413033f9,CVE-2010-1152,https://github.com/memcached/memcached/commit/75cc83685e103bc8ba380a57468c8f04413033f9,2010-04-12T18:30Z,1477,"<S2SV_ModStart> } if ( ptr - c -> rcurr > 100 || strchr ( ptr,'<S2SV_blank>') ) { strncpy ( ptr, ""get <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; } if ( strncmp ( ptr, ""gets <S2SV_blank> "" ) ) { strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "", 4 ) ; strncpy ( ptr, ""gets <S2SV_blank> "" ) ; strncpy ( ptr, ""gets <S2SV_blank> "" ) ; strncpy ( ptr, ""gets <S2SV_blank> "" ) ; strncpy ( ptr, ""gets <S2SV_blank> "" ) ; strncpy ( ptr, ""gets <S2SV_blank> "" ) ;",0
1486,CWE-20,"CWE-20 error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( ""Initializing<S2SV_blank>ENC624J600<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <S2SV_EndBug> if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) { <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <S2SV_EndBug> interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ; <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <S2SV_EndBug> interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ; <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <S2SV_EndBug> interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <S2SV_EndBug> temp = htole16 ( interface -> macAddr . w [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <S2SV_EndBug> temp = htole16 ( interface -> macAddr . w [ 2 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN | <S2SV_EndBug> ERXFCON_CRCEN | ERXFCON_RUNTEN | ERXFCON_UCEN | ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , 0x0000 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , <S2SV_EndBug> MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_MAMXFL , ETH_MAX_FRAME_SIZE ) ; <S2SV_StartBug> enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 | <S2SV_EndBug> PHANA_AD100FD | PHANA_AD100 | PHANA_AD10FD | PHANA_AD10 | PHANA_ADIEEE0 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EIR , 0x0000 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE | <S2SV_EndBug> EIE_LINKIE | EIE_PKTIE | EIE_TXIE | EIE_TXABTIE ) ; <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> enc624j600DumpReg ( interface ) ; enc624j600DumpPhyReg ( interface ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_ERXST <S2SV_ModEnd> , ENC624J600_RX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL <S2SV_ModEnd> , ENC624J600_RX_BUFFER_STOP ) <S2SV_ModStart> ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <S2SV_ModEnd> ) ; enc624j600DumpReg
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1486,"<S2SV_ModStart> ( interface, ENC624J600_ECON2, ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( interface, ENC624J600_MAADR1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR3 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR0 <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ( interface, ENC624J600_MAADR1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR3 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR0 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface, ENC624J600_MAADR1 <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( interface, ENC624J600_MAADR2 <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( interface, ENC624J600_MAADR3 <S2SV_ModEnd> )",0
1491,CWE-20,"CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
","<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
",torvalds@linux/bfd0a56b90005f8c8a004baf407ad90045c2b11e,CVE-2014-3645,https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e,2014-11-10T11:55Z,1491,<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :,1
1493,CWE-20,"CWE-20 static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK && dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) set_bit ( IPS_ASSURED_BIT , & ct -> status ) ; break ; case CT_DCCP_IGNORE : if ( ct -> proto . dccp . last_dir == ! dir && ct -> proto . dccp . last_pkt == DCCP_PKT_REQUEST && type == DCCP_PKT_RESPONSE ) { ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; new_state = CT_DCCP_RESPOND ; break ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>ignored<S2SV_blank>"" ) ; return NF_ACCEPT ; case CT_DCCP_INVALID : spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ) ; return - NF_ACCEPT ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; ct -> proto . dccp . state = new_state ; spin_unlock_bh ( & ct -> lock ) ; if ( new_state != old_state ) nf_conntrack_event_cache ( IPCT_PROTOINFO , ct ) ; nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; return NF_ACCEPT ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,1493,"<S2SV_ModStart> ), & _dh <S2SV_ModEnd> ) ; BUG_ON",1
1496,CWE-416,"CWE-416 void luaD_shrinkstack ( lua_State * L ) { int inuse = stackinuse ( L ) ; <S2SV_StartBug> int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; <S2SV_EndBug> if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L , goodsize , 0 ) ; else condmovestack ( L , { } , { } ) ; luaE_shrinkCI ( L ) ; }
","<S2SV_ModStart> = inuse + BASIC_STACK_SIZE <S2SV_ModEnd> ; if (
",lua@lua/6298903e35217ab69c279056f925fb72900ce0b7,CVE-2020-15888,https://github.com/lua/lua/commit/6298903e35217ab69c279056f925fb72900ce0b7,2020-07-21T22:15Z,1496,"<S2SV_ModStart> * EXTRA_STACK ; luaE_checkstack ( L ) ; int maxgoodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; if ( maxgoodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) { luaD_reallocstack ( L, goodsize, 0 ) ; else if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) { luaD_reallocstack ( L, goodsize, 0 ) ; } else if ( goodsize < ( LUAI_MAXSTACK - EXTRA_STACK ) ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L, goodsize, 0 ) ; else condmovestack ( L, { }, { } ) ;",0
1497,CWE-125,"CWE-125 PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1497,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result,1
1498,CWE-125,"CWE-125 static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ; <S2SV_StartBug> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <S2SV_EndBug> int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\'' && * raw != \'""\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) { <S2SV_StartBug> char * s = """" ; <S2SV_EndBug> char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf , sizeof ( buf ) , ""(unicode<S2SV_blank>error)<S2SV_blank>%s"" , s ) ; ast_error ( n , buf ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n , ""(unicode<S2SV_blank>error)<S2SV_blank>unknown<S2SV_blank>error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; } # endif return NULL ; } PyArena_AddPyObject ( c -> c_arena , str ) ; return Str ( str , kind , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case NUMBER : { PyObject * pynum = parsenumber ( c , STR ( ch ) ) ; if ( ! pynum ) return NULL ; PyArena_AddPyObject ( c -> c_arena , pynum ) ; return Num ( pynum , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case LPAR : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RPAR ) return Tuple ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( TYPE ( ch ) == yield_expr ) return ast_for_expr ( c , ch ) ; return ast_for_testlist_comp ( c , ch ) ; case LSQB : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RSQB ) return List ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; REQ ( ch , listmaker ) ; if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts = seq_for_testlist ( c , ch ) ; if ( ! elts ) return NULL ; return List ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else return ast_for_listcomp ( c , ch ) ; case LBRACE : { int i , size ; asdl_seq * keys , * values ; ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RBRACE ) { return Dict ( NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts ; size = ( NCH ( ch ) + 1 ) / 2 ; elts = asdl_seq_new ( size , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 2 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( elts , i / 2 , expression ) ; } return Set ( elts , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { return ast_for_setcomp ( c , ch ) ; } else if ( NCH ( ch ) > 3 && TYPE ( CHILD ( ch , 3 ) ) == comp_for ) { return ast_for_dictcomp ( c , ch ) ; } else { size = ( NCH ( ch ) + 1 ) / 4 ; keys = asdl_seq_new ( size , c -> c_arena ) ; if ( ! keys ) return NULL ; values = asdl_seq_new ( size , c -> c_arena ) ; if ( ! values ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 4 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( keys , i / 4 , expression ) ; expression = ast_for_expr ( c , CHILD ( ch , i + 2 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( values , i / 4 , expression ) ; } return Dict ( keys , values , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } case BACKQUOTE : { expr_ty expression ; if ( Py_Py3kWarningFlag && ! ast_warn ( c , n , ""backquote<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>3.x;<S2SV_blank>use<S2SV_blank>repr()"" ) ) return NULL ; expression = ast_for_testlist ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; return Repr ( expression , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } default : PyErr_Format ( PyExc_SystemError , ""unhandled<S2SV_blank>atom<S2SV_blank>%d"" , TYPE ( ch ) ) ; return NULL ; } }
","<S2SV_ModStart> , 0 ) <S2SV_ModEnd> ) ; char <S2SV_ModStart> errstr ) { const
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1498,"<S2SV_ModStart>, * s = STR ( CHILD ( n, 0 ) ) ; const char * raw <S2SV_ModStart> errstr ) { <S2SV_ModEnd> char buf [ <S2SV_ModStart> = """" ; PyOS_snprintf ( buf, sizeof ( buf ), ""(unicode <S2SV_blank> error) <S2SV_blank> %s"", _PyUnicode_AsString ( errstr ) ; } else { ast_error ( n, ""(unicode <S2SV_blank> error) <S2SV_blank> unknown <S2SV_blank> error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; <S2SV_ModStart> ) ; } if (! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { Py_DECREF ( type ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n, ""(unicode <S2SV_blank> error) <S2SV_blank> unknown <S2SV_blank> error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( tback ) ; if ( errstr ) { char * s = """" ; char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf, sizeof ( buf ), ""(unicode <S2SV_blank>",0
1500,CWE-416,"CWE-416 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
",torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z,1500,<S2SV_ModStart> event ) ; <S2SV_ModEnd> hlist_add_head_rcu ( & <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> perf_event_update_userpage ( event,0
1507,CWE-125,"CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
","<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
",radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z,1507,<S2SV_ModStart> : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x16 : case <S2SV_ModStart> : case 0x1e : case 0x1f : case 0x8a : case 0x8b : case 0x8c : case 0x8f :,0
1508,CWE-416,"CWE-416 int dbd_db_login ( SV * dbh , imp_dbh_t * imp_dbh , char * dbname , char * user , char * password ) { # ifdef dTHR dTHR ; # endif dTHX ; D_imp_xxh ( dbh ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->connect:<S2SV_blank>dsn<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" ) ; imp_dbh -> stats . auto_reconnects_ok = 0 ; imp_dbh -> stats . auto_reconnects_failed = 0 ; imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> has_transactions = TRUE ; imp_dbh -> auto_reconnect = FALSE ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_dbh -> enable_utf8 = FALSE ; # endif if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) { <S2SV_StartBug> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <S2SV_EndBug> mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; return FALSE ; } DBIc_ACTIVE_on ( imp_dbh ) ; DBIc_on ( imp_dbh , DBIcf_IMPSET ) ; return TRUE ; }
","<S2SV_ModStart> ) ) { if ( imp_dbh -> pmysql )
",perl5-dbi@DBD-mysql/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,CVE-2014-9906,https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,2016-08-19T21:59Z,1508,<S2SV_ModStart> ) ) { <S2SV_ModEnd> do_error ( dbh,0
1510,CWE-20,"CWE-20 static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ; <S2SV_StartBug> struct ieee_802_11_phdr phdr ; <S2SV_EndBug> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti = proto_tree_add_item ( ppi_tree , hf_ppi_head_flags , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; ppi_flags_tree = proto_item_add_subtree ( ti , ett_ppi_flags ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_alignment , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_reserved , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_len , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_dlt , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; } tot_len -= PPI_V0_HEADER_LEN ; offset += 8 ; memset ( & phdr , 0 , sizeof ( phdr ) ) ; phdr . fcs_len = - 1 ; phdr . decrypted = FALSE ; phdr . datapad = FALSE ; phdr . phy = PHDR_802_11_PHY_UNKNOWN ; phdr . presence_flags = 0 ; while ( tot_len > 0 ) { data_type = tvb_get_letohs ( tvb , offset ) ; data_len = tvb_get_letohs ( tvb , offset + 2 ) + 4 ; tot_len -= data_len ; switch ( data_type ) { case PPI_80211_COMMON : dissect_80211_common ( tvb , pinfo , ppi_tree , offset , data_len , & phdr ) ; break ; case PPI_80211N_MAC : dissect_80211n_mac ( tvb , pinfo , ppi_tree , offset , data_len , TRUE , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_80211N_MAC_PHY : dissect_80211n_mac_phy ( tvb , pinfo , ppi_tree , offset , data_len , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_SPECTRUM_MAP : ADD_BASIC_TAG ( hf_spectrum_map ) ; break ; case PPI_PROCESS_INFO : ADD_BASIC_TAG ( hf_process_info ) ; break ; case PPI_CAPTURE_INFO : ADD_BASIC_TAG ( hf_capture_info ) ; break ; case PPI_AGGREGATION_EXTENSION : dissect_aggregation_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_8023_EXTENSION : dissect_8023_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_GPS_INFO : if ( ppi_gps_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_gps , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ; } break ; default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ; } offset += data_len ; if ( IS_PPI_FLAG_ALIGN ( flags ) ) { offset += PADDING4 ( offset ) ; } } if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) { len_remain = tvb_captured_length_remaining ( tvb , offset ) ; # if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { pad_len = PADDING4 ( len_remain ) ; } # endif pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; while ( fd_head ) { ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ; fd_head = fd_head -> next ; } if ( ampdu_len > AGGREGATE_MAX ) { if ( tree ) { proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ; THROW ( ReportedBoundsError ) ; } else { return ; } } fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ; pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; if ( fd_head && tree ) { ft_fdh = fd_head ; seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; while ( ft_fdh ) { if ( ft_fdh -> tvb_data && ft_fdh -> len ) { last_frame = ft_fdh -> frame ; if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ; first_mpdu = FALSE ; proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ; proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ; } ft_fdh = ft_fdh -> next ; } if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ; } if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ; agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ; } while ( fd_head ) { if ( fd_head -> tvb_data && fd_head -> len ) { mpdu_count ++ ; mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ; next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ; add_new_data_source ( pinfo , next_tvb , mpdu_str ) ; ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ; call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ; } fd_head = fd_head -> next ; } proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ; pinfo -> fragmented = FALSE ; } else { next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ; col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ; call_dissector ( data_handle , next_tvb , pinfo , tree ) ; } return ; } next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; if ( dlt == 105 ) { call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; } else { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> ( wtap_encap_dissector_table , wtap_encap <S2SV_ModEnd> , next_tvb , <S2SV_ModStart> pinfo , tree , TRUE , phdrp
",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z,1510,<S2SV_ModStart> struct ieee_802_11_phdr phdr ; if ( len_remain < sizeof ( struct ieee_802_11_phdr ) ) { return ; } <S2SV_ModStart> struct ieee_802_11_phdr phdr ; if ( len_remain < sizeof ( struct ieee_802_11_phdr ) ) { return ; },0
1512,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,1512,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> BYTE a_val ; <S2SV_ModEnd> rw = ( <S2SV_ModStart> ; tempWidth = ROUND_UP_TO ( context -> width, 8 ) ; ccl = context -> ColorLossLevel ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; yplane = context -> priv -> PlaneBuffers [ 3 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; b_val = * src ++ ; r_val = * src ++ ; b_val = * src ++ ; a",0
1519,CWE-125,"CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { <S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Hello<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Dead<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Interface-ID<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>Backup<S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>List:"" ) ) ; ap = hellop -> hello_neighbor ; while ( ( const u_char * ) ap < dataend ) { ND_TCHECK ( * ap ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , ipaddr_string ( ndo , ap ) ) ) ; ++ ap ; } } break ; } case OSPF_TYPE_DD : { register const struct dd6 * ddp = ( const struct dd6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( ddp -> db_options ) ; ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & ddp -> db_options ) ) ) ) ; ND_TCHECK ( ddp -> db_flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>DD<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( ospf6_dd_flag_values , ""none"" , ddp -> db_flags ) ) ) ; ND_TCHECK ( ddp -> db_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>DD-Sequence<S2SV_blank>0x%08x"" , EXTRACT_16BITS ( & ddp -> db_mtu ) , EXTRACT_32BITS ( & ddp -> db_seq ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { lshp = ddp -> db_lshdr ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; } case OSPF_TYPE_LS_REQ : if ( ndo -> ndo_vflag > 1 ) { lsrp = ( const struct lsr6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lsrp < dataend ) { ND_TCHECK ( * lsrp ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & lsrp -> ls_router ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lsrp -> ls_type ) , & lsrp -> ls_stateid ) ; ++ lsrp ; } } break ; case OSPF_TYPE_LS_UPDATE : if ( ndo -> ndo_vflag > 1 ) { register const struct lsu6 * lsup = ( const struct lsu6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( lsup -> lsu_count ) ; i = EXTRACT_32BITS ( & lsup -> lsu_count ) ; lsap = lsup -> lsu_lsa ; while ( ( const u_char * ) lsap < dataend && i -- ) { if ( ospf6_print_lsa ( ndo , lsap , dataend ) ) goto trunc ; lsap = ( const struct lsa6 * ) ( ( const u_char * ) lsap + EXTRACT_16BITS ( & lsap -> ls_hdr . ls_length ) ) ; } } break ; case OSPF_TYPE_LS_ACK : if ( ndo -> ndo_vflag > 1 ) { lshp = ( const struct lsa6_hdr * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; default : break ; } return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
",the-tcpdump-group@tcpdump/88b2dac837e81cf56dce05e6e7b5989332c0092d,CVE-2017-13036,https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d,2017-09-14T06:29Z,1519,<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options,1
1523,CWE-125,"CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; <S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
","<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
",espruino@Espruino/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,CVE-2018-11592,https://github.com/espruino/Espruino/commit/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,2018-05-31T16:29Z,1523,<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;,1
1537,CWE-787,"CWE-787 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
","<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,1537,"<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if (! s_check_rem ( s, length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(), <S2SV_blank> consume <S2SV_blank> domain <S2SV_blank> params <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; }",1
1541,CWE-20,"CWE-20 int read_filesystem_tables_4 ( ) { <S2SV_StartBug> long long directory_table_end , table_start ; <S2SV_EndBug> if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( read_uids_guids ( & table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( parse_exports_table ( & table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <S2SV_EndBug> return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> { long long table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_xattrs_from_disk <S2SV_ModStart> == 0 ) goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_id_table <S2SV_ModEnd> ( & table_start <S2SV_ModStart> == FALSE ) goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( parse_exports_table <S2SV_ModStart> == FALSE ) goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_fragment_table <S2SV_ModStart> read_fragment_table ( & table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_inode_table <S2SV_ModStart> == FALSE ) goto corrupted <S2SV_ModEnd> ; if ( <S2SV_ModStart> return TRUE ; corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\n"" ) ; return FALSE ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z,1541,"<S2SV_ModStart> { long long <S2SV_ModEnd> directory_table_end, table_start <S2SV_ModStart> 0 ) return FALSE <S2SV_ModEnd> ; if ( <S2SV_ModStart> == FALSE ) return FALSE ; if ( parse_exports_and_fragment_tables ( & table_start, & directory_table_end ) == FALSE ) return FALSE ; if ( read_inode_table ( sBlk. s. inode_table_start, sBlk. s. directory_table_start ) == FALSE ) return FALSE ; if ( read_directory_table ( sBlk. s. directory_table_start, directory_table_end ) == FALSE ) return FALSE ; if ( read_inode_table ( sBlk. s. inode_table_start, sBlk. s. directory_table_start ) == FALSE ) return FALSE ; if ( read_directory_table ( sBlk. s. directory_table_start, directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk. s. xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ;",0
1545,CWE-125,"CWE-125 static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! Module_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_EndBug> 1 ) ; <S2SV_StartBug> if ( ! Interactive_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ; <S2SV_EndBug> if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields , <S2SV_StartBug> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! FunctionDef_type ) return 0 ; <S2SV_EndBug> AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , <S2SV_StartBug> AsyncFunctionDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! AsyncFunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ClassDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ; <S2SV_EndBug> if ( ! Return_type ) return 0 ; <S2SV_StartBug> Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; <S2SV_EndBug> if ( ! Delete_type ) return 0 ; <S2SV_StartBug> Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ; <S2SV_EndBug> if ( ! Assign_type ) return 0 ; <S2SV_StartBug> AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; <S2SV_EndBug> if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ; if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ; if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" , stmt_type , With_fields , 2 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , AsyncWith_fields , 2 ) ; if ( ! AsyncWith_type ) return 0 ; Raise_type = make_type ( ""Raise"" , stmt_type , Raise_fields , 2 ) ; if ( ! Raise_type ) return 0 ; Try_type = make_type ( ""Try"" , stmt_type , Try_fields , 4 ) ; if ( ! Try_type ) return 0 ; Assert_type = make_type ( ""Assert"" , stmt_type , Assert_fields , 2 ) ; if ( ! Assert_type ) return 0 ; Import_type = make_type ( ""Import"" , stmt_type , Import_fields , 1 ) ; if ( ! Import_type ) return 0 ; ImportFrom_type = make_type ( ""ImportFrom"" , stmt_type , ImportFrom_fields , 3 ) ; if ( ! ImportFrom_type ) return 0 ; Global_type = make_type ( ""Global"" , stmt_type , Global_fields , 1 ) ; if ( ! Global_type ) return 0 ; Nonlocal_type = make_type ( ""Nonlocal"" , stmt_type , Nonlocal_fields , 1 ) ; if ( ! Nonlocal_type ) return 0 ; Expr_type = make_type ( ""Expr"" , stmt_type , Expr_fields , 1 ) ; if ( ! Expr_type ) return 0 ; Pass_type = make_type ( ""Pass"" , stmt_type , NULL , 0 ) ; if ( ! Pass_type ) return 0 ; Break_type = make_type ( ""Break"" , stmt_type , NULL , 0 ) ; if ( ! Break_type ) return 0 ; Continue_type = make_type ( ""Continue"" , stmt_type , NULL , 0 ) ; if ( ! Continue_type ) return 0 ; expr_type = make_type ( ""expr"" , & AST_type , NULL , 0 ) ; if ( ! expr_type ) return 0 ; if ( ! add_attributes ( expr_type , expr_attributes , 4 ) ) return 0 ; BoolOp_type = make_type ( ""BoolOp"" , expr_type , BoolOp_fields , 2 ) ; if ( ! BoolOp_type ) return 0 ; NamedExpr_type = make_type ( ""NamedExpr"" , expr_type , NamedExpr_fields , 2 ) ; if ( ! NamedExpr_type ) return 0 ; BinOp_type = make_type ( ""BinOp"" , expr_type , BinOp_fields , 3 ) ; if ( ! BinOp_type ) return 0 ; UnaryOp_type = make_type ( ""UnaryOp"" , expr_type , UnaryOp_fields , 2 ) ; if ( ! UnaryOp_type ) return 0 ; Lambda_type = make_type ( ""Lambda"" , expr_type , Lambda_fields , 2 ) ; if ( ! Lambda_type ) return 0 ; IfExp_type = make_type ( ""IfExp"" , expr_type , IfExp_fields , 3 ) ; if ( ! IfExp_type ) return 0 ; Dict_type = make_type ( ""Dict"" , expr_type , Dict_fields , 2 ) ; if ( ! Dict_type ) return 0 ; Set_type = make_type ( ""Set"" , expr_type , Set_fields , 1 ) ; if ( ! Set_type ) return 0 ; ListComp_type = make_type ( ""ListComp"" , expr_type , ListComp_fields , 2 ) ; if ( ! ListComp_type ) return 0 ; SetComp_type = make_type ( ""SetComp"" , expr_type , SetComp_fields , 2 ) ; if ( ! SetComp_type ) return 0 ; DictComp_type = make_type ( ""DictComp"" , expr_type , DictComp_fields , 3 ) ; if ( ! DictComp_type ) return 0 ; GeneratorExp_type = make_type ( ""GeneratorExp"" , expr_type , GeneratorExp_fields , 2 ) ; if ( ! GeneratorExp_type ) return 0 ; Await_type = make_type ( ""Await"" , expr_type , Await_fields , 1 ) ; if ( ! Await_type ) return 0 ; Yield_type = make_type ( ""Yield"" , expr_type , Yield_fields , 1 ) ; if ( ! Yield_type ) return 0 ; YieldFrom_type = make_type ( ""YieldFrom"" , expr_type , YieldFrom_fields , 1 ) ; if ( ! YieldFrom_type ) return 0 ; Compare_type = make_type ( ""Compare"" , expr_type , Compare_fields , 3 ) ; if ( ! Compare_type ) return 0 ; Call_type = make_type ( ""Call"" , expr_type , Call_fields , 3 ) ; if ( ! Call_type ) return 0 ; FormattedValue_type = make_type ( ""FormattedValue"" , expr_type , FormattedValue_fields , 3 ) ; if ( ! FormattedValue_type ) return 0 ; JoinedStr_type = make_type ( ""JoinedStr"" , expr_type , JoinedStr_fields , 1 ) ; if ( ! JoinedStr_type ) return 0 ; Constant_type = make_type ( ""Constant"" , expr_type , Constant_fields , 1 ) ; if ( ! Constant_type ) return 0 ; Attribute_type = make_type ( ""Attribute"" , expr_type , Attribute_fields , 3 ) ; if ( ! Attribute_type ) return 0 ; Subscript_type = make_type ( ""Subscript"" , expr_type , Subscript_fields , 3 ) ; if ( ! Subscript_type ) return 0 ; Starred_type = make_type ( ""Starred"" , expr_type , Starred_fields , 2 ) ; if ( ! Starred_type ) return 0 ; Name_type = make_type ( ""Name"" , expr_type , Name_fields , 2 ) ; if ( ! Name_type ) return 0 ; List_type = make_type ( ""List"" , expr_type , List_fields , 2 ) ; if ( ! List_type ) return 0 ; Tuple_type = make_type ( ""Tuple"" , expr_type , Tuple_fields , 2 ) ; if ( ! Tuple_type ) return 0 ; expr_context_type = make_type ( ""expr_context"" , & AST_type , NULL , 0 ) ; if ( ! expr_context_type ) return 0 ; if ( ! add_attributes ( expr_context_type , NULL , 0 ) ) return 0 ; Load_type = make_type ( ""Load"" , expr_context_type , NULL , 0 ) ; if ( ! Load_type ) return 0 ; Load_singleton = PyType_GenericNew ( Load_type , NULL , NULL ) ; if ( ! Load_singleton ) return 0 ; Store_type = make_type ( ""Store"" , expr_context_type , NULL , 0 ) ; if ( ! Store_type ) return 0 ; Store_singleton = PyType_GenericNew ( Store_type , NULL , NULL ) ; if ( ! Store_singleton ) return 0 ; Del_type = make_type ( ""Del"" , expr_context_type , NULL , 0 ) ; if ( ! Del_type ) return 0 ; Del_singleton = PyType_GenericNew ( Del_type , NULL , NULL ) ; if ( ! Del_singleton ) return 0 ; AugLoad_type = make_type ( ""AugLoad"" , expr_context_type , NULL , 0 ) ; if ( ! AugLoad_type ) return 0 ; AugLoad_singleton = PyType_GenericNew ( AugLoad_type , NULL , NULL ) ; if ( ! AugLoad_singleton ) return 0 ; AugStore_type = make_type ( ""AugStore"" , expr_context_type , NULL , 0 ) ; if ( ! AugStore_type ) return 0 ; AugStore_singleton = PyType_GenericNew ( AugStore_type , NULL , NULL ) ; if ( ! AugStore_singleton ) return 0 ; Param_type = make_type ( ""Param"" , expr_context_type , NULL , 0 ) ; if ( ! Param_type ) return 0 ; Param_singleton = PyType_GenericNew ( Param_type , NULL , NULL ) ; if ( ! Param_singleton ) return 0 ; NamedStore_type = make_type ( ""NamedStore"" , expr_context_type , NULL , 0 ) ; if ( ! NamedStore_type ) return 0 ; NamedStore_singleton = PyType_GenericNew ( NamedStore_type , NULL , NULL ) ; if ( ! NamedStore_singleton ) return 0 ; slice_type = make_type ( ""slice"" , & AST_type , NULL , 0 ) ; if ( ! slice_type ) return 0 ; if ( ! add_attributes ( slice_type , NULL , 0 ) ) return 0 ; Slice_type = make_type ( ""Slice"" , slice_type , Slice_fields , 3 ) ; if ( ! Slice_type ) return 0 ; ExtSlice_type = make_type ( ""ExtSlice"" , slice_type , ExtSlice_fields , 1 ) ; if ( ! ExtSlice_type ) return 0 ; Index_type = make_type ( ""Index"" , slice_type , Index_fields , 1 ) ; if ( ! Index_type ) return 0 ; boolop_type = make_type ( ""boolop"" , & AST_type , NULL , 0 ) ; if ( ! boolop_type ) return 0 ; if ( ! add_attributes ( boolop_type , NULL , 0 ) ) return 0 ; And_type = make_type ( ""And"" , boolop_type , NULL , 0 ) ; if ( ! And_type ) return 0 ; And_singleton = PyType_GenericNew ( And_type , NULL , NULL ) ; if ( ! And_singleton ) return 0 ; Or_type = make_type ( ""Or"" , boolop_type , NULL , 0 ) ; if ( ! Or_type ) return 0 ; Or_singleton = PyType_GenericNew ( Or_type , NULL , NULL ) ; if ( ! Or_singleton ) return 0 ; operator_type = make_type ( ""operator"" , & AST_type , NULL , 0 ) ; if ( ! operator_type ) return 0 ; if ( ! add_attributes ( operator_type , NULL , 0 ) ) return 0 ; Add_type = make_type ( ""Add"" , operator_type , NULL , 0 ) ; if ( ! Add_type ) return 0 ; Add_singleton = PyType_GenericNew ( Add_type , NULL , NULL ) ; if ( ! Add_singleton ) return 0 ; Sub_type = make_type ( ""Sub"" , operator_type , NULL , 0 ) ; if ( ! Sub_type ) return 0 ; Sub_singleton = PyType_GenericNew ( Sub_type , NULL , NULL ) ; if ( ! Sub_singleton ) return 0 ; Mult_type = make_type ( ""Mult"" , operator_type , NULL , 0 ) ; if ( ! Mult_type ) return 0 ; Mult_singleton = PyType_GenericNew ( Mult_type , NULL , NULL ) ; if ( ! Mult_singleton ) return 0 ; MatMult_type = make_type ( ""MatMult"" , operator_type , NULL , 0 ) ; if ( ! MatMult_type ) return 0 ; MatMult_singleton = PyType_GenericNew ( MatMult_type , NULL , NULL ) ; if ( ! MatMult_singleton ) return 0 ; Div_type = make_type ( ""Div"" , operator_type , NULL , 0 ) ; if ( ! Div_type ) return 0 ; Div_singleton = PyType_GenericNew ( Div_type , NULL , NULL ) ; if ( ! Div_singleton ) return 0 ; Mod_type = make_type ( ""Mod"" , operator_type , NULL , 0 ) ; if ( ! Mod_type ) return 0 ; Mod_singleton = PyType_GenericNew ( Mod_type , NULL , NULL ) ; if ( ! Mod_singleton ) return 0 ; Pow_type = make_type ( ""Pow"" , operator_type , NULL , 0 ) ; if ( ! Pow_type ) return 0 ; Pow_singleton = PyType_GenericNew ( Pow_type , NULL , NULL ) ; if ( ! Pow_singleton ) return 0 ; LShift_type = make_type ( ""LShift"" , operator_type , NULL , 0 ) ; if ( ! LShift_type ) return 0 ; LShift_singleton = PyType_GenericNew ( LShift_type , NULL , NULL ) ; if ( ! LShift_singleton ) return 0 ; RShift_type = make_type ( ""RShift"" , operator_type , NULL , 0 ) ; if ( ! RShift_type ) return 0 ; RShift_singleton = PyType_GenericNew ( RShift_type , NULL , NULL ) ; if ( ! RShift_singleton ) return 0 ; BitOr_type = make_type ( ""BitOr"" , operator_type , NULL , 0 ) ; if ( ! BitOr_type ) return 0 ; BitOr_singleton = PyType_GenericNew ( BitOr_type , NULL , NULL ) ; if ( ! BitOr_singleton ) return 0 ; BitXor_type = make_type ( ""BitXor"" , operator_type , NULL , 0 ) ; if ( ! BitXor_type ) return 0 ; BitXor_singleton = PyType_GenericNew ( BitXor_type , NULL , NULL ) ; if ( ! BitXor_singleton ) return 0 ; BitAnd_type = make_type ( ""BitAnd"" , operator_type , NULL , 0 ) ; if ( ! BitAnd_type ) return 0 ; BitAnd_singleton = PyType_GenericNew ( BitAnd_type , NULL , NULL ) ; if ( ! BitAnd_singleton ) return 0 ; FloorDiv_type = make_type ( ""FloorDiv"" , operator_type , NULL , 0 ) ; if ( ! FloorDiv_type ) return 0 ; FloorDiv_singleton = PyType_GenericNew ( FloorDiv_type , NULL , NULL ) ; if ( ! FloorDiv_singleton ) return 0 ; unaryop_type = make_type ( ""unaryop"" , & AST_type , NULL , 0 ) ; if ( ! unaryop_type ) return 0 ; if ( ! add_attributes ( unaryop_type , NULL , 0 ) ) return 0 ; Invert_type = make_type ( ""Invert"" , unaryop_type , NULL , 0 ) ; if ( ! Invert_type ) return 0 ; Invert_singleton = PyType_GenericNew ( Invert_type , NULL , NULL ) ; if ( ! Invert_singleton ) return 0 ; Not_type = make_type ( ""Not"" , unaryop_type , NULL , 0 ) ; if ( ! Not_type ) return 0 ; Not_singleton = PyType_GenericNew ( Not_type , NULL , NULL ) ; if ( ! Not_singleton ) return 0 ; UAdd_type = make_type ( ""UAdd"" , unaryop_type , NULL , 0 ) ; if ( ! UAdd_type ) return 0 ; UAdd_singleton = PyType_GenericNew ( UAdd_type , NULL , NULL ) ; if ( ! UAdd_singleton ) return 0 ; USub_type = make_type ( ""USub"" , unaryop_type , NULL , 0 ) ; if ( ! USub_type ) return 0 ; USub_singleton = PyType_GenericNew ( USub_type , NULL , NULL ) ; if ( ! USub_singleton ) return 0 ; cmpop_type = make_type ( ""cmpop"" , & AST_type , NULL , 0 ) ; if ( ! cmpop_type ) return 0 ; if ( ! add_attributes ( cmpop_type , NULL , 0 ) ) return 0 ; Eq_type = make_type ( ""Eq"" , cmpop_type , NULL , 0 ) ; if ( ! Eq_type ) return 0 ; Eq_singleton = PyType_GenericNew ( Eq_type , NULL , NULL ) ; if ( ! Eq_singleton ) return 0 ; NotEq_type = make_type ( ""NotEq"" , cmpop_type , NULL , 0 ) ; if ( ! NotEq_type ) return 0 ; NotEq_singleton = PyType_GenericNew ( NotEq_type , NULL , NULL ) ; if ( ! NotEq_singleton ) return 0 ; Lt_type = make_type ( ""Lt"" , cmpop_type , NULL , 0 ) ; if ( ! Lt_type ) return 0 ; Lt_singleton = PyType_GenericNew ( Lt_type , NULL , NULL ) ; if ( ! Lt_singleton ) return 0 ; LtE_type = make_type ( ""LtE"" , cmpop_type , NULL , 0 ) ; if ( ! LtE_type ) return 0 ; LtE_singleton = PyType_GenericNew ( LtE_type , NULL , NULL ) ; if ( ! LtE_singleton ) return 0 ; Gt_type = make_type ( ""Gt"" , cmpop_type , NULL , 0 ) ; if ( ! Gt_type ) return 0 ; Gt_singleton = PyType_GenericNew ( Gt_type , NULL , NULL ) ; if ( ! Gt_singleton ) return 0 ; GtE_type = make_type ( ""GtE"" , cmpop_type , NULL , 0 ) ; if ( ! GtE_type ) return 0 ; GtE_singleton = PyType_GenericNew ( GtE_type , NULL , NULL ) ; if ( ! GtE_singleton ) return 0 ; Is_type = make_type ( ""Is"" , cmpop_type , NULL , 0 ) ; if ( ! Is_type ) return 0 ; Is_singleton = PyType_GenericNew ( Is_type , NULL , NULL ) ; if ( ! Is_singleton ) return 0 ; IsNot_type = make_type ( ""IsNot"" , cmpop_type , NULL , 0 ) ; if ( ! IsNot_type ) return 0 ; IsNot_singleton = PyType_GenericNew ( IsNot_type , NULL , NULL ) ; if ( ! IsNot_singleton ) return 0 ; In_type = make_type ( ""In"" , cmpop_type , NULL , 0 ) ; if ( ! In_type ) return 0 ; In_singleton = PyType_GenericNew ( In_type , NULL , NULL ) ; if ( ! In_singleton ) return 0 ; NotIn_type = make_type ( ""NotIn"" , cmpop_type , NULL , 0 ) ; if ( ! NotIn_type ) return 0 ; NotIn_singleton = PyType_GenericNew ( NotIn_type , NULL , NULL ) ; if ( ! NotIn_singleton ) return 0 ; comprehension_type = make_type ( ""comprehension"" , & AST_type , comprehension_fields , 4 ) ; if ( ! comprehension_type ) return 0 ; if ( ! add_attributes ( comprehension_type , NULL , 0 ) ) return 0 ; excepthandler_type = make_type ( ""excepthandler"" , & AST_type , NULL , 0 ) ; if ( ! excepthandler_type ) return 0 ; if ( ! add_attributes ( excepthandler_type , excepthandler_attributes , 4 ) ) return 0 ; ExceptHandler_type = make_type ( ""ExceptHandler"" , excepthandler_type , ExceptHandler_fields , 3 ) ; if ( ! ExceptHandler_type ) return 0 ; arguments_type = make_type ( ""arguments"" , & AST_type , arguments_fields , 6 ) ; if ( ! arguments_type ) return 0 ; if ( ! add_attributes ( arguments_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ; <S2SV_EndBug> if ( ! arg_type ) return 0 ; if ( ! add_attributes ( arg_type , arg_attributes , 4 ) ) return 0 ; keyword_type = make_type ( ""keyword"" , & AST_type , keyword_fields , 2 ) ; if ( ! keyword_type ) return 0 ; if ( ! add_attributes ( keyword_type , NULL , 0 ) ) return 0 ; alias_type = make_type ( ""alias"" , & AST_type , alias_fields , 2 ) ; if ( ! alias_type ) return 0 ; if ( ! add_attributes ( alias_type , NULL , 0 ) ) return 0 ; withitem_type = make_type ( ""withitem"" , & AST_type , withitem_fields , 2 ) ; if ( ! withitem_type ) return 0 ; if ( ! add_attributes ( withitem_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> initialized = 1 ; <S2SV_EndBug> return 1 ; }
","<S2SV_ModStart> , Module_fields , 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_ModStart> if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , Expression_fields , <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> if ( ! Expression_type ) return 0 ; FunctionType_type = make_type ( ""FunctionType"" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , FunctionType_fields , 2 ) ; if ( ! FunctionType_type <S2SV_ModEnd> ) return 0 <S2SV_ModStart> , FunctionDef_fields , 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , <S2SV_ModStart> if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( ""Return"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncFor_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncWith_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , arg_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> return 0 ; type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,1545,"<S2SV_ModStart> ; Module_type = make_type ( ""Module"", mod_type, Module_fields, 1 ) ; if (! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"", mod_type, Interactive_fields, 1 ) ; if (! Interactive_type <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; Interactive_type = make_type ( ""Interactive"", mod_type, Interactive_fields, 1 ) ; if (! Interactive_type <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; Expression_type = make_type ( ""Expression"", mod_type, Expression_fields, 1 ) ; if (! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"", mod_type, Suite_fields, 1 ) ; if (! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"", & AST_type, NULL, 0 ) ; if (! stmt_type ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"", stmt_type, FunctionDef_fields, 5 ) ; if (! FunctionDef_type ) return 0 ; AsyncFunctionDef_type",0
1547,CWE-787,"CWE-787 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
",miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a,CVE-2019-16347,https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a,2019-09-16T13:15Z,1547,<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; },1
1552,CWE-20,"CWE-20 int DoOneObject ( char * cinput ) { <S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ; <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> return ( 0 ) ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" , axohelp , nameobject ) ; <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) { <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>no<S2SV_blank>extra<S2SV_blank>numbers<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""Curve"" ) == 0 ) { Curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) { Polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) { Polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) { <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> if ( num2 != 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>two<S2SV_blank>numbers<S2SV_blank>after<S2SV_blank>the<S2SV_blank>coordinates\\n<S2SV_blank><S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; DashCurve ( argbuf , num1 ) ; free ( argbuf ) ; <S2SV_StartBug> } <S2SV_EndBug> } else { <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < sizeof ( commands ) / sizeof ( KEYWORD ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; SetLineWidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>%d(+1)<S2SV_blank>arguments<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( KEYWORD ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; CleanupOutput ( StartClean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }
","<S2SV_ModStart> num1 , num2 , retcode <S2SV_ModStart> , * t <S2SV_ModEnd> ; double * <S2SV_ModStart> argbuf = 0 ; retcode = - 1 <S2SV_ModStart> t ++ ; fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> = outputbuffer ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ] == 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> = 1 ; fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> , VERSION , <S2SV_ModStart> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" <S2SV_ModStart> nameobject ) ; goto EXIT ; } } <S2SV_ModEnd> if ( ( <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; for ( <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } } <S2SV_ModStart> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> argbuf ) ; } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> ) ; }
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,1552,"<S2SV_ModStart> cinput ) { <S2SV_ModEnd> char * s <S2SV_ModStart> * s, * t, * StartClean ; double <S2SV_ModEnd> * argbuf = <S2SV_ModStart> * argbuf = 0 <S2SV_ModEnd> ; SetDefaults ( <S2SV_ModStart> ; s = cinput ; while ( * s!= '[' ) s ++ ; t = s ; while ( * t!= ']' ) t ++ ; <S2SV_ModStart> += sprintf ( outbuffer <S2SV_ModEnd>, ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"", <S2SV_ModStart> ; if ( * s == '0' && s [ 1 ] == ']' ) { if ( strcmp ( nameobject, ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ; outpos += sprintf ( outpos, ""Axohelp <S2SV_blank> version <S2SV_blank> %d.%d. <S2SV_blank> PDF <S2SV_blank> output.}"", VERSION, SUBVERSION ) ; fprintf ( outfile, ""%s"", outputbuffer ) ; free ( argbuf ) ; return ( 0 ) ; } StartClean = outpos ; nameobject = t ; while ( * t!='<S2SV_blank>'&& * t!= '\\n' ) t ++ ; * t ++ = 0 ; if ( strcmp ( nameobject, ""Curve"" ) == 0 ) {",0
1555,CWE-125,"CWE-125 int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_lower ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> slice_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( dims , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; <S2SV_EndBug> return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lower , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { slice_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1555,"<S2SV_ModStart> expr_ty step ; string type_comment ; <S2SV_ModStart> int res ; tmp = _PyObject_GetAttrId ( obj, & PyId_lower ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp, & lower, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { lower = NULL ; } if ( exists_not_none ( obj, & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj, & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp, & upper, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj, & PyId_step ) ) { int res ; res = obj2ast_expr ( tmp, & step, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } <S2SV_ModStart> ) ; } if ( exists_not_none ( obj, &",0
1561,CWE-787,"CWE-787 PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rdd"" , & IM , & input , & output ) == FAILURE ) { return ; } <S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }
","<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; }
",php@php-src/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae,CVE-2016-7127,https://github.com/php/php-src/commit/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae?w=1,2016-09-12T01:59Z,1561,"<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC, E_WARNING, ""Gamma <S2SV_blank> values <S2SV_blank> should <S2SV_blank> be <S2SV_blank> positive"" ) ; RETURN_FALSE ; }",1
1573,CWE-416,"CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; <S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( ""[timerfd]"" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }
","<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;
",torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6,CVE-2017-10661,https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6,2017-08-19T18:29Z,1573,"<S2SV_ModStart> wqh ) ; init_waitqueue_func_entry ( & ctx -> wait, ctx_wakeup ) ;",0
1587,CWE-20,"CWE-20 error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '=' ) { separatorFound = TRUE ; param -> nameLen = p + i - param -> name ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { } else { error = ERROR_INVALID_SYNTAX ; } } else if ( ! separatorFound ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == '=' ) { separatorFound = TRUE ; } else if ( c == \'\\""\' ) { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> value == NULL ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == \'\\""\' ) { param -> value = p + i ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { param -> value = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( param -> value [ 0 ] == \'\\""\' ) { if ( c == '\\0' ) { error = ERROR_INVALID_SYNTAX ; } else if ( escapeFlag ) { escapeFlag = FALSE ; } else if ( c == '\\\\' ) { escapeFlag = TRUE ; } else if ( c == \'\\""\' ) { i ++ ; param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } else if ( isprint ( c ) || c == '\\t' || c >= 128 ) { } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( c == '\\0' || c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { } else { error = ERROR_INVALID_SYNTAX ; } } } if ( error == ERROR_IN_PROGRESS ) i ++ ; } if ( param -> valueLen >= 2 && param -> value [ 0 ] == \'\\""\' ) { param -> value ++ ; param -> valueLen -= 2 ; } * pos = p + i ; return error ; }
","<S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1587,"<S2SV_ModStart> } else if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c <S2SV_ModEnd> ) || c <S2SV_ModStart> } else if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c <S2SV_ModEnd> ) || c <S2SV_ModStart> } else if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c <S2SV_ModEnd> ) || c <S2SV_ModStart> else if ( ISALNUM ( <S2SV_ModEnd> c ) || <S2SV_ModStart> } else if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c <S2SV_ModEnd> ) || c <S2SV_ModStart> } else if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c <S2SV_ModEnd> ) || c <S2SV_ModStart> } else { if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c <S2SV_ModEnd> ) || c <S2SV_ModStart> } else if ( ISALNUM ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"", c",0
1588,CWE-416,"CWE-416 static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , <S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug> packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }
","<S2SV_ModStart> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->
",ntop@nDPI/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,CVE-2020-15475,https://github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,2020-07-01T11:15Z,1588,"<S2SV_ModStart> -> http_contentlen. ptr = NULL, packet -> http_contentlen. len = 0, packet -> http_cookie. ptr = NULL, packet -> http_cookie. len = 0, packet -> http_origin. ptr = NULL, packet -> http_origin. ptr = NULL, packet -> http_origin. ptr = NULL, packet -> http_origin. len = 0, packet -> content_line. ptr = NULL, packet -> content_line. ptr = NULL, packet -> content_line. len = 0, packet -> accept_line. ptr = NULL, packet -> accept_line. len = 0, packet -> user_agent_line. ptr = NULL, packet -> user_agent_line. len = 0, packet -> http_url_name. ptr = NULL, packet -> http_url_name. len = 0, packet -> http_transfer_encoding. ptr = NULL, packet -> http_contentlen. ptr = NULL, packet -> http_transfer_encoding. len = 0, packet -> http_x_session_type. ptr = NULL, packet -> http_x_session_type. len = 0, packet ->",0
1589,CWE-20,"CWE-20 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> out : return ERR_PTR ( error ) ; }
","<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return
",torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z,1589,<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return,1
1591,CWE-20,"CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> return MagickTrue ; }
","<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,1591,"<S2SV_ModStart>, y, MagickMin <S2SV_ModEnd> ( 4, <S2SV_ModStart> x ), MagickMin <S2SV_ModEnd> ( 4, <S2SV_ModStart> ; } } return SyncAuthenticPixels ( image, exception ) <S2SV_ModEnd> ; } <S2SV_null>",0
1595,CWE-20,"CWE-20 void BezierOval ( double w , double h , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , w , - h * BzK , w * BzK , - h , - h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - w * BzK , - h , - w , - h * BzK , - w , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,1595,"<S2SV_ModStart> action ) { sprintf ( outputbuffer <S2SV_ModEnd>, "" <S2SV_blank> %12.3f <S2SV_blank> 0 <S2SV_blank> m <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> 0 <S2SV_blank> c\\n"", <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;",0
1598,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
",ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z,1598,"<S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> ""ImproperImageHeader"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" ) ; <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" ) ;",0
1599,CWE-20,"CWE-20 void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,1599,"<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd>, ""%12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> cm\\n"", <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;",1
1600,CWE-125,"CWE-125 static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }
","<S2SV_ModStart> , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1
",FreeRDP@FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65,CVE-2020-11047,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,2020-05-07T20:15Z,1600,<S2SV_ModStart> return FALSE ; if ( Stream_GetRemainingLength ( s ) < 4 ) { return FALSE ; },0
1601,CWE-416,"CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
","<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
",torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z,1601,<S2SV_ModStart> user ) { cleanup_srcu_struct ( & user -> release_barrier ) ;,0
1611,CWE-787,"CWE-787 void process_bitmap_updates ( STREAM s ) { <S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }
","<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,1611,"<S2SV_ModStart> s ) { struct stream packet = * s ; <S2SV_ModStart> int i ; if (! s_check_rem ( s, 2 ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> of <S2SV_blank> bitmaps <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> of <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> of <S2SV_blank> bitmaps <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; }",0
1613,CWE-125,"CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else <S2SV_StartBug> { <S2SV_EndBug> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : { <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }
","<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z,1613,"<S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg6 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; } <S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; goto trunc ; }",0
1627,CWE-787,"CWE-787 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z,1627,"<S2SV_ModStart> 4 ) ; if ( idx + 4 > len ) return NULL ; <S2SV_ModStart> ]. len ) ; CHECKINT16 ( idx, len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; a -> guid = CHECKED_XMALLOC ( GUID, 1 ) ; copy_guid_from_buf ( a -> guid, buf + idx, len ) ; idx += sizeof ( GUID ) ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID, 1 ) ; copy_guid_from_buf ( a -> guid, buf + idx, len ) ; idx += sizeof ( GUID ) ; } for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx, len ) ; a -> names [ i ]. data = CHECKED_XMALLOC ( unsigned char, a -> names [ i ]. len ) ; for ( j = 0 ; j < a -> num_names ; j ++ ) a -> names [ i ]. data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to",0
1635,CWE-125,"CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
","<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
",radareorg@radare2/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,CVE-2018-20459,https://github.com/radareorg/radare2/commit/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,2018-12-25T19:29Z,1635,<S2SV_ModStart> [ i ] && j < sizeof ( buf ),0
1637,CWE-125,"CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""trailingnull.bson"" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""dollarquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$query\\"""" ) ; VALIDATE_TEST ( ""dotquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\"".\\"":<S2SV_blank>\\""abc.def\\"""" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow4.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""empty_key.bson"" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , ""empty<S2SV_blank>key"" ) ; VALIDATE_TEST ( ""test40.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test41.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test42.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test43.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test44.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test45.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test46.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test47.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test48.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test49.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test50.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test51.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test52.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test53.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test54.bson"" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; <S2SV_StartBug> b = BCON_NEW ( ""my_dbref"" , <S2SV_EndBug> ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$id\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$ref\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""extra"" , BCON_INT32 ( 2 ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\""extra\\"""" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }
","<S2SV_ModStart> ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;
",mongodb@mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,CVE-2018-16790,https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,2018-09-10T05:29Z,1637,"<S2SV_ModStart> ""corrupt <S2SV_blank> BSON"" ) ; VALIDATE_TEST ( ""test59.bson"", BSON_VALIDATE_NONE, 9, BSON_VALIDATE_NONE, ""corrupt <S2SV_blank> BSON"" ) ;",1
1638,CWE-20,"CWE-20 __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_arch_events_quirk ) ; switch ( boot_cpu_data . x86_model ) { case 14 : pr_cont ( ""Core<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 15 : x86_add_quirk ( intel_clovertown_quirk ) ; case 22 : case 23 : case 29 : memcpy ( hw_cache_event_ids , core2_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_core ( ) ; x86_pmu . event_constraints = intel_core2_event_constraints ; x86_pmu . pebs_constraints = intel_core2_pebs_event_constraints ; pr_cont ( ""Core2<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 26 : case 30 : case 46 : memcpy ( hw_cache_event_ids , nehalem_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_nehalem_event_constraints ; x86_pmu . pebs_constraints = intel_nehalem_pebs_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . extra_regs = intel_nehalem_extra_regs ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; x86_add_quirk ( intel_nehalem_quirk ) ; pr_cont ( ""Nehalem<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 28 : case 38 : case 39 : case 53 : case 54 : memcpy ( hw_cache_event_ids , atom_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_atom ( ) ; x86_pmu . event_constraints = intel_gen_event_constraints ; x86_pmu . pebs_constraints = intel_atom_pebs_event_constraints ; pr_cont ( ""Atom<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 37 : case 44 : case 47 : memcpy ( hw_cache_event_ids , westmere_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_westmere_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . pebs_constraints = intel_westmere_pebs_event_constraints ; x86_pmu . extra_regs = intel_westmere_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""Westmere<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 42 : case 45 : x86_add_quirk ( intel_sandybridge_quirk ) ; memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_snb_event_constraints ; x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""SandyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 58 : case 62 : memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_ivb_event_constraints ; x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ; <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> x86_pmu . extra_regs = intel_snb_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""IvyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; default : switch ( x86_pmu . version ) { case 1 : x86_pmu . event_constraints = intel_v1_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon<S2SV_blank>v1,<S2SV_blank>"" ) ; break ; default : x86_pmu . event_constraints = intel_gen_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon,<S2SV_blank>"" ) ; break ; } } if ( x86_pmu . num_counters > INTEL_PMC_MAX_GENERIC ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters , INTEL_PMC_MAX_GENERIC ) ; x86_pmu . num_counters = INTEL_PMC_MAX_GENERIC ; } x86_pmu . intel_ctrl = ( 1 << x86_pmu . num_counters ) - 1 ; if ( x86_pmu . num_counters_fixed > INTEL_PMC_MAX_FIXED ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>fixed<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters_fixed , INTEL_PMC_MAX_FIXED ) ; x86_pmu . num_counters_fixed = INTEL_PMC_MAX_FIXED ; } x86_pmu . intel_ctrl |= ( ( 1LL << x86_pmu . num_counters_fixed ) - 1 ) << INTEL_PMC_IDX_FIXED ; if ( x86_pmu . event_constraints ) { for_each_event_constraint ( c , x86_pmu . event_constraints ) { if ( c -> cmask != X86_RAW_EVENT_MASK || c -> idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES ) { continue ; } c -> idxmsk64 |= ( 1ULL << x86_pmu . num_counters ) - 1 ; c -> weight += x86_pmu . num_counters ; } } return 0 ; }
","<S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
",torvalds@linux/f1923820c447e986a9da0fc6bf60c1dccdf0408e,CVE-2013-2146,https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e,2013-06-07T14:03Z,1638,"<S2SV_ModStart> ; if ( cpu_has ( & boot_cpu_data, X86_FEATURE_ARCH_PERFMON ) ) { if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask |= ( 1ULL << eax. split. bit_width ) - 1 ; if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask |= ( 1ULL << eax. split. bit_width ) - 1 ; } else if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask &= ( 1ULL << eax. split. bit_width ) - 1 ; if ( x86_pmu. cntval_mask & ( 1ULL << eax. split. bit_width ) ) x86_pmu. cntval_mask |= ( 1ULL << eax. split. bit_width ) - 1 ;",0
1639,CWE-20,"CWE-20 void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; <S2SV_StartBug> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <S2SV_EndBug> ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec -> ps_dec_err_status -> u1_err_flag = ACCEPT_ALL_PICS ; ps_dec -> ps_dec_err_status -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; ps_dec -> ps_dec_err_status -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; ps_dec -> ps_dec_err_status -> u4_cur_frm = INIT_FRAME ; ps_dec -> ps_dec_err_status -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; ps_dec -> u1_pr_sl_type = 0xFF ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_prev_poc = & ps_dec -> s_prev_pic_poc ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb = 0 ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_top_field_order_count = ps_cur_poc -> i4_top_field_order_count = 0 ; ps_prev_poc -> i4_bottom_field_order_count = ps_cur_poc -> i4_bottom_field_order_count = 0 ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst = 0 ; ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = 0 ; ps_dec -> i4_max_poc = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> u1_recon_mb_grp = 4 ; ps_dec -> u1_second_field = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; ps_dec -> u2_crop_offset_y = 0 ; ps_dec -> u2_crop_offset_uv = 0 ; ps_dec -> i4_vui_frame_rate = - 1 ; ps_dec -> i4_pic_type = - 1 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u1_res_changed = 0 ; ps_dec -> u1_frame_decoded_flag = 0 ; ps_dec -> u4_skip_frm_mask = SKIP_NONE ; ps_dec -> pf_cavlc_4x4res_block [ 0 ] = ih264d_cavlc_4x4res_block_totalcoeff_1 ; ps_dec -> pf_cavlc_4x4res_block [ 1 ] = ih264d_cavlc_4x4res_block_totalcoeff_2to10 ; ps_dec -> pf_cavlc_4x4res_block [ 2 ] = ih264d_cavlc_4x4res_block_totalcoeff_11to16 ; ps_dec -> pf_cavlc_parse4x4coeff [ 0 ] = ih264d_cavlc_parse4x4coeff_n0to7 ; ps_dec -> pf_cavlc_parse4x4coeff [ 1 ] = ih264d_cavlc_parse4x4coeff_n8 ; ps_dec -> pf_cavlc_parse_8x8block [ 0 ] = ih264d_cavlc_parse_8x8block_none_available ; ps_dec -> pf_cavlc_parse_8x8block [ 1 ] = ih264d_cavlc_parse_8x8block_left_available ; ps_dec -> pf_cavlc_parse_8x8block [ 2 ] = ih264d_cavlc_parse_8x8block_top_available ; ps_dec -> pf_cavlc_parse_8x8block [ 3 ] = ih264d_cavlc_parse_8x8block_both_available ; ps_dec -> pf_fill_bs1 [ 0 ] [ 0 ] = ih264d_fill_bs1_16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 0 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 0 ] = ih264d_fill_bs1_16x16mb_bslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_bslice ; ps_dec -> pf_fill_bs_xtra_left_edge [ 0 ] = ih264d_fill_bs_xtra_left_edge_cur_frm ; ps_dec -> pf_fill_bs_xtra_left_edge [ 1 ] = ih264d_fill_bs_xtra_left_edge_cur_fld ; ih264d_init_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_dec -> u2_prv_frame_num = 0 ; ps_dec -> u1_top_bottom_decoded = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> s_cab_dec_env . cabac_table = gau4_ih264d_cabac_table ; ps_dec -> pu1_left_mv_ctxt_inc = ps_dec -> u1_left_mv_ctxt_inc_arr [ 0 ] ; ps_dec -> pi1_left_ref_idx_ctxt_inc = & ps_dec -> i1_left_ref_idx_ctx_inc_arr [ 0 ] [ 0 ] ; ps_dec -> pu1_left_yuv_dc_csbp = & ps_dec -> u1_yuv_dc_csbp_topmb ; ps_dec -> u1_flushfrm = 0 ; { ps_dec -> s_cab_dec_env . pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_bitstrm -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_cur_slice -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ( void * ) ps_dec ; } memset ( ps_dec -> disp_bufs , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( disp_buf_t ) ) ; memset ( ps_dec -> u4_disp_buf_mapping , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; memset ( ps_dec -> u4_disp_buf_to_be_freed , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; ih264d_init_arch ( ps_dec ) ; ih264d_init_function_ptr ( ps_dec ) ; ps_dec -> e_frm_out_mode = IVD_DISPLAY_FRAME_OUT ; ps_dec -> init_done = 1 ; }
","<S2SV_ModStart> , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )
",external@libavc/ecf6c7ce6d5a22d52160698aab44fc234c63291a,CVE-2016-3743,https://android.googlesource.com/platform/external/libavc/+/ecf6c7ce6d5a22d52160698aab44fc234c63291a,2016-07-11T01:59Z,1639,"<S2SV_ModStart> ; pocstruct_t * ps_prev_poc, * ps_cur_poc ; memset ( ( void * ) ps_cur_slice, 0, sizeof ( dec_slice_params_t ) ) ; ps_prev_poc = ps_dec -> ps_prev_poc ; ps_cur_poc = ps_dec -> ps_cur_poc",0
1646,CWE-125,"CWE-125 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; <S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug> markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }
","<S2SV_ModStart> , g -> allgc <S2SV_ModEnd> , g ->
",lua@lua/127e7a6c8942b362aa3c6627f44d660a4fb75312,CVE-2020-15889,https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312,2020-07-21T22:15Z,1646,"<S2SV_ModStart> survival, g -> old ) ; markold ( g, g -> allgc, g -> reallyold ) ; markold ( g, g -> finobj, g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L, g, & g -> allgc, g -> survival, g -> reallyold ) ; sweepgen ( L, g, psurvival, g -> finobjold ) ; g -> finobjold = * psurvival ; psurvival = sweepgen ( L, g, & g -> allgc, g -> survival, g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; sweepgen ( L, g, psurvival, g -> finobjrold ) ; g -> finobjrold = g -> finobjold ;",0
1651,CWE-20,"CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,1651,"<S2SV_ModStart> ), & _dh <S2SV_ModEnd> ) ; BUG_ON",1
1653,CWE-125,"CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]"" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } else ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , mldv2_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,1653,<S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data8 [ 0 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data12 [ 0 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data16 [ 1 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data12 [ 0 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & bp [ 26 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data12 [ 0 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data12 [ 1 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> icmp6_data12 [ 0 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & bp [ 26 ] ) ; <S2SV_ModStart> ] ) ; ND_TCHECK_16BITS ( & icp -> i,0
1664,CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; } } return - 1 ;
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,1664,<S2SV_ModStart> } } } <S2SV_null> <S2SV_null>,0
1666,CWE-125,"CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>"" , tok2str ( icmp6_opt_values , ""unknown"" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , ""%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s"" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? ""badlen"" : """" , bittok2str ( icmp6_opt_pi_flag_values , ""none"" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s"" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u%s"" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? ""bad<S2SV_blank>option<S2SV_blank>length"" : """" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,"" , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>addr:<S2SV_blank>%s"" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):"" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%ums"" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u"" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%u"" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref=%s"" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lifetime=%s"" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ; <S2SV_EndBug> return ; # undef ECHECK }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,1666,"<S2SV_ModStart> ( ndo, ""%s"", tok2str ( icmp6_opt_values, ""dnssl"", op -> nd_opt_mtu ) ) ; break ; case ND_OPT_ADV_INTERVAL : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo, cp, l ) ; break ; case ND_OPT_TLV_ADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo, cp + 2, l ) ; break ; case ND_OPT_RDNSSL : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo, cp + 2, l ) ; break ; case ND_OPT_TLV_ADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo, cp + 2, l ) ; break ; case ND_OPT_TLV_ADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo, cp + 2, l ) ;",0
1669,CWE-20,"CWE-20 static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; <S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug> str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }
","<S2SV_ModStart> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> , & error <S2SV_ModStart> if ( ret > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> , error ) <S2SV_ModStart> 1 ; } <S2SV_ModEnd> else if (
",dovecot@core/000030feb7a30f193197f1aab8a7b04a26b42735,CVE-2017-2669,https://github.com/dovecot/core/commit/000030feb7a30f193197f1aab8a7b04a26b42735,2018-06-21T13:29Z,1669,"<S2SV_ModStart> ) ) ; dict_lookup ( iter -> conn -> dict, iter -> pool, str_c ( path ), & key -> value, & error ) ; if ( ret > 0 ) { auth_request_log_error ( iter -> auth_request, AUTH_SUBSYS_DB, ""Failed <S2SV_blank> to <S2SV_blank> expand <S2SV_blank> key <S2SV_blank> %s: <S2SV_blank> %s"", key -> key -> key, error ) ; return - 1 ; } <S2SV_ModStart> 0 ) { dict_lookup ( iter -> conn -> dict, iter -> pool, str_c ( path ), & key -> value, & error ) ; if ( ret > 0 ) { auth_request_log_error ( iter -> auth_request, AUTH_SUBSYS_DB, ""Failed <S2SV_blank> to <S2SV_blank> lookup <S2SV_blank> key <S2SV_blank> %s: <S2SV_blank> %s"", key -> key -> key, error ) ; return - 1 ; } <S2SV_ModEnd> return - 1",0
1672,CWE-20,"CWE-20 void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send ( <S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }
","<S2SV_ModStart> ; stbbr_send ( ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>""
",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z,1672,"<S2SV_ModStart> ; stbbr_send ( ""<message <S2SV_blank> type=\'chat\' <S2SV_blank> to=\'stabber@localhost/profanity\' <S2SV_blank> from=\'stabber@localhost\'>"" <S2SV_ModEnd> ""<received <S2SV_blank> xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded <S2SV_blank> xmlns=\'urn:xmpp:forward:0\'>"" ""<message <S2SV_blank> id=\'prof_msg_7\' <S2SV_blank> xmlns=\'jabber:client\' <S2SV_blank> type=\'chat\' <S2SV_blank> lang=\'en\' <S2SV_blank> to=\'stabber@localhost/profanity\' <S2SV_blank> from=\'buddy1@localhost/mobile\'>""",1
1674,CWE-125,"CWE-125 static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <S2SV_StartBug> return tok ; <S2SV_EndBug> }
","<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1674,<S2SV_ModStart> = 0 ; # ifdef HAVE_PYMEM PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok -> buf == NULL ) return NULL ; # endif <S2SV_ModStart> = 0 ; # ifdef HAVE_PYMEM PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok -> fp == NULL ) { PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok -> nextprompt!= NULL ) { PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; } # else PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok -> prompt == NULL ) { PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok -> prompt == NULL ) { PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; },0
1681,CWE-125,"CWE-125 BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>TPDU<S2SV_blank>length<S2SV_blank>indicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>routing<S2SV_blank>token<S2SV_blank>or<S2SV_blank>cookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>negotiation<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%"" PRIu8 """" , type ) ; return FALSE ; } <S2SV_StartBug> nego_process_negotiation_request ( nego , s ) ; <S2SV_EndBug> } return tpkt_ensure_stream_consumed ( s , length ) ; }
","<S2SV_ModStart> FALSE ; } if ( ! <S2SV_ModStart> , s ) ) return FALSE
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1681,"<S2SV_ModStart> FALSE ; } if (! <S2SV_ModStart>, s ) ) return FALSE",1
1684,CWE-20,"CWE-20 uint16_t dm9000ReadPhyReg ( uint8_t address ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> usleep ( 5 ) ; <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,1684,"<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd>, 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ; while ( ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ; return ( dm9000ReadReg ( DM9000_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_EPDRL ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>",0
1685,CWE-787,"CWE-787 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z,1685,"<S2SV_ModStart> { if ( t2p -> tiff_datasize > max_striplength ) { TIFFError ( TIFF2PDF_MODULE, ""T2P_readwrite_pdf_image: <S2SV_blank> Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> samples <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", t2p -> tiff_datasize, ( int ) ( max_striplength ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } <S2SV_ModStart> { if ( t2p -> tiff_datasize > max_striplength ) { TIFFError ( TIFF2PDF_MODULE, ""T2P_readwrite_pdf_image: <S2SV_blank> Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> samples <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", ( int ) ( t2p -> tiff_datasize - max_striplength ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; }",0
1687,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,1687,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> BYTE a_val ; <S2SV_ModEnd> rw = ( <S2SV_ModStart> ; tempWidth = ROUND_UP_TO ( context -> width, 8 ) ; ccl = context -> ColorLossLevel ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; yplane = context -> priv -> PlaneBuffers [ 3 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; b_val = * src ++ ; r_val = * src ++ ; b_val = * src ++ ; a",0
1688,CWE-20,"CWE-20 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }
","<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z,1688,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int isofs_read_inode (,0
1692,CWE-20,"CWE-20 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; <S2SV_StartBug> msg . msg_name = ( struct sockaddr * ) & address ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_namelen = sizeof ( address ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> . msg_name = addr ? <S2SV_ModStart> ) & address : NULL <S2SV_ModStart> . msg_namelen = 0 <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,1692,"<S2SV_ModStart> = ubuf ; memset ( & address, 0, sizeof ( address ) ) ;",0
1697,CWE-20,"CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,1697,<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0,0
1705,CWE-20,"CWE-20 static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ; <S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ; <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> new -> d_name . len ) ; <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> goto out_unlock ; <S2SV_StartBug> } <S2SV_EndBug> err = - ESTALE ; <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> goto out_dput ; <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ; <S2SV_StartBug> out_unlock : <S2SV_EndBug> unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }
","<S2SV_ModStart> ; olddentry = lookup_one_len ( old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> . name , old_upperdir , old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> = PTR_ERR ( olddentry <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( IS_ERR ( olddentry <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto out_unlock ; <S2SV_ModEnd> err = - <S2SV_ModStart> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> newdentry ) ; out_dput_old : dput ( olddentry ) ;
",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z,1705,<S2SV_ModStart> ; if ( new -> d_inode && new -> d_inode -> i_uid == old -> d_inode -> i_uid ) { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid ) { err = - EPERM ; goto out ; } else { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid && new -> d_inode -> i_uid == old -> d_inode -> i_uid && new -> d_inode -> i_uid!= new -> d_inode -> i_uid ) { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid ) { err = - EPERM ; goto out ; } } else { if ( new -> d_inode -> i_uid == old -> d_inode -> i_uid && new -> d_inode -> i_uid!= old -> d_inode -> i_uid && new -> d_inode -> i_uid!= new -> d_inode -> i_uid ) { err = - EPER,0
