Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0,raw_predictions,correctly_predicted
2,CWE-401,"CWE-401 int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , ""Timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>WMI<S2SV_blank>command:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , ""WMI<S2SV_blank>failure<S2SV_blank>for:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; kfree_skb ( skb ) ; return ret ; }
","<S2SV_ModStart> op_mutex ) ; kfree_skb ( skb ) ;
",torvalds@linux/728c1e2a05e4b5fc52fab3421dce772a806612a2,CVE-2019-19074,https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2,2019-11-18T06:15Z,0,<S2SV_ModStart> ; return - EINVAL ; if (,0
4,CWE-189,"CWE-189 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen
",torvalds@linux/0e033e04c2678dbbe74a46b23fffb7bb918c288e,CVE-2013-4563,https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e,2013-11-20T13:19Z,1,<S2SV_ModStart> ; if ( unlikely (,0
7,CWE-416,"CWE-416 void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) { <S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }
","<S2SV_ModStart> writers , 0 ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc
",gpac@gpac/5aba27604d957e960d8069d85ccaf868f8a7b07a,CVE-2020-35980,https://github.com/gpac/gpac/commit/5aba27604d957e960d8069d85ccaf868f8a7b07a,2021-04-21T16:15Z,2,,0
10,CWE-119,"CWE-119 cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { <S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> -- item ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> return c ; }
","<S2SV_ModStart> c = array ? array -> child : 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) item -- , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> return c ;
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,3,<S2SV_ModStart>,0
13,CWE-400,"CWE-400 <S2SV_StartBug> void __perf_sw_event ( u32 event_id , u64 nr , int nmi , <S2SV_EndBug> struct pt_regs * regs , u64 addr ) { struct perf_sample_data data ; int rctx ; preempt_disable_notrace ( ) ; rctx = perf_swevent_get_recursion_context ( ) ; if ( rctx < 0 ) return ; perf_sample_data_init ( & data , addr ) ; <S2SV_StartBug> do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ; <S2SV_EndBug> perf_swevent_put_recursion_context ( rctx ) ; preempt_enable_notrace ( ) ; }
","<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct pt_regs * <S2SV_ModStart> , nr , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,4,"<S2SV_ModStart> perf_event * regs <S2SV_ModEnd>, void",0
14,CWE-119,"CWE-119 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> else <S2SV_EndBug> { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z,5,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> data ) { return 0 ; } <S2SV_ModStart> data ) { if (! buf ) { return - 1 ; } <S2SV_ModStart> - 1 ; },0
15,CWE-119,"CWE-119 <S2SV_StartBug> static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) { <S2SV_EndBug> <S2SV_StartBug> int step1 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step2 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step3 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; { <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int t0 , t1 , t2 , t3 ; <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ; <S2SV_StartBug> out [ 0 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 4 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 8 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 12 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ; <S2SV_StartBug> out [ 2 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 6 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 10 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 14 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ; <S2SV_StartBug> temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ; <S2SV_EndBug> step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ; <S2SV_StartBug> temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ; <S2SV_EndBug> temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ; <S2SV_StartBug> step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ; <S2SV_EndBug> step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ; <S2SV_StartBug> out [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 9 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ; <S2SV_StartBug> out [ 5 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 13 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ; <S2SV_StartBug> out [ 3 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 11 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ; <S2SV_StartBug> out [ 7 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 15 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> fdct16 ( const tran_low_t <S2SV_ModEnd> in [ 16 <S2SV_ModStart> 16 ] , tran_low_t <S2SV_ModEnd> out [ 16 <S2SV_ModStart> ] ) { tran_high_t <S2SV_ModEnd> step1 [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> step2 [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> step3 [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> input [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> temp1 , temp2 <S2SV_ModStart> ] ; { tran_high_t <S2SV_ModEnd> s0 , s1 <S2SV_ModStart> , s7 ; tran_high_t <S2SV_ModEnd> t0 , t1 <S2SV_ModStart> , t3 ; tran_high_t <S2SV_ModEnd> x0 , x1 <S2SV_ModStart> 0 ] = ( tran_low_t ) <S2SV_ModStart> 4 ] = ( tran_low_t ) <S2SV_ModStart> 8 ] = ( tran_low_t ) <S2SV_ModStart> 12 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] = ( tran_low_t ) <S2SV_ModStart> 6 ] = ( tran_low_t ) <S2SV_ModStart> 10 ] = ( tran_low_t ) <S2SV_ModStart> 14 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] * cospi_24_64 + <S2SV_ModEnd> step3 [ 5 <S2SV_ModStart> 2 ] * cospi_8_64 - <S2SV_ModEnd> step3 [ 5 <S2SV_ModStart> [ 3 ] + step2 [ 2 ] ; step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] + <S2SV_ModEnd> step2 [ 5 <S2SV_ModStart> 1 ] = ( tran_low_t ) <S2SV_ModStart> 9 ] = ( tran_low_t ) <S2SV_ModStart> 5 ] = ( tran_low_t ) <S2SV_ModStart> 13 ] = ( tran_low_t ) <S2SV_ModStart> 3 ] = ( tran_low_t ) <S2SV_ModStart> 11 ] = ( tran_low_t ) <S2SV_ModStart> 7 ] = ( tran_low_t ) <S2SV_ModStart> 15 ] = ( tran_low_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,6,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
18,CWE-787,"CWE-787 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
","<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
",torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe,CVE-2018-11506,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,2018-05-28T04:29Z,7,"<S2SV_ModStart> -> sense ; memset ( & cgc -> sense, 0, sizeof ( * sense ) <S2SV_ModEnd> ) ; if",0
19,CWE-119,"CWE-119 int CLASS parse_jpeg ( int offset ) { int len , save , hlen , mark ; fseek ( ifp , offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff || fgetc ( ifp ) != 0xd8 ) return 0 ; while ( fgetc ( ifp ) == 0xff && ( mark = fgetc ( ifp ) ) != 0xda ) { order = 0x4d4d ; len = get2 ( ) - 2 ; save = ftell ( ifp ) ; if ( mark == 0xc0 || mark == 0xc3 || mark == 0xc9 ) { fgetc ( ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; } order = get2 ( ) ; hlen = get4 ( ) ; <S2SV_StartBug> if ( get4 ( ) == 0x48454150 ) <S2SV_EndBug> { # ifdef LIBRAW_LIBRARY_BUILD <S2SV_StartBug> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <S2SV_EndBug> imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( save + hlen , len - hlen , 0 ) ; } if ( parse_tiff ( save + 6 ) ) apply_tiff ( ) ; fseek ( ifp , save + len , SEEK_SET ) ; } return 1 ; }
","<S2SV_ModStart> ) == 0x48454150 <S2SV_ModEnd> # ifdef LIBRAW_LIBRARY_BUILD <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD
",LibRaw@LibRaw/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,CVE-2017-6887,https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,2017-05-16T16:29Z,8,<S2SV_ModStart> ; if ( len < 0 ||,0
20,CWE-119,"CWE-119 <S2SV_StartBug> static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , <S2SV_EndBug> int partial_frame ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct loopfilter * const lf = & cm -> lf ; <S2SV_EndBug> const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; <S2SV_StartBug> int best_err ; <S2SV_EndBug> int filt_best ; <S2SV_StartBug> int filt_direction = 0 ; <S2SV_EndBug> int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ; int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ; <S2SV_StartBug> int ss_err [ MAX_LOOP_FILTER + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ; <S2SV_EndBug> vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ; best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ; filt_best = filt_mid ; ss_err [ filt_mid ] = best_err ; while ( filter_step > 0 ) { const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ; const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ; <S2SV_StartBug> int filt_err ; <S2SV_EndBug> int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; <S2SV_StartBug> if ( cpi -> twopass . section_intra_rating < 20 ) <S2SV_EndBug> <S2SV_StartBug> bias = bias * cpi -> twopass . section_intra_rating / 20 ; <S2SV_EndBug> if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ; if ( filt_direction <= 0 && filt_low != filt_mid ) { if ( ss_err [ filt_low ] < 0 ) { <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_low ] = filt_err ; <S2SV_EndBug> } else { filt_err = ss_err [ filt_low ] ; } if ( ( filt_err - bias ) < best_err ) { <S2SV_StartBug> if ( filt_err < best_err ) <S2SV_EndBug> best_err = filt_err ; filt_best = filt_low ; } } if ( filt_direction >= 0 && filt_high != filt_mid ) { if ( ss_err [ filt_high ] < 0 ) { <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_high ] = filt_err ; <S2SV_EndBug> } else { filt_err = ss_err [ filt_high ] ; } if ( filt_err < ( best_err - bias ) ) { <S2SV_StartBug> best_err = filt_err ; <S2SV_EndBug> filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step /= 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } <S2SV_StartBug> lf -> filter_level = filt_best ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> search_filter_level ( const <S2SV_ModStart> partial_frame ) { const <S2SV_ModStart> -> common ; const <S2SV_ModStart> ) ; int <S2SV_ModEnd> filt_direction = 0 <S2SV_ModStart> filt_direction = 0 ; int64_t best_err ; int filt_best <S2SV_ModStart> / 4 ; int64_t <S2SV_ModEnd> ss_err [ MAX_LOOP_FILTER <S2SV_ModStart> 1 ] ; memset <S2SV_ModEnd> ( ss_err , <S2SV_ModStart> min_filter_level ) ; int64_t <S2SV_ModEnd> bias = ( <S2SV_ModStart> filter_step ; if ( ( cpi -> oxcf . pass == 2 ) && <S2SV_ModStart> < 20 ) ) bias = ( <S2SV_ModEnd> bias * cpi <S2SV_ModStart> twopass . section_intra_rating ) <S2SV_ModStart> 0 ) { ss_err [ filt_low ] <S2SV_ModEnd> = try_filter_frame ( <S2SV_ModStart> partial_frame ) ; } if ( ( ss_err [ filt_low ] <S2SV_ModEnd> - bias ) <S2SV_ModStart> { if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] <S2SV_ModEnd> ; filt_best = <S2SV_ModStart> 0 ) { ss_err [ filt_high ] <S2SV_ModEnd> = try_filter_frame ( <S2SV_ModStart> partial_frame ) ; } if ( ss_err [ filt_high ] <S2SV_ModEnd> < ( best_err <S2SV_ModStart> { best_err = ss_err [ filt_high ] <S2SV_ModEnd> ; filt_best = <S2SV_ModStart> ; } } return <S2SV_ModEnd> filt_best ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,9,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
21,CWE-787,"CWE-787 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
","<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,10,,0
22,CWE-119,"CWE-119 <S2SV_StartBug> static void encode_mv_component ( vp9_writer * w , int comp , <S2SV_EndBug> const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ; <S2SV_StartBug> vp9_write ( w , sign , mvcomp -> sign ) ; <S2SV_EndBug> vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <S2SV_EndBug> } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp ) <S2SV_StartBug> vp9_write ( w , hp , <S2SV_EndBug> mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }
","<S2SV_ModStart> void encode_mv_component ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> 0 ) ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> ++ i ) vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> ( usehp ) vpx_write <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,11,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
25,CWE-20,"CWE-20 error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }
","<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,12,<S2SV_ModStart> == 16 ) { <S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> = COAP_SIZE_32 ; } <S2SV_ModStart> == 16 ) { <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> = COAP_32 ; } <S2SV_ModStart> = COAP_SIZE_32 ; } <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> = COAP_SIZE_32 ; },0
28,CWE-125,"CWE-125 static void l2tp_ppp_discon_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , <S2SV_StartBug> ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 5 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) dat ; if ( length < 5 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , ""Direction-#%u"" , EXTRACT_8BITS ( ptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; ptr ++ ; length -- ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,13,"<S2SV_ModStart> u_char * dat, u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ) ; return ; } if ( length < 4 ) { ND_PRINT ( ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ) ; return ; } if ( length < 4 ) { ND_PRINT ( ( ( ( ndo, "" <S2SV_blank> short"" ) ) ) ) ; return ; } <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null>",0
35,CWE-862,"CWE-862 <S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> if ( dest_keyring ) { key_get ( dest_keyring ) ; <S2SV_StartBug> } else { <S2SV_EndBug> switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <S2SV_StartBug> break ; <S2SV_EndBug> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } <S2SV_StartBug> } <S2SV_EndBug> * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct <S2SV_ModStart> * authkey ; int ret ; <S2SV_ModStart> } else { bool do_perm_check = true ; <S2SV_ModStart> ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING <S2SV_ModStart> ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> ) ; return 0
",torvalds@linux/4dca6ea1d9432052afb06baf2e3ae78188a4410b,CVE-2017-17807,https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b,2017-12-20T23:29Z,14,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> * dest_keyring_keyring_keyring_keyring_key_keyring ( dest_keyring, dest_keyring ) <S2SV_ModEnd> ) ; if ( dest_keyring_keyring <S2SV_ModStart> ) break ; if ( dest_keyring_keyring_keyring_key_key_key_keyring ) { if ( dest_key_key_key_key_keyring ( dest_keyring ) == NULL ) { if ( dest_keyring ( dest_keyring ) continue ; }",0
36,CWE-763,"CWE-763 static OM_uint32 init_ctx_new ( OM_uint32 * minor_status , spnego_gss_cred_id_t spcred , gss_ctx_id_t * ctx , send_token_flag * tokflag ) { OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ; <S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> if ( sc == NULL ) return GSS_S_FAILURE ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_INITIATE , & sc -> mech_set ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; sc -> internal_mech = & sc -> mech_set -> elements [ 0 ] ; if ( put_mech_set ( sc -> mech_set , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> ctx_handle = GSS_C_NO_CONTEXT ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; * tokflag = INIT_TOKEN_SEND ; ret = GSS_S_CONTINUE_NEEDED ; cleanup : release_spnego_ctx ( & sc ) ; return ret ; }
","<S2SV_ModStart> = create_spnego_ctx ( 1
",krb5@krb5/b51b33f2bc5d1497ddf5bd107f791c101695000d,CVE-2015-2695,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,2015-11-09T03:59Z,15,<S2SV_ModStart> = NULL ;,0
37,CWE-416,"CWE-416 static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
","<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out
",torvalds@linux/32c231164b762dddefa13af5a0101032c70b50ef,CVE-2016-10200,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,2017-03-07T21:59Z,16,<S2SV_ModStart> ; if ( addr_len < sizeof ( sk ) ) return - EINVAL ; if (,0
40,CWE-416,"CWE-416 char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; <S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
","<S2SV_ModStart> ( & t ) ; if ( tm == NULL ) return g_strdup ( ""???""
",irssi@irssi/5e26325317c72a04c1610ad952974e206384d291,CVE-2017-10966,https://github.com/irssi/irssi/commit/5e26325317c72a04c1610ad952974e206384d291,2017-07-07T14:29Z,17,,0
41,CWE-787,"CWE-787 static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; <S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
","<S2SV_ModStart> , password , length <S2SV_ModEnd> ) ; attr
",FreeRADIUS@pam_radius/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,CVE-2015-9542,https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,2020-02-24T15:15Z,18,,0
49,CWE-119,"CWE-119 enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , ""vu-"" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; <S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , ""org.freedesktop.machine1"" , ""/org/freedesktop/machine1"" , ""org.freedesktop.machine1.Manager"" , ""MapFromMachineUser"" , & error , & reply , ""su"" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , ""u"" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = buffer ; pwd -> pw_uid = mapped ; pwd -> pw_gid = 65534 ; pwd -> pw_gecos = buffer ; pwd -> pw_passwd = ( char * ) ""*"" ; pwd -> pw_dir = ( char * ) ""/"" ; pwd -> pw_shell = ( char * ) ""/sbin/nologin"" ; * errnop = 0 ; return NSS_STATUS_SUCCESS ; not_found : * errnop = 0 ; return NSS_STATUS_NOTFOUND ; fail : * errnop = - r ; return NSS_STATUS_UNAVAIL ; }
","<S2SV_ModStart> e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
",keszybz@systemd/cb31827d62066a04b02111df3052949fda4b6888,CVE-2015-7510,https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888,2017-09-25T21:29Z,19,<S2SV_ModStart> goto,0
52,CWE-264,"CWE-264 int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }
","<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z,20,"<S2SV_ModStart> ) ||! capable_uid_uidgid <S2SV_ModEnd> ( inode,",0
53,CWE-284,"CWE-284 static bool has_byte ( const eager_reader_t * reader ) { assert ( reader != NULL ) ; fd_set read_fds ; FD_ZERO ( & read_fds ) ; FD_SET ( reader -> bytes_available_fd , & read_fds ) ; struct timeval timeout ; timeout . tv_sec = 0 ; timeout . tv_usec = 0 ; <S2SV_StartBug> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <S2SV_EndBug> return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }
","<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> & timeout ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,21,"<S2SV_ModStart>, NULL, NULL )",0
55,CWE-119,"CWE-119 <S2SV_StartBug> static int detect_transition_to_still ( struct twopass_rc * twopass , <S2SV_EndBug> int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) { <S2SV_StartBug> int trans_to_still = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_interval > MIN_GF_INTERVAL && <S2SV_EndBug> loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) { int j ; <S2SV_StartBug> const FIRSTPASS_STATS * position = twopass -> stats_in ; <S2SV_EndBug> FIRSTPASS_STATS tmp_next_frame ; for ( j = 0 ; j < still_interval ; ++ j ) { <S2SV_StartBug> if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) <S2SV_EndBug> break ; <S2SV_StartBug> if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 ) <S2SV_EndBug> break ; } <S2SV_StartBug> reset_fpf_position ( twopass , position ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j == still_interval ) <S2SV_EndBug> trans_to_still = 1 ; } <S2SV_StartBug> return trans_to_still ; <S2SV_EndBug> }
","<S2SV_ModStart> int detect_transition_to_still ( VP9_COMP * cpi <S2SV_ModEnd> , int frame_interval <S2SV_ModStart> last_decay_rate ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( frame_interval > rc -> min_gf_interval <S2SV_ModEnd> && loop_decay_rate >= <S2SV_ModStart> int j ; <S2SV_ModEnd> for ( j <S2SV_ModStart> j ) { const FIRSTPASS_STATS * stats = & twopass -> stats_in [ j ] ; if ( stats >= twopass -> stats_in_end <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; if ( stats -> pcnt_inter - stats -> <S2SV_ModEnd> pcnt_motion < 0.999 <S2SV_ModStart> break ; } return <S2SV_ModEnd> j == still_interval <S2SV_ModStart> j == still_interval <S2SV_ModEnd> ; } return <S2SV_ModStart> ; } return 0 <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,22,<S2SV_ModStart> <S2SV_null>,0
57,CWE-000,"CWE-000 static int ext4_end_io_nolock ( ext4_io_end_t * io ) { struct inode * inode = io -> inode ; loff_t offset = io -> offset ; ssize_t size = io -> size ; int ret = 0 ; ext4_debug ( ""ext4_end_io_nolock:<S2SV_blank>io<S2SV_blank>0x%p<S2SV_blank>from<S2SV_blank>inode<S2SV_blank>%lu,list->next<S2SV_blank>0x%p,"" ""list->prev<S2SV_blank>0x%p\\n"" , io , inode -> i_ino , io -> list . next , io -> list . prev ) ; if ( list_empty ( & io -> list ) ) return ret ; if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ; <S2SV_StartBug> if ( offset + size <= i_size_read ( inode ) ) <S2SV_EndBug> ret = ext4_convert_unwritten_extents ( inode , offset , size ) ; if ( ret < 0 ) { printk ( KERN_EMERG ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>unwritten"" ""extents<S2SV_blank>to<S2SV_blank>written<S2SV_blank>extents,<S2SV_blank>error<S2SV_blank>is<S2SV_blank>%d"" ""<S2SV_blank>io<S2SV_blank>is<S2SV_blank>still<S2SV_blank>on<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>aio<S2SV_blank>dio<S2SV_blank>list\\n"" , __func__ , ret , inode -> i_ino ) ; return ret ; } io -> flag = 0 ; return ret ; }
","<S2SV_ModStart> return ret ; <S2SV_ModEnd> ret = ext4_convert_unwritten_extents
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,23,<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; ret =,0
59,CWE-269,"CWE-269 struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
","<S2SV_ModStart> { request_module ( ""crypto-%s"" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( ""crypto-%s-all"" <S2SV_ModEnd> , name )
",torvalds@linux/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,CVE-2013-7421,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,2015-03-02T11:59Z,24,"<S2SV_ModStart> ( name <S2SV_ModEnd>, ""%s"",",0
65,CWE-125,"CWE-125 static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; <S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , ""invalid<S2SV_blank>packet<S2SV_blank>line"" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
","<S2SV_ModStart> = GIT_PKT_NG ; if ( len < 3 ) goto out_err ; <S2SV_ModStart> += 3 ; len -= 3 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '<S2SV_blank>' , len <S2SV_ModStart> = '\\0' ; if ( len < 1 ) goto out_err ; <S2SV_ModStart> + 1 ; len -= 1 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '\\n' , len
",libgit2@libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,CVE-2018-15501,https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,2018-08-18T02:29Z,25,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ptr,0
72,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; <S2SV_StartBug> UINT16 length ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> RequestedProtocols ) ; WLog_DBG ( TAG , ""RDP_NEG_REQ:<S2SV_blank>RequestedProtocol:<S2SV_blank>0x%08"" PRIX32 """" , nego -> RequestedProtocols ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> ; UINT16 length ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,26,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> int length ; if (!,0
75,CWE-787,"CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }
","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z,27,<S2SV_ModStart> pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;,0
77,CWE-59,"CWE-59 static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }
","<S2SV_ModStart> mntent , path , rootfs
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z,28,"<S2SV_ModStart> path, path, NULL",0
82,CWE-416,"CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
",torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z,29,<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if (,0
83,CWE-190,"CWE-190 static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } } return ( result ) ; }
","<S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel & <S2SV_ModStart> pixel & ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel << <S2SV_ModStart> pixel << ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel | <S2SV_ModStart> pixel | ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel >> <S2SV_ModStart> pixel >> ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel ^ <S2SV_ModStart> pixel ^ ( ssize_t <S2SV_ModEnd> ) ( value
",ImageMagick@ImageMagick6/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5,CVE-2020-27764,https://github.com/ImageMagick/ImageMagick6/commit/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5,2020-12-03T17:15Z,30,<S2SV_ModStart> ; } break <S2SV_ModEnd> ; } break,0
84,CWE-20,"CWE-20 bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , ""LinkKeyType"" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , ""PinLength"" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , ""LinkKey"" , link_key , sizeof ( LINK_KEY ) ) ; <S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }
","<S2SV_ModStart> ) ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ; }
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,31,<S2SV_ModStart> ( FALSE ) &&,0
86,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , unsigned int usage ) { vpx_codec_err_t res ; <S2SV_StartBug> vpx_codec_enc_cfg_map_t * map ; <S2SV_EndBug> if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { res = VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <S2SV_EndBug> if ( map -> usage == ( int ) usage ) { * cfg = map -> cfg ; cfg -> g_usage = usage ; res = VPX_CODEC_OK ; break ; } } } return res ; }
","<S2SV_ModStart> vpx_codec_enc_cfg_map_t * map ; int i <S2SV_ModStart> ; for ( i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <S2SV_ModStart> enc . cfg_maps + i ; <S2SV_ModEnd> if ( map
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,32,<S2SV_ModStart> <S2SV_null> <S2SV_null> static,0
91,CWE-416,"CWE-416 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( po -> fanout ) <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
","<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
",torvalds@linux/d199fab63c11998a602205f7ee7ff7c05c97164b,CVE-2017-6346,https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b,2017-03-01T20:59Z,33,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct <S2SV_ModEnd> spin_lock ( struct <S2SV_ModStart> rollover ) ; mutex_lock_lock ( & fanout_mutex ) ; mutex_lock ( & fanout_lock ) ; goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> if (! rollover ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> sizeof ( rollover ) ) goto out <S2SV_ModEnd> ; if (,0
93,CWE-401,"CWE-401 static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }
","<S2SV_ModStart> ) ; } kfree ( table ) ;
",torvalds@linux/b4b814fec1a5a849383f7b3886b654a13abbda7d,CVE-2019-19058,https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d,2019-11-18T06:15Z,34,<S2SV_ModStart> ) ; },0
94,CWE-119,"CWE-119 <S2SV_StartBug> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <S2SV_EndBug> fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,35,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
95,CWE-416,"CWE-416 AV * dbd_st_fetch ( SV * sth , imp_sth_t * imp_sth ) { dTHX ; int num_fields , ChopBlanks , i , rc ; unsigned long * lengths ; AV * av ; int av_length , av_readonly ; MYSQL_ROW cols ; D_imp_dbh_from_sth ; MYSQL * svsock = imp_dbh -> pmysql ; imp_sth_fbh_t * fbh ; D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION MYSQL_BIND * buffer ; # endif MYSQL_FIELD * fields ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_fetch\\n"" ) ; # if MYSQL_ASYNC if ( imp_dbh -> async_query_in_flight ) { if ( mysql_db_async_result ( sth , & imp_sth -> result ) <= 0 ) { return Nullav ; } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( ! DBIc_ACTIVE ( imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""no<S2SV_blank>statement<S2SV_blank>executing\\n"" , NULL ) ; return Nullav ; } if ( imp_sth -> fetch_done ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>but<S2SV_blank>fetch<S2SV_blank>already<S2SV_blank>done"" , NULL ) ; return Nullav ; } if ( ! imp_sth -> done_desc ) { if ( ! dbd_describe ( sth , imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""Error<S2SV_blank>while<S2SV_blank>describe<S2SV_blank>result<S2SV_blank>set."" , NULL ) ; return Nullav ; } } } # endif ChopBlanks = DBIc_is ( imp_sth , DBIcf_ChopBlanks ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>chopblanks<S2SV_blank>%d\\n"" , sth , ChopBlanks ) ; if ( ! imp_sth -> result ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>without<S2SV_blank>execute()"" , NULL ) ; return Nullav ; } imp_dbh -> pmysql -> net . last_errno = 0 ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>calling<S2SV_blank>mysql_fetch\\n"" ) ; if ( ( rc = mysql_stmt_fetch ( imp_sth -> stmt ) ) ) { if ( rc == 1 ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; # if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 if ( rc == MYSQL_DATA_TRUNCATED ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>data<S2SV_blank>truncated\\n"" ) ; goto process ; } # endif if ( rc == MYSQL_NO_DATA ) { imp_sth -> row_num = mysql_stmt_affected_rows ( imp_sth -> stmt ) ; imp_sth -> fetch_done = 1 ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>no<S2SV_blank>data\\n"" ) ; } dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } process : imp_sth -> currow ++ ; av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; num_fields = mysql_stmt_field_count ( imp_sth -> stmt ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>called<S2SV_blank>mysql_fetch,<S2SV_blank>rc<S2SV_blank>%d<S2SV_blank>num_fields<S2SV_blank>%d\\n"" , rc , num_fields ) ; for ( buffer = imp_sth -> buffer , fbh = imp_sth -> fbh , i = 0 ; i < num_fields ; i ++ , fbh ++ , buffer ++ ) { SV * sv = AvARRAY ( av ) [ i ] ; STRLEN len ; if ( fbh -> is_null ) ( void ) SvOK_off ( sv ) ; else { if ( fbh -> length > buffer -> buffer_length || fbh -> error ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tRefetch<S2SV_blank>BLOB/TEXT<S2SV_blank>column:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%lu,<S2SV_blank>error:<S2SV_blank>%d\\n"" , i , fbh -> length , fbh -> error ) ; Renew ( fbh -> data , fbh -> length , char ) ; buffer -> buffer_length = fbh -> length ; <S2SV_StartBug> buffer -> buffer = ( char * ) fbh -> data ; <S2SV_EndBug> if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tbefore<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } if ( mysql_stmt_fetch_column ( imp_sth -> stmt , buffer , i , 0 ) ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tafter<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } } switch ( buffer -> buffer_type ) { case MYSQL_TYPE_DOUBLE : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>double<S2SV_blank>data<S2SV_blank>%f\\n"" , fbh -> ddata ) ; sv_setnv ( sv , fbh -> ddata ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>int<S2SV_blank>data<S2SV_blank>%"" IVdf "",<S2SV_blank>unsigned?<S2SV_blank>%d\\n"" , fbh -> ldata , buffer -> is_unsigned ) ; if ( buffer -> is_unsigned ) sv_setuv ( sv , fbh -> ldata ) ; else sv_setiv ( sv , fbh -> ldata ) ; break ; case MYSQL_TYPE_BIT : sv_setpvn ( sv , fbh -> data , fbh -> length ) ; break ; default : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tERROR<S2SV_blank>IN<S2SV_blank>st_fetch_string"" ) ; len = fbh -> length ; if ( ChopBlanks ) { if ( fbh -> charsetnr != 63 ) while ( len && fbh -> data [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , fbh -> data , len ) ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fbh -> charsetnr != 63 ) # else if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && ! ( fbh -> flags & BINARY_FLAG ) ) # endif sv_utf8_decode ( sv ) ; # endif break ; } } } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; } else { # endif imp_sth -> currow ++ ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>result<S2SV_blank>set<S2SV_blank>details\\n"" ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\timp_sth->result=%p\\n"" , imp_sth -> result ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_fields=%u\\n"" , mysql_num_fields ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_rows=%llu\\n"" , mysql_num_rows ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_affected_rows=%llu\\n"" , mysql_affected_rows ( imp_dbh -> pmysql ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>currow=<S2SV_blank>%d\\n"" , sth , imp_sth -> currow ) ; } if ( ! ( cols = mysql_fetch_row ( imp_sth -> result ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch,<S2SV_blank>no<S2SV_blank>more<S2SV_blank>rows<S2SV_blank>to<S2SV_blank>fetch"" ) ; } if ( mysql_errno ( imp_dbh -> pmysql ) ) do_error ( sth , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; # if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION if ( ! mysql_more_results ( svsock ) ) # endif dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } num_fields = mysql_num_fields ( imp_sth -> result ) ; fields = mysql_fetch_fields ( imp_sth -> result ) ; lengths = mysql_fetch_lengths ( imp_sth -> result ) ; if ( ( av = DBIc_FIELDS_AV ( imp_sth ) ) != Nullav ) { av_length = av_len ( av ) + 1 ; if ( av_length != num_fields ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>size<S2SV_blank>of<S2SV_blank>results<S2SV_blank>array(%d)<S2SV_blank>!=<S2SV_blank>num_fields(%d)\\n"" , av_length , num_fields ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>result<S2SV_blank>fields(%d)\\n"" , DBIc_NUM_FIELDS ( imp_sth ) ) ; av_readonly = SvREADONLY ( av ) ; if ( av_readonly ) SvREADONLY_off ( av ) ; while ( av_length < num_fields ) { av_store ( av , av_length ++ , newSV ( 0 ) ) ; } while ( av_length > num_fields ) { SvREFCNT_dec ( av_pop ( av ) ) ; av_length -- ; } if ( av_readonly ) SvREADONLY_on ( av ) ; } } av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; for ( i = 0 ; i < num_fields ; ++ i ) { char * col = cols [ i ] ; SV * sv = AvARRAY ( av ) [ i ] ; if ( col ) { STRLEN len = lengths [ i ] ; if ( ChopBlanks ) { while ( len && col [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , col , len ) ; switch ( mysql_to_perl_type ( fields [ i ] . type ) ) { case MYSQL_TYPE_DOUBLE : ( void ) SvNV ( sv ) ; SvNOK_only ( sv ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( fields [ i ] . flags & UNSIGNED_FLAG ) { ( void ) SvUV ( sv ) ; SvIOK_only_UV ( sv ) ; } else { ( void ) SvIV ( sv ) ; SvIOK_only ( sv ) ; } break ; # if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION case MYSQL_TYPE_BIT : break ; # endif default : # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fields [ i ] . charsetnr != 63 ) sv_utf8_decode ( sv ) ; # endif break ; } } else ( void ) SvOK_off ( sv ) ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION } # endif }
","<S2SV_ModStart> ; buffer -> buffer = ( char * ) fbh -> data ; imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ; imp_sth -> stmt -> bind [ i ] .
",perl5-dbi@DBD-mysql/3619c170461a3107a258d1fd2d00ed4832adb1b1,CVE-2016-1251,https://github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1,2016-11-29T20:59Z,36,<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY (,0
96,CWE-20,"CWE-20 error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> enc28j60WriteBuffer ( interface , buffer , offset ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,37,"<S2SV_ModStart> ( interface, ENC28J60_ESTAT ) { <S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd>, buffer ) <S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd> ) ; }",0
97,CWE-125,"CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> value = ast2obj_int ( o -> lineno ) ; <S2SV_EndBug> if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value =
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,38,<S2SV_ModStart> o ) ; Py_RETURN_NONE <S2SV_ModEnd> ; } switch,0
98,CWE-22,"CWE-22 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
",yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z,39,<S2SV_ModStart> ) ) { <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> ) ) ; } else { <S2SV_ModEnd> if (!,0
102,CWE-119,"CWE-119 void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , <S2SV_StartBug> int flag ) <S2SV_EndBug> { double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ; int ppl = ( int ) ( level + .5 ) ; <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> unsigned char * limits = cm -> pp_limits_buffer ; ; <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> ( void ) post ; ( void ) low_var_thresh ; ( void ) flag ; <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> for ( mbr = 0 ; mbr < mb_rows ; mbr ++ ) { vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ; <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> , int flag , int uvfilter ) { int mbr ; <S2SV_ModEnd> double level = <S2SV_ModStart> int mb_rows = cm -> mb_rows <S2SV_ModEnd> ; int mb_cols <S2SV_ModStart> int mb_cols = cm -> mb_cols <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> pp_limits_buffer ; ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ) flag ; memset <S2SV_ModEnd> ( limits , <S2SV_ModStart> 16 ) ; if ( uvfilter == 1 ) { <S2SV_ModStart> , limits , 8 ) ; } <S2SV_ModEnd> } } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,40,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
103,CWE-264,"CWE-264 static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) { <S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }
","<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;
",torvalds@linux/2145e15e0557a01b9195d1c7199a1b92cb9be81f,CVE-2014-1738,https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f,2014-05-11T21:55Z,41,<S2SV_ModStart> * cmd = NULL <S2SV_ModEnd> ; cmd,0
105,CWE-19,"CWE-19 static void <S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> int error ; <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> if ( ! ce ) { ea_bdebug ( bh , ""out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ; } <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> if ( error ) { <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> } } else { ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ; <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ext4_xattr_cache_insert ( struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ext4_mb_cache , GFP_NOFS , hash , <S2SV_ModEnd> bh -> b_blocknr <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> - EBUSY ) <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> ""already<S2SV_blank>in<S2SV_blank>cache"" ) ; } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> hash ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z,42,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct mb2SV_null> <S2SV_ModEnd> struct mb2SV_cache_cache_cache_cache_entry ( struct <S2SV_ModStart> bh ) ; <S2SV_ModEnd> struct mb2_cache_cache_cache_cache_cache_cache_cache_cache ( bh <S2SV_ModStart> bh ) ; <S2SV_ModEnd> error = mb2SV_null>,0
106,CWE-78,"CWE-78 R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s\\r\\n"" ""Content-Length:<S2SV_blank>%i\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; <S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z,43,<S2SV_ModStart> 1 ) ; return NULL ;,0
109,CWE-362,"CWE-362 <S2SV_StartBug> int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> unsigned char __user * data , int optlen ) { <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> if ( ! opt ) return - ENOMEM ; <S2SV_StartBug> if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) { <S2SV_EndBug> kfree ( opt ) ; return - EFAULT ; } return ip_options_get_finish ( net , optp , opt , optlen ) ; }
","<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,44,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct ip_options_options_options ( struct ip_rcu <S2SV_ModEnd> * opt, <S2SV_ModStart> * opt, & opt, 0 <S2SV_ModEnd> ) ; if",0
111,CWE-125,"CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,45,"<S2SV_ModStart> ( ndo, ""%s"", rpl_tstr <S2SV_ModEnd> ) ) ;",1
115,CWE-20,"CWE-20 static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) <S2SV_StartBug> { <S2SV_EndBug> errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) { <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }
","<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
",vim@vim/d0b5138ba4bccff8a744c99836041ef6322ed39a,CVE-2016-1248,https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a,2016-11-23T15:59Z,46,,0
116,CWE-285,"CWE-285 int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : kfree ( value ) ; out : return ret ; }
","<S2SV_ModStart> { ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ; } break
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z,47,"<S2SV_ModStart> { ret = posix_acl_mode ( inode <S2SV_ModEnd>, & acl",0
121,CWE-190,"CWE-190 static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; <S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug> ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( size > 0 ) { if ( size - 1 > LONG_MAX ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == EOF || jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) < 0 ) { goto error ; } } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }
","<S2SV_ModStart> size_t size ; JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n"" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> tly , height , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> if ( ! jas_safe_size_mul3 <S2SV_ModEnd> ( cmpt -> <S2SV_ModStart> cmpt -> height_ <S2SV_ModEnd> , cmpt ->
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,48,<S2SV_ModStart> size ) { jas_uchar <S2SV_ModEnd> jas_stream_t,0
126,CWE-000,"CWE-000 void * getHTTPResponse ( int s , int * size ) { char buf [ 2048 ] ; int n ; int endofheaders = 0 ; int chunked = 0 ; int content_length = - 1 ; unsigned int chunksize = 0 ; unsigned int bytestocopy = 0 ; char * header_buf ; unsigned int header_buf_len = 2048 ; unsigned int header_buf_used = 0 ; char * content_buf ; unsigned int content_buf_len = 2048 ; unsigned int content_buf_used = 0 ; char chunksize_buf [ 32 ] ; unsigned int chunksize_buf_index ; header_buf = malloc ( header_buf_len ) ; content_buf = malloc ( content_buf_len ) ; chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; while ( ( n = receivedata ( s , buf , 2048 , 5000 , NULL ) ) > 0 ) { if ( endofheaders == 0 ) { int i ; int linestart = 0 ; int colon = 0 ; int valuestart = 0 ; if ( header_buf_used + n > header_buf_len ) { header_buf = realloc ( header_buf , header_buf_used + n ) ; header_buf_len = header_buf_used + n ; } memcpy ( header_buf + header_buf_used , buf , n ) ; header_buf_used += n ; i = 0 ; while ( i < ( ( int ) header_buf_used - 1 ) && ( endofheaders == 0 ) ) { if ( header_buf [ i ] == '\\r' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\r' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } } } else if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } i ++ ; } if ( endofheaders == 0 ) continue ; for ( i = 0 ; i < endofheaders - 1 ; i ++ ) { if ( colon <= linestart && header_buf [ i ] == ':' ) { colon = i ; while ( i < ( endofheaders - 1 ) && ( header_buf [ i + 1 ] == '<S2SV_blank>' || header_buf [ i + 1 ] == '\\t' ) ) i ++ ; valuestart = i + 1 ; } else if ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) { if ( colon > linestart && valuestart > colon ) { # ifdef DEBUG printf ( ""header=\'%.*s\',<S2SV_blank>value=\'%.*s\'\\n"" , colon - linestart , header_buf + linestart , i - valuestart , header_buf + valuestart ) ; # endif if ( 0 == strncasecmp ( header_buf + linestart , ""content-length"" , colon - linestart ) ) { content_length = atoi ( header_buf + valuestart ) ; # ifdef DEBUG printf ( ""Content-Length:<S2SV_blank>%d\\n"" , content_length ) ; # endif } else if ( 0 == strncasecmp ( header_buf + linestart , ""transfer-encoding"" , colon - linestart ) && 0 == strncasecmp ( header_buf + valuestart , ""chunked"" , 7 ) ) { # ifdef DEBUG printf ( ""chunked<S2SV_blank>transfer-encoding!\\n"" ) ; # endif chunked = 1 ; } } <S2SV_StartBug> while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) <S2SV_EndBug> i ++ ; linestart = i ; colon = linestart ; valuestart = 0 ; } } n = header_buf_used - endofheaders ; memcpy ( buf , header_buf + endofheaders , n ) ; } if ( endofheaders ) { if ( chunked ) { int i = 0 ; while ( i < n ) { if ( chunksize == 0 ) { if ( chunksize_buf_index == 0 ) { if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) i ++ ; } while ( i < n && isxdigit ( buf [ i ] ) && chunksize_buf_index < ( sizeof ( chunksize_buf ) - 1 ) ) { chunksize_buf [ chunksize_buf_index ++ ] = buf [ i ] ; chunksize_buf [ chunksize_buf_index ] = '\\0' ; i ++ ; } while ( i < n && buf [ i ] != '\\r' && buf [ i ] != '\\n' ) i ++ ; if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) { unsigned int j ; for ( j = 0 ; j < chunksize_buf_index ; j ++ ) { if ( chunksize_buf [ j ] >= '0' && chunksize_buf [ j ] <= '9' ) chunksize = ( chunksize << 4 ) + ( chunksize_buf [ j ] - '0' ) ; else chunksize = ( chunksize << 4 ) + ( ( chunksize_buf [ j ] | 32 ) - 'a' + 10 ) ; } chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; i ++ ; } else { continue ; } # ifdef DEBUG printf ( ""chunksize<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(%x)\\n"" , chunksize , chunksize ) ; # endif if ( chunksize == 0 ) { # ifdef DEBUG printf ( ""end<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>%d\\n"" , i , n ) ; # endif goto end_of_stream ; } } bytestocopy = ( ( int ) chunksize < ( n - i ) ) ? chunksize : ( unsigned int ) ( n - i ) ; if ( ( content_buf_used + bytestocopy ) > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + bytestocopy ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + bytestocopy ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf + i , bytestocopy ) ; content_buf_used += bytestocopy ; i += bytestocopy ; chunksize -= bytestocopy ; } } else { if ( content_length > 0 && ( int ) ( content_buf_used + n ) > content_length ) { n = content_length - content_buf_used ; } if ( content_buf_used + n > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + n ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + n ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf , n ) ; content_buf_used += n ; } } if ( content_length > 0 && ( int ) content_buf_used >= content_length ) { # ifdef DEBUG printf ( ""End<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content\\n"" ) ; # endif break ; } } end_of_stream : free ( header_buf ) ; header_buf = NULL ; * size = content_buf_used ; if ( content_buf_used == 0 ) { free ( content_buf ) ; content_buf = NULL ; } return content_buf ; }
","<S2SV_ModStart> } while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ] == '\\n' )
",miniupnp@miniupnp/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9,CVE-2014-3985,https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9,2014-09-11T18:55Z,49,,0
128,CWE-310,"CWE-310 int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || <S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> flags &= ~ FLAG_LAST_MATCHED ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) goto long_tag_not_supported ; if ( op & ASN1_OP_MATCH__ANY ) { pr_debug ( ""-<S2SV_blank>any<S2SV_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & FLAG_CONS ; tmp = optag ^ tag ; tmp &= ~ ( optag & ASN1_CONS_BIT ) ; pr_debug ( ""-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & ASN1_OP_MATCH__SKIP ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= FLAG_MATCHED ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) goto indefinite_len_primitive ; flags |= FLAG_INDEFINITE_LENGTH ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & FLAG_CONS ) { if ( unlikely ( csp >= NR_CONS_STACK ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n"" , tag , len , flags & FLAG_CONS ? ""<S2SV_blank>CONS"" : """" ) ; tdp = dp ; } switch ( op ) { case ASN1_OP_MATCH_ANY_ACT : case ASN1_OP_COND_MATCH_ANY_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH_ACT : case ASN1_OP_MATCH_ACT_OR_SKIP : case ASN1_OP_COND_MATCH_ACT_OR_SKIP : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH : case ASN1_OP_MATCH_OR_SKIP : case ASN1_OP_MATCH_ANY : case ASN1_OP_COND_MATCH_OR_SKIP : case ASN1_OP_COND_MATCH_ANY : skip_data : if ( ! ( flags & FLAG_CONS ) ) { if ( flags & FLAG_INDEFINITE_LENGTH ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MATCH_JUMP : case ASN1_OP_MATCH_JUMP_OR_SKIP : case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : pr_debug ( ""-<S2SV_blank>MATCH_JUMP\\n"" ) ; if ( unlikely ( jsp == NR_JUMP_STACK ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case ASN1_OP_COND_FAIL : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_COMPLETE : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n"" , jsp , csp ) ; return - EBADMSG ; } return 0 ; case ASN1_OP_END_SET : case ASN1_OP_END_SET_ACT : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; case ASN1_OP_END_SEQ : case ASN1_OP_END_SET_OF : case ASN1_OP_END_SEQ_OF : case ASN1_OP_END_SEQ_ACT : case ASN1_OP_END_SET_OF_ACT : case ASN1_OP_END_SEQ_OF_ACT : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & ASN1_OP_END__OF ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & ASN1_OP_END__OF ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & ASN1_OP_END__ACT ) { unsigned char act ; if ( op & ASN1_OP_END__OF ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MAYBE_ACT : if ( ! ( flags & FLAG_LAST_MATCHED ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case ASN1_OP_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_RETURN : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; goto next_op ; default : break ; } pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n"" , op , pc ) ; return - EBADMSG ; data_overrun_error : errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""Machine<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""Cons<S2SV_blank>length<S2SV_blank>error"" ; goto error ; missing_eoc : errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; length_too_long : errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""Unexpected<S2SV_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported"" ; error : pr_debug ( ""\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - EBADMSG ; }
","<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
",torvalds@linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,CVE-2016-2053,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,2016-05-02T10:59Z,50,<S2SV_ModStart>,0
136,CWE-189,"CWE-189 static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , <S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> { <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> uint32_t attrlen , bitmap [ 3 ] = { 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ; <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ; <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) { <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ; <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> } else status = - EOPNOTSUPP ; out : return status ; }
","<S2SV_ModStart> * req , struct nfs_getaclres * res <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> __be32 * savep , * bm_p <S2SV_ModStart> int status ; res -> <S2SV_ModEnd> acl_len = 0 <S2SV_ModStart> ) goto out ; bm_p = xdr -> p <S2SV_ModStart> u32 recvd ; xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> iov -> iov_base ; attrlen += res -> acl_data_offset <S2SV_ModStart> recvd ) { if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> , attrlen , <S2SV_ModStart> attrlen ) ; res -> <S2SV_ModEnd> acl_len = attrlen
",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z,51,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
139,CWE-189,"CWE-189 static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
","<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
",torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z,52,<S2SV_ModStart> -> tv_rem ; u32 <S2SV_ModEnd> rem ; u64,0
142,CWE-000,"CWE-000 static int makeDirDirective ( MaState * state , cchar * key , cchar * value ) { MprPath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! maTokenize ( state , value , ""%S<S2SV_blank>?*"" , & auth , & dirs ) ) { return MPR_ERR_BAD_SYNTAX ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) { <S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { uid = HTTP -> uid ; } else { uid = userToID ( owner ) ; } } <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug> if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { gid = HTTP -> gid ; } else { gid = groupToID ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , NULL ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpMakePath ( state -> route , state -> configDir , dir ) ; if ( mprGetPathInfo ( path , & info ) == 0 && info . isDir ) { continue ; } if ( mprMakeDir ( path , mode , uid , gid , 1 ) < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }
","<S2SV_ModStart> { owner = ssplit <S2SV_ModEnd> ( auth , <S2SV_ModStart> } group = ssplit <S2SV_ModEnd> ( tok ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,53,<S2SV_ModStart> ; if ( ( <S2SV_ModEnd> == 0 ) {,0
147,CWE-119,"CWE-119 void * vpx_memalign ( size_t align , size_t size ) { void * addr , * x = NULL ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> int number_aau ; if ( vpx_mm_create_heap_memory ( ) < 0 ) { _P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\n"" ) ; ) } number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ; addr = hmm_alloc ( & hmm_d , number_aau ) ; # else addr = VPX_MALLOC_L ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( addr ) { x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ; ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ; } return x ; }
","<S2SV_ModStart> = NULL ; addr = malloc <S2SV_ModEnd> ( size + <S2SV_ModStart> ADDRESS_STORAGE_SIZE ) ; <S2SV_ModEnd> if ( addr
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,54,<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( addr,0
148,CWE-20,"CWE-20 static int parse_exports_table ( long long * table_start ) { int res ; <S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>export<S2SV_blank>index<S2SV_blank>table\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
","<S2SV_ModStart> = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> ; long long * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> ; res = <S2SV_ModStart> . lookup_table_start , length , <S2SV_ModEnd> export_index_table ) ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z,55,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
152,CWE-611,"CWE-611 static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) { directory_config * dcfg = ( directory_config * ) _dcfg ; if ( dcfg == NULL ) return NULL ; if ( strcasecmp ( p1 , ""on"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_ENABLED ; dcfg -> hash_enforcement = HASH_ENABLED ; } else if ( strcasecmp ( p1 , ""off"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_DISABLED ; dcfg -> hash_enforcement = HASH_DISABLED ; } <S2SV_StartBug> else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" <S2SV_ModEnd> , p1 )
",SpiderLabs@ModSecurity/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,CVE-2013-1915,https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,2013-04-25T23:55Z,56,<S2SV_ModStart> ; return NULL ; } if (,0
153,CWE-416,"CWE-416 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,57,<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ;,0
154,CWE-119,"CWE-119 static int loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) { uint32 i ; float xres = 0.0 , yres = 0.0 ; <S2SV_StartBug> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; <S2SV_EndBug> uint16 bps = 0 , spp = 0 , res_unit = 0 ; uint16 orientation = 0 ; uint16 input_compression = 0 , input_photometric = 0 ; uint16 subsampling_horiz , subsampling_vert ; uint32 width = 0 , length = 0 ; uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; uint32 tw = 0 , tl = 0 ; uint32 tile_rowsize = 0 ; unsigned char * read_buff = NULL ; unsigned char * new_buff = NULL ; int readunit = 0 ; static uint32 prev_readsize = 0 ; TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) TIFFError ( ""loadImage"" , ""Image<S2SV_blank>lacks<S2SV_blank>Photometric<S2SV_blank>interpreation<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>width<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>length<S2SV_blank>tag"" ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_RESOLUTIONUNIT , & res_unit ) ) res_unit = RESUNIT_INCH ; if ( ! TIFFGetField ( in , TIFFTAG_COMPRESSION , & input_compression ) ) input_compression = COMPRESSION_NONE ; # ifdef DEBUG2 char compressionid [ 16 ] ; switch ( input_compression ) { case COMPRESSION_NONE : strcpy ( compressionid , ""None/dump"" ) ; break ; case COMPRESSION_CCITTRLE : strcpy ( compressionid , ""Huffman<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTFAX3 : strcpy ( compressionid , ""Group3<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_CCITTFAX4 : strcpy ( compressionid , ""Group4<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_LZW : strcpy ( compressionid , ""LZW"" ) ; break ; case COMPRESSION_OJPEG : strcpy ( compressionid , ""Old<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_JPEG : strcpy ( compressionid , ""New<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_NEXT : strcpy ( compressionid , ""Next<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTRLEW : strcpy ( compressionid , ""CITTRLEW"" ) ; break ; case COMPRESSION_PACKBITS : strcpy ( compressionid , ""Mac<S2SV_blank>Packbits"" ) ; break ; case COMPRESSION_THUNDERSCAN : strcpy ( compressionid , ""Thunderscan"" ) ; break ; case COMPRESSION_IT8CTPAD : strcpy ( compressionid , ""IT8<S2SV_blank>padded"" ) ; break ; case COMPRESSION_IT8LW : strcpy ( compressionid , ""IT8<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_IT8MP : strcpy ( compressionid , ""IT8<S2SV_blank>mono"" ) ; break ; case COMPRESSION_IT8BL : strcpy ( compressionid , ""IT8<S2SV_blank>lineart"" ) ; break ; case COMPRESSION_PIXARFILM : strcpy ( compressionid , ""Pixar<S2SV_blank>10<S2SV_blank>bit"" ) ; break ; case COMPRESSION_PIXARLOG : strcpy ( compressionid , ""Pixar<S2SV_blank>11bit"" ) ; break ; case COMPRESSION_DEFLATE : strcpy ( compressionid , ""Deflate"" ) ; break ; case COMPRESSION_ADOBE_DEFLATE : strcpy ( compressionid , ""Adobe<S2SV_blank>deflate"" ) ; break ; default : strcpy ( compressionid , ""None/unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>compression<S2SV_blank>%s"" , compressionid ) ; # endif scanlinesize = TIFFScanlineSize ( in ) ; image -> bps = bps ; image -> spp = spp ; image -> planar = planar ; image -> width = width ; image -> length = length ; image -> xres = xres ; image -> yres = yres ; image -> res_unit = res_unit ; image -> compression = input_compression ; image -> photometric = input_photometric ; # ifdef DEBUG2 char photometricid [ 12 ] ; switch ( input_photometric ) { case PHOTOMETRIC_MINISWHITE : strcpy ( photometricid , ""MinIsWhite"" ) ; break ; case PHOTOMETRIC_MINISBLACK : strcpy ( photometricid , ""MinIsBlack"" ) ; break ; case PHOTOMETRIC_RGB : strcpy ( photometricid , ""RGB"" ) ; break ; case PHOTOMETRIC_PALETTE : strcpy ( photometricid , ""Palette"" ) ; break ; case PHOTOMETRIC_MASK : strcpy ( photometricid , ""Mask"" ) ; break ; case PHOTOMETRIC_SEPARATED : strcpy ( photometricid , ""Separated"" ) ; break ; case PHOTOMETRIC_YCBCR : strcpy ( photometricid , ""YCBCR"" ) ; break ; case PHOTOMETRIC_CIELAB : strcpy ( photometricid , ""CIELab"" ) ; break ; case PHOTOMETRIC_ICCLAB : strcpy ( photometricid , ""ICCLab"" ) ; break ; case PHOTOMETRIC_ITULAB : strcpy ( photometricid , ""ITULab"" ) ; break ; case PHOTOMETRIC_LOGL : strcpy ( photometricid , ""LogL"" ) ; break ; case PHOTOMETRIC_LOGLUV : strcpy ( photometricid , ""LOGLuv"" ) ; break ; default : strcpy ( photometricid , ""Unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>photometric<S2SV_blank>interpretation<S2SV_blank>%s"" , photometricid ) ; # endif image -> orientation = orientation ; switch ( orientation ) { case 0 : case ORIENTATION_TOPLEFT : image -> adjustments = 0 ; break ; case ORIENTATION_TOPRIGHT : image -> adjustments = MIRROR_HORIZ ; break ; case ORIENTATION_BOTRIGHT : image -> adjustments = ROTATECW_180 ; break ; case ORIENTATION_BOTLEFT : image -> adjustments = MIRROR_VERT ; break ; case ORIENTATION_LEFTTOP : image -> adjustments = MIRROR_VERT | ROTATECW_90 ; break ; case ORIENTATION_RIGHTTOP : image -> adjustments = ROTATECW_90 ; break ; case ORIENTATION_RIGHTBOT : image -> adjustments = MIRROR_VERT | ROTATECW_270 ; break ; case ORIENTATION_LEFTBOT : image -> adjustments = ROTATECW_270 ; break ; default : image -> adjustments = 0 ; image -> orientation = ORIENTATION_TOPLEFT ; } if ( ( bps == 0 ) || ( spp == 0 ) ) { TIFFError ( ""loadImage"" , ""Invalid<S2SV_blank>samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>(%d)<S2SV_blank>or<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>(%d)"" , spp , bps ) ; return ( - 1 ) ; } if ( TIFFIsTiled ( in ) ) { readunit = TILE ; tlsize = TIFFTileSize ( in ) ; ntiles = TIFFNumberOfTiles ( in ) ; TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; tile_rowsize = TIFFTileRowSize ( in ) ; if ( ntiles == 0 || tlsize == 0 || tile_rowsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>tiled,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>tiles,<S2SV_blank>tile<S2SV_blank>size,<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = tlsize * ntiles ; if ( tlsize != ( buffsize / ntiles ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ntiles * tl * tile_rowsize ) ) { buffsize = ntiles * tl * tile_rowsize ; if ( ntiles != ( buffsize / tl / tile_rowsize ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Tilesize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>ntiles<S2SV_blank>*<S2SV_blank>tilelength<S2SV_blank>*<S2SV_blank>tilerowsize<S2SV_blank>%lu"" , tlsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Tilesize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Tiles:<S2SV_blank>%u,<S2SV_blank>Tile<S2SV_blank>row<S2SV_blank>size:<S2SV_blank>%u"" , tlsize , ntiles , tile_rowsize ) ; } else { uint32 buffsize_check ; readunit = STRIP ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; stsize = TIFFStripSize ( in ) ; nstrips = TIFFNumberOfStrips ( in ) ; if ( nstrips == 0 || stsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>striped,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>stipes<S2SV_blank>or<S2SV_blank>stripe<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = stsize * nstrips ; if ( stsize != ( buffsize / nstrips ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } buffsize_check = ( ( length * width * spp * bps ) + 7 ) ; if ( length != ( ( buffsize_check - 7 ) / width / spp / bps ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>detected."" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ( ( length * width * spp * bps ) + 7 ) / 8 ) ) { buffsize = ( ( length * width * spp * bps ) + 7 ) / 8 ; # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Stripsize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>imagelength<S2SV_blank>*<S2SV_blank>width<S2SV_blank>*<S2SV_blank>spp<S2SV_blank>*<S2SV_blank>bps<S2SV_blank>/<S2SV_blank>8<S2SV_blank>=<S2SV_blank>%lu"" , stsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Stripsize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Strips:<S2SV_blank>%u,<S2SV_blank>Rows<S2SV_blank>per<S2SV_blank>Strip:<S2SV_blank>%u,<S2SV_blank>Scanline<S2SV_blank>size:<S2SV_blank>%u"" , stsize , nstrips , rowsperstrip , scanlinesize ) ; } if ( input_compression == COMPRESSION_JPEG ) { jpegcolormode = JPEGCOLORMODE_RGB ; TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { if ( input_photometric == PHOTOMETRIC_YCBCR ) { TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsampling_horiz , & subsampling_vert ) ; if ( subsampling_horiz != 1 || subsampling_vert != 1 ) { TIFFError ( ""loadImage"" , ""Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image<S2SV_blank>with<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>horiz<S2SV_blank>%d<S2SV_blank>vert"" , subsampling_horiz , subsampling_vert ) ; return ( - 1 ) ; } } } read_buff = * read_ptr ; if ( ! read_buff ) <S2SV_StartBug> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> { if ( prev_readsize < buffsize ) <S2SV_StartBug> { <S2SV_EndBug> new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ; if ( ! new_buff ) { free ( read_buff ) ; read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; } else read_buff = new_buff ; } } if ( ! read_buff ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } read_buff [ buffsize ] = 0 ; read_buff [ buffsize + 1 ] = 0 ; read_buff [ buffsize + 2 ] = 0 ; prev_readsize = buffsize ; * read_ptr = read_buff ; switch ( readunit ) { case STRIP : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigStripsIntoBuffer ( in , read_buff ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateStripsIntoBuffer ( in , read_buff , length , width , spp , dump ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; case TILE : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; default : TIFFError ( ""loadImage"" , ""Unsupported<S2SV_blank>image<S2SV_blank>file<S2SV_blank>format"" ) ; return ( - 1 ) ; break ; } if ( ( dump -> infile != NULL ) && ( dump -> level == 2 ) ) { dump_info ( dump -> infile , dump -> format , ""loadImage"" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Raw<S2SV_blank>image<S2SV_blank>data,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , buffsize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d"" , bps , spp ) ; for ( i = 0 ; i < length ; i ++ ) dump_buffer ( dump -> infile , dump -> format , 1 , scanlinesize , i , read_buff + ( i * scanlinesize ) ) ; } return ( 0 ) ; }
","<S2SV_ModStart> = 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> planar = 0 <S2SV_ModStart> ! read_buff ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } <S2SV_ModStart> 3 ) ; } <S2SV_ModStart> buffsize ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; }
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9537,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a,2016-11-22T19:59Z,58,"<S2SV_ModStart> = 0.0 ; uint32 nstrips = 0, nstrips",0
155,CWE-119,"CWE-119 static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ; <S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif <S2SV_StartBug> } <S2SV_EndBug> for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; } <S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ; <S2SV_StartBug> } else if ( arg_match ( & arg , & stereo_mode , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ; <S2SV_EndBug> } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ; <S2SV_StartBug> } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) { <S2SV_EndBug> config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) { <S2SV_StartBug> config -> cfg . kf_mode = VPX_KF_DISABLED ; <S2SV_EndBug> } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ ) <S2SV_StartBug> if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] ) <S2SV_EndBug> break ; <S2SV_StartBug> assert ( j < ARG_CTRL_CNT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j < ARG_CTRL_CNT_MAX ) { <S2SV_EndBug> config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } } <S2SV_StartBug> return eos_mark_found ; <S2SV_EndBug> }
","<S2SV_ModStart> = 0 ; # if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ; # endif <S2SV_ModStart> ; # endif # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map ; # endif <S2SV_ModStart> } if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; # if CONFIG_FP_MB_STATS } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { config -> fpmb_stats_fn = arg . val ; # endif } else if ( arg_match ( & arg , & use_webm , argi ) ) { # if CONFIG_WEBM_IO config -> write_webm = 1 ; # else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ; # endif } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> arg ) ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; # endif # if CONFIG_WEBM_IO <S2SV_ModStart> arg ) ; # endif <S2SV_ModStart> arg , & resize_width , argi ) ) { config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_height , argi ) ) { config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & <S2SV_ModStart> = VPX_KF_DISABLED ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { test_16bit_internal = 1 ; } # endif <S2SV_ModStart> ) if ( ctrl_args_map != NULL && <S2SV_ModStart> ( j < ( int ) <S2SV_ModStart> ; if ( ctrl_args_map != NULL && j < ( int ) <S2SV_ModEnd> ARG_CTRL_CNT_MAX ) { <S2SV_ModStart> ; } } # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ; } # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,59,<S2SV_ModStart> ; # endif # if CONFIG_VP9_HIGHBITDEPTH # endif # else if CONFIG_VP9_HIGHBITDEPTH if CONFIG_VP9_HIGHBITDEPTH if CONFIG_VP9_HIGHBITDEPTH endif # endif # endif # endif # else if CONFIG_VP9_VP9_HIGHBITDEPTH # endif # endif # endif # endif # endif # endif # endif # endif # endif # else if CONFIG_VP9_VP9_HIGHBITDEPTH if CONFIG_VP9_HIGHBITDEPTH if CONFIG_HIGHBITDEPTH if CONFIG_VP9_VP9_HIGHBITDEPTH # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # else if CONFIG_VP9_HIGHBITDEPTH if CONFIG_VP9_HIGHBITDEPTH # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # ifdef CONFIG_VP9_VP9_HIGHBITDEPTH # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # endif # ifdef CONFIG_VP9_VP9_,0
157,CWE-264,"CWE-264 static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,60,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->,1
160,CWE-200,"CWE-200 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
","<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ) ; neh
",torvalds@linux/592acbf16821288ecdc4192c47e3774a4c48bb64,CVE-2019-11833,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,2019-05-15T13:29Z,61,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( inode,0
161,CWE-295,"CWE-295 NOEXPORT int verify_callback ( int preverify_ok , X509_STORE_CTX * callback_ctx ) { SSL * ssl ; CLI * c ; ssl = X509_STORE_CTX_get_ex_data ( callback_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) ) ; c = SSL_get_ex_data ( ssl , index_ssl_cli ) ; if ( ! c -> opt -> option . verify_chain && ! c -> opt -> option . verify_peer ) { s_log ( LOG_INFO , ""Certificate<S2SV_blank>verification<S2SV_blank>disabled"" ) ; return 1 ; } <S2SV_StartBug> if ( verify_checks ( c , preverify_ok , callback_ctx ) ) { <S2SV_EndBug> SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ; if ( sess ) { int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated , <S2SV_StartBug> ( void * ) ( - 1 ) ) ; <S2SV_EndBug> SSL_SESSION_free ( sess ) ; if ( ! ok ) { sslerror ( ""SSL_SESSION_set_ex_data"" ) ; return 0 ; } } return 1 ; } <S2SV_StartBug> if ( c -> opt -> option . client || c -> opt -> protocol ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( c -> opt -> redirect_addr . names ) <S2SV_EndBug> return 1 ; return 0 ; }
","<S2SV_ModStart> callback_ctx ) ) return 1 ; if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ; if ( c -> opt -> redirect_addr . names ) <S2SV_ModStart> , index_session_authenticated , NULL <S2SV_ModEnd> ) ; SSL_SESSION_free <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,62,<S2SV_ModStart> ) return <S2SV_ModEnd> ; if (,0
163,CWE-203,"CWE-203 int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) { at91_aes_key_size_t key_size ; unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; init_keys ( & key_size , cipher_key , cmac_key , iv ) ; at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; <S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug> goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }
","<S2SV_ModStart> ; if ( ! consttime_memequal <S2SV_ModEnd> ( cmac ,
",linux4sam@at91bootstrap/7753914c9a622c245f3a3cf2af5e24b6a9904213,CVE-2020-11683,https://github.com/linux4sam/at91bootstrap/commit/7753914c9a622c245f3a3cf2af5e24b6a9904213,2020-09-14T14:15Z,63,<S2SV_ModStart>,0
165,CWE-000,"CWE-000 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
",JACoders@OpenJK/b248763e4878ef12d5835ece6600be8334f67da1,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/b248763e4878ef12d5835ece6600be8334f67da1,2017-03-14T22:59Z,64,"<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string, "".pk3"" ) ) { Com_Printf ( ""Rejecting <S2SV_blank> DLL <S2SV_blank> named <S2SV_blank> \\""%s\\"""", s_alDriver -> string ) ; return qfalse ; }",1
171,CWE-399,"CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> power_pmu_stop ( event , 0 ) ; } }
","<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,65,"<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event, <S2SV_ModEnd> & data,",1
172,CWE-119,"CWE-119 void vp9_twopass_postencode_update ( VP9_COMP * cpi ) { <S2SV_StartBug> # ifdef DISABLE_RC_LONG_TERM_MEM <S2SV_EndBug> const uint64_t bits_used = cpi -> rc . this_frame_target ; # else const uint64_t bits_used = cpi -> rc . projected_frame_size ; # endif cpi -> twopass . bits_left -= bits_used ; cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ; <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ; } else { cpi -> twopass . kf_group_bits -= bits_used ; <S2SV_StartBug> cpi -> twopass . gf_group_bits -= bits_used ; <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ; }
","<S2SV_ModStart> cpi ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; const int bits_used = rc -> base_frame_target ; rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; if ( rc -> total_actual_bits ) { rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; } else { rc -> rate_error_estimate = 0 ; } <S2SV_ModEnd> if ( cpi <S2SV_ModStart> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) { twopass -> <S2SV_ModEnd> kf_group_bits -= bits_used <S2SV_ModStart> -= bits_used ; twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; } twopass -> kf_group_bits <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( twopass -> kf_group_bits <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ; ++ twopass -> gf_group . index ; if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) { const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ; const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { -- twopass -> extend_maxq ; if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ; } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { -- twopass -> extend_minq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ; } else { if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ; else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ; } twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ; twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; if ( rc -> projected_frame_size < fast_extra_thresh ) { rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ; rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; if ( rc -> avg_frame_bandwidth ) { twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; } twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else if ( rc -> vbr_bits_off_target_fast ) { twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else { twopass -> extend_minq_fast = 0 ; } } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,66,<S2SV_ModStart> ) ) { VP9_null> <S2SV_null> <S2SV_null>,0
183,CWE-20,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } <S2SV_StartBug> colormap = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( number_colormaps != 0 ) { <S2SV_StartBug> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , <S2SV_EndBug> 3 * map_length * sizeof ( * colormap ) ) ; <S2SV_StartBug> if ( colormap == ( unsigned char * ) NULL ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , * p & mask , & index , exception ) ; <S2SV_EndBug> * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> colormap = ( <S2SV_ModStart> char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> ( unsigned char <S2SV_ModEnd> ) ScaleQuantumToChar ( <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( Quantum )
",ImageMagick@ImageMagick/f6240ee77847787f6d7618b669d3a2040a2d6d40,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/f6240ee77847787f6d7618b669d3a2040a2d6d40,2017-05-22T14:29Z,67,"<S2SV_ModStart> ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> rows ) ; return ( exception ) ; }",0
185,CWE-000,"CWE-000 static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; } <S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n"" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; if ( usb_endpoint_xfer_int ( endpoint ) ) dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n"" ) ; dev_dbg ( & usbinterface -> dev , ""endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n"" , usbinterface -> altsetting [ 0 ] . extralen ) ; if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , HID_DEVICE_TYPE , & hid_desc ) != 0 ) { dev_err ( & usbinterface -> dev , ""Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n"" ) ; error = - EIO ; goto err_free_urb ; } dev_dbg ( & usbinterface -> dev , ""Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n"" , hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; if ( ! report ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n"" ) ; error = - ENOMEM ; goto err_free_urb ; } for ( retry = 0 ; retry < 3 ; retry ++ ) { result = usb_control_msg ( gtco -> usbdev , usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , USB_REQ_GET_DESCRIPTOR , USB_RECIP_INTERFACE | USB_DIR_IN , REPORT_DEVICE_TYPE << 8 , 0 , report , le16_to_cpu ( hid_desc -> wDescriptorLength ) , 5000 ) ; dev_dbg ( & usbinterface -> dev , ""usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n"" , result ) ; if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { parse_hid_report_descriptor ( gtco , report , result ) ; break ; } } kfree ( report ) ; if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n"" , hid_desc -> wDescriptorLength ) ; error = - EIO ; goto err_free_urb ; } usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; strlcat ( gtco -> usbpath , ""/input0"" , sizeof ( gtco -> usbpath ) ) ; input_dev -> open = gtco_input_open ; input_dev -> close = gtco_input_close ; input_dev -> name = ""GTCO_CalComp"" ; input_dev -> phys = gtco -> usbpath ; input_set_drvdata ( input_dev , gtco ) ; gtco_setup_caps ( input_dev ) ; usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; input_dev -> dev . parent = & usbinterface -> dev ; endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( gtco -> urbinfo , gtco -> usbdev , usb_rcvintpipe ( gtco -> usbdev , endpoint -> bEndpointAddress ) , gtco -> buffer , REPORT_MAX_SIZE , gtco_urb_callback , gtco , endpoint -> bInterval ) ; gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_set_intfdata ( usbinterface , gtco ) ; error = input_register_device ( input_dev ) ; if ( error ) goto err_free_urb ; return 0 ; err_free_urb : usb_free_urb ( gtco -> urbinfo ) ; err_free_buf : usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , gtco -> buffer , gtco -> buf_dma ) ; err_free_devs : input_free_device ( input_dev ) ; kfree ( gtco ) ; return error ; }
","<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; }
",torvalds@linux/162f98dea487206d9ab79fc12ed64700667a894d,CVE-2016-2187,https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d,2016-05-02T10:59Z,68,<S2SV_ModStart> 0 ) ; ret = - EINVAL ;,0
188,CWE-000,"CWE-000 <S2SV_StartBug> static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; <S2SV_StartBug> nfs_set_open_stateid_locked ( state , stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; }
","<S2SV_ModStart> * stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,69,"<S2SV_ModStart> * state, fmode_t fmode <S2SV_ModEnd>, int state",0
192,CWE-264,"CWE-264 static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; <S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> & tmpname , ""/etc"" , "".vipw"" <S2SV_ModEnd> ) ) ==
",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z,70,"<S2SV_ModStart> char * dir <S2SV_ModEnd>, dir,",0
196,CWE-000,"CWE-000 IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ; <S2SV_StartBug> BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; <S2SV_EndBug> ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols ) || ( ps_pps -> i1_num_tile_rows < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows ) ) return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_pps_done = 1 ; return ret ; }
","<S2SV_ModStart> = value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
",external@libhevc/25c0ffbe6a181b4a373c3c9b421ea449d457e6ed,CVE-2017-0811,https://android.googlesource.com/platform/external/libhevc/+/25c0ffbe6a181b4a373c3c9b421ea449d457e6ed,2017-10-04T01:29Z,71,,0
201,CWE-399,"CWE-399 void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) { <S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }
","<S2SV_ModStart> NULL ) { flush_cmd ( ) ;
",jedisct1@pure-ftpd/65c4d4ad331e94661de763e9b5304d28698999c4,CVE-2011-1575,https://github.com/jedisct1/pure-ftpd/commit/65c4d4ad331e94661de763e9b5304d28698999c4,2011-05-23T22:55Z,72,<S2SV_ModStart> ; if ( ( 1 <S2SV_ModEnd> ) == 0,0
202,CWE-119,"CWE-119 <S2SV_StartBug> void vp9_setup_dst_planes ( MACROBLOCKD * xd , <S2SV_EndBug> const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <S2SV_EndBug> setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ; } }
","<S2SV_ModStart> void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , const YV12_BUFFER_CONFIG <S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int <S2SV_ModStart> pd = & planes <S2SV_ModEnd> [ i ]
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,73,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
204,CWE-000,"CWE-000 <S2SV_StartBug> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <S2SV_EndBug> { <S2SV_StartBug> switch ( ctxt -> op_bytes ) { <S2SV_EndBug> case 2 : ctxt -> _eip = ( u16 ) dst ; break ; case 4 : ctxt -> _eip = ( u32 ) dst ; break ; case 8 : ctxt -> _eip = dst ; break ; default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\n"" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> assign_eip_near ( struct <S2SV_ModStart> dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z,74,<S2SV_ModStart> <S,0
205,CWE-119,"CWE-119 static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,75,"<S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args )",1
207,CWE-362,"CWE-362 static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ ) <S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> else <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }
","<S2SV_ModStart> ) get_block = ocfs2_lock_get_block <S2SV_ModEnd> ; else get_block <S2SV_ModStart> else get_block = ocfs2_dio_wr_get_block <S2SV_ModEnd> ; return __blockdev_direct_IO
",torvalds@linux/3e4c56d41eef5595035872a2ec5a483f42e8917f,CVE-2017-18224,https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f,2018-03-12T03:29Z,76,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
209,CWE-120,"CWE-120 void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefault<S2SV_blank>file:<S2SV_blank>%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; <S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug> { if ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }
","<S2SV_ModStart> ( f , ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> , def ,
",AXDOOMER@doom-vanille/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,CVE-2020-15007,https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,2020-06-24T11:15Z,77,<S2SV_ModStart> ( str ) <S2SV_ModEnd> ) ; if,0
212,CWE-125,"CWE-125 static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { <S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> int kind ; void * data ; PyCompilerFlags cf ; <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> char * str ; <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
","<S2SV_ModStart> n ) { <S2SV_ModEnd> PyCompilerFlags cf ; <S2SV_ModStart> PyCompilerFlags cf ; node * mod_n ; <S2SV_ModStart> * str ; Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ':' ) ; for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> expr_end - expr_start <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; str = <S2SV_ModStart> == NULL ) { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> str [ 0 <S2SV_ModStart> = PyCF_ONLY_AST ; mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> PyMem_RawFree ( str ) ; Ta3Node_Free ( mod_n
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,78,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
214,CWE-119,"CWE-119 cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { <S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }
","<S2SV_ModStart> c = object ? object -> child : 0 <S2SV_ModEnd> ; while (
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,79,<S2SV_ModStart> string ) { <S2SV_ModEnd> c = c,0
222,CWE-400,"CWE-400 int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = ""maxconns_fast"" , [ HASHPOWER_INIT ] = ""hashpower"" , [ NO_HASHEXPAND ] = ""no_hashexpand"" , [ SLAB_REASSIGN ] = ""slab_reassign"" , [ SLAB_AUTOMOVE ] = ""slab_automove"" , [ SLAB_AUTOMOVE_RATIO ] = ""slab_automove_ratio"" , [ SLAB_AUTOMOVE_WINDOW ] = ""slab_automove_window"" , [ TAIL_REPAIR_TIME ] = ""tail_repair_time"" , [ HASH_ALGORITHM ] = ""hash_algorithm"" , [ LRU_CRAWLER ] = ""lru_crawler"" , [ LRU_CRAWLER_SLEEP ] = ""lru_crawler_sleep"" , [ LRU_CRAWLER_TOCRAWL ] = ""lru_crawler_tocrawl"" , [ LRU_MAINTAINER ] = ""lru_maintainer"" , [ HOT_LRU_PCT ] = ""hot_lru_pct"" , [ WARM_LRU_PCT ] = ""warm_lru_pct"" , [ HOT_MAX_FACTOR ] = ""hot_max_factor"" , [ WARM_MAX_FACTOR ] = ""warm_max_factor"" , [ TEMPORARY_TTL ] = ""temporary_ttl"" , [ IDLE_TIMEOUT ] = ""idle_timeout"" , [ WATCHER_LOGBUF_SIZE ] = ""watcher_logbuf_size"" , [ WORKER_LOGBUF_SIZE ] = ""worker_logbuf_size"" , [ SLAB_SIZES ] = ""slab_sizes"" , [ SLAB_CHUNK_MAX ] = ""slab_chunk_max"" , [ TRACK_SIZES ] = ""track_sizes"" , [ NO_INLINE_ASCII_RESP ] = ""no_inline_ascii_resp"" , [ MODERN ] = ""modern"" , [ NO_MODERN ] = ""no_modern"" , [ NO_CHUNKED_ITEMS ] = ""no_chunked_items"" , [ NO_SLAB_REASSIGN ] = ""no_slab_reassign"" , [ NO_SLAB_AUTOMOVE ] = ""no_slab_automove"" , [ NO_MAXCONNS_FAST ] = ""no_maxconns_fast"" , [ INLINE_ASCII_RESP ] = ""inline_ascii_resp"" , [ NO_LRU_CRAWLER ] = ""no_lru_crawler"" , [ NO_LRU_MAINTAINER ] = ""no_lru_maintainer"" , [ NO_DROP_PRIVILEGES ] = ""no_drop_privileges"" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = ""relaxed_privileges"" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = ""ext_page_size"" , [ EXT_PAGE_COUNT ] = ""ext_page_count"" , [ EXT_WBUF_SIZE ] = ""ext_wbuf_size"" , [ EXT_THREADS ] = ""ext_threads"" , [ EXT_IO_DEPTH ] = ""ext_io_depth"" , [ EXT_PATH ] = ""ext_path"" , [ EXT_ITEM_SIZE ] = ""ext_item_size"" , [ EXT_ITEM_AGE ] = ""ext_item_age"" , [ EXT_LOW_TTL ] = ""ext_low_ttl"" , [ EXT_RECACHE_RATE ] = ""ext_recache_rate"" , [ EXT_COMPACT_UNDER ] = ""ext_compact_under"" , [ EXT_DROP_UNDER ] = ""ext_drop_under"" , [ EXT_MAX_FRAG ] = ""ext_max_frag"" , [ EXT_DROP_UNREAD ] = ""ext_drop_unread"" , [ SLAB_AUTOMOVE_FREERATIO ] = ""slab_automove_freeratio"" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = ""a:"" ""A"" ""p:"" ""s:"" ""U:"" ""m:"" ""M"" ""c:"" ""k"" ""hiV"" ""r"" ""v"" ""d"" ""l:"" ""u:"" ""P:"" ""f:"" ""n:"" ""t:"" ""D:"" ""L"" ""R:"" ""C"" ""b:"" ""B:"" ""I:"" ""S"" ""F"" ""X"" ""o:"" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { ""unix-mask"" , required_argument , 0 , 'a' } , { ""enable-shutdown"" , no_argument , 0 , 'A' } , { ""port"" , required_argument , 0 , 'p' } , { ""unix-socket"" , required_argument , 0 , 's' } , { ""udp-port"" , required_argument , 0 , 'U' } , { ""memory-limit"" , required_argument , 0 , 'm' } , { ""disable-evictions"" , no_argument , 0 , 'M' } , { ""conn-limit"" , required_argument , 0 , 'c' } , { ""lock-memory"" , no_argument , 0 , 'k' } , { ""help"" , no_argument , 0 , 'h' } , { ""license"" , no_argument , 0 , 'i' } , { ""version"" , no_argument , 0 , 'V' } , { ""enable-coredumps"" , no_argument , 0 , 'r' } , { ""verbose"" , optional_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""listen"" , required_argument , 0 , 'l' } , { ""user"" , required_argument , 0 , 'u' } , { ""pidfile"" , required_argument , 0 , 'P' } , { ""slab-growth-factor"" , required_argument , 0 , 'f' } , { ""slab-min-size"" , required_argument , 0 , 'n' } , { ""threads"" , required_argument , 0 , 't' } , { ""enable-largepages"" , no_argument , 0 , 'L' } , { ""max-reqs-per-event"" , required_argument , 0 , 'R' } , { ""disable-cas"" , no_argument , 0 , 'C' } , { ""listen-backlog"" , required_argument , 0 , 'b' } , { ""protocol"" , required_argument , 0 , 'B' } , { ""max-item-size"" , required_argument , 0 , 'I' } , { ""enable-sasl"" , no_argument , 0 , 'S' } , { ""disable-flush-all"" , no_argument , 0 , 'F' } , { ""disable-dumping"" , no_argument , 0 , 'X' } , { ""extended"" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , ""Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE ""<S2SV_blank>"" VERSION ""\\n"" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n"" ) ; return 1 ; } snprintf ( p , len , ""%s,%s"" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , ""Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , ""Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n"" ""<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in"" ""<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n"" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\n"" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n"" ""(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n"" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , ""auto"" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , ""binary"" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , ""ascii"" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n"" ""<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n"" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n"" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n"" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n"" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n"" ""Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\""STAT<S2SV_blank>hash_power_level\\""<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n"" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n"" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n"" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n"" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n"" ) ; return 1 ; } ; if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n"" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n"" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n"" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n"" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n"" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n"" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n"" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n"" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n"" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n"" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n"" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n"" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n"" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n"" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n"" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\""%s\\""\\n"" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\""%c\\""\\n"" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n"" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n"" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n"" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n"" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n"" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n"" ) ; exit ( EX_USAGE ) ; } } } <S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n"" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\0' ) { fprintf ( stderr , ""can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n"" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , ""can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n"" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n"" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( ""Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP"" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; } # else fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n"" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n"" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( ""extstore<S2SV_blank>open"" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( ""failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction"" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n"" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s"" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( ""MEMCACHED_PORT_FILENAME"" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , ""%s.lck"" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , ""a"" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d"" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d"" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , ""Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }
","<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
",memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z,80,<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings,1
224,CWE-476,"CWE-476 static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; <S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }
","<S2SV_ModStart> size ) ; if ( ! px -> ft ) { return FALSE ; }
",bitlbee@bitlbee/30d598ce7cd3f136ee9d7097f39fa9818a272441,CVE-2017-5668,https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441,2017-03-14T14:59Z,81,,0
230,CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,82,"<S2SV_ModStart> ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } ptr ++ ; if ( length < 4 ) { ND_PRINT ( ( ( ndo, ""AVP <S2SV_blank> short"" ) ) ) ; return ; } ptr ++ ; ptr ++ ; val_h = EXTRACT_16BITS ( ptr ++ ) ptr ++ ; if ( ptr ++ ) { ND_PRINT ( ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ++ ) ; val_h = EXTRACT_16BITS ( ptr ++ ) ; if ( ptr ++ ) { ND_PRINT ( ( ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ) ) ; return ; } ptr ++ ; ptr ++ ; ptr ++ = EXTRACT_16BITS ( ptr ++ ; ptr ++ ; ptr ++ = EXTRACT_16BITS ( ptr ++ ) ; ptr ++ ; ptr ++ ; ptr ++ = EXTRACT_16BITS ( ptr ++ ) ; if ( ptr ++ ) { ND_PRINT ( ndo, ""AVP <S2SV_blank> short"" ) ) ) { ND_PRINT ( ( ndo, """,0
233,CWE-401,"CWE-401 static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif <S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if
",libarchive@libarchive/ba641f73f3d758d9032b3f0e5597a9c6e593a505,CVE-2019-11463,https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505,2019-04-23T03:29Z,83,,0
240,CWE-20,"CWE-20 void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( ""refs/heads/git_tilde1"" <S2SV_ModStart> "".git/foobar"" ) ; test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libgit2@libgit2/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,CVE-2020-12279,https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,2020-04-27T17:15Z,84,<S2SV_ModStart> ( ) { <S2SV_ModEnd> char * test_test,0
244,CWE-119,"CWE-119 void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }
","<S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; for
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,85,<S2SV_ModStart> * src ; vpx_buffer <S2SV_ModEnd> ( src ->,0
248,CWE-20,"CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,86,<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0,0
251,CWE-119,"CWE-119 static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ; <S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }
","<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( sortlist ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,87,"<S2SV_ModStart> { memset <S2SV_ModEnd> ( cpi,",0
254,CWE-416,"CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
","<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
",torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z,88,<S2SV_ModStart> user ) { <S2SV_ModEnd> struct user,0
256,CWE-190,"CWE-190 static int mongo_cursor_get_more ( mongo_cursor * cursor ) { int res ; if ( cursor -> limit > 0 && cursor -> seen >= cursor -> limit ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else if ( ! cursor -> reply ) { cursor -> err = MONGO_CURSOR_INVALID ; return MONGO_ERROR ; } else if ( ! cursor -> reply -> fields . cursorID ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else { char * data ; <S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug> int limit = 0 ; mongo_message * mm ; if ( cursor -> limit > 0 ) limit = cursor -> limit - cursor -> seen ; mm = mongo_message_create ( 16 + 4 + sl + 4 + 8 , 0 , 0 , MONGO_OP_GET_MORE ) ; data = & mm -> data ; data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , cursor -> ns , sl ) ; data = mongo_data_append32 ( data , & limit ) ; mongo_data_append64 ( data , & cursor -> reply -> fields . cursorID ) ; bson_free ( cursor -> reply ) ; res = mongo_message_send ( cursor -> conn , mm ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } res = mongo_read_response ( cursor -> conn , & ( cursor -> reply ) ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } cursor -> current . data = NULL ; cursor -> seen += cursor -> reply -> fields . num ; return MONGO_OK ; } }
","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> sl = strlen
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,89,,0
259,CWE-125,"CWE-125 static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; <S2SV_StartBug> int is_async = 0 ; <S2SV_EndBug> REQ ( n , comp_for ) ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> is_async = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async<S2SV_blank>comprehensions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.6<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } <S2SV_StartBug> for_ch = CHILD ( n , 1 + is_async ) ; <S2SV_EndBug> t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; <S2SV_StartBug> expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; <S2SV_EndBug> if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> int j , n_ifs ; asdl_seq * ifs ; <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
","<S2SV_ModStart> * for_ch ; node * sync_n ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 <S2SV_ModEnd> ) { is_async <S2SV_ModStart> = 1 ; REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> if ( is_async <S2SV_ModStart> = CHILD ( sync_n , 1 <S2SV_ModEnd> ) ; t <S2SV_ModStart> , CHILD ( sync_n , 3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( NCH ( sync_n ) == 5 <S2SV_ModEnd> ) { int <S2SV_ModStart> = CHILD ( sync_n , 4 <S2SV_ModEnd> ) ; n_ifs
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,90,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> NCH ( NCH ( NCH ( NCH ( NCH ( NCH ( NCH ( n, 1 ) ) == NCH ( NCH ( NCH ( n, 1 ) ) == NCH ( n, NCH ( NCH ( NCH ( n, NCH ( n, 1 ) ) ) == 0 ) ) { n = 1 ; } else { n = NCH ( NCH ( NCH ( n, 1 ) - 1 ) - 1 ) - 1 ; n = NCH ( NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n ) ), NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n, NCH ( n )",0
260,CWE-189,"CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <S2SV_StartBug> } <S2SV_EndBug> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
","<S2SV_ModStart> NULL ; } dst_state -> speculative = src -> speculative ;
",torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,CVE-2019-7308,https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,2019-02-01T22:29Z,91,,0
261,CWE-119,"CWE-119 <S2SV_StartBug> static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const struct segmentation * const seg = & cm -> seg ; const MODE_INFO * const mi = mi_8x8 [ 0 ] ; <S2SV_StartBug> const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ; <S2SV_EndBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; const BLOCK_SIZE bsize = mbmi -> sb_type ; if ( seg -> update_map ) write_segment_id ( w , seg , mbmi -> segment_id ) ; <S2SV_StartBug> write_skip ( cpi , mbmi -> segment_id , mi , w ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 ) { write_intra_mode ( w , mbmi -> mode , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int block = idy * 2 + idx ; write_intra_mode ( w , mi -> bmi [ block ] . as_mode , get_y_mode_probs ( mi , above_mi , left_mi , block ) ) ; } } } write_intra_mode ( w , mbmi -> uv_mode , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }
","<S2SV_ModStart> write_mb_modes_kf ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> MODE_INFO * * <S2SV_ModStart> * mi_8x8 , vpx_writer * w ) { <S2SV_ModEnd> const struct segmentation <S2SV_ModStart> const above_mi = xd -> above_mi <S2SV_ModEnd> ; const MODE_INFO <S2SV_ModStart> = xd -> left_mi <S2SV_ModEnd> ; const MB_MODE_INFO <S2SV_ModStart> ; write_skip ( cm , xd <S2SV_ModEnd> , mbmi -> <S2SV_ModStart> ) write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,92,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static MACROBLOCKD <S2SV_ModEnd> const MACROBLOCKD * const MACROBLOCK * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const mbmi, MACROBLOCKD * const MACROBLOCKD * const mbmi, MACROBLOCKD * const x, MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const MACROBLOCKD * const mbmi_mode = & cpi -> mi [ 0 ] ; const MACROBLOCKD * const mbmi_mode = & cpi -> mi [ 0 ] ; const MACROBLOCKD * const MACROBLOCKD * cm -> mbmi_mode_mode = cm -> mbmi_mode ; const PREDICTION_INFO *",0
265,CWE-119,"CWE-119 int decompileAction ( int n , SWF_ACTION * actions , int maxn ) { <S2SV_StartBug> if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ; <S2SV_EndBug> # ifdef DEBUG fprintf ( stderr , ""%d:\\tACTION[%3.3d]:<S2SV_blank>%s\\n"" , actions [ n ] . SWF_ACTIONRECORD . Offset , n , actionName ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) ) ; # endif <S2SV_StartBug> switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) <S2SV_EndBug> { case SWFACTION_END : return 0 ; case SWFACTION_CONSTANTPOOL : decompileCONSTANTPOOL ( & actions [ n ] ) ; return 0 ; case SWFACTION_GOTOLABEL : return decompileGOTOFRAME ( n , actions , maxn , 1 ) ; case SWFACTION_GOTOFRAME : return decompileGOTOFRAME ( n , actions , maxn , 0 ) ; case SWFACTION_GOTOFRAME2 : return decompileGOTOFRAME2 ( n , actions , maxn ) ; case SWFACTION_WAITFORFRAME : decompileWAITFORFRAME ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL2 : decompileGETURL2 ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL : decompileGETURL ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSH : decompilePUSH ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSHDUP : decompilePUSHDUP ( & actions [ n ] ) ; return 0 ; case SWFACTION_STACKSWAP : decompileSTACKSWAP ( & actions [ n ] ) ; return 0 ; case SWFACTION_SETPROPERTY : decompileSETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETPROPERTY : decompileGETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETTIME : return decompileGETTIME ( n , actions , maxn ) ; case SWFACTION_TRACE : decompileTRACE ( n , actions , maxn ) ; return 0 ; case SWFACTION_CALLFRAME : decompileCALLFRAME ( n , actions , maxn ) ; return 0 ; case SWFACTION_EXTENDS : decompileEXTENDS ( n , actions , maxn ) ; return 0 ; case SWFACTION_INITOBJECT : decompileINITOBJECT ( n , actions , maxn ) ; return 0 ; case SWFACTION_NEWOBJECT : decompileNEWOBJECT ( n , actions , maxn ) ; return 0 ; case SWFACTION_NEWMETHOD : decompileNEWMETHOD ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETMEMBER : decompileGETMEMBER ( n , actions , maxn ) ; return 0 ; case SWFACTION_SETMEMBER : decompileSETMEMBER ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETVARIABLE : decompileGETVARIABLE ( n , actions , maxn ) ; return 0 ; case SWFACTION_SETVARIABLE : decompileSETVARIABLE ( n , actions , maxn , 0 ) ; return 0 ; case SWFACTION_DEFINELOCAL : decompileSETVARIABLE ( n , actions , maxn , 1 ) ; return 0 ; case SWFACTION_DEFINELOCAL2 : decompileDEFINELOCAL2 ( n , actions , maxn ) ; return 0 ; case SWFACTION_DECREMENT : return decompileINCR_DECR ( n , actions , maxn , 0 ) ; case SWFACTION_INCREMENT : return decompileINCR_DECR ( n , actions , maxn , 1 ) ; case SWFACTION_STOREREGISTER : decompileSTOREREGISTER ( n , actions , maxn ) ; return 0 ; case SWFACTION_JUMP : return decompileJUMP ( n , actions , maxn ) ; case SWFACTION_RETURN : decompileRETURN ( n , actions , maxn ) ; return 0 ; case SWFACTION_LOGICALNOT : return decompileLogicalNot ( n , actions , maxn ) ; case SWFACTION_IF : return decompileIF ( n , actions , maxn ) ; case SWFACTION_WITH : decompileWITH ( n , actions , maxn ) ; return 0 ; case SWFACTION_ENUMERATE : return decompileENUMERATE ( n , actions , maxn , 0 ) ; case SWFACTION_ENUMERATE2 : return decompileENUMERATE ( n , actions , maxn , 1 ) ; case SWFACTION_INITARRAY : return decompileINITARRAY ( n , actions , maxn ) ; case SWFACTION_DEFINEFUNCTION : return decompileDEFINEFUNCTION ( n , actions , maxn , 0 ) ; case SWFACTION_DEFINEFUNCTION2 : return decompileDEFINEFUNCTION ( n , actions , maxn , 1 ) ; case SWFACTION_CALLFUNCTION : return decompileCALLFUNCTION ( n , actions , maxn ) ; case SWFACTION_CALLMETHOD : return decompileCALLMETHOD ( n , actions , maxn ) ; case SWFACTION_INSTANCEOF : case SWFACTION_SHIFTLEFT : case SWFACTION_SHIFTRIGHT : case SWFACTION_SHIFTRIGHT2 : case SWFACTION_ADD : case SWFACTION_ADD2 : case SWFACTION_SUBTRACT : case SWFACTION_MULTIPLY : case SWFACTION_DIVIDE : case SWFACTION_MODULO : case SWFACTION_BITWISEAND : case SWFACTION_BITWISEOR : case SWFACTION_BITWISEXOR : case SWFACTION_EQUAL : case SWFACTION_EQUALS2 : case SWFACTION_LESS2 : case SWFACTION_LOGICALAND : case SWFACTION_LOGICALOR : case SWFACTION_GREATER : case SWFACTION_LESSTHAN : case SWFACTION_STRINGEQ : case SWFACTION_STRINGCOMPARE : case SWFACTION_STRICTEQUALS : return decompileArithmeticOp ( n , actions , maxn ) ; case SWFACTION_POP : pop ( ) ; return 0 ; case SWFACTION_STARTDRAG : return decompileSTARTDRAG ( n , actions , maxn ) ; case SWFACTION_DELETE : return decompileDELETE ( n , actions , maxn , 0 ) ; case SWFACTION_DELETE2 : return decompileDELETE ( n , actions , maxn , 1 ) ; case SWFACTION_TARGETPATH : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""targetPath"" ) ; case SWFACTION_TYPEOF : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""typeof"" ) ; case SWFACTION_ORD : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""ord"" ) ; case SWFACTION_CHR : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""chr"" ) ; case SWFACTION_INT : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""int"" ) ; case SWFACTION_TOSTRING : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""String"" ) ; case SWFACTION_TONUMBER : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""Number"" ) ; case SWFACTION_RANDOMNUMBER : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""random"" ) ; case SWFACTION_STRINGLENGTH : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""length"" ) ; case SWFACTION_PLAY : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""play"" ) ; case SWFACTION_STOP : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stop"" ) ; case SWFACTION_NEXTFRAME : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""nextFrame"" ) ; case SWFACTION_PREVFRAME : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""prevFrame"" ) ; case SWFACTION_ENDDRAG : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stopDrag"" ) ; case SWFACTION_STOPSOUNDS : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stopAllSounds"" ) ; case SWFACTION_TOGGLEQUALITY : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""toggleHighQuality"" ) ; case SWFACTION_MBSUBSTRING : case SWFACTION_SUBSTRING : return decompileSUBSTRING ( n , actions , maxn ) ; case SWFACTION_STRINGCONCAT : return decompileSTRINGCONCAT ( n , actions , maxn ) ; case SWFACTION_REMOVECLIP : return decompileREMOVECLIP ( n , actions , maxn ) ; case SWFACTION_DUPLICATECLIP : return decompileDUPLICATECLIP ( n , actions , maxn ) ; case SWFACTION_SETTARGET : return decompileSETTARGET ( n , actions , maxn , 0 ) ; case SWFACTION_SETTARGET2 : return decompileSETTARGET ( n , actions , maxn , 1 ) ; case SWFACTION_IMPLEMENTSOP : return decompileIMPLEMENTS ( n , actions , maxn ) ; case SWFACTION_CASTOP : return decompileCAST ( n , actions , maxn ) ; case SWFACTION_THROW : return decompileTHROW ( n , actions , maxn ) ; case SWFACTION_TRY : return decompileTRY ( n , actions , maxn ) ; default : outputSWF_ACTION ( n , & actions [ n ] ) ; return 0 ; } }
","<S2SV_ModStart> maxn ) { <S2SV_ModEnd> # ifdef DEBUG <S2SV_ModStart> endif switch ( OpCode ( actions , n , maxn ) <S2SV_ModEnd> ) { case
",libming@libming/da9d86eab55cbf608d5c916b8b690f5b76bca462,CVE-2019-12982,https://github.com/libming/libming/commit/da9d86eab55cbf608d5c916b8b690f5b76bca462,2019-06-26T18:15Z,93,<S2SV_ModStart> ) ) { size_t <S2SV_ModEnd> n = 0,0
268,CWE-125,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z,94,<S2SV_ModStart> ( len < 1 <S2SV_ModEnd> ) ; ND_TCHECK,0
269,CWE-835,"CWE-835 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
","<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
",torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z,95,<S2SV_ModStart> } <S2SV_null> <S2SV_null>,0
271,CWE-190,"CWE-190 <S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; if ( azModuleArg == 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }
","<S2SV_ModStart> void addModuleArgument ( Parse * pParse <S2SV_ModEnd> , Table * <S2SV_ModStart> zArg ) { sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof <S2SV_ModStart> * azModuleArg ; sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ; }
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,96,<S2SV_ModStart> * y ; sqlite3_int64,0
276,CWE-787,"CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
","<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,97,,0
277,CWE-125,"CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
",kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z,98,,0
278,CWE-416,"CWE-416 <S2SV_StartBug> static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) <S2SV_EndBug> { <S2SV_StartBug> struct bfq_data * bfqd = bfqq -> bfqd ; <S2SV_EndBug> enum bfqq_expiration reason ; unsigned long flags ; <S2SV_StartBug> spin_lock_irqsave ( & bfqd -> lock , flags ) ; <S2SV_EndBug> bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
","<S2SV_ModStart> void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , <S2SV_ModStart> bfqq ) { <S2SV_ModEnd> enum bfqq_expiration reason <S2SV_ModStart> lock , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> return ; } bfq_clear_bfqq_wait_request ( bfqq ) ;
",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z,99,<S2SV_ModStart> <S2SV_null> <S2SV_null> static int,0
285,CWE-119,"CWE-119 void cJSON_AddItemReferenceToObject ( cJSON * object , const char * string , cJSON * item ) { cJSON_AddItemToObject ( object , string , create_reference ( item ) ) ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,100,,1
288,CWE-400,"CWE-400 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,101,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",1
290,CWE-787,"CWE-787 static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }
","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z,102,<S2SV_ModStart>,0
293,CWE-264,"CWE-264 static int tcp_v6_send_synack ( const struct sock * sk , struct dst_entry * dst , struct flowi * fl , struct request_sock * req , struct tcp_fastopen_cookie * foc , bool attach_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sk_buff * skb ; int err = - ENOMEM ; if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ; skb = tcp_make_synack ( sk , dst , req , foc , attach_req ) ; if ( skb ) { __tcp_v6_send_check ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; if ( np -> repflow && ireq -> pktopts ) fl6 -> flowlabel = ip6_flowlabel ( ipv6_hdr ( ireq -> pktopts ) ) ; <S2SV_StartBug> err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> err = net_xmit_eval ( err ) ; } done : return err ; }
","<S2SV_ModStart> , fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,103,"<S2SV_ModStart> & fl6, rcu_dereference ( <S2SV_ModStart> np -> opt )",0
298,CWE-120,"CWE-120 static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { <S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image <S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels ,
",ImageMagick@ImageMagick/e45e48b881038487d0bc94d92a16c1537616cc0a,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/e45e48b881038487d0bc94d92a16c1537616cc0a,2017-03-03T17:59Z,104,<S2SV_ModStart> NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image,0
299,CWE-399,"CWE-399 static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , ""itime:0x%"" PRIx64 "",<S2SV_blank>pct:%d,<S2SV_blank>ict:%d\\n"" , itime , pct , ict ) ; for ( i = 0 ; i < ict ; i ++ ) { int pktnum = avio_rl32 ( s -> pb ) ; int pktct = avio_rl16 ( s -> pb ) ; int64_t pos = s -> internal -> data_offset + s -> packet_size * ( int64_t ) pktnum ; <S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> if ( pos != last_pos ) { av_log ( s , AV_LOG_DEBUG , ""pktnum:%d,<S2SV_blank>pktct:%d<S2SV_blank><S2SV_blank>pts:<S2SV_blank>%"" PRId64 ""\\n"" , pktnum , pktct , index_pts ) ; av_add_index_entry ( s -> streams [ stream_index ] , pos , index_pts , s -> packet_size , 0 , AVINDEX_KEYFRAME ) ; last_pos = pos ; } } asf -> index_read = ict > 1 ; } end : avio_seek ( s -> pb , current_pos , SEEK_SET ) ; return ret ; }
","<S2SV_ModStart> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
",FFmpeg@FFmpeg/afc9c683ed9db01edb357bc8c19edad4282b3a97,CVE-2017-14223,https://github.com/FFmpeg/FFmpeg/commit/afc9c683ed9db01edb357bc8c19edad4282b3a97,2017-09-09T01:29Z,105,<S2SV_ModStart> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; },1
302,CWE-119,"CWE-119 static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { <S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> }
","<S2SV_ModStart> data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,106,<S2SV_ModStart> ctx ) { ( void ) ctx ;,0
306,CWE-190,"CWE-190 static int <S2SV_StartBug> _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size ) <S2SV_EndBug> { <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> assert ( new_size > self -> memo_size ) ; PyObject * * memo_new = self -> memo ; PyMem_RESIZE ( memo_new , PyObject * , new_size ) ; if ( memo_new == NULL ) { PyErr_NoMemory ( ) ; return - 1 ; } self -> memo = memo_new ; for ( i = self -> memo_size ; i < new_size ; i ++ ) self -> memo [ i ] = NULL ; self -> memo_size = new_size ; return 0 ; }
","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> new_size ) { <S2SV_ModStart> new_size ) { size_t <S2SV_ModEnd> i ; assert
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,107,"<S2SV_ModStart> * new, size_t <S2SV_ModEnd> size, size_t",0
309,CWE-119,"CWE-119 <S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> if ( delta_q != 0 ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> write_delta_q ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , <S2SV_ModStart> 0 ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 1 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 4 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> } else { vpx_wb_write_bit <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,108,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> vpx_write_bit_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> 8 ) { vpx_write_bit_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> 8 ) vpx_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> 8 ) { vpx_write_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> 8 ) ; vpx_write_bit <S2SV_ModEnd> ( wb,",0
310,CWE-119,"CWE-119 void vp8_mv_pred ( VP8_COMP * cpi , MACROBLOCKD * xd , const MODE_INFO * here , int_mv * mvp , int refframe , int * ref_frame_sign_bias , int * sr , int near_sadidx [ ] ) { const MODE_INFO * above = here - xd -> mode_info_stride ; const MODE_INFO * left = here - 1 ; const MODE_INFO * aboveleft = above - 1 ; int_mv near_mvs [ 8 ] ; int near_ref [ 8 ] ; int_mv mv ; int vcnt = 0 ; int find = 0 ; int mb_offset ; int mvx [ 8 ] ; int mvy [ 8 ] ; int i ; mv . as_int = 0 ; if ( here -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ 0 ] . as_int = near_mvs [ 1 ] . as_int = near_mvs [ 2 ] . as_int = near_mvs [ 3 ] . as_int = near_mvs [ 4 ] . as_int = near_mvs [ 5 ] . as_int = near_mvs [ 6 ] . as_int = near_mvs [ 7 ] . as_int = 0 ; near_ref [ 0 ] = near_ref [ 1 ] = near_ref [ 2 ] = near_ref [ 3 ] = near_ref [ 4 ] = near_ref [ 5 ] = near_ref [ 6 ] = near_ref [ 7 ] = 0 ; if ( above -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = above -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ above -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = above -> mbmi . ref_frame ; } vcnt ++ ; if ( left -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = left -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ left -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = left -> mbmi . ref_frame ; } vcnt ++ ; if ( aboveleft -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = aboveleft -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ aboveleft -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = aboveleft -> mbmi . ref_frame ; } vcnt ++ ; if ( cpi -> common . last_frame_type != KEY_FRAME ) { mb_offset = ( - xd -> mb_to_top_edge / 128 + 1 ) * ( xd -> mode_info_stride + 1 ) + ( - xd -> mb_to_left_edge / 128 + 1 ) ; if ( cpi -> lf_ref_frame [ mb_offset ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset - xd -> mode_info_stride - 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset - xd -> mode_info_stride - 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset - xd -> mode_info_stride - 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset - xd -> mode_info_stride - 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset - 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset - 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset - 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset - 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset + 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset + 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset + 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset + 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset + xd -> mode_info_stride + 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset + xd -> mode_info_stride + 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset + xd -> mode_info_stride + 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset + xd -> mode_info_stride + 1 ] ; } vcnt ++ ; } for ( i = 0 ; i < vcnt ; i ++ ) { if ( near_ref [ near_sadidx [ i ] ] != INTRA_FRAME ) { if ( here -> mbmi . ref_frame == near_ref [ near_sadidx [ i ] ] ) { mv . as_int = near_mvs [ near_sadidx [ i ] ] . as_int ; find = 1 ; if ( i < 3 ) * sr = 3 ; else * sr = 2 ; break ; } } } if ( ! find ) { for ( i = 0 ; i < vcnt ; i ++ ) { mvx [ i ] = near_mvs [ i ] . as_mv . row ; mvy [ i ] = near_mvs [ i ] . as_mv . col ; } insertsortmv ( mvx , vcnt ) ; insertsortmv ( mvy , vcnt ) ; mv . as_mv . row = mvx [ vcnt / 2 ] ; mv . as_mv . col = mvy [ vcnt / 2 ] ; <S2SV_StartBug> find = 1 ; <S2SV_EndBug> * sr = 0 ; } } mvp -> as_int = mv . as_int ; vp8_clamp_mv2 ( mvp , xd ) ; }
","<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> * sr =
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,109,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
311,CWE-264,"CWE-264 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; if ( sock -> type == SOCK_PACKET ) msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; else msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ; if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } <S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
","<S2SV_ModStart> 0 ; } aux . tp_padding = 0 ;
",torvalds@linux/13fcb7bd322164c67926ffe272846d4860196dc6,CVE-2011-2898,https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6,2012-05-24T23:55Z,110,<S2SV_ModStart> 0 ; } msg -> msg_namelen = 0 ;,0
314,CWE-190,"CWE-190 int bson_check_field_name ( bson * b , const char * string , <S2SV_StartBug> const int length ) { <S2SV_EndBug> return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }
","<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,111,"<S2SV_ModStart> string, const size_t <S2SV_ModEnd> length ) {",1
315,CWE-20,"CWE-20 struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { <S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> err_code = sctp_process_asconf_param ( asoc , asconf , <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> if ( SCTP_ERROR_NO_ERROR != err_code ) <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
","<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
",torvalds@linux/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,CVE-2014-3673,https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,2014-11-10T11:55Z,112,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
317,CWE-20,"CWE-20 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
","<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,113,<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;,0
319,CWE-617,"CWE-617 int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; <S2SV_StartBug> pci_populate_msicap ( & msicap , msgnum , 0 ) ; <S2SV_EndBug> return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }
","<S2SV_ModStart> msicap msicap ; return <S2SV_ModStart> , 0 ) || <S2SV_ModEnd> pci_emul_add_capability ( dev
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,114,<S2SV_ModStart> dev ) ; if <S2SV_ModEnd> ( buf,0
324,CWE-20,"CWE-20 int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { <S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
","<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,115,<S2SV_ModStart> <S2SV_null> <S,0
330,CWE-119,"CWE-119 static vpx_codec_err_t vp8e_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) ) <S2SV_EndBug> <S2SV_StartBug> && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; <S2SV_EndBug> if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ; res = validate_config ( ctx , cfg , & ctx -> vp8_cfg , 0 ) ; if ( ! res ) { ctx -> cfg = * cfg ; set_vp8e_config ( & ctx -> oxcf , ctx -> cfg , ctx -> vp8_cfg , NULL ) ; vp8_change_config ( ctx -> cpi , & ctx -> oxcf ) ; } return res ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> cfg -> g_w <S2SV_ModStart> cfg . g_w || <S2SV_ModEnd> cfg -> g_h <S2SV_ModStart> . g_h ) { if <S2SV_ModEnd> ( cfg -> <S2SV_ModStart> != VPX_RC_ONE_PASS ) <S2SV_ModEnd> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" <S2SV_ModStart> ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,116,,0
337,CWE-119,"CWE-119 void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { <S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cpi ) { <S2SV_ModEnd> vp9_init_plane_quantizers ( cpi <S2SV_ModStart> & cpi -> td .
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,117,<S2SV_ModStart> cpi ) { memset <S2SV_ModEnd> ( cpi ->,0
339,CWE-000,"CWE-000 static int em_call_far ( struct x86_emulate_ctxt * ctxt ) { u16 sel , old_cs ; ulong old_eip ; int rc ; <S2SV_StartBug> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <S2SV_EndBug> old_eip = ctxt -> _eip ; memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <S2SV_StartBug> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <S2SV_EndBug> return X86EMUL_CONTINUE ; <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; ctxt -> src . val = old_eip ; return em_push ( ctxt ) ; }
","<S2SV_ModStart> int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> , VCPU_SREG_CS ) <S2SV_ModStart> , VCPU_SREG_CS ) <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> 2 ) ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> ) return X86EMUL_CONTINUE <S2SV_ModStart> return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z,118,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static struct x86EMUL_CONTINUE <S2SV_ModEnd> ; rc = <S2SV_ModStart> return X86EMUL_CONTINUE ; rc = assign_eip_segment_eip ( ctxt, & old_desc, VCPU_SREG_CS ) ; if ( ctxt -> src. l ) return X86EMUL_CONTINUE ; if ( rc!= X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; rc = assign_eip = ctxt -> src. val ; if ( rc!= X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; rc = assign_eip = ctxt -> src. val ; if ( ctxt -> src. val!= X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; if ( ctxt -> src. val == X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; if ( rc!= X86EMUL_CONTINUE ; rc!= X86EMUL_CONTINUE ; rc!= X86EMUL_CONTINUE ; if ( rc!= X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; if ( rc!= X86EMUL_CONTINUE ; rc!= X86EMUL_CONTINUE )",0
343,CWE-000,"CWE-000 long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; <S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
","<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
",torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z,119,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( info,0
348,CWE-125,"CWE-125 GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }
","<S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; tmp_str =
",gpac@gpac/8e05648d6b4459facbc783025c5c42d301fef5c3,CVE-2020-23928,https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3,2021-04-21T18:15Z,120,"<S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_DECREASE_SIZE ( ptr, 1 ) <S2SV_ModStart> tmp_strsize ; } ISOM_DECREASE_DECREASE_DECREASE_DECREASE_DECREASE_SIZE ( ptr, 1 )",0
349,CWE-119,"CWE-119 vpx_fixed_buf_t * vpx_codec_get_global_headers ( vpx_codec_ctx_t * ctx ) { vpx_fixed_buf_t * buf = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_glob_hdrs ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> } return buf ; }
","<S2SV_ModStart> . get_glob_hdrs ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,121,,0
354,CWE-000,"CWE-000 void <S2SV_StartBug> nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> { <S2SV_StartBug> if ( state -> state == mode ) <S2SV_EndBug> return ; <S2SV_StartBug> if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( mode & FMODE_WRITE ) <S2SV_EndBug> list_move ( & state -> open_states , & state -> owner -> so_states ) ; else list_move_tail ( & state -> open_states , & state -> owner -> so_states ) ; } <S2SV_StartBug> state -> state = mode ; <S2SV_EndBug> }
","<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> state == fmode <S2SV_ModEnd> ) return ; <S2SV_ModStart> if ( ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> { if ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> -> state = fmode <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,122,"<S2SV_ModStart> * state, fmode_t fmode <S2SV_ModEnd> ) { switch <S2SV_ModStart> -> state & fmode <S2SV_ModEnd> ) ; }",0
357,CWE-416,"CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
",ImageMagick@ImageMagick/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,CVE-2016-10051,https://github.com/ImageMagick/ImageMagick/commit/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,2017-03-23T17:59Z,123,<S2SV_ModStart> ) break ; <S2SV_ModEnd> if ( c,0
360,CWE-120,"CWE-120 static size_t send_control_msg ( VirtIOSerial * vser , void * buf , size_t len ) { VirtQueueElement elem ; VirtQueue * vq ; vq = vser -> c_ivq ; if ( ! virtio_queue_ready ( vq ) ) { return 0 ; } if ( ! virtqueue_pop ( vq , & elem ) ) { return 0 ; } <S2SV_StartBug> memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ; <S2SV_EndBug> virtqueue_push ( vq , & elem , len ) ; virtio_notify ( VIRTIO_DEVICE ( vser ) , vq ) ; return len ; }
","<S2SV_ModStart> 0 ; } iov_from_buf <S2SV_ModEnd> ( elem . <S2SV_ModStart> elem . in_sg , elem . in_num , 0 <S2SV_ModEnd> , buf ,
",qemu@qemu/7882080388be5088e72c425b02223c02e6cb4295,CVE-2015-5745,https://github.com/qemu/qemu/commit/7882080388be5088e72c425b02223c02e6cb4295,2020-01-23T20:15Z,124,"<S2SV_ModStart>, buf, <S2SV_ModEnd> len )",0
361,CWE-000,"CWE-000 static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numguard<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numstepsizes<S2SV_blank>=<S2SV_blank>%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n"" , <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( qcd <S2SV_ModStart> i ] ) ) <S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( qcd <S2SV_ModStart> ] ) ) )
",mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z,125,,0
363,CWE-119,"CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixel<S2SV_blank>format<S2SV_blank>0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }
","<S2SV_ModStart> == 8 ) && c -> format != CHUNKY
",FFmpeg@FFmpeg/1e42736b95065c69a7481d0cf55247024f54b660,CVE-2017-9996,https://github.com/FFmpeg/FFmpeg/commit/1e42736b95065c69a7481d0cf55247024f54b660,2017-06-28T06:29Z,126,<S2SV_ModStart> ++ ) { if ( c -> height <= 8 ) return AVERROR_INVALIDDATA ;,0
364,CWE-125,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,127,"<S2SV_ModStart> p, length <S2SV_ModEnd> ) ; return",0
368,CWE-000,"CWE-000 static int fit_image_verify_sig ( const void * fit , int image_noffset , const char * data , size_t size , const void * sig_blob , int sig_offset ) { int noffset ; char * err_msg = """" ; int verified = 0 ; int ret ; fdt_for_each_subnode ( noffset , fit , image_noffset ) { <S2SV_StartBug> const char * name = fit_get_name ( fit , noffset , NULL ) ; <S2SV_EndBug> if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) { ret = fit_image_check_sig ( fit , noffset , data , size , - 1 , & err_msg ) ; if ( ret ) { puts ( ""-<S2SV_blank>"" ) ; } else { puts ( ""+<S2SV_blank>"" ) ; verified = 1 ; break ; } } } if ( noffset == - FDT_ERR_TRUNCATED || noffset == - FDT_ERR_BADSTRUCTURE ) { err_msg = ""Corrupted<S2SV_blank>or<S2SV_blank>truncated<S2SV_blank>tree"" ; goto error ; } return verified ? 0 : - EPERM ; error : printf ( ""<S2SV_blank>error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg , fit_get_name ( fit , noffset , NULL ) , fit_get_name ( fit , image_noffset , NULL ) ) ; return - 1 ; }
","<S2SV_ModStart> NULL ) ; if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto error ; }
",u-boot@u-boot/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,CVE-2021-27138,https://github.com/u-boot/u-boot/commit/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,2021-02-17T23:15Z,128,"<S2SV_ModStart>, * name <S2SV_ModEnd> ) ; if",0
370,CWE-401,"CWE-401 int cx23888_ir_probe ( struct cx23885_dev * dev ) { struct cx23888_ir_state * state ; struct v4l2_subdev * sd ; struct v4l2_subdev_ir_parameters default_params ; int ret ; state = kzalloc ( sizeof ( struct cx23888_ir_state ) , GFP_KERNEL ) ; if ( state == NULL ) return - ENOMEM ; spin_lock_init ( & state -> rx_kfifo_lock ) ; <S2SV_StartBug> if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> state -> dev = dev ; <S2SV_EndBug> sd = & state -> sd ; v4l2_subdev_init ( sd , & cx23888_ir_controller_ops ) ; v4l2_set_subdevdata ( sd , state ) ; snprintf ( sd -> name , sizeof ( sd -> name ) , ""%s/888-ir"" , dev -> name ) ; sd -> grp_id = CX23885_HW_888_IR ; ret = v4l2_device_register_subdev ( & dev -> v4l2_dev , sd ) ; if ( ret == 0 ) { cx23888_ir_write4 ( dev , CX23888_IR_IRQEN_REG , 0 ) ; mutex_init ( & state -> rx_params_lock ) ; default_params = default_rx_params ; v4l2_subdev_call ( sd , ir , rx_s_parameters , & default_params ) ; mutex_init ( & state -> tx_params_lock ) ; default_params = default_tx_params ; v4l2_subdev_call ( sd , ir , tx_s_parameters , & default_params ) ; } else { kfifo_free ( & state -> rx_kfifo ) ; } return ret ; }
","<S2SV_ModStart> GFP_KERNEL ) ) { kfree ( state ) ; <S2SV_ModStart> - ENOMEM ; }
",torvalds@linux/a7b2df76b42bdd026e3106cf2ba97db41345a177,CVE-2019-19054,https://github.com/torvalds/linux/commit/a7b2df76b42bdd026e3106cf2ba97db41345a177,2019-11-18T06:15Z,129,<S2SV_ModStart> ; ret = - EINVAL ; if (,0
373,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_dec_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . dec = cfg ; <S2SV_StartBug> res = VPX_CODEC_OK ; <S2SV_EndBug> if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> * iface , const <S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_POSTPROC ) && <S2SV_ModStart> ; res = <S2SV_ModEnd> ctx -> iface <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return SAVE_STATUS
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,130,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
375,CWE-20,"CWE-20 error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ; tja1100WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,131,,0
376,CWE-362,"CWE-362 void icmp_send ( struct sk_buff * skb_in , int type , int code , __be32 info ) { struct iphdr * iph ; int room ; struct icmp_bxm icmp_param ; struct rtable * rt = skb_rtable ( skb_in ) ; struct ipcm_cookie ipc ; __be32 saddr ; u8 tos ; struct net * net ; struct sock * sk ; if ( ! rt ) goto out ; net = dev_net ( rt -> dst . dev ) ; iph = ip_hdr ( skb_in ) ; if ( ( u8 * ) iph < skb_in -> head || ( skb_in -> network_header + sizeof ( * iph ) ) > skb_in -> tail ) goto out ; if ( skb_in -> pkt_type != PACKET_HOST ) goto out ; if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST ) ) goto out ; if ( iph -> frag_off & htons ( IP_OFFSET ) ) goto out ; if ( icmp_pointers [ type ] . error ) { if ( iph -> protocol == IPPROTO_ICMP ) { u8 _inner_type , * itp ; itp = skb_header_pointer ( skb_in , skb_network_header ( skb_in ) + ( iph -> ihl << 2 ) + offsetof ( struct icmphdr , type ) - skb_in -> data , sizeof ( _inner_type ) , & _inner_type ) ; if ( itp == NULL ) goto out ; if ( * itp > NR_ICMP_TYPES || icmp_pointers [ * itp ] . error ) goto out ; } } sk = icmp_xmit_lock ( net ) ; if ( sk == NULL ) return ; saddr = iph -> daddr ; if ( ! ( rt -> rt_flags & RTCF_LOCAL ) ) { struct net_device * dev = NULL ; rcu_read_lock ( ) ; if ( rt_is_input_route ( rt ) && net -> ipv4 . sysctl_icmp_errors_use_inbound_ifaddr ) dev = dev_get_by_index_rcu ( net , rt -> rt_iif ) ; if ( dev ) saddr = inet_select_addr ( dev , 0 , RT_SCOPE_LINK ) ; else saddr = 0 ; rcu_read_unlock ( ) ; } tos = icmp_pointers [ type ] . error ? ( ( iph -> tos & IPTOS_TOS_MASK ) | IPTOS_PREC_INTERNETCONTROL ) : iph -> tos ; <S2SV_StartBug> if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) ) <S2SV_EndBug> goto out_unlock ; icmp_param . data . icmph . type = type ; icmp_param . data . icmph . code = code ; icmp_param . data . icmph . un . gateway = info ; icmp_param . data . icmph . checksum = 0 ; icmp_param . skb = skb_in ; icmp_param . offset = skb_network_offset ( skb_in ) ; inet_sk ( sk ) -> tos = tos ; ipc . addr = iph -> saddr ; <S2SV_StartBug> ipc . opt = & icmp_param . replyopts ; <S2SV_EndBug> ipc . tx_flags = 0 ; rt = icmp_route_lookup ( net , skb_in , iph , saddr , tos , type , code , & icmp_param ) ; if ( IS_ERR ( rt ) ) goto out_unlock ; if ( ! icmpv4_xrlim_allow ( net , rt , type , code ) ) goto ende ; room = dst_mtu ( & rt -> dst ) ; if ( room > 576 ) room = 576 ; <S2SV_StartBug> room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ; <S2SV_EndBug> room -= sizeof ( struct icmphdr ) ; icmp_param . data_len = skb_in -> len - icmp_param . offset ; if ( icmp_param . data_len > room ) icmp_param . data_len = room ; icmp_param . head_len = sizeof ( struct icmphdr ) ; icmp_push_reply ( & icmp_param , & ipc , & rt ) ; ende : ip_rt_put ( rt ) ; out_unlock : icmp_xmit_unlock ( sk ) ; out : ; }
","<S2SV_ModStart> icmp_param . replyopts . opt . opt <S2SV_ModStart> icmp_param . replyopts . opt <S2SV_ModStart> . replyopts . opt . opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,132,<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if (,0
381,CWE-20,"CWE-20 static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
","<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,133,<S2SV_ModStart> ; if (,0
383,CWE-362,"CWE-362 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
","<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,134,<S2SV_ModStart> ; rq = <S2SV_ModEnd> off + rqs,0
384,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { int i ; void * mem_loc = NULL ; if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) { for ( i = 0 ; i < num_enc ; i ++ ) { vpx_codec_priv_enc_mr_cfg_t mr_cfg ; if ( dsf -> num < 1 || dsf -> num > 4096 || dsf -> den < 1 || dsf -> den > dsf -> num ) { res = VPX_CODEC_INVALID_PARAM ; break ; } mr_cfg . mr_low_res_mode_info = mem_loc ; mr_cfg . mr_total_resolutions = num_enc ; mr_cfg . mr_encoder_id = num_enc - 1 - i ; mr_cfg . mr_down_sampling_factor . num = dsf -> num ; mr_cfg . mr_down_sampling_factor . den = dsf -> den ; if ( mr_cfg . mr_encoder_id ) cfg -> kf_mode = VPX_KF_DISABLED ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , & mr_cfg ) ; if ( res ) { const char * error_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; while ( i ) { ctx -- ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; i -- ; } } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; if ( res ) break ; ctx ++ ; cfg ++ ; dsf ++ ; } ctx -- ; } } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && <S2SV_ModStart> } if ( <S2SV_ModEnd> res ) break
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,135,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( cfg,0
385,CWE-20,"CWE-20 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
","<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,136,<S2SV_ModStart> msg -> msg_namelen = 0,0
386,CWE-189,"CWE-189 static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
","<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
",torvalds@linux/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,CVE-2014-3145,https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,2014-05-11T21:55Z,137,<S2SV_ModStart> ; if ( skb -> len < sizeof ( skb ) ) return 0 ; if (,0
387,CWE-000,"CWE-000 static inline void encode_openhdr ( struct xdr_stream * xdr , const struct nfs_openargs * arg ) { __be32 * p ; RESERVE_SPACE ( 8 ) ; WRITE32 ( OP_OPEN ) ; WRITE32 ( arg -> seqid -> sequence -> counter ) ; <S2SV_StartBug> encode_share_access ( xdr , arg -> open_flags ) ; <S2SV_EndBug> RESERVE_SPACE ( 28 ) ; WRITE64 ( arg -> clientid ) ; WRITE32 ( 16 ) ; WRITEMEM ( ""open<S2SV_blank>id:"" , 8 ) ; WRITE64 ( arg -> id ) ; }
","<S2SV_ModStart> , arg -> fmode <S2SV_ModEnd> ) ; RESERVE_SPACE
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,138,"<S2SV_ModStart>, arg -> flags &",0
389,CWE-119,"CWE-119 static int readContigTilesIntoBuffer ( TIFF * in , uint8 * buf , uint32 imagelength , uint32 imagewidth , uint32 tw , uint32 tl , tsample_t spp , uint16 bps ) { int status = 1 ; tsample_t sample = 0 ; tsample_t count = spp ; uint32 row , col , trow ; uint32 nrow , ncol ; uint32 dst_rowsize , shift_width ; uint32 bytes_per_sample , bytes_per_pixel ; uint32 trailing_bits , prev_trailing_bits ; uint32 tile_rowsize = TIFFTileRowSize ( in ) ; uint32 src_offset , dst_offset ; uint32 row_offset , col_offset ; uint8 * bufp = ( uint8 * ) buf ; unsigned char * src = NULL ; unsigned char * dst = NULL ; tsize_t tbytes = 0 , tile_buffsize = 0 ; tsize_t tilesize = TIFFTileSize ( in ) ; unsigned char * tilebuf = NULL ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( ( bps % 8 ) == 0 ) shift_width = 0 ; else { if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; } tile_buffsize = tilesize ; if ( tilesize == 0 || tile_rowsize == 0 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Tile<S2SV_blank>size<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero"" ) ; exit ( - 1 ) ; } if ( tilesize < ( tsize_t ) ( tl * tile_rowsize ) ) { # ifdef DEBUG2 TIFFError ( ""readContigTilesIntoBuffer"" , ""Tilesize<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>alternate<S2SV_blank>calculation<S2SV_blank>%u"" , tilesize , tl * tile_rowsize ) ; # endif tile_buffsize = tl * tile_rowsize ; if ( tl != ( tile_buffsize / tile_rowsize ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } } <S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> if ( tilebuf == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ; for ( row = 0 ; row < imagelength ; row += tl ) { nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; for ( col = 0 ; col < imagewidth ; col += tw ) { tbytes = TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) ; if ( tbytes < tilesize && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>row<S2SV_blank>%lu<S2SV_blank>col<S2SV_blank>%lu,<S2SV_blank>Read<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row , ( unsigned long ) tbytes , ( unsigned long ) tilesize ) ; status = 0 ; _TIFFfree ( tilebuf ) ; return status ; } row_offset = row * dst_rowsize ; col_offset = ( ( col * bps * spp ) + 7 ) / 8 ; bufp = buf + row_offset + col_offset ; if ( col + tw > imagewidth ) ncol = imagewidth - col ; else ncol = tw ; if ( ( ( bps % 8 ) == 0 ) && ( count == spp ) ) { for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; _TIFFmemcpy ( bufp , tilebuf + src_offset , ( ncol * spp * bps ) / 8 ) ; bufp += ( imagewidth * bps * spp ) / 8 ; } } else { prev_trailing_bits = trailing_bits = 0 ; trailing_bits = ( ncol * bps * spp ) % 8 ; for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; src = tilebuf + src_offset ; dst_offset = ( row + trow ) * dst_rowsize ; dst = buf + dst_offset + col_offset ; switch ( shift_width ) { case 0 : if ( extractContigSamplesBytes ( src , dst , ncol , sample , spp , bps , count , 0 , ncol ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 1 : if ( bps == 1 ) { if ( extractContigSamplesShifted8bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; } else if ( extractContigSamplesShifted16bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 2 : if ( extractContigSamplesShifted24bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 3 : case 4 : case 5 : if ( extractContigSamplesShifted32bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; default : TIFFError ( ""readContigTilesIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return 1 ; } } prev_trailing_bits += trailing_bits ; } } } _TIFFfree ( tilebuf ) ; return status ; }
","<S2SV_ModStart> ; } } if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } <S2SV_ModStart> _TIFFmalloc ( tile_buffsize + 3 <S2SV_ModStart> 0 ) return 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] =
",vadz@libtiff/ae9365db1b271b62b35ce018eac8799b1d5e8a53,CVE-2016-9539,https://github.com/vadz/libtiff/commit/ae9365db1b271b62b35ce018eac8799b1d5e8a53,2016-11-22T19:59Z,139,<S2SV_ModStart> ; tile_buffsize =,0
391,CWE-617,"CWE-617 <S2SV_StartBug> static void <S2SV_EndBug> modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) { int error ; struct inout_port iop ; struct mem_range mr ; if ( is_pci_gvt ( dev ) ) { printf ( ""modify_bar_registration:<S2SV_blank>bypass<S2SV_blank>for<S2SV_blank>pci-gvt\\n"" ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } switch ( dev -> bar [ idx ] . type ) { case PCIBAR_IO : bzero ( & iop , sizeof ( struct inout_port ) ) ; iop . name = dev -> name ; iop . port = dev -> bar [ idx ] . addr ; iop . size = dev -> bar [ idx ] . size ; if ( registration ) { iop . flags = IOPORT_F_INOUT ; iop . handler = pci_emul_io_handler ; iop . arg = dev ; error = register_inout ( & iop ) ; } else error = unregister_inout ( & iop ) ; break ; case PCIBAR_MEM32 : case PCIBAR_MEM64 : bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = dev -> name ; mr . base = dev -> bar [ idx ] . addr ; mr . size = dev -> bar [ idx ] . size ; if ( registration ) { mr . flags = MEM_F_RW ; mr . handler = pci_emul_mem_handler ; mr . arg1 = dev ; mr . arg2 = idx ; error = register_mem ( & mr ) ; } else error = unregister_mem ( & mr ) ; break ; default : error = EINVAL ; break ; } <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> modify_bar_registration ( struct <S2SV_ModStart> ) ; return 0 <S2SV_ModStart> break ; } return error <S2SV_ModEnd> ; } <S2SV_null>
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,140,<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,0
393,CWE-119,"CWE-119 PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( ""ptaReadStream"" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( ! strcmp ( typestr , ""float"" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( ""pta<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n"" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>floats"" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>ints"" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }
","<S2SV_ModStart> ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> , & n
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z,141,"<S2SV_ModStart> ( fp ) <S2SV_ModEnd> ( fp,",0
394,CWE-125,"CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
","<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
",radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z,142,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
396,CWE-20,"CWE-20 error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { connection -> request . version = HTTP_VERSION_1_1 ; connection -> request . keepAlive = TRUE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }
","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,143,"<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token,",1
398,CWE-125,"CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/e01c9bf76740802025c9328901b55ee4a0c49ed6,CVE-2018-14880,https://github.com/the-tcpdump-group/tcpdump/commit/e01c9bf76740802025c9328901b55ee4a0c49ed6,2019-10-03T16:15Z,144,<S2SV_ModStart> ) ) { ND_TCHECK_16BITS ( 2 ) ;,0
401,CWE-416,"CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z,145,<S2SV_ModStart> 1 ) ; if (!,0
407,CWE-119,"CWE-119 <S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
","<S2SV_ModStart> void vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree , unsigned
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,146,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
410,CWE-284,"CWE-284 void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..."" , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>"" ""dev_status<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]"" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) { <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; } p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; break ; } p_dev = NULL ; } if ( p_dev == NULL ) { for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { p_dev = & btif_hh_cb . devices [ i ] ; p_dev -> dev_handle = dev_handle ; p_dev -> attr_mask = attr_mask ; p_dev -> sub_class = sub_class ; p_dev -> app_id = app_id ; p_dev -> local_vup = FALSE ; btif_hh_cb . device_num ++ ; <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else { APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; } break ; } } } if ( p_dev == NULL ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected"" , __FUNCTION__ ) ; return ; } p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; }
","<S2SV_ModStart> -> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_CLOEXEC ) ) <S2SV_ModStart> -> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_CLOEXEC ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,147,"<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart>, 0 ) )",0
417,CWE-264,"CWE-264 static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; <S2SV_StartBug> u64 msr_data ; <S2SV_EndBug> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; <S2SV_StartBug> cs . dpl = 3 ; <S2SV_EndBug> ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; <S2SV_StartBug> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <S2SV_EndBug> return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> ; u64 msr_data , rcx , rdx <S2SV_ModStart> = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> -> _eip = rdx <S2SV_ModEnd> ; * reg_write <S2SV_ModStart> VCPU_REGS_RSP ) = rcx <S2SV_ModEnd> ; return X86EMUL_CONTINUE
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z,148,"<S2SV_ModStart> ; u16 ) ; u64 <S2SV_ModEnd> = X86EMUL_REGS_PROT64 <S2SV_ModStart> = X86EMUL_REGS_PROT64 ; rcx = rcx = rcx -> rdx <S2SV_ModStart> = X86EMUL_REGS_REGS_REGS_REGS_REGS_PROT64 ; rcx = rcx <S2SV_ModEnd> ( ctxt,",0
421,CWE-119,"CWE-119 <S2SV_StartBug> static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs , <S2SV_EndBug> int i , int c ) { <S2SV_StartBug> const vp9_prob prob = probs [ i / 2 ] ; <S2SV_EndBug> int b ; for ( b = 0 ; b <= 1 ; ++ b ) { const int cc = c + vp9_cost_bit ( prob , b ) ; <S2SV_StartBug> const vp9_tree_index ii = tree [ i + b ] ; <S2SV_EndBug> if ( ii <= 0 ) costs [ - ii ] = cc ; else cost ( costs , tree , probs , ii , cc ) ; } }
","<S2SV_ModStart> * costs , vpx_tree <S2SV_ModEnd> tree , const <S2SV_ModStart> tree , const vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> ) { const vpx_prob <S2SV_ModEnd> prob = probs <S2SV_ModStart> ) ; const vpx_tree_index <S2SV_ModEnd> ii = tree
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,149,"<S2SV_ModStart> int probs, vpx_prob <S2SV_ModEnd> * probs, <S2SV_ModStart> * probs, vpx_prob <S2SV_ModEnd> p ) {",0
424,CWE-119,"CWE-119 <S2SV_StartBug> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <S2SV_EndBug> __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in0 + 8 , stride ) ; output += 8 ; write_buffer_8x8 ( output , in1 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in1 + 8 , stride ) ; }
","<S2SV_ModStart> void write_buffer_16x16 ( tran_low_t <S2SV_ModEnd> * output ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,150,"<S2SV_ModStart> * output, tran_low_t <S2SV_ModEnd> * output,",0
425,CWE-189,"CWE-189 int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( ""sequencer_write(dev=%d,<S2SV_blank>count=%d)\\n"" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; <S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>Invalid<S2SV_blank>level<S2SV_blank>2<S2SV_blank>event<S2SV_blank>%x\\n"" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>4<S2SV_blank>byte<S2SV_blank>event<S2SV_blank>in<S2SV_blank>level<S2SV_blank>2<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ] != SEQ_MIDIPUTC ) obsolete_api_used = 1 ; } if ( event_rec [ 0 ] == SEQ_MIDIPUTC ) { if ( ! midi_opened [ event_rec [ 2 ] ] ) { int err , mode ; int dev = event_rec [ 2 ] ; if ( dev >= max_mididev || midi_devs [ dev ] == NULL ) { return - ENXIO ; } mode = translate_mode ( file ) ; if ( ( err = midi_devs [ dev ] -> open ( dev , mode , sequencer_midi_input , sequencer_midi_output ) ) < 0 ) { seq_reset ( ) ; printk ( KERN_WARNING ""Sequencer<S2SV_blank>Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Midi<S2SV_blank>#%d\\n"" , dev ) ; return err ; } midi_opened [ dev ] = 1 ; } } if ( ! seq_queue ( event_rec , ( file -> f_flags & ( O_NONBLOCK ) ? 1 : 0 ) ) ) { int processed = count - c ; if ( ! seq_playing ) seq_startplay ( ) ; if ( ! processed && ( file -> f_flags & O_NONBLOCK ) ) return - EAGAIN ; else return processed ; } p += ev_size ; c -= ev_size ; } if ( ! seq_playing ) seq_startplay ( ) ; out : return count ; }
","<S2SV_ModStart> fmt , buf + p <S2SV_ModEnd> , c ,
",torvalds@linux/b769f49463711205d57286e64cf535ed4daf59e9,CVE-2011-1476,https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9,2012-06-21T23:55Z,151,<S2SV_ModStart> ; if ( len < 0 ||,0
429,CWE-119,"CWE-119 <S2SV_StartBug> static void fadst16 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ; <S2SV_EndBug> <S2SV_StartBug> int x0 = input [ 15 ] ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 13 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> int x8 = input [ 7 ] ; <S2SV_EndBug> <S2SV_StartBug> int x9 = input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int x10 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x11 = input [ 10 ] ; <S2SV_EndBug> <S2SV_StartBug> int x12 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x13 = input [ 12 ] ; <S2SV_EndBug> <S2SV_StartBug> int x14 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x15 = input [ 14 ] ; <S2SV_EndBug> s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ; s1 = x0 * cospi_31_64 - x1 * cospi_1_64 ; s2 = x2 * cospi_5_64 + x3 * cospi_27_64 ; s3 = x2 * cospi_27_64 - x3 * cospi_5_64 ; s4 = x4 * cospi_9_64 + x5 * cospi_23_64 ; s5 = x4 * cospi_23_64 - x5 * cospi_9_64 ; s6 = x6 * cospi_13_64 + x7 * cospi_19_64 ; s7 = x6 * cospi_19_64 - x7 * cospi_13_64 ; s8 = x8 * cospi_17_64 + x9 * cospi_15_64 ; s9 = x8 * cospi_15_64 - x9 * cospi_17_64 ; s10 = x10 * cospi_21_64 + x11 * cospi_11_64 ; s11 = x10 * cospi_11_64 - x11 * cospi_21_64 ; s12 = x12 * cospi_25_64 + x13 * cospi_7_64 ; s13 = x12 * cospi_7_64 - x13 * cospi_25_64 ; s14 = x14 * cospi_29_64 + x15 * cospi_3_64 ; s15 = x14 * cospi_3_64 - x15 * cospi_29_64 ; x0 = fdct_round_shift ( s0 + s8 ) ; x1 = fdct_round_shift ( s1 + s9 ) ; x2 = fdct_round_shift ( s2 + s10 ) ; x3 = fdct_round_shift ( s3 + s11 ) ; x4 = fdct_round_shift ( s4 + s12 ) ; x5 = fdct_round_shift ( s5 + s13 ) ; x6 = fdct_round_shift ( s6 + s14 ) ; x7 = fdct_round_shift ( s7 + s15 ) ; x8 = fdct_round_shift ( s0 - s8 ) ; x9 = fdct_round_shift ( s1 - s9 ) ; x10 = fdct_round_shift ( s2 - s10 ) ; x11 = fdct_round_shift ( s3 - s11 ) ; x12 = fdct_round_shift ( s4 - s12 ) ; x13 = fdct_round_shift ( s5 - s13 ) ; x14 = fdct_round_shift ( s6 - s14 ) ; x15 = fdct_round_shift ( s7 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 ; s5 = x5 ; s6 = x6 ; s7 = x7 ; s8 = x8 * cospi_4_64 + x9 * cospi_28_64 ; s9 = x8 * cospi_28_64 - x9 * cospi_4_64 ; s10 = x10 * cospi_20_64 + x11 * cospi_12_64 ; s11 = x10 * cospi_12_64 - x11 * cospi_20_64 ; s12 = - x12 * cospi_28_64 + x13 * cospi_4_64 ; s13 = x12 * cospi_4_64 + x13 * cospi_28_64 ; s14 = - x14 * cospi_12_64 + x15 * cospi_20_64 ; s15 = x14 * cospi_20_64 + x15 * cospi_12_64 ; x0 = s0 + s4 ; x1 = s1 + s5 ; x2 = s2 + s6 ; x3 = s3 + s7 ; x4 = s0 - s4 ; x5 = s1 - s5 ; x6 = s2 - s6 ; x7 = s3 - s7 ; x8 = fdct_round_shift ( s8 + s12 ) ; x9 = fdct_round_shift ( s9 + s13 ) ; x10 = fdct_round_shift ( s10 + s14 ) ; x11 = fdct_round_shift ( s11 + s15 ) ; x12 = fdct_round_shift ( s8 - s12 ) ; x13 = fdct_round_shift ( s9 - s13 ) ; x14 = fdct_round_shift ( s10 - s14 ) ; x15 = fdct_round_shift ( s11 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 * cospi_8_64 + x5 * cospi_24_64 ; s5 = x4 * cospi_24_64 - x5 * cospi_8_64 ; s6 = - x6 * cospi_24_64 + x7 * cospi_8_64 ; s7 = x6 * cospi_8_64 + x7 * cospi_24_64 ; s8 = x8 ; s9 = x9 ; s10 = x10 ; s11 = x11 ; s12 = x12 * cospi_8_64 + x13 * cospi_24_64 ; s13 = x12 * cospi_24_64 - x13 * cospi_8_64 ; s14 = - x14 * cospi_24_64 + x15 * cospi_8_64 ; s15 = x14 * cospi_8_64 + x15 * cospi_24_64 ; x0 = s0 + s2 ; x1 = s1 + s3 ; x2 = s0 - s2 ; x3 = s1 - s3 ; x4 = fdct_round_shift ( s4 + s6 ) ; x5 = fdct_round_shift ( s5 + s7 ) ; x6 = fdct_round_shift ( s4 - s6 ) ; x7 = fdct_round_shift ( s5 - s7 ) ; x8 = s8 + s10 ; x9 = s9 + s11 ; x10 = s8 - s10 ; x11 = s9 - s11 ; x12 = fdct_round_shift ( s12 + s14 ) ; x13 = fdct_round_shift ( s13 + s15 ) ; x14 = fdct_round_shift ( s12 - s14 ) ; x15 = fdct_round_shift ( s13 - s15 ) ; s2 = ( - cospi_16_64 ) * ( x2 + x3 ) ; s3 = cospi_16_64 * ( x2 - x3 ) ; s6 = cospi_16_64 * ( x6 + x7 ) ; s7 = cospi_16_64 * ( - x6 + x7 ) ; s10 = cospi_16_64 * ( x10 + x11 ) ; s11 = cospi_16_64 * ( - x10 + x11 ) ; s14 = ( - cospi_16_64 ) * ( x14 + x15 ) ; s15 = cospi_16_64 * ( x14 - x15 ) ; x2 = fdct_round_shift ( s2 ) ; x3 = fdct_round_shift ( s3 ) ; x6 = fdct_round_shift ( s6 ) ; x7 = fdct_round_shift ( s7 ) ; x10 = fdct_round_shift ( s10 ) ; x11 = fdct_round_shift ( s11 ) ; x14 = fdct_round_shift ( s14 ) ; x15 = fdct_round_shift ( s15 ) ; <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x8 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x12 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = x14 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x10 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 8 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 9 ] = x11 ; <S2SV_EndBug> <S2SV_StartBug> output [ 10 ] = x15 ; <S2SV_EndBug> <S2SV_StartBug> output [ 11 ] = x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 12 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 13 ] = - x13 ; <S2SV_EndBug> <S2SV_StartBug> output [ 14 ] = x9 ; <S2SV_EndBug> <S2SV_StartBug> output [ 15 ] = - x1 ; <S2SV_EndBug> }
","<S2SV_ModStart> fadst16 ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output ) <S2SV_ModStart> output ) { tran_high_t <S2SV_ModEnd> s0 , s1 <S2SV_ModStart> s7 , s8 ; tran_high_t <S2SV_ModEnd> s9 , s10 <S2SV_ModStart> , s15 ; tran_high_t <S2SV_ModEnd> x0 = input <S2SV_ModStart> 15 ] ; tran_high_t <S2SV_ModEnd> x1 = input <S2SV_ModStart> 0 ] ; tran_high_t <S2SV_ModEnd> x2 = input <S2SV_ModStart> 13 ] ; tran_high_t <S2SV_ModEnd> x3 = input <S2SV_ModStart> 2 ] ; tran_high_t <S2SV_ModEnd> x4 = input <S2SV_ModStart> 11 ] ; tran_high_t <S2SV_ModEnd> x5 = input <S2SV_ModStart> 4 ] ; tran_high_t <S2SV_ModEnd> x6 = input <S2SV_ModStart> 9 ] ; tran_high_t <S2SV_ModEnd> x7 = input <S2SV_ModStart> 6 ] ; tran_high_t <S2SV_ModEnd> x8 = input <S2SV_ModStart> 7 ] ; tran_high_t <S2SV_ModEnd> x9 = input <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> x10 = input <S2SV_ModStart> 5 ] ; tran_high_t <S2SV_ModEnd> x11 = input <S2SV_ModStart> 10 ] ; tran_high_t <S2SV_ModEnd> x12 = input <S2SV_ModStart> 3 ] ; tran_high_t <S2SV_ModEnd> x13 = input <S2SV_ModStart> 12 ] ; tran_high_t <S2SV_ModEnd> x14 = input <S2SV_ModStart> 1 ] ; tran_high_t <S2SV_ModEnd> x15 = input <S2SV_ModStart> 0 ] = ( tran_low_t ) <S2SV_ModStart> 1 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] = ( tran_low_t ) <S2SV_ModStart> 3 ] = ( tran_low_t ) <S2SV_ModStart> 4 ] = ( tran_low_t ) <S2SV_ModStart> 5 ] = ( tran_low_t ) <S2SV_ModStart> 6 ] = ( tran_low_t ) <S2SV_ModStart> 7 ] = ( tran_low_t ) <S2SV_ModStart> 8 ] = ( tran_low_t ) <S2SV_ModStart> 9 ] = ( tran_low_t ) <S2SV_ModStart> 10 ] = ( tran_low_t ) <S2SV_ModStart> 11 ] = ( tran_low_t ) <S2SV_ModStart> 12 ] = ( tran_low_t ) <S2SV_ModStart> 13 ] = ( tran_low_t ) <S2SV_ModStart> 14 ] = ( tran_low_t ) <S2SV_ModStart> 15 ] = ( tran_low_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,152,<S2SV_ModStart> <S2SV_null,0
430,CWE-119,"CWE-119 int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ; <S2SV_StartBug> # if HAVE_EDSP <S2SV_EndBug> flags |= HAS_EDSP ; # endif # if HAVE_MEDIA flags |= HAS_MEDIA ; # endif <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> flags |= HAS_NEON ; # endif return flags & mask ; }
","<S2SV_ModStart> ; # if <S2SV_ModEnd> HAVE_MEDIA flags |= <S2SV_ModStart> # if HAVE_NEON || HAVE_NEON_ASM
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,153,<S2SV_ModStart> flags ; } <S2SV_ModEnd> if ( flags,0
431,CWE-119,"CWE-119 <S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> const MODE_INFO * left_mi , int b ) { if ( b == 0 || b == 2 ) { if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( left_mi , b + 1 ) ; } else { assert ( b == 1 || b == 3 ) ; return cur_mi -> bmi [ b - 1 ] . as_mode ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode ( const
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,154,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
433,CWE-416,"CWE-416 struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; <S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,155,"<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt, 1 ) ;",1
437,CWE-269,"CWE-269 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> flag & CL_UNPRIVILEGED <S2SV_ModStart> & CL_UNPRIVILEGED ) { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> ( mnt -> <S2SV_ModStart> mnt_flags & MNT_READONLY <S2SV_ModEnd> ) mnt -> <S2SV_ModStart> ; if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if (
",torvalds@linux/9566d6742852c527bf5af38af5cbb878dad75705,CVE-2014-5207,https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705,2014-08-18T11:15Z,156,<S2SV_ModStart> ; if ( mnt -> mnt. mnt. mnt. mnt.,0
444,CWE-119,"CWE-119 <S2SV_StartBug> static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> const int mis = cm -> mi_stride ; int bw , bh ; const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_StartBug> bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> <S2SV_StartBug> bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> if ( bw == bs && bh == bs ) { <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ; } else if ( bw == bs && bh < bs ) { <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ; <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts , <S2SV_EndBug> temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ; } else if ( bw < bs && bh == bs ) { <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ; <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs , <S2SV_EndBug> no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ; } else { const BLOCK_SIZE subsize = subsize_lookup [ PARTITION_SPLIT ] [ bsize ] ; int n ; assert ( bw < bs && bh < bs ) ; for ( n = 0 ; n < 4 ; n ++ ) { const int mi_dc = hbs * ( n & 1 ) ; const int mi_dr = hbs * ( n >> 1 ) ; <S2SV_StartBug> count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] , <S2SV_EndBug> no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ; } } }
","<S2SV_ModStart> void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> const TileInfo * <S2SV_ModStart> const TileInfo * tile , <S2SV_ModEnd> MODE_INFO * * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> , int * <S2SV_ModStart> bsize ) { <S2SV_ModEnd> const int mis <S2SV_ModStart> = num_8x8_blocks_wide_lookup [ mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = num_8x8_blocks_high_lookup [ mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , <S2SV_ModStart> { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , <S2SV_ModStart> ; count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs * <S2SV_ModStart> { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , <S2SV_ModStart> ; count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs , <S2SV_ModStart> ; count_segs_sb ( cm , xd <S2SV_ModEnd> , tile , <S2SV_ModStart> tile , & mi <S2SV_ModEnd> [ mi_dr *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,157,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
445,CWE-254,"CWE-254 void processInputBuffer ( client * c ) { server . current_client = c ; while ( sdslen ( c -> querybuf ) ) { if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ; if ( c -> flags & CLIENT_BLOCKED ) break ; <S2SV_StartBug> if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; <S2SV_EndBug> if ( ! c -> reqtype ) { if ( c -> querybuf [ 0 ] == '*' ) { c -> reqtype = PROTO_REQ_MULTIBULK ; } else { c -> reqtype = PROTO_REQ_INLINE ; } } if ( c -> reqtype == PROTO_REQ_INLINE ) { if ( processInlineBuffer ( c ) != C_OK ) break ; } else if ( c -> reqtype == PROTO_REQ_MULTIBULK ) { if ( processMultibulkBuffer ( c ) != C_OK ) break ; } else { serverPanic ( ""Unknown<S2SV_blank>request<S2SV_blank>type"" ) ; } if ( c -> argc == 0 ) { resetClient ( c ) ; } else { if ( processCommand ( c ) == C_OK ) resetClient ( c ) ; if ( server . current_client == NULL ) break ; } } server . current_client = NULL ; }
","<S2SV_ModStart> -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ) break ;
",antirez@redis/874804da0c014a7d704b3d285aa500098a931f50,CVE-2016-10517,https://github.com/antirez/redis/commit/874804da0c014a7d704b3d285aa500098a931f50,2017-10-24T18:29Z,158,,0
446,CWE-000,"CWE-000 static int mpage_da_map_blocks ( struct mpage_da_data * mpd ) { int err , blks , get_blocks_flags ; struct buffer_head new ; sector_t next = mpd -> b_blocknr ; unsigned max_blocks = mpd -> b_size >> mpd -> inode -> i_blkbits ; loff_t disksize = EXT4_I ( mpd -> inode ) -> i_disksize ; handle_t * handle = NULL ; if ( ( mpd -> b_state & ( 1 << BH_Mapped ) ) && ! ( mpd -> b_state & ( 1 << BH_Delay ) ) && ! ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) return 0 ; if ( ! mpd -> b_size ) return 0 ; handle = ext4_journal_current_handle ( ) ; BUG_ON ( ! handle ) ; new . b_state = 0 ; <S2SV_StartBug> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; <S2SV_EndBug> if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ; blks = ext4_get_blocks ( handle , mpd -> inode , next , max_blocks , & new , get_blocks_flags ) ; if ( blks < 0 ) { err = blks ; if ( err == - EAGAIN ) return 0 ; if ( err == - ENOSPC && ext4_count_free_blocks ( mpd -> inode -> i_sb ) ) { mpd -> retval = err ; return 0 ; } ext4_msg ( mpd -> inode -> i_sb , KERN_CRIT , ""delayed<S2SV_blank>block<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>at<S2SV_blank>"" ""logical<S2SV_blank>offset<S2SV_blank>%llu<S2SV_blank>with<S2SV_blank>max<S2SV_blank>blocks<S2SV_blank>%zd<S2SV_blank>with<S2SV_blank>"" ""error<S2SV_blank>%d\\n"" , mpd -> inode -> i_ino , ( unsigned long long ) next , mpd -> b_size >> mpd -> inode -> i_blkbits , err ) ; printk ( KERN_CRIT ""This<S2SV_blank>should<S2SV_blank>not<S2SV_blank>happen!!<S2SV_blank><S2SV_blank>"" ""Data<S2SV_blank>will<S2SV_blank>be<S2SV_blank>lost\\n"" ) ; if ( err == - ENOSPC ) { ext4_print_free_blocks ( mpd -> inode ) ; } ext4_da_block_invalidatepages ( mpd , next , mpd -> b_size >> mpd -> inode -> i_blkbits ) ; return err ; } BUG_ON ( blks == 0 ) ; new . b_size = ( blks << mpd -> inode -> i_blkbits ) ; if ( buffer_new ( & new ) ) __unmap_underlying_blocks ( mpd -> inode , & new ) ; if ( ( mpd -> b_state & ( 1 << BH_Delay ) ) || ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) mpage_put_bnr_to_bhs ( mpd , next , & new ) ; if ( ext4_should_order_data ( mpd -> inode ) ) { err = ext4_jbd2_file_inode ( handle , mpd -> inode ) ; if ( err ) return err ; } disksize = ( ( loff_t ) next + blks ) << mpd -> inode -> i_blkbits ; if ( disksize > i_size_read ( mpd -> inode ) ) disksize = i_size_read ( mpd -> inode ) ; if ( disksize > EXT4_I ( mpd -> inode ) -> i_disksize ) { ext4_update_i_disksize ( mpd -> inode , disksize ) ; return ext4_mark_inode_dirty ( handle , mpd -> inode ) ; } return 0 ; }
","<S2SV_ModStart> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,159,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return 0 ;,0
450,CWE-552,"CWE-552 static int _hostresolver_getaddrinfo ( oe_resolver_t * resolver , const char * node , const char * service , const struct oe_addrinfo * hints , struct oe_addrinfo * * res ) { int ret = OE_EAI_FAIL ; uint64_t handle = 0 ; struct oe_addrinfo * head = NULL ; struct oe_addrinfo * tail = NULL ; struct oe_addrinfo * p = NULL ; OE_UNUSED ( resolver ) ; if ( res ) * res = NULL ; if ( ! res ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } { int retval = OE_EAI_FAIL ; if ( oe_syscall_getaddrinfo_open_ocall ( & retval , node , service , hints , & handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ! handle ) { ret = retval ; goto done ; } } for ( ; ; ) { int retval = 0 ; <S2SV_StartBug> size_t canonnamelen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) <S2SV_EndBug> { ret = OE_EAI_MEMORY ; goto done ; } if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , <S2SV_StartBug> & p -> ai_flags , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_family , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_socktype , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_protocol , <S2SV_EndBug> p -> ai_addrlen , <S2SV_StartBug> & p -> ai_addrlen , <S2SV_EndBug> NULL , <S2SV_StartBug> canonnamelen , <S2SV_EndBug> & canonnamelen , NULL ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( retval == 1 ) break ; if ( retval != - 1 || oe_errno != OE_ENAMETOOLONG ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; } <S2SV_StartBug> if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) <S2SV_EndBug> { ret = OE_EAI_MEMORY ; goto done ; } <S2SV_StartBug> if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) <S2SV_EndBug> { ret = OE_EAI_MEMORY ; goto done ; } <S2SV_StartBug> if ( oe_syscall_getaddrinfo_read_ocall ( <S2SV_EndBug> & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol , <S2SV_StartBug> p -> ai_addrlen , <S2SV_EndBug> & p -> ai_addrlen , p -> ai_addr , <S2SV_StartBug> canonnamelen , <S2SV_EndBug> & canonnamelen , p -> ai_canonname ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( tail ) <S2SV_EndBug> { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 ; if ( oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } handle = 0 ; if ( retval != 0 ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; } } if ( ! head ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } * res = head ; head = NULL ; tail = NULL ; ret = 0 ; done : if ( handle ) { int retval ; oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) ; } if ( head ) oe_freeaddrinfo ( head ) ; if ( p ) oe_freeaddrinfo ( p ) ; return ret ; }
","<S2SV_ModStart> 0 ; size_t canonnamelen_in <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; size_t canonnamelen_out = 0 ; struct oe_addrinfo p_out ; memset ( & p_out , 0 , sizeof ( struct oe_addrinfo ) ) ; <S2SV_ModEnd> if ( oe_syscall_getaddrinfo_read_ocall <S2SV_ModStart> handle , & p_out . <S2SV_ModEnd> ai_flags , & <S2SV_ModStart> ai_flags , & p_out . <S2SV_ModEnd> ai_family , & <S2SV_ModStart> ai_family , & p_out . <S2SV_ModEnd> ai_socktype , & <S2SV_ModStart> ai_socktype , & p_out . ai_protocol , p_out . <S2SV_ModEnd> ai_addrlen , & <S2SV_ModStart> ai_addrlen , & p_out . <S2SV_ModEnd> ai_addrlen , NULL <S2SV_ModStart> , NULL , canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ) ; } switch ( p_out . ai_family ) { case OE_AF_INET : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; case OE_AF_INET6 : case OE_AF_INET6_WIN : case OE_AF_UNSPEC : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr_in6 ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; default : ret = OE_EAI_FAIL ; goto done ; } if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) { ret = OE_EAI_MEMORY ; goto done ; } if ( p_out . <S2SV_ModEnd> ai_addrlen && ! <S2SV_ModStart> ( 1 , p_out . <S2SV_ModEnd> ai_addrlen ) ) <S2SV_ModStart> } if ( canonnamelen_out <S2SV_ModEnd> && ! ( <S2SV_ModStart> ( 1 , canonnamelen_out <S2SV_ModEnd> ) ) ) <S2SV_ModStart> done ; } canonnamelen_in = canonnamelen_out ; <S2SV_ModStart> -> ai_protocol , p_out . <S2SV_ModEnd> ai_addrlen , & <S2SV_ModStart> -> ai_addr , canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> , p -> <S2SV_ModStart> } if ( ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\0' ) ) { ret = OE_EAI_FAIL ; goto done ; } if ( tail ) { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 <S2SV_ModEnd> ; if (
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,160,<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> OE_RAISE_EINVAL ; ret = 0 ; if ( ssize_t ) ret = 0 ; if ( ret > OE_EINVAL ) { ret = - EINVAL ; OE_RAISE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ssize_t ) ret = 0 ;,0
451,CWE-20,"CWE-20 void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; <S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,161,"<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token,",0
453,CWE-119,"CWE-119 void vp8_default_coef_probs ( VP8_COMMON * pc ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> sizeof ( default_coef_probs ) ) ; }
","<S2SV_ModStart> pc ) { memcpy <S2SV_ModEnd> ( pc ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,162,<S2SV_ModStart> size ) { memcpy <S2SV_ModEnd> ( pc ->,0
454,CWE-119,"CWE-119 <S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z,163,"<S2SV_ModStart> data ) { u8 * buf ; int ret ; if (! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart>, size, buf <S2SV_ModEnd>, buf",0
455,CWE-125,"CWE-125 mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }
","<S2SV_ModStart> asdl_seq * body , asdl_seq * type_ignores <S2SV_ModStart> = body ; p -> v . Module . type_ignores = type_ignores ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,164,<S2SV_ModStart> * body ; if ( p == NULL ) return NULL ;,0
457,CWE-119,"CWE-119 int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , <S2SV_StartBug> int64_t ts_start , int64_t ts_end , unsigned int flags ) { <S2SV_EndBug> struct lookahead_entry * buf ; # if USE_PARTIAL_COPY int row , col , active_end ; int mb_rows = ( src -> y_height + 15 ) >> 4 ; int mb_cols = ( src -> y_width + 15 ) >> 4 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ; ctx -> sz ++ ; buf = pop ( ctx , & ctx -> write_idx ) ; <S2SV_StartBug> # if USE_PARTIAL_COPY <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> max_sz == 1 && active_map && ! flags ) { <S2SV_EndBug> for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ; while ( 1 ) { for ( ; col < mb_cols ; ++ col ) { if ( active_map [ col ] ) break ; } if ( col == mb_cols ) break ; active_end = col ; for ( ; active_end < mb_cols ; ++ active_end ) { if ( ! active_map [ active_end ] ) break ; } vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , row << 4 , col << 4 , 16 , ( active_end - col ) << 4 ) ; col = active_end ; } active_map += mb_cols ; } } else { <S2SV_StartBug> vp9_copy_and_extend_frame ( src , & buf -> img ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> # else vp9_copy_and_extend_frame ( src , & buf -> img ) ; # endif buf -> ts_start = ts_start ; buf -> ts_end = ts_end ; buf -> flags = flags ; return 0 ; }
","<S2SV_ModStart> int64_t ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> ; # endif int width = src -> y_crop_width ; int height = src -> y_crop_height ; int uv_width = src -> uv_crop_width ; int uv_height = src -> uv_crop_height ; int subsampling_x = src -> subsampling_x ; int subsampling_y = src -> subsampling_y ; int larger_dimensions , new_dimensions ; <S2SV_ModStart> write_idx ) ; new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ; larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ; assert ( ! larger_dimensions || new_dimensions ) ; <S2SV_ModStart> USE_PARTIAL_COPY if ( ! new_dimensions && <S2SV_ModStart> } else { # endif if ( larger_dimensions ) { YV12_BUFFER_CONFIG new_img ; memset ( & new_img , 0 , sizeof ( new_img ) ) ; if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ; vpx_free_frame_buffer ( & buf -> img ) ; buf -> img = new_img ; } else if ( new_dimensions ) { buf -> img . y_crop_width = src -> y_crop_width ; buf -> img . y_crop_height = src -> y_crop_height ; buf -> img . uv_crop_width = src -> uv_crop_width ; buf -> img . uv_crop_height = src -> uv_crop_height ; buf -> img . subsampling_x = src -> subsampling_x ; buf -> img . subsampling_y = src -> subsampling_y ; } <S2SV_ModStart> img ) ; # if USE_PARTIAL_COPY } <S2SV_ModEnd> # endif buf
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,165,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
466,CWE-000,"CWE-000 static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,166,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->,1
472,CWE-119,"CWE-119 void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , LPF_PICK_METHOD method ) { VP9_COMMON * const cm = & cpi -> common ; struct loopfilter * const lf = & cm -> lf ; lf -> sharpness_level = cm -> frame_type == KEY_FRAME ? 0 : cpi -> oxcf . sharpness ; <S2SV_StartBug> if ( method == LPF_PICK_FROM_Q ) { <S2SV_EndBug> const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; <S2SV_StartBug> const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ; lf -> filter_level = clamp ( filt_guess , min_filter_level , max_filter_level ) ; } else { <S2SV_StartBug> search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) { lf -> filter_level = 0 ; } else if ( method >= <S2SV_ModStart> base_qindex , 0 , cm -> bit_depth ) ; # if CONFIG_VP9_HIGHBITDEPTH int filt_guess ; switch ( cm -> bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> filt_guess = ROUND_POWER_OF_TWO <S2SV_ModStart> 18 ) ; break ; case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ; break ; case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ; break ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ; return ; } # else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; # endif <S2SV_ModStart> } else { lf -> filter_level =
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,167,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> vp9_filter_filter_filter_level ( cpi <S2SV_ModStart> = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cpi -> oxcf. spatial_level == 0 ) { vp9_filter_filter_level = 0 ; } else { vp9_filter_filter_level ( cpi, cm -> oxcf. layer ) ; } else { vp9_filter_level = 0 ; } else { vp9_filter_level = 0 ; } else { vp9_filter_filter_filter_filter_level ( cpi, cm, cm -> oxcf. layer ) ; } else { vp9_filter_filter_filter_level = 0 ; } else { vp9_filter_level ( cpi -> oxcf. layer ) ; } else { vp9_filter_level = vp9_level ( cpi -> oxcf. layer_level ) ; } else { vp9_level = vp9_filter_level ( cpi -> oxcf. layer ) ; } else { vp9_level = vp9_filter_filter_level ( cpi -> oxcf.",0
473,CWE-284,"CWE-284 static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) { tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; tBTA_SERVICE_MASK service_mask ; uint32_t i ; bt_bdaddr_t bd_addr ; BTIF_TRACE_EVENT ( ""btif_dm_upstreams_cback<S2SV_blank><S2SV_blank>ev:<S2SV_blank>%s"" , dump_dm_event ( event ) ) ; switch ( event ) { case BTA_DM_ENABLE_EVT : { BD_NAME bdname ; bt_status_t status ; bt_property_t prop ; prop . type = BT_PROPERTY_BDNAME ; prop . len = BD_NAME_LEN ; prop . val = ( void * ) bdname ; status = btif_storage_get_adapter_property ( & prop ) ; if ( status == BT_STATUS_SUCCESS ) { BTA_DmSetDeviceName ( ( char * ) prop . val ) ; } else { BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; } # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; # endif service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , TRUE ) ; } } memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; btif_storage_load_bonded_devices ( ) ; btif_storage_load_autopair_device_list ( ) ; btif_enable_bluetooth_evt ( p_data -> enable . status ) ; } break ; case BTA_DM_DISABLE_EVT : service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , FALSE ) ; } } btif_disable_bluetooth_evt ( ) ; break ; case BTA_DM_PIN_REQ_EVT : btif_dm_pin_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_AUTH_CMPL_EVT : btif_dm_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_BOND_CANCEL_CMPL_EVT : if ( pairing_cb . state == BT_BOND_STATE_BONDING ) { bdcpy ( bd_addr . address , pairing_cb . bd_addr ) ; btm_set_bond_type_dev ( pairing_cb . bd_addr , BOND_TYPE_UNKNOWN ) ; bond_state_changed ( p_data -> bond_cancel_cmpl . result , & bd_addr , BT_BOND_STATE_NONE ) ; } break ; case BTA_DM_SP_CFM_REQ_EVT : btif_dm_ssp_cfm_req_evt ( & p_data -> cfm_req ) ; break ; case BTA_DM_SP_KEY_NOTIF_EVT : btif_dm_ssp_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_DEV_UNPAIRED_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; # if ( defined ( BTA_HH_INCLUDED ) && ( BTA_HH_INCLUDED == TRUE ) ) btif_hh_remove_device ( bd_addr ) ; # endif btif_storage_remove_bonded_device ( & bd_addr ) ; bond_state_changed ( BT_STATUS_SUCCESS , & bd_addr , BT_BOND_STATE_NONE ) ; break ; case BTA_DM_BUSY_LEVEL_EVT : { if ( p_data -> busy_level . level_flags & BTM_BL_INQUIRY_PAGING_MASK ) { if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_STARTED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STARTED ) ; btif_dm_inquiry_in_progress = TRUE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_CANCELLED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STOPPED ) ; btif_dm_inquiry_in_progress = FALSE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_COMPLETE ) { btif_dm_inquiry_in_progress = FALSE ; } } } break ; case BTA_DM_LINK_UP_EVT : bdcpy ( bd_addr . address , p_data -> link_up . bd_addr ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_UP_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_CONNECTED"" ) ; btif_update_remote_version_property ( & bd_addr ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_CONNECTED ) ; break ; case BTA_DM_LINK_DOWN_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_DOWN_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_DISCONNECTED"" ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_DISCONNECTED ) ; break ; case BTA_DM_HW_ERROR_EVT : BTIF_TRACE_ERROR ( ""Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>"" ) ; btif_config_flush ( ) ; <S2SV_StartBug> usleep ( 100000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; break ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) case BTA_DM_BLE_KEY_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_KEY_EVT<S2SV_blank>key_type=0x%02x<S2SV_blank>"" , p_data -> ble_key . key_type ) ; if ( pairing_cb . state != BT_BOND_STATE_BONDING ) { BTIF_TRACE_DEBUG ( ""Bond<S2SV_blank>state<S2SV_blank>not<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>App<S2SV_blank>so<S2SV_blank>far.Notify<S2SV_blank>the<S2SV_blank>app<S2SV_blank>now"" ) ; bond_state_changed ( BT_STATUS_SUCCESS , ( bt_bdaddr_t * ) p_data -> ble_key . bd_addr , BT_BOND_STATE_BONDING ) ; } else if ( memcmp ( pairing_cb . bd_addr , p_data -> ble_key . bd_addr , BD_ADDR_LEN ) != 0 ) { BTIF_TRACE_ERROR ( ""BD<S2SV_blank>mismatch<S2SV_blank>discard<S2SV_blank>BLE<S2SV_blank>key_type=%d<S2SV_blank>"" , p_data -> ble_key . key_type ) ; break ; } switch ( p_data -> ble_key . key_type ) { case BTA_LE_KEY_PENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PENC"" ) ; pairing_cb . ble . is_penc_key_rcvd = TRUE ; pairing_cb . ble . penc_key = p_data -> ble_key . p_key_value -> penc_key ; break ; case BTA_LE_KEY_PID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PID"" ) ; pairing_cb . ble . is_pid_key_rcvd = TRUE ; pairing_cb . ble . pid_key = p_data -> ble_key . p_key_value -> pid_key ; break ; case BTA_LE_KEY_PCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PCSRK"" ) ; pairing_cb . ble . is_pcsrk_key_rcvd = TRUE ; pairing_cb . ble . pcsrk_key = p_data -> ble_key . p_key_value -> pcsrk_key ; break ; case BTA_LE_KEY_LENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LENC"" ) ; pairing_cb . ble . is_lenc_key_rcvd = TRUE ; pairing_cb . ble . lenc_key = p_data -> ble_key . p_key_value -> lenc_key ; break ; case BTA_LE_KEY_LCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LCSRK"" ) ; pairing_cb . ble . is_lcsrk_key_rcvd = TRUE ; pairing_cb . ble . lcsrk_key = p_data -> ble_key . p_key_value -> lcsrk_key ; break ; case BTA_LE_KEY_LID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LID"" ) ; pairing_cb . ble . is_lidk_key_rcvd = TRUE ; break ; default : BTIF_TRACE_ERROR ( ""unknown<S2SV_blank>BLE<S2SV_blank>key<S2SV_blank>type<S2SV_blank>(0x%02x)"" , p_data -> ble_key . key_type ) ; break ; } break ; case BTA_DM_BLE_SEC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_SEC_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_sec_req_evt ( & p_data -> ble_req ) ; break ; case BTA_DM_BLE_PASSKEY_NOTIF_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_NOTIF_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_PASSKEY_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_passkey_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_BLE_NC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_nc_req_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_OOB_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_OOB_REQ_EVT.<S2SV_blank>"" ) ; break ; case BTA_DM_BLE_LOCAL_IR_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_IR_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_id_keys_rcvd = TRUE ; memcpy ( & ble_local_key_cb . id_keys . irk [ 0 ] , & p_data -> ble_id_keys . irk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . ir [ 0 ] , & p_data -> ble_id_keys . ir [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . dhk [ 0 ] , & p_data -> ble_id_keys . dhk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . irk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IRK , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . ir [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IR , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . dhk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_DHK , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_LOCAL_ER_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_ER_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_er_rcvd = TRUE ; memcpy ( & ble_local_key_cb . er [ 0 ] , & p_data -> ble_er [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . er [ 0 ] , BTIF_DM_LE_LOCAL_KEY_ER , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_AUTH_CMPL_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_AUTH_CMPL_EVT.<S2SV_blank>"" ) ; btif_dm_ble_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_LE_FEATURES_READ : { tBTM_BLE_VSC_CB cmn_vsc_cb ; bt_local_le_features_t local_le_features ; char buf [ 512 ] ; bt_property_t prop ; prop . type = BT_PROPERTY_LOCAL_LE_FEATURES ; prop . val = ( void * ) buf ; prop . len = sizeof ( buf ) ; BTM_BleGetVendorCapabilities ( & cmn_vsc_cb ) ; local_le_features . local_privacy_enabled = BTM_BleLocalPrivacyEnabled ( ) ; prop . len = sizeof ( bt_local_le_features_t ) ; if ( cmn_vsc_cb . filter_support == 1 ) local_le_features . max_adv_filter_supported = cmn_vsc_cb . max_filter ; else local_le_features . max_adv_filter_supported = 0 ; local_le_features . max_adv_instance = cmn_vsc_cb . adv_inst_max ; local_le_features . max_irk_list_size = cmn_vsc_cb . max_irk_list_sz ; local_le_features . rpa_offload_supported = cmn_vsc_cb . rpa_offloading ; local_le_features . activity_energy_info_supported = cmn_vsc_cb . energy_support ; local_le_features . scan_result_storage_size = cmn_vsc_cb . tot_scan_results_strg ; local_le_features . version_supported = cmn_vsc_cb . version_supported ; local_le_features . total_trackable_advertisers = cmn_vsc_cb . total_trackable_advertisers ; local_le_features . extended_scan_support = cmn_vsc_cb . extended_scan_support > 0 ; local_le_features . debug_logging_supported = cmn_vsc_cb . debug_logging_supported > 0 ; memcpy ( prop . val , & local_le_features , prop . len ) ; HAL_CBACK ( bt_hal_cbacks , adapter_properties_cb , BT_STATUS_SUCCESS , 1 , & prop ) ; break ; } case BTA_DM_ENER_INFO_READ : { btif_activity_energy_info_cb_t * p_ener_data = ( btif_activity_energy_info_cb_t * ) p_param ; bt_activity_energy_info energy_info ; energy_info . status = p_ener_data -> status ; energy_info . ctrl_state = p_ener_data -> ctrl_state ; energy_info . rx_time = p_ener_data -> rx_time ; energy_info . tx_time = p_ener_data -> tx_time ; energy_info . idle_time = p_ener_data -> idle_time ; energy_info . energy_used = p_ener_data -> energy_used ; HAL_CBACK ( bt_hal_cbacks , energy_info_cb , & energy_info ) ; break ; } # endif case BTA_DM_AUTHORIZE_EVT : case BTA_DM_SIG_STRENGTH_EVT : case BTA_DM_SP_RMT_OOB_EVT : case BTA_DM_SP_KEYPRESS_EVT : case BTA_DM_ROLE_CHG_EVT : default : BTIF_TRACE_WARNING ( ""btif_dm_cback<S2SV_blank>:<S2SV_blank>unhandled<S2SV_blank>event<S2SV_blank>(%d)"" , event ) ; break ; } btif_dm_data_free ( event , p_data ) ; }
","<S2SV_ModStart> ( ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 100000 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,168,<S2SV_ModStart> ( int ret ; if (,0
475,CWE-190,"CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '<S2SV_blank>' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <S2SV_StartBug> int a = getnum ( fmt , MAXALIGN ) ; <S2SV_EndBug> if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalid<S2SV_blank>format<S2SV_blank>option<S2SV_blank>\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
","<S2SV_ModStart> = getnum ( L ,
",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z,169,,0
478,CWE-119,"CWE-119 static Image * ReadCMYKImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; SetImageColorspace ( image , CMYKColorspace ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; quantum_type = CMYKQuantum ; if ( LocaleCompare ( image_info -> magick , ""CMYKA"" ) == 0 ) { quantum_type = CMYKAQuantum ; image -> matte = MagickTrue ; } if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } count = 0 ; length = 0 ; scene = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <S2SV_StartBug> break ; <S2SV_EndBug> SetImageColorspace ( image , CMYKColorspace ) ; switch ( image_info -> interlace ) { case NoInterlace : default : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; SetPixelBlack ( indexes + x , GetPixelBlack ( canvas_indexes + image -> extract_info . x + x ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } break ; } case LineInterlace : { static QuantumType quantum_types [ 5 ] = { CyanQuantum , MagentaQuantum , YellowQuantum , BlackQuantum , OpacityQuantum } ; if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } for ( i = 0 ; i < ( image -> matte != MagickFalse ? 5 : 4 ) ; i ++ ) { quantum_type = quantum_types [ i ] ; q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( quantum_type ) { case CyanQuantum : { SetPixelCyan ( q , GetPixelCyan ( p ) ) ; break ; } case MagentaQuantum : { SetPixelMagenta ( q , GetPixelMagenta ( p ) ) ; break ; } case YellowQuantum : { SetPixelYellow ( q , GetPixelYellow ( p ) ) ; break ; } case BlackQuantum : { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; break ; } case OpacityQuantum : { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; break ; } default : break ; } p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case PlaneInterlace : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , CyanQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , MagentaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( q , GetPixelGreen ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlackQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 6 ) ; if ( status == MagickFalse ) break ; } if ( image -> matte != MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , AlphaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 6 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 6 , 6 ) ; if ( status == MagickFalse ) break ; } break ; } case PartitionInterlace : { AppendImageFormat ( ""C"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , CyanQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""M"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , MagentaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , MagentaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( q , GetPixelGreen ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , YellowQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""K"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , BlackQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlackQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> matte != MagickFalse ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""A"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,170,"<S2SV_ModStart> ) break ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",1
480,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_decode ( vpx_codec_ctx_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug> user_priv , deadline ) ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> && data_sz ) || ( data && ! data_sz ) <S2SV_ModStart> . decode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , data ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,171,<S2SV_ModStart> ( void ) <S2SV_ModEnd> ; if (,0
482,CWE-20,"CWE-20 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }
","<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z,172,<S2SV_ModStart> <S2SV_null> <S2SV_null> static struct,0
485,CWE-20,"CWE-20 void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,173,"<S2SV_ModStart> y2 ) { sprintf ( outputbuffer <S2SV_ModEnd>, "" <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f"", outputbuffer ) ;",0
488,CWE-125,"CWE-125 static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
","<S2SV_ModStart> self ) { PyObject_GC_UnTrack ( self ) ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,174,,0
497,CWE-119,"CWE-119 cJSON * cJSON_CreateStringArray ( const char * * strings , int count ) { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> n = cJSON_CreateString ( strings [ i ] ) ; <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
","<S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,175,,0
504,CWE-125,"CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> type_ignore_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( type_ignores , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( argtypes , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; <S2SV_EndBug> return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; <S2SV_EndBug> return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { type_ignore_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,176,"<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_None ) < 0 ) { return 1 ; } if ( <S2SV_ModStart> ) goto failed ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_id, & PyId_type, & PyId_t ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> field <S2SV_blank> field <S2SV_blank> missing <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> from <S2SV_blank> missing"" ) ; return 1 ; } if ( tmp == NULL ) { Py_SetString ( Py_TypeError, arena ) ; return 1 ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart> ( obj, & PyId_type, & PyId_type, & PyId_type, & PyId_type, & PyId_type, & PyId_type, & PyId_type, & PyId_t ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) < 0 ) { return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModEnd> ; } if",0
510,CWE-269,"CWE-269 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; } <S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
","<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
",torvalds@linux/9566d6742852c527bf5af38af5cbb878dad75705,CVE-2014-5207,https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705,2014-08-18T11:15Z,177,<S2SV_ModStart>. mnt_flags & MNT_MASK <S2SV_ModEnd> ; if (,0
512,CWE-190,"CWE-190 int ras_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug> int i ; int n ; uint_fast32_t magic ; assert ( JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , RAS_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < RAS_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != RAS_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ RAS_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,178,<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ RAS_MAGICLEN,1
514,CWE-119,"CWE-119 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
",dbry@WavPack/d5bf76b5a88d044a1be1d5656698e3ba737167e5,CVE-2018-6767,https://github.com/dbry/WavPack/commit/d5bf76b5a88d044a1be1d5656698e3ba737167e5,2018-02-06T22:29Z,179,"<S2SV_ModStart>, ds64_chunk, & ds64_chunk <S2SV_ModStart> size + sizeof ( ds64_chunk ), sizeof ( cs64_chunk <S2SV_ModStart> ds64_chunk ), sizeof ( cs64_chunk ) <S2SV_ModEnd> ) )",0
515,CWE-20,"CWE-20 static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; <S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; <S2SV_StartBug> } else <S2SV_EndBug> err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }
","<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,180,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
516,CWE-119,"CWE-119 static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; <S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }
","<S2SV_ModStart> ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> height - 1 ; int ret <S2SV_ModStart> ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } }
",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z,181,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
517,CWE-119,"CWE-119 static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) { # define SHOW ( field ) fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-28s<S2SV_blank>=<S2SV_blank>%d\\n"" , # field , stream -> config . cfg . field ) if ( stream -> index == 0 ) { fprintf ( stderr , ""Codec:<S2SV_blank>%s\\n"" , <S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , input -> filename , <S2SV_StartBug> input -> use_i420 ? ""I420"" : ""YV12"" ) ; <S2SV_EndBug> } if ( stream -> next || stream -> index ) fprintf ( stderr , ""\\nStream<S2SV_blank>Index:<S2SV_blank>%d\\n"" , stream -> index ) ; fprintf ( stderr , ""Destination<S2SV_blank>file:<S2SV_blank>%s\\n"" , stream -> config . out_fn ) ; fprintf ( stderr , ""Encoder<S2SV_blank>parameters:\\n"" ) ; SHOW ( g_usage ) ; SHOW ( g_threads ) ; SHOW ( g_profile ) ; SHOW ( g_w ) ; SHOW ( g_h ) ; <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> SHOW ( g_timebase . den ) ; SHOW ( g_error_resilient ) ; SHOW ( g_pass ) ; SHOW ( g_lag_in_frames ) ; SHOW ( rc_dropframe_thresh ) ; <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug> SHOW ( rc_resize_up_thresh ) ; SHOW ( rc_resize_down_thresh ) ; SHOW ( rc_end_usage ) ; SHOW ( rc_target_bitrate ) ; SHOW ( rc_min_quantizer ) ; SHOW ( rc_max_quantizer ) ; SHOW ( rc_undershoot_pct ) ; SHOW ( rc_overshoot_pct ) ; SHOW ( rc_buf_sz ) ; SHOW ( rc_buf_initial_sz ) ; SHOW ( rc_buf_optimal_sz ) ; SHOW ( rc_2pass_vbr_bias_pct ) ; SHOW ( rc_2pass_vbr_minsection_pct ) ; SHOW ( rc_2pass_vbr_maxsection_pct ) ; SHOW ( kf_mode ) ; SHOW ( kf_min_dist ) ; SHOW ( kf_max_dist ) ; }
","<S2SV_ModStart> -> codec -> codec_interface ( ) ) ) ; fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , <S2SV_ModEnd> input -> filename <S2SV_ModStart> -> filename , file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; SHOW ( g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> SHOW ( rc_resize_allowed ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,182,<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,0
519,CWE-399,"CWE-399 xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) { xmlAttrPtr attr , copy , last ; xmlNodePtr oldInsert , text ; xmlNsPtr origNs = NULL , copyNs = NULL ; const xmlChar * value ; xmlChar * valueAVT ; if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ; oldInsert = ctxt -> insert ; ctxt -> insert = target ; if ( target -> properties ) { last = target -> properties ; while ( last -> next != NULL ) last = last -> next ; } else { last = NULL ; } attr = attrs ; do { # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) { goto next_attribute ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { goto next_attribute ; } # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>"" ""literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n"" ) ; goto error ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ; if ( copy == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } goto error ; } copy -> parent = target ; if ( last == NULL ) { target -> properties = copy ; last = copy ; } else { last -> next = copy ; copy -> prev = last ; last = copy ; } if ( attr -> ns != origNs ) { origNs = attr -> ns ; if ( attr -> ns != NULL ) { # ifdef XSLT_REFACTORED copyNs = xsltGetSpecialNamespace ( ctxt , attr -> parent , attr -> ns -> href , attr -> ns -> prefix , target ) ; # else copyNs = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; # endif if ( copyNs == NULL ) goto error ; } else copyNs = NULL ; } copy -> ns = copyNs ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { copy -> last = copy -> children = text ; text -> parent = ( xmlNodePtr ) copy ; text -> doc = copy -> doc ; if ( attr -> psvi != NULL ) { valueAVT = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( valueAVT == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST """" ) ; goto error ; } else { text -> content = valueAVT ; } } else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && <S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) <S2SV_EndBug> { text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } if ( ( copy != NULL ) && ( text != NULL ) && ( xmlIsID ( copy -> doc , copy -> parent , copy ) ) ) xmlAddID ( NULL , copy -> doc , text -> content , copy ) ; } next_attribute : attr = attr -> next ; } while ( attr != NULL ) ; attr = attrs ; do { # ifdef XSLT_REFACTORED if ( ( attr -> psvi == xsltXSLTAttrMarker ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # endif attr = attr -> next ; } while ( attr != NULL ) ; ctxt -> insert = oldInsert ; return ( target -> properties ) ; error : ctxt -> insert = oldInsert ; return ( NULL ) ; }
","<S2SV_ModStart> -> dict ) && xmlDictOwns ( ctxt -> dict , value )
",chromium@chromium/2de493f4a1d48952e09230a0c32ccbd45db973b2,CVE-2012-2893,https://github.com/chromium/chromium/commit/2de493f4a1d48952e09230a0c32ccbd45db973b2,2012-09-26T10:56Z,183,,0
520,CWE-269,"CWE-269 static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( fname ) ; } }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.zshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.cshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.bashrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" <S2SV_ModStart> ) ; } <S2SV_ModEnd> free ( fname
",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z,184,"<S2SV_ModStart> ; if ( ( fname ) ) { fprintf ( ""Invalid <S2SV_blank> file\\n"", fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { fprintf ( ""Error: <S2SV_blank> file\\n"", fname ) ; exit ( 1 ) ; } if (",0
523,CWE-617,"CWE-617 static void pci_populate_msixcap ( struct msixcap * msixcap , int msgnum , int barnum , uint32_t msix_tab_size ) { <S2SV_StartBug> assert ( msix_tab_size % 4096 == 0 ) ; <S2SV_EndBug> bzero ( msixcap , sizeof ( struct msixcap ) ) ; msixcap -> capid = PCIY_MSIX ; msixcap -> msgctrl = msgnum - 1 ; msixcap -> table_info = barnum & PCIM_MSIX_BIR_MASK ; msixcap -> pba_info = msix_tab_size | ( barnum & PCIM_MSIX_BIR_MASK ) ; }
","<S2SV_ModStart> msix_tab_size ) { <S2SV_ModEnd> bzero ( msixcap
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,185,<S2SV_ModStart> ( size < 0,0
525,CWE-674,"CWE-674 static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
","<S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z,186,"<S2SV_ModStart> { if ( js_doregexec ( J, <S2SV_ModEnd> re -> prog",0
526,CWE-119,"CWE-119 static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; ReadItems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case OFreshOID : <S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug> caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case OShift : * dest += sp -> arg ; sp -- ; break ; case OReadItems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= PREFIX_SMALL_INT ) { if ( code >= PREFIX_SMALL_BLOCK ) { tag = code & 0xF ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = Atom ( tag ) ; } else { v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == Object_tag ) { Assert ( size >= 2 ) ; ReadItems ( & Field ( v , 2 ) , size - 2 ) ; PushItem ( ) ; sp -> op = OFreshOID ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; ReadItems ( & Field ( v , 0 ) , 2 ) ; } else ReadItems ( & Field ( v , 0 ) , size ) ; } } else { v = Val_int ( code & 0x3F ) ; } } else { if ( code >= PREFIX_SMALL_STRING ) { len = ( code & 0x1F ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , String_tag , intern_color ) ; intern_dest += 1 + size ; Field ( v , size - 1 ) = 0 ; ofs_ind = Bsize_wsize ( size ) - 1 ; Byte ( v , ofs_ind ) = ofs_ind - len ; readblock ( String_val ( v ) , len ) ; } else { switch ( code ) { case CODE_INT8 : v = Val_long ( read8s ( ) ) ; break ; case CODE_INT16 : v = Val_long ( read16s ( ) ) ; break ; case CODE_INT32 : v = Val_long ( read32s ( ) ) ; break ; case CODE_INT64 : # ifdef ARCH_SIXTYFOUR v = Val_long ( read64s ( ) ) ; break ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>integer<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_SHARED8 : ofs = read8u ( ) ; read_shared : Assert ( ofs > 0 ) ; Assert ( ofs <= obj_counter ) ; Assert ( intern_obj_table != NULL ) ; v = intern_obj_table [ obj_counter - ofs ] ; break ; case CODE_SHARED16 : ofs = read16u ( ) ; goto read_shared ; case CODE_SHARED32 : ofs = read32u ( ) ; goto read_shared ; case CODE_BLOCK32 : header = ( header_t ) read32u ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; case CODE_BLOCK64 : # ifdef ARCH_SIXTYFOUR header = ( header_t ) read64s ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>data<S2SV_blank>block<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_STRING8 : len = read8u ( ) ; goto read_string ; case CODE_STRING32 : len = read32u ( ) ; goto read_string ; case CODE_DOUBLE_LITTLE : case CODE_DOUBLE_BIG : v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( Double_wosize , Double_tag , intern_color ) ; intern_dest += 1 + Double_wosize ; readfloat ( ( double * ) v , code ) ; break ; case CODE_DOUBLE_ARRAY8_LITTLE : case CODE_DOUBLE_ARRAY8_BIG : len = read8u ( ) ; read_double_array : size = len * Double_wosize ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Double_array_tag , intern_color ) ; intern_dest += 1 + size ; readfloats ( ( double * ) v , len , code ) ; break ; case CODE_DOUBLE_ARRAY32_LITTLE : case CODE_DOUBLE_ARRAY32_BIG : len = read32u ( ) ; goto read_double_array ; case CODE_CODEPOINTER : ofs = read32u ( ) ; readblock ( digest , 16 ) ; codeptr = intern_resolve_code_pointer ( digest , ofs ) ; if ( codeptr != NULL ) { v = ( value ) codeptr ; } else { value * function_placeholder = caml_named_value ( ""Debugger.function_placeholder"" ) ; if ( function_placeholder != NULL ) { v = * function_placeholder ; } else { intern_cleanup ( ) ; intern_bad_code_pointer ( digest ) ; } } break ; case CODE_INFIXPOINTER : ofs = read32u ( ) ; PushItem ( ) ; sp -> dest = dest ; sp -> op = OShift ; sp -> arg = ofs ; ReadItems ( dest , 1 ) ; continue ; case CODE_CUSTOM : ops = caml_find_custom_operations ( ( char * ) intern_src ) ; if ( ops == NULL ) { intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>unknown<S2SV_blank>custom<S2SV_blank>block<S2SV_blank>identifier"" ) ; } while ( * intern_src ++ != 0 ) ; size = ops -> deserialize ( ( void * ) ( intern_dest + 2 ) ) ; size = 1 + ( size + sizeof ( value ) - 1 ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Custom_tag , intern_color ) ; Custom_ops_val ( v ) = ops ; if ( ops -> finalize != NULL && Is_young ( v ) ) { if ( caml_finalize_table . ptr >= caml_finalize_table . limit ) { CAMLassert ( caml_finalize_table . ptr == caml_finalize_table . limit ) ; caml_realloc_ref_table ( & caml_finalize_table ) ; } * caml_finalize_table . ptr ++ = ( value * ) v ; } intern_dest += 1 + size ; break ; default : intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>ill-formed<S2SV_blank>message"" ) ; } } } * dest = v ; break ; default : Assert ( 0 ) ; } } intern_free_stack ( ) ; }
","<S2SV_ModStart> : if ( Long_val <S2SV_ModEnd> ( Field (
",ocaml@ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74,CVE-2015-8869,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,2016-06-13T19:59Z,187,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
528,CWE-20,"CWE-20 bool_t ksz8851IrqHandler ( NetInterface * interface ) { bool_t flag ; size_t n ; uint16_t ier ; uint16_t isr ; flag = FALSE ; <S2SV_StartBug> ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> if ( ( isr & ISR_LCIS ) != 0 ) { <S2SV_StartBug> ier &= ~ IER_LCIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( isr & ISR_TXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } } <S2SV_StartBug> if ( ( isr & ISR_RXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ier &= ~ IER_RXIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ; <S2SV_EndBug> return flag ; }
","<S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> ) ; ksz8851WriteReg <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_LCIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( isr & KSZ8851_ISR_TXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( isr & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_RXIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , ier )
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,188,"<S2SV_ModStart> ( interface, KSZ8851_ISR, KSZ8851_ISR, KSZ8851_ISR, KSZ8851_ISR, KSZ8851_ISR_ISR_ISR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & KSZ8851_ISR, KSZ8851_ISR, KSZ8851_ISR_P1 <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_P1 <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface, KSZ8851_E <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_P1SR_IS <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_E <S2SV_ModEnd> ) ; }",0
529,CWE-119,"CWE-119 <S2SV_StartBug> static void encode_quantization ( VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; <S2SV_EndBug> write_delta_q ( wb , cm -> y_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_ac_delta_q ) ; }
","<S2SV_ModStart> void encode_quantization ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,189,"<S2SV_ModStart> * wb, vpx_writer <S2SV_ModEnd> * wb )",0
531,CWE-284,"CWE-284 BOOLEAN UIPC_Send ( tUIPC_CH_ID ch_id , UINT16 msg_evt , UINT8 * p_buf , UINT16 msglen ) { UNUSED ( msg_evt ) ; BTIF_TRACE_DEBUG ( ""UIPC_Send<S2SV_blank>:<S2SV_blank>ch_id:%d<S2SV_blank>%d<S2SV_blank>bytes"" , ch_id , msglen ) ; UIPC_LOCK ( ) ; <S2SV_StartBug> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( ""failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>(%s)"" , strerror ( errno ) ) ; } UIPC_UNLOCK ( ) ; return FALSE ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> p_buf , msglen )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,190,"<S2SV_ModStart> ; TEMP_FAILURE_RETRY ( <S2SV_ModStart>, 0 ) )",0
540,CWE-639,"CWE-639 int ca_validate_pubkey ( struct iked * env , struct iked_static_id * id , void * data , size_t len , struct iked_id * out ) { BIO * rawcert = NULL ; RSA * peerrsa = NULL , * localrsa = NULL ; EC_KEY * peerec = NULL ; EVP_PKEY * peerkey = NULL , * localkey = NULL ; int ret = - 1 ; FILE * fp = NULL ; char idstr [ IKED_ID_SIZE ] ; char file [ PATH_MAX ] ; struct iked_id idp ; switch ( id -> id_type ) { case IKEV2_ID_IPV4 : case IKEV2_ID_FQDN : case IKEV2_ID_UFQDN : case IKEV2_ID_IPV6 : break ; default : log_debug ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s"" , __func__ , print_map ( id -> id_type , ikev2_id_map ) ) ; return ( - 1 ) ; } bzero ( & idp , sizeof ( idp ) ) ; if ( ( idp . id_buf = ibuf_new ( id -> id_data , id -> id_length ) ) == NULL ) goto done ; idp . id_type = id -> id_type ; idp . id_offset = id -> id_offset ; if ( ikev2_print_id ( & idp , idstr , sizeof ( idstr ) ) == - 1 ) goto done ; if ( len == 0 && data ) { peerkey = ( EVP_PKEY * ) data ; } if ( len > 0 ) { if ( ( rawcert = BIO_new_mem_buf ( data , len ) ) == NULL ) goto done ; if ( ( peerkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ( peerrsa = d2i_RSAPublicKey_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_RSA ( peerkey , peerrsa ) ) { goto sslerr ; } } else if ( BIO_reset ( rawcert ) == 1 && ( peerec = d2i_EC_PUBKEY_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_EC_KEY ( peerkey , peerec ) ) { goto sslerr ; } } else { log_debug ( ""%s:<S2SV_blank>unknown<S2SV_blank>key<S2SV_blank>type<S2SV_blank>received"" , __func__ ) ; goto sslerr ; } } lc_idtype ( idstr ) ; if ( strlcpy ( file , IKED_PUBKEY_DIR , sizeof ( file ) ) >= sizeof ( file ) || strlcat ( file , idstr , sizeof ( file ) ) >= sizeof ( file ) ) { log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>id<S2SV_blank>too<S2SV_blank>long<S2SV_blank>%s"" , __func__ , idstr ) ; goto done ; } if ( ( fp = fopen ( file , ""r"" ) ) == NULL ) { logit ( len == 0 ? LOG_DEBUG : LOG_INFO , ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>public<S2SV_blank>key<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } localkey = PEM_read_PUBKEY ( fp , NULL , NULL , NULL ) ; if ( localkey == NULL ) { rewind ( fp ) ; localrsa = PEM_read_RSAPublicKey ( fp , NULL , NULL , NULL ) ; fclose ( fp ) ; if ( localrsa == NULL ) goto sslerr ; if ( ( localkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ! EVP_PKEY_set1_RSA ( localkey , localrsa ) ) goto sslerr ; } else { fclose ( fp ) ; } if ( localkey == NULL ) goto sslerr ; <S2SV_StartBug> if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { <S2SV_EndBug> log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } log_debug ( ""%s:<S2SV_blank>valid<S2SV_blank>public<S2SV_blank>key<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s"" , __func__ , file ) ; if ( out && ca_pubkey_serialize ( localkey , out ) ) goto done ; ret = 0 ; sslerr : if ( ret != 0 ) ca_sslerror ( __func__ ) ; done : ibuf_release ( idp . id_buf ) ; if ( localkey != NULL ) EVP_PKEY_free ( localkey ) ; if ( peerrsa != NULL ) RSA_free ( peerrsa ) ; if ( peerec != NULL ) EC_KEY_free ( peerec ) ; if ( localrsa != NULL ) RSA_free ( localrsa ) ; if ( rawcert != NULL ) { BIO_free ( rawcert ) ; if ( peerkey != NULL ) EVP_PKEY_free ( peerkey ) ; } return ( ret ) ; }
","<S2SV_ModStart> ( peerkey && <S2SV_ModEnd> EVP_PKEY_cmp ( peerkey <S2SV_ModStart> , localkey ) != 1
",openbsd@src/7afb2d41c6d373cf965285840b85c45011357115,CVE-2020-16088,https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115,2020-07-28T12:15Z,191,,0
541,CWE-119,"CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
",TeX-Live@texlive-source/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,CVE-2018-17407,https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,2018-09-23T21:29Z,192,<S2SV_ModStart>,0
542,CWE-119,"CWE-119 static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col , <S2SV_StartBug> BLOCK_SIZE bsize , BLOCK_SIZE subsize ) { <S2SV_EndBug> MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> assert ( bsize >= BLOCK_8X8 ) ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; break ; case PARTITION_VERT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ; <S2SV_EndBug> } break ; case PARTITION_HORZ : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ; <S2SV_EndBug> } break ; case PARTITION_SPLIT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize , <S2SV_StartBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , <S2SV_EndBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , <S2SV_EndBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; * get_sb_index ( x , subsize ) = 3 ; fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col + hbs , subsize , * ( get_sb_partitioning ( x , subsize ) ) ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : break ; } }
","<S2SV_ModStart> BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModEnd> ) { MACROBLOCKD <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> PARTITION_TYPE partition = pc_tree -> partitioning ; BLOCK_SIZE subsize = get_subsize ( bsize , partition ) <S2SV_ModEnd> ; assert ( <S2SV_ModStart> case PARTITION_NONE : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> ] ) = pc_tree -> none . mic ; * ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext <S2SV_ModEnd> ; duplicate_mode_info_in_sb ( <S2SV_ModStart> case PARTITION_VERT : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> ] ) = pc_tree -> vertical [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> , mi_col , subsize <S2SV_ModEnd> ) ; if <S2SV_ModStart> mi_cols ) { set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> + hbs , subsize <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> ] ) = pc_tree -> horizontal [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> , mi_col , subsize <S2SV_ModEnd> ) ; if <S2SV_ModStart> mi_rows ) { set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> , mi_col , subsize <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_SPLIT : { <S2SV_ModEnd> fill_mode_info_sb ( cm <S2SV_ModStart> , subsize , pc_tree -> split [ 0 ] ) ; fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; fill_mode_info_sb ( <S2SV_ModStart> x , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; fill_mode_info_sb ( <S2SV_ModStart> hbs , mi_col + hbs , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> ) ; break <S2SV_ModStart> ; break ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,193,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
543,CWE-20,"CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;
",git@git/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,CVE-2018-17456,https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,2018-10-06T14:29Z,194,,0
549,CWE-476,"CWE-476 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
","<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }
",torvalds@linux/37863c43b2c6464f252862bf2e9768264e961678,CVE-2017-12192,https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678,2017-10-12T00:29Z,195,"<S2SV_ModStart> ret = key_read <S2SV_ModEnd> ( key,",0
550,CWE-172,"CWE-172 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) <S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) <S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; <S2SV_ModEnd> break ; } <S2SV_ModStart> == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T )
",external@libavc/7554755536019e439433c515eeb44e701fb3bfb2,CVE-2016-3828,https://android.googlesource.com/platform/external/libavc/+/7554755536019e439433c515eeb44e701fb3bfb2,2016-08-05T20:59Z,196,,0
551,CWE-190,"CWE-190 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; <S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
",torvalds@linux/bb7f0f989ca7de1153bd128a40a71709e339fa03,CVE-2017-17854,https://github.com/torvalds/linux/commit/bb7f0f989ca7de1153bd128a40a71709e339fa03,2017-12-27T17:08Z,197,<S2SV_ModStart> dst_val ) ; <S2SV_ModEnd> if ( insn,0
552,CWE-264,"CWE-264 struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , ""parent<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p<S2SV_blank>name<S2SV_blank>is:<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>dentry<S2SV_blank>=<S2SV_blank>0x%p"" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\\\' ) { cFYI ( 1 , ""Invalid<S2SV_blank>file<S2SV_blank>name"" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , ""non-NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } else { cFYI ( 1 , ""NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } cFYI ( 1 , ""Full<S2SV_blank>path:<S2SV_blank>%s<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p"" , full_path , direntry -> d_inode ) ; if ( pTcon -> unix_ext ) { if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { rc = cifs_posix_open ( full_path , & newInode , parent_dir_inode -> i_sb , nd -> intent . open . create_mode , nd -> intent . open . file -> f_flags , & oplock , & fileHandle , xid ) ; <S2SV_StartBug> if ( ( rc == 0 ) || ( rc == - ENOENT ) ) <S2SV_EndBug> posix_open = true ; else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ; } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) { rc = 0 ; direntry -> d_time = jiffies ; d_add ( direntry , NULL ) ; } else if ( rc != - EACCES ) { cERROR ( 1 , ""Unexpected<S2SV_blank>lookup<S2SV_blank>error<S2SV_blank>%d"" , rc ) ; } lookup_out : kfree ( full_path ) ; cifs_put_tlink ( tlink ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
","<S2SV_ModStart> xid ) ; switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; <S2SV_ModStart> == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if <S2SV_ModEnd> ( rc == <S2SV_ModStart> - ENOENT ) <S2SV_ModEnd> { rc =
",torvalds@linux/88d7d4e4a439f32acc56a6d860e415ee71d3df08,CVE-2012-1090,https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08,2012-05-17T11:00Z,198,<S2SV_ModStart> ; if ( i < 0 ||,0
556,CWE-362,"CWE-362 struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) { struct tcp_options_received tcp_opt ; u8 * hash_location ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct rtable * rt ; __u8 rcv_wscale ; bool ecn_ok ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) || ( mss = cookie_check ( skb , cookie ) ) == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , & hash_location , 0 ) ; if ( ! cookie_check_timestamp ( & tcp_opt , & ecn_ok ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp_request_sock_ops ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; req -> mss = mss ; ireq -> loc_port = th -> dest ; ireq -> rmt_port = th -> source ; ireq -> loc_addr = ip_hdr ( skb ) -> daddr ; ireq -> rmt_addr = ip_hdr ( skb ) -> saddr ; ireq -> ecn_ok = ecn_ok ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; if ( opt && opt -> optlen ) { <S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ; <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug> kfree ( ireq -> opt ) ; ireq -> opt = NULL ; } } if ( security_inet_conn_request ( sk , skb , req ) ) { reqsk_free ( req ) ; goto out ; } req -> expires = 0UL ; req -> retrans = 0 ; { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , 0 , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , IPPROTO_TCP , inet_sk_flowi_flags ( sk ) , ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , ireq -> loc_addr , th -> source , th -> dest ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( sock_net ( sk ) , & fl4 ) ; if ( IS_ERR ( rt ) ) { reqsk_free ( req ) ; goto out ; } } req -> window_clamp = tp -> window_clamp ? : dst_metric ( & rt -> dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rcv_wnd , & req -> window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( & rt -> dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ret = get_cookie_sock ( sk , skb , req , & rt -> dst ) ; out : return ret ; }
","<S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + opt <S2SV_ModStart> && ip_options_echo ( & ireq -> opt <S2SV_ModEnd> -> opt ,
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,199,<S2SV_ModStart> ; if ( sk ),0
557,CWE-119,"CWE-119 <S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> len ++ ; if ( digit3 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> len ++ ; if ( digit4 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }
","<S2SV_ModStart> char * in , size_t olen <S2SV_ModStart> += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ;
",neomutt@neomutt/6f163e07ae68654d7ac5268cbb7565f6df79ad85,CVE-2018-14359,https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85,2018-07-17T17:29Z,200,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
561,CWE-119,"CWE-119 const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { <S2SV_StartBug> int number_of_frames , number_of_keyframes , encode_frame_count ; <S2SV_EndBug> int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ; <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ; <S2SV_StartBug> encode_frame_count = si -> encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_INFO , ""\\n"" ) ; <S2SV_StartBug> number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < si -> layers ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> number_of_frames = encode_frame_count ; <S2SV_EndBug> if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n"" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ; si -> sse_sum [ i ] [ j ] = 0 ; } } <S2SV_StartBug> si -> encode_frame_count = 0 ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\n"" , bytes_total ) ; return vpx_svc_get_message ( svc_ctx ) ; }
","<S2SV_ModStart> { int number_of_frames <S2SV_ModEnd> ; int i <S2SV_ModStart> double y_scale ; SvcInternal_t <S2SV_ModEnd> * const si <S2SV_ModStart> svc_ctx ) ; number_of_frames = si -> psnr_pkt_received <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( number_of_frames <S2SV_ModEnd> <= 0 ) <S2SV_ModStart> ""\\n"" ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ; i < svc_ctx -> spatial_layers <S2SV_ModEnd> ; ++ i <S2SV_ModStart> i ) { <S2SV_ModEnd> svc_log ( svc_ctx <S2SV_ModStart> } si -> psnr_pkt_received <S2SV_ModEnd> = 0 ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,201,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
563,CWE-476,"CWE-476 static int resize ( int new_rows , int new_cols , VTermPos * delta , void * user ) { VTermScreen * screen = user ; int is_altscreen = ( screen -> buffers [ 1 ] && screen -> buffer == screen -> buffers [ 1 ] ) ; int old_rows = screen -> rows ; int old_cols = screen -> cols ; int first_blank_row ; if ( ! is_altscreen && new_rows < old_rows ) { VTermPos pos = { 0 , 0 } ; VTermPos cursor = screen -> state -> pos ; for ( pos . row = old_rows - 1 ; pos . row >= new_rows ; pos . row -- ) if ( ! vterm_screen_is_eol ( screen , pos ) || cursor . row == pos . row ) break ; first_blank_row = pos . row + 1 ; if ( first_blank_row > new_rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; rect . end_row = old_rows ; rect . end_col = old_cols ; scrollrect ( rect , first_blank_row - new_rows , 0 , user ) ; vterm_screen_flush_damage ( screen ) ; delta -> row -= first_blank_row - new_rows ; } } screen -> buffers [ 0 ] = realloc_buffer ( screen , screen -> buffers [ 0 ] , new_rows , new_cols ) ; if ( screen -> buffers [ 1 ] ) screen -> buffers [ 1 ] = realloc_buffer ( screen , screen -> buffers [ 1 ] , new_rows , new_cols ) ; screen -> buffer = is_altscreen ? screen -> buffers [ 1 ] : screen -> buffers [ 0 ] ; screen -> rows = new_rows ; screen -> cols = new_cols ; <S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug> vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( VTermScreenCell ) * new_cols ) ; if ( new_cols > old_cols ) { VTermRect rect ; rect . start_row = 0 ; rect . end_row = old_rows ; rect . start_col = old_cols ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } if ( new_rows > old_rows ) { if ( ! is_altscreen && screen -> callbacks && screen -> callbacks -> sb_popline ) { int rows = new_rows - old_rows ; while ( rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; VTermPos pos = { 0 , 0 } ; if ( ! ( screen -> callbacks -> sb_popline ( screen -> cols , screen -> sb_buffer , screen -> cbdata ) ) ) break ; rect . end_row = screen -> rows ; rect . end_col = screen -> cols ; scrollrect ( rect , - 1 , 0 , user ) ; for ( pos . col = 0 ; pos . col < screen -> cols ; pos . col += screen -> sb_buffer [ pos . col ] . width ) vterm_screen_set_cell ( screen , pos , screen -> sb_buffer + pos . col ) ; rect . end_row = 1 ; damagerect ( screen , rect ) ; vterm_screen_flush_damage ( screen ) ; rows -- ; delta -> row ++ ; } } { VTermRect rect ; rect . start_row = old_rows ; rect . end_row = new_rows ; rect . start_col = 0 ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } } if ( screen -> callbacks && screen -> callbacks -> resize ) return ( * screen -> callbacks -> resize ) ( new_rows , new_cols , screen -> cbdata ) ; return 1 ; }
","<S2SV_ModStart> = new_cols ; <S2SV_ModEnd> vterm_allocator_free ( screen
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,202,,0
564,CWE-125,"CWE-125 static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { <S2SV_StartBug> const char * literal_start = * str ; <S2SV_EndBug> const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; <S2SV_StartBug> for ( ; * str < end ; ( * str ) ++ ) { <S2SV_EndBug> char ch = * * str ; <S2SV_StartBug> if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && <S2SV_EndBug> * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { <S2SV_StartBug> in_named_escape = 0 ; <S2SV_EndBug> } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { <S2SV_StartBug> if ( * str + 1 < end && * ( * str + 1 ) == ch ) { <S2SV_EndBug> literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { <S2SV_StartBug> ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ; <S2SV_EndBug> return - 1 ; } } <S2SV_StartBug> break ; <S2SV_EndBug> } } <S2SV_StartBug> literal_end = * str ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str <= end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str == end || * * str == '{' || * * str == '}' ) ; <S2SV_EndBug> done : <S2SV_StartBug> if ( literal_start != literal_end ) { <S2SV_EndBug> if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , <S2SV_StartBug> literal_end - literal_start , <S2SV_EndBug> NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , <S2SV_StartBug> literal_end - literal_start ) ; <S2SV_EndBug> if ( ! * literal ) return - 1 ; } return result ; }
","<S2SV_ModStart> const char * s = * str ; const char * literal_start = s <S2SV_ModEnd> ; int result <S2SV_ModStart> NULL ) ; while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> '}' ) { <S2SV_ModStart> '}' ) { } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> if ( ch <S2SV_ModStart> { if ( s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> ; result = <S2SV_ModStart> '}' ) { * str = s - 1 ; <S2SV_ModStart> ; } } s -- ; <S2SV_ModStart> ; } } * str = s <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> <= end ) <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> == end || <S2SV_ModStart> end || * s <S2SV_ModEnd> == '{' || <S2SV_ModStart> '{' || * s <S2SV_ModEnd> == '}' ) <S2SV_ModStart> ( literal_start != s <S2SV_ModEnd> ) { if <S2SV_ModStart> ( literal_start , s <S2SV_ModEnd> - literal_start , <S2SV_ModStart> , literal_start , s <S2SV_ModEnd> - literal_start )
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,203,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> char * str, str <S2SV_ModStart> char * str, str, str, str, str, str, str, str ) { char * str ; if ( * str ) { char * str ; * str = * str ; const char * str ; * str ; const char * str = * str ; const char * str ; * str = * str ; const char * str ; const char * str ; * str == '\\\\' <S2SV_ModEnd> * str ) <S2SV_ModStart> * str ; <S2SV_ModEnd> if (! <S2SV_ModStart> * str ) { char * str = * str ; <S2SV_ModStart> * str ; <S2SV_ModEnd> = str ; <S2SV_ModStart> * str ; <S2SV_ModEnd> if (! <S2SV_ModStart> * str ) { <S2SV_ModStart> * str ; <S2SV_ModEnd> return 0 ; <S2SV_ModStart> * str ; } <S2SV_ModEnd> * str = str_end ++ ; <S2SV_ModStart> * str ; <S2SV_ModEnd> = str ; <S2SV_ModStart> * str ; <S2SV_ModEnd> = str ; <S2SV_ModStart> * str ; <S2SV_ModEnd> } else <S2SV_ModStart> * str ; <S2SV_ModEnd> return 0 ; <S2SV_ModStart> * str ; <S2SV_ModStart> * str ; <S2SV_ModEnd> return 0 ; <S2SV_ModStart> * str ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>",0
566,CWE-200,"CWE-200 char * problem_data_save ( problem_data_t * pd ) { load_abrt_conf ( ) ; <S2SV_StartBug> struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; <S2SV_EndBug> char * problem_id = NULL ; if ( dd ) { problem_id = xstrdup ( dd -> dd_dirname ) ; dd_close ( dd ) ; } log_info ( ""problem<S2SV_blank>id:<S2SV_blank>\'%s\'"" , problem_id ) ; return problem_id ; }
","<S2SV_ModStart> struct dump_dir * dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else
",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z,204,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
569,CWE-190,"CWE-190 void rfbScaledScreenUpdateRect ( rfbScreenInfoPtr screen , rfbScreenInfoPtr ptr , int x0 , int y0 , int w0 , int h0 ) { int x , y , w , v , z ; int x1 , y1 , w1 , h1 ; int bitsPerPixel , bytesPerPixel , bytesPerLine , areaX , areaY , area2 ; unsigned char * srcptr , * dstptr ; if ( screen == ptr ) return ; x1 = x0 ; y1 = y0 ; w1 = w0 ; h1 = h0 ; rfbScaledCorrection ( screen , ptr , & x1 , & y1 , & w1 , & h1 , ""rfbScaledScreenUpdateRect"" ) ; x0 = ScaleX ( ptr , screen , x1 ) ; y0 = ScaleY ( ptr , screen , y1 ) ; w0 = ScaleX ( ptr , screen , w1 ) ; h0 = ScaleY ( ptr , screen , h1 ) ; bitsPerPixel = screen -> bitsPerPixel ; bytesPerPixel = bitsPerPixel / 8 ; bytesPerLine = w1 * bytesPerPixel ; srcptr = ( unsigned char * ) ( screen -> frameBuffer + ( y0 * screen -> paddedWidthInBytes + x0 * bytesPerPixel ) ) ; dstptr = ( unsigned char * ) ( ptr -> frameBuffer + ( y1 * ptr -> paddedWidthInBytes + x1 * bytesPerPixel ) ) ; areaX = ScaleX ( ptr , screen , 1 ) ; areaY = ScaleY ( ptr , screen , 1 ) ; area2 = areaX * areaY ; if ( ( x1 + w1 ) > ( ptr -> width ) ) { if ( x1 == 0 ) w1 = ptr -> width ; else x1 = ptr -> width - w1 ; } if ( ( y1 + h1 ) > ( ptr -> height ) ) { if ( y1 == 0 ) h1 = ptr -> height ; else y1 = ptr -> height - h1 ; } if ( screen -> serverFormat . trueColour ) { unsigned char * srcptr2 ; unsigned long pixel_value , red , green , blue ; unsigned int redShift = screen -> serverFormat . redShift ; unsigned int greenShift = screen -> serverFormat . greenShift ; unsigned int blueShift = screen -> serverFormat . blueShift ; unsigned long redMax = screen -> serverFormat . redMax ; unsigned long greenMax = screen -> serverFormat . greenMax ; unsigned long blueMax = screen -> serverFormat . blueMax ; for ( y = 0 ; y < h1 ; y ++ ) { for ( x = 0 ; x < w1 ; x ++ ) { red = green = blue = 0 ; for ( w = 0 ; w < areaX ; w ++ ) { for ( v = 0 ; v < areaY ; v ++ ) { srcptr2 = & srcptr [ ( ( ( x * areaX ) + w ) * bytesPerPixel ) + ( v * screen -> paddedWidthInBytes ) ] ; pixel_value = 0 ; switch ( bytesPerPixel ) { case 4 : pixel_value = * ( ( unsigned int * ) srcptr2 ) ; break ; case 2 : pixel_value = * ( ( unsigned short * ) srcptr2 ) ; break ; case 1 : pixel_value = * ( ( unsigned char * ) srcptr2 ) ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) <S2SV_StartBug> pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ; <S2SV_EndBug> break ; } red += ( ( pixel_value >> redShift ) & redMax ) ; green += ( ( pixel_value >> greenShift ) & greenMax ) ; blue += ( ( pixel_value >> blueShift ) & blueMax ) ; } } red /= area2 ; green /= area2 ; blue /= area2 ; pixel_value = ( ( red & redMax ) << redShift ) | ( ( green & greenMax ) << greenShift ) | ( ( blue & blueMax ) << blueShift ) ; switch ( bytesPerPixel ) { case 4 : * ( ( unsigned int * ) dstptr ) = ( unsigned int ) pixel_value ; break ; case 2 : * ( ( unsigned short * ) dstptr ) = ( unsigned short ) pixel_value ; break ; case 1 : * ( ( unsigned char * ) dstptr ) = ( unsigned char ) pixel_value ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) dstptr [ z ] = ( pixel_value >> ( 8 * z ) ) & 0xff ; break ; } dstptr += bytesPerPixel ; } srcptr += ( screen -> paddedWidthInBytes * areaY ) ; dstptr += ( ptr -> paddedWidthInBytes - bytesPerLine ) ; } } else { for ( y = y1 ; y < ( y1 + h1 ) ; y ++ ) { for ( x = x1 ; x < ( x1 + w1 ) ; x ++ ) memcpy ( & ptr -> frameBuffer [ ( y * ptr -> paddedWidthInBytes ) + ( x * bytesPerPixel ) ] , & screen -> frameBuffer [ ( y * areaY * screen -> paddedWidthInBytes ) + ( x * areaX * bytesPerPixel ) ] , bytesPerPixel ) ; } } }
","<S2SV_ModStart> pixel_value += ( ( unsigned long )
",LibVNC@libvncserver/a6788d1da719ae006605b78d22f5a9f170b423af,CVE-2020-14401,https://github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af,2020-06-17T16:15Z,205,,0
572,CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,206,"<S2SV_ModStart> u_char * dat, u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; }",1
575,CWE-119,"CWE-119 int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
","<S2SV_ModStart> bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,207,"<S2SV_ModStart> bestaddress, in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here, in_what_stride <S2SV_ModEnd> ) ; if",1
577,CWE-269,"CWE-269 struct crypto_template * crypto_lookup_template ( const char * name ) { <S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" , <S2SV_EndBug> name ) ; }
","<S2SV_ModStart> name ) , ""crypto-%s"" <S2SV_ModEnd> , name )
",torvalds@linux/4943ba16bbc2db05115707b3ff7b4874e9e3c560,CVE-2014-9644,https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560,2015-03-02T11:59Z,208,"<S2SV_ModStart>, const char * name <S2SV_ModEnd> ; if (",0
579,CWE-119,"CWE-119 <S2SV_StartBug> static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * cm = & cpi -> common ; MACROBLOCKD * xd = & cpi -> mb . e_mbd ; int mi_col ; <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> mi_col += MI_BLOCK_SIZE ) { <S2SV_StartBug> int dummy_rate = 0 ; <S2SV_EndBug> int64_t dummy_dist = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE bsize ; <S2SV_EndBug> cpi -> mb . source_variance = UINT_MAX ; <S2SV_StartBug> vp9_zero ( cpi -> mb . pred_mv ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( cpi -> sf . partition_search_type ) { <S2SV_EndBug> case VAR_BASED_PARTITION : <S2SV_StartBug> choose_partitioning ( cpi , tile , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> break ; case SOURCE_VAR_BASED_PARTITION : <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case VAR_BASED_FIXED_PARTITION : <S2SV_EndBug> case FIXED_PARTITION : <S2SV_StartBug> bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? <S2SV_EndBug> cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; <S2SV_StartBug> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> break ; case REFERENCE_PARTITION : <S2SV_StartBug> if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; <S2SV_EndBug> } else { <S2SV_StartBug> copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> } break ; default : assert ( 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { SPEED_FEATURES * const sf = & cpi -> sf ; VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * const <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> xd -> left_context <S2SV_ModStart> xd -> left_context ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> ( xd -> left_seg_context <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( mi_col = tile_info <S2SV_ModEnd> -> mi_col_start ; <S2SV_ModStart> ; mi_col < tile_info <S2SV_ModEnd> -> mi_col_end ; <S2SV_ModStart> MI_BLOCK_SIZE ) { const struct segmentation * const seg = & cm -> seg ; RD_COST dummy_rdc <S2SV_ModEnd> ; const int <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> = cm -> <S2SV_ModStart> + idx_str ; PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type <S2SV_ModEnd> ; BLOCK_SIZE bsize <S2SV_ModStart> ; BLOCK_SIZE bsize = BLOCK_64X64 ; int seg_skip = 0 ; x -> <S2SV_ModEnd> source_variance = UINT_MAX <S2SV_ModStart> ; vp9_zero ( x -> <S2SV_ModEnd> pred_mv ) ; <S2SV_ModStart> pred_mv ) ; vp9_rd_cost_init ( & dummy_rdc ) ; x -> color_sensitivity [ 0 ] = 0 ; x -> color_sensitivity [ 1 ] = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; if ( seg_skip ) { partition_search_type = FIXED_PARTITION ; } } switch ( <S2SV_ModEnd> partition_search_type ) { <S2SV_ModStart> ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , & <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; break <S2SV_ModStart> case SOURCE_VAR_BASED_PARTITION : <S2SV_ModEnd> set_source_var_based_partition ( cpi <S2SV_ModStart> ( cpi , tile_info , x , mi <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , & <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; break <S2SV_ModStart> ; break ; <S2SV_ModEnd> case FIXED_PARTITION : <S2SV_ModStart> case FIXED_PARTITION : if ( ! seg_skip ) bsize = sf -> always_this_block_size <S2SV_ModEnd> ; set_fixed_partitioning ( <S2SV_ModStart> ( cpi , tile_info , mi <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , & <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; break <S2SV_ModStart> case REFERENCE_PARTITION : set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_ModStart> ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && xd -> mi [ 0 ] -> mbmi . segment_id ) { if ( cm -> width <= 352 && cm -> height <= 288 ) x -> max_partition_size = BLOCK_32X32 ; else x -> max_partition_size = BLOCK_64X64 ; x -> min_partition_size = BLOCK_8X8 ; <S2SV_ModEnd> nonrd_pick_partition ( cpi <S2SV_ModStart> ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , & dummy_rdc <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1 , INT64_MAX , td -> pc_root <S2SV_ModStart> } else { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; if ( cm -> frame_type == KEY_FRAME ) <S2SV_ModEnd> nonrd_use_partition ( cpi <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root ) ; else nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; } <S2SV_ModStart> 0 ) ; break ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,209,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static MACROBLOCKD <S2SV_ModEnd> int mi_col ; <S2SV_ModStart> int mi_col ; MACROBLOCKD * mi_col ; memset <S2SV_ModEnd> ( cpi, <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; } memcpy <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi",0
581,CWE-20,"CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,210,"<S2SV_ModStart> ), & _dh <S2SV_ModEnd> ) ; if",0
583,CWE-000,"CWE-000 static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; <S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> & tmpname , ""/etc"" , "".vipw"" <S2SV_ModEnd> ) ) ==
",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z,211,"<S2SV_ModStart> char * dir <S2SV_ModEnd>, dir,",0
587,CWE-20,"CWE-20 static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; <S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
","<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
",torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z,212,<S2SV_ModStart> mnt ) ; nd -> path = NULL ;,0
589,CWE-362,"CWE-362 <S2SV_StartBug> static int ip_options_get_finish ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt , int optlen ) <S2SV_EndBug> { while ( optlen & 3 ) <S2SV_StartBug> opt -> __data [ optlen ++ ] = IPOPT_END ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen && ip_options_compile ( net , opt , NULL ) ) { <S2SV_EndBug> kfree ( opt ) ; return - EINVAL ; } kfree ( * optp ) ; * optp = opt ; return 0 ; }
","<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> optp , struct ip_options_rcu <S2SV_ModEnd> * opt , <S2SV_ModStart> ) opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ( net , & opt ->
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,213,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct ip_options_options_options ( struct ip_options_options_options * opt, <S2SV_ModStart> * opt, & opt, & opt_options_options_options_rcu <S2SV_ModEnd> ) ; if <S2SV_ModStart> return - EINVAL ; } <S2SV_null>",0
592,CWE-190,"CWE-190 static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( ""Header:<S2SV_blank>%s:<S2SV_blank>%s"" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , ""Host"" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , ""Upgrade"" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , ""websocket"" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , ""Connection"" ) ; <S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "","" , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , ""<S2SV_blank>"" ) ; if ( strcasecmp ( token , ""Upgrade"" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , ""Sec-WebSocket-Version"" ) ; if ( ws_version == NULL || strcmp ( ws_version , ""13"" ) != 0 ) goto error ; const char * ws_key = http_request_get_header ( info -> request , ""Sec-WebSocket-Key"" ) ; if ( ws_key == NULL ) goto error ; const char * protocol_list = http_request_get_header ( info -> request , ""Sec-WebSocket-Protocol"" ) ; if ( protocol_list && ! is_good_protocol ( protocol_list , svr -> protocol ) ) goto error ; if ( strlen ( svr -> origin ) > 0 ) { const char * origin = http_request_get_header ( info -> request , ""Origin"" ) ; if ( origin == NULL || ! is_good_origin ( origin , svr -> origin ) ) goto error ; } if ( svr -> type . on_privdata_alloc ) { info -> privdata = svr -> type . on_privdata_alloc ( svr ) ; if ( info -> privdata == NULL ) goto error ; } info -> upgrade = true ; info -> remote = sdsnew ( http_get_remote_ip ( info -> ses , info -> request ) ) ; info -> url = sdsnew ( info -> request -> url ) ; if ( svr -> type . on_upgrade ) { svr -> type . on_upgrade ( info -> ses , info -> remote ) ; } if ( protocol_list ) { send_hand_shake_reply ( info -> ses , svr -> protocol , ws_key ) ; } else { send_hand_shake_reply ( info -> ses , NULL , ws_key ) ; } return 0 ; error : ws_svr_close_clt ( ws_svr_from_ses ( info -> ses ) , info -> ses ) ; return - 1 ; }
","<S2SV_ModStart> connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE
",viabtc@viabtc_exchange_server/4a7c27bfe98f409623d4d857894d017ff0672cc9,CVE-2018-17568,https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8,2018-09-26T22:29Z,214,,0
593,CWE-20,"CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed"" ""<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device."" , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> * findalldevs_if ; uint32 replylen ; <S2SV_ModStart> 0 ; } replylen = 0 ; <S2SV_ModStart> -> description ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> -> name ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> name ) ; replylen <S2SV_ModEnd> += sizeof ( <S2SV_ModStart> : # endif replylen <S2SV_ModEnd> += ( sizeof <S2SV_ModStart> , nif , replylen <S2SV_ModEnd> ) ; for
",the-tcpdump-group@libpcap/617b12c0339db4891d117b661982126c495439ea,CVE-2019-15161,https://github.com/the-tcpdump-group/libpcap/commit/617b12c0339db4891d117b661982126c495439ea,2019-10-03T19:15Z,215,<S2SV_ModStart> ; if ( len < 0 || <S2SV_ModStart> ) return - EINVAL ; } if (,0
594,CWE-200,"CWE-200 static int create_problem_dir ( GHashTable * problem_info , unsigned pid ) { if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) exit ( 1 ) ; } gchar * dir_basename = g_hash_table_lookup ( problem_info , ""basename"" ) ; if ( ! dir_basename ) dir_basename = g_hash_table_lookup ( problem_info , FILENAME_TYPE ) ; char * path = xasprintf ( ""%s/%s-%s-%u.new"" , g_settings_dump_location , dir_basename , iso_date_string ( NULL ) , pid ) ; g_hash_table_remove ( problem_info , ""basename"" ) ; <S2SV_StartBug> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> if ( ! dd ) { error_msg_and_die ( ""Error<S2SV_blank>creating<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'"" , path ) ; } dd_create_basic_files ( dd , client_uid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; gpointer gpkey = g_hash_table_lookup ( problem_info , FILENAME_CMDLINE ) ; if ( ! gpkey ) { char * cmdline = get_cmdline ( pid ) ; if ( cmdline ) { dd_save_text ( dd , FILENAME_CMDLINE , cmdline ) ; free ( cmdline ) ; } } char uid_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( uid_str , ""%lu"" , ( long ) client_uid ) ; dd_save_text ( dd , FILENAME_UID , uid_str ) ; GHashTableIter iter ; gpointer gpvalue ; g_hash_table_iter_init ( & iter , problem_info ) ; while ( g_hash_table_iter_next ( & iter , & gpkey , & gpvalue ) ) { dd_save_text ( dd , ( gchar * ) gpkey , ( gchar * ) gpvalue ) ; } dd_close ( dd ) ; g_hash_table_destroy ( problem_info ) ; char * newpath = xstrndup ( path , strlen ( path ) - strlen ( "".new"" ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log_notice ( ""Saved<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>\'%s\'"" , pid , path ) ; printf ( ""HTTP/1.1<S2SV_blank>201<S2SV_blank>Created\\r\\n\\r\\n"" ) ; fflush ( NULL ) ; close ( STDOUT_FILENO ) ; xdup2 ( STDERR_FILENO , STDOUT_FILENO ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { trim_problem_dirs ( g_settings_dump_location , g_settings_nMaxCrashReportsSize * ( double ) ( 1024 * 1024 ) , path ) ; } run_post_create ( path ) ; exit ( 0 ) ; }
","<S2SV_ModStart> ( path , g_settings_privatereports ? 0 :
",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z,216,<S2SV_ModStart>,0
595,CWE-787,"CWE-787 static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b6ae2f9e0ab13343c0281732d479757a8e8979c7,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7,2017-04-20T18:59Z,217,<S2SV_ModStart> -> columns - 1,0
596,CWE-310,"CWE-310 void bn_sqr_comba8 ( BN_ULONG * r , const BN_ULONG * a ) { <S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; sqr_add_c ( a , 0 , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 0 , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 5 , 0 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 4 , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 4 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 1 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 0 , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 7 , 0 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 6 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 5 , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 3 , c2 , c3 , c1 ) ; r [ 7 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 4 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 5 , 3 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 6 , 2 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 7 , 1 , c3 , c1 , c2 ) ; r [ 8 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 7 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 4 , c1 , c2 , c3 ) ; r [ 9 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 5 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 6 , 4 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 7 , 3 , c2 , c3 , c1 ) ; r [ 10 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 7 , 4 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 6 , 5 , c3 , c1 , c2 ) ; r [ 11 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 6 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 7 , 5 , c1 , c2 , c3 ) ; r [ 12 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 7 , 6 , c2 , c3 , c1 ) ; r [ 13 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 7 , c3 , c1 , c2 ) ; r [ 14 ] = c3 ; r [ 15 ] = c1 ; }
","<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z,218,"<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1, c2",1
598,CWE-119,"CWE-119 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) <S2SV_EndBug> { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,219,,0
599,CWE-125,"CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u,<S2SV_blank>%s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "",<S2SV_blank>(ttl<S2SV_blank>%u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>authtype<S2SV_blank>%s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>auth<S2SV_blank>\\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
","<S2SV_ModStart> 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> ) ) ; }
",the-tcpdump-group@tcpdump/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,CVE-2018-14463,https://github.com/the-tcpdump-group/tcpdump/commit/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,2019-10-03T16:15Z,220,<S2SV_ModStart> ) ) ; ND_TCHECK ( bp [ 0 ],0
601,CWE-264,"CWE-264 static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
","<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
",torvalds@linux/d049f74f2dbe71354d43d393ac3a188947811348,CVE-2013-2929,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,2013-12-09T18:55Z,221,<S2SV_ModStart> ; if ( task_lock <S2SV_ModEnd> ( task ),0
604,CWE-190,"CWE-190 void jas_matrix_clip ( jas_matrix_t * matrix , jas_seqent_t minval , jas_seqent_t maxval ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t v ; jas_seqent_t * rowstart ; jas_seqent_t * data ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { data = rowstart ; for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { v = * data ; if ( v < minval ) { * data = minval ; } else if ( v > maxval ) { * data = maxval ; } } } } }
","<S2SV_ModStart> maxval ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * data ; jas_matind_t <S2SV_ModEnd> rowstep ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,222,<S2SV_ModStart> val ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_matind_t,0
605,CWE-190,"CWE-190 void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask >> final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( ""payload_bit_equal_to_one"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( ""payload_bit_equal_to_zero"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }
","<S2SV_ModStart> = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> u4_payload_size ) ; } <S2SV_ModStart> = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> u4_payload_size ) ; }
",external@libhevc/9f0fb67540d2259e4930d9bd5f1a1a6fb95af862,CVE-2018-9473,https://android.googlesource.com/platform/external/libhevc/+/9f0fb67540d2259e4930d9bd5f1a1a6fb95af862,2018-10-02T19:29Z,223,<S2SV_ModStart> } else { if ( i4_t == 0 &&,0
607,CWE-401,"CWE-401 int sdma_init ( struct hfi1_devdata * dd , u8 port ) { unsigned this_idx ; struct sdma_engine * sde ; struct rhashtable * tmp_sdma_rht ; u16 descq_cnt ; void * curr_head ; struct hfi1_pportdata * ppd = dd -> pport + port ; u32 per_sdma_credits ; uint idle_cnt = sdma_idle_cnt ; size_t num_engines = chip_sdma_engines ( dd ) ; int ret = - ENOMEM ; if ( ! HFI1_CAP_IS_KSET ( SDMA ) ) { HFI1_CAP_CLEAR ( SDMA_AHG ) ; return 0 ; } if ( mod_num_sdma && mod_num_sdma <= chip_sdma_engines ( dd ) && mod_num_sdma >= num_vls ) num_engines = mod_num_sdma ; dd_dev_info ( dd , ""SDMA<S2SV_blank>mod_num_sdma:<S2SV_blank>%u\\n"" , mod_num_sdma ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>chip_sdma_engines:<S2SV_blank>%u\\n"" , chip_sdma_engines ( dd ) ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>chip_sdma_mem_size:<S2SV_blank>%u\\n"" , chip_sdma_mem_size ( dd ) ) ; per_sdma_credits = chip_sdma_mem_size ( dd ) / ( num_engines * SDMA_BLOCK_SIZE ) ; init_waitqueue_head ( & dd -> sdma_unfreeze_wq ) ; atomic_set ( & dd -> sdma_unfreeze_count , 0 ) ; descq_cnt = sdma_get_descq_cnt ( ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>engines<S2SV_blank>%zu<S2SV_blank>descq_cnt<S2SV_blank>%u\\n"" , num_engines , descq_cnt ) ; dd -> per_sdma = kcalloc_node ( num_engines , sizeof ( * dd -> per_sdma ) , GFP_KERNEL , dd -> node ) ; if ( ! dd -> per_sdma ) return ret ; idle_cnt = ns_to_cclock ( dd , idle_cnt ) ; if ( idle_cnt ) dd -> default_desc1 = SDMA_DESC1_HEAD_TO_HOST_FLAG ; else dd -> default_desc1 = SDMA_DESC1_INT_REQ_FLAG ; if ( ! sdma_desct_intr ) sdma_desct_intr = SDMA_DESC_INTR ; for ( this_idx = 0 ; this_idx < num_engines ; ++ this_idx ) { sde = & dd -> per_sdma [ this_idx ] ; sde -> dd = dd ; sde -> ppd = ppd ; sde -> this_idx = this_idx ; sde -> descq_cnt = descq_cnt ; sde -> desc_avail = sdma_descq_freecnt ( sde ) ; sde -> sdma_shift = ilog2 ( descq_cnt ) ; sde -> sdma_mask = ( 1 << sde -> sdma_shift ) - 1 ; sde -> int_mask = ( u64 ) 1 << ( 0 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> progress_mask = ( u64 ) 1 << ( 1 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> idle_mask = ( u64 ) 1 << ( 2 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> imask = sde -> int_mask | sde -> progress_mask | sde -> idle_mask ; spin_lock_init ( & sde -> tail_lock ) ; seqlock_init ( & sde -> head_lock ) ; spin_lock_init ( & sde -> senddmactrl_lock ) ; spin_lock_init ( & sde -> flushlist_lock ) ; seqlock_init ( & sde -> waitlock ) ; sde -> ahg_bits = 0xfffffffe00000000ULL ; sdma_set_state ( sde , sdma_state_s00_hw_down ) ; kref_init ( & sde -> state . kref ) ; init_completion ( & sde -> state . comp ) ; INIT_LIST_HEAD ( & sde -> flushlist ) ; INIT_LIST_HEAD ( & sde -> dmawait ) ; sde -> tail_csr = get_kctxt_csr_addr ( dd , this_idx , SD ( TAIL ) ) ; tasklet_init ( & sde -> sdma_hw_clean_up_task , sdma_hw_clean_up_task , ( unsigned long ) sde ) ; tasklet_init ( & sde -> sdma_sw_clean_up_task , sdma_sw_clean_up_task , ( unsigned long ) sde ) ; INIT_WORK ( & sde -> err_halt_worker , sdma_err_halt_wait ) ; INIT_WORK ( & sde -> flush_worker , sdma_field_flush ) ; sde -> progress_check_head = 0 ; timer_setup ( & sde -> err_progress_check_timer , sdma_err_progress_check , 0 ) ; sde -> descq = dma_alloc_coherent ( & dd -> pcidev -> dev , descq_cnt * sizeof ( u64 [ 2 ] ) , & sde -> descq_phys , GFP_KERNEL ) ; if ( ! sde -> descq ) goto bail ; sde -> tx_ring = kvzalloc_node ( array_size ( descq_cnt , sizeof ( struct sdma_txreq * ) ) , GFP_KERNEL , dd -> node ) ; if ( ! sde -> tx_ring ) goto bail ; } dd -> sdma_heads_size = L1_CACHE_BYTES * num_engines ; dd -> sdma_heads_dma = dma_alloc_coherent ( & dd -> pcidev -> dev , dd -> sdma_heads_size , & dd -> sdma_heads_phys , GFP_KERNEL ) ; if ( ! dd -> sdma_heads_dma ) { dd_dev_err ( dd , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>SendDMA<S2SV_blank>head<S2SV_blank>memory\\n"" ) ; goto bail ; } dd -> sdma_pad_dma = dma_alloc_coherent ( & dd -> pcidev -> dev , sizeof ( u32 ) , & dd -> sdma_pad_phys , GFP_KERNEL ) ; if ( ! dd -> sdma_pad_dma ) { dd_dev_err ( dd , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>SendDMA<S2SV_blank>pad<S2SV_blank>memory\\n"" ) ; goto bail ; } curr_head = ( void * ) dd -> sdma_heads_dma ; for ( this_idx = 0 ; this_idx < num_engines ; ++ this_idx ) { unsigned long phys_offset ; sde = & dd -> per_sdma [ this_idx ] ; sde -> head_dma = curr_head ; curr_head += L1_CACHE_BYTES ; phys_offset = ( unsigned long ) sde -> head_dma - ( unsigned long ) dd -> sdma_heads_dma ; sde -> head_phys = dd -> sdma_heads_phys + phys_offset ; init_sdma_regs ( sde , per_sdma_credits , idle_cnt ) ; } dd -> flags |= HFI1_HAS_SEND_DMA ; dd -> flags |= idle_cnt ? HFI1_HAS_SDMA_TIMEOUT : 0 ; dd -> num_sdma = num_engines ; ret = sdma_map_init ( dd , port , ppd -> vls_operational , NULL ) ; if ( ret < 0 ) goto bail ; tmp_sdma_rht = kzalloc ( sizeof ( * tmp_sdma_rht ) , GFP_KERNEL ) ; if ( ! tmp_sdma_rht ) { ret = - ENOMEM ; goto bail ; } ret = rhashtable_init ( tmp_sdma_rht , & sdma_rht_params ) ; <S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> goto bail ; <S2SV_StartBug> dd -> sdma_rht = tmp_sdma_rht ; <S2SV_EndBug> dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\n"" , dd -> num_sdma ) ; return 0 ; bail : sdma_clean ( dd , num_engines ) ; return ret ; }
","<S2SV_ModStart> < 0 ) { kfree ( tmp_sdma_rht ) ; <S2SV_ModStart> goto bail ; }
",torvalds@linux/34b3be18a04ecdc610aae4c48e5d1b799d8689f6,CVE-2019-19065,https://github.com/torvalds/linux/commit/34b3be18a04ecdc610aae4c48e5d1b799d8689f6,2019-11-18T06:15Z,224,,0
609,CWE-362,"CWE-362 int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , <S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM * sort_param = 0 ; MYISAM_SHARE * share = info -> s ; ulong * rec_per_key_part ; HA_KEYSEG * keyseg ; char llbuff [ 22 ] ; IO_CACHE new_data_cache ; IO_CACHE_SHARE io_share ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; DBUG_ENTER ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>parallel<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_PRINT ( ""info"" , ( ""is<S2SV_blank>quick<S2SV_blank>repair:<S2SV_blank>%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ; mysql_cond_init ( mi_key_cond_MI_SORT_INFO_cond , & sort_info . cond , 0 ) ; mysql_mutex_init ( mi_key_mutex_MI_CHECK_print_msg , & param -> print_msg_mutex , MY_MUTEX_INIT_FAST ) ; param -> need_print_msg_lock = 1 ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , READ_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_DONT_CHECK_FILESIZE ) ) ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ; else rec_length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ; del = info -> state -> del ; param -> glob_crc = 0 ; max_pack_reclength = share -> base . pack_reclength ; if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ; if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ; goto err ; } total_key_length = 0 ; rec_per_key_part = param -> rec_per_key_part ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; for ( i = key = 0 , istep = 1 ; key < share -> base . keys ; rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) { sort_param [ i ] . key = key ; sort_param [ i ] . keyinfo = share -> keyinfo + key ; sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; istep = 0 ; continue ; } istep = 1 ; if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , key + 1 ) ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { sort_param [ i ] . key_read = sort_ft_key_read ; sort_param [ i ] . key_write = sort_ft_key_write ; } else { sort_param [ i ] . key_read = sort_key_read ; sort_param [ i ] . key_write = sort_key_write ; } sort_param [ i ] . key_cmp = sort_key_cmp ; sort_param [ i ] . lock_in_memory = lock_memory ; sort_param [ i ] . tmpdir = param -> tmpdir ; sort_param [ i ] . sort_info = & sort_info ; sort_param [ i ] . master = 0 ; sort_param [ i ] . fix_datafile = 0 ; sort_param [ i ] . calc_checksum = 0 ; sort_param [ i ] . filepos = new_header_length ; sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ; sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ; goto err ; } sort_param [ i ] . key_length = share -> rec_reflength ; for ( keyseg = sort_param [ i ] . seg ; keyseg -> type != HA_KEYTYPE_END ; keyseg ++ ) { sort_param [ i ] . key_length += keyseg -> length ; if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ; if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ; if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ; } total_key_length += sort_param [ i ] . key_length ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ; sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; } } sort_info . total_keys = i ; sort_param [ 0 ] . master = 1 ; sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ; if ( ! ftparser_alloc_param ( info ) ) goto err ; sort_info . got_error = 0 ; mysql_mutex_lock ( & sort_info . mutex ) ; if ( i > 1 ) { if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ; else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ; } else io_share . total_threads = 0 ; ( void ) pthread_attr_init ( & thr_attr ) ; ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ; for ( i = 0 ; i < sort_info . total_keys ; i ++ ) { sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ; DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ; sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ; # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ; # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) { mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ; if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ; DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ; sort_info . got_error = 1 ; } else sort_info . threads_running ++ ; } ( void ) pthread_attr_destroy ( & thr_attr ) ; while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ; mysql_mutex_unlock ( & sort_info . mutex ) ; if ( ( got_error = thr_write_keys ( sort_param ) ) ) { param -> retry_repair = 1 ; goto err ; } got_error = 1 ; if ( sort_param [ 0 ] . fix_datafile ) { if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; } else info -> state -> data_file_length = sort_param -> max_pos ; if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) { <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; mysql_cond_destroy ( & sort_info . cond ) ; mysql_mutex_destroy ( & sort_info . mutex ) ; mysql_mutex_destroy ( & param -> print_msg_mutex ) ; param -> need_print_msg_lock = 0 ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . key_block ) ; my_free ( sort_param ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }
","<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,225,<S2SV_ModStart> <S2SV_null> <S,0
610,CWE-000,"CWE-000 Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ; <S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }
","<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )
",ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z,226,,0
612,CWE-189,"CWE-189 Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } <S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> ) ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,227,,0
613,CWE-476,"CWE-476 static void parserule ( struct scanner * s , struct environment * env ) { struct rule * r ; char * var ; struct evalstring * val ; bool hascommand = false , hasrspfile = false , hasrspcontent = false ; r = mkrule ( scanname ( s ) ) ; scannewline ( s ) ; while ( scanindent ( s ) ) { var = scanname ( s ) ; parselet ( s , & val ) ; <S2SV_StartBug> ruleaddvar ( r , var , val ) ; <S2SV_EndBug> if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ; else if ( strcmp ( var , ""rspfile"" ) == 0 ) hasrspfile = true ; else if ( strcmp ( var , ""rspfile_content"" ) == 0 ) hasrspcontent = true ; } if ( ! hascommand ) fatal ( ""rule<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>no<S2SV_blank>command"" , r -> name ) ; if ( hasrspfile != hasrspcontent ) fatal ( ""rule<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>rspfile<S2SV_blank>and<S2SV_blank>no<S2SV_blank>rspfile_content<S2SV_blank>or<S2SV_blank>vice<S2SV_blank>versa"" , r -> name ) ; envaddrule ( env , r ) ; }
","<S2SV_ModStart> , val ) ; if ( ! val ) continue
",michaelforney@samurai/d2af3bc375e2a77139c3a28d6128c60cd8d08655,CVE-2021-30219,https://github.com/michaelforney/samurai/commit/d2af3bc375e2a77139c3a28d6128c60cd8d08655,2021-04-29T15:15Z,228,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> } else,0
615,CWE-444,"CWE-444 static HeadReturn con_header_read ( agooCon c , size_t * mlenp ) { char * hend = strstr ( c -> buf , ""\\r\\n\\r\\n"" ) ; agooMethod method ; struct _agooSeg path ; char * query = NULL ; char * qend ; char * b ; size_t clen = 0 ; long mlen ; agooHook hook = NULL ; agooPage p ; struct _agooErr err = AGOO_ERR_INIT ; if ( NULL == hend ) { if ( sizeof ( c -> buf ) - 1 <= c -> bcnt ) { return bad_request ( c , 431 , __LINE__ ) ; } return HEAD_AGAIN ; } if ( agoo_req_cat . on ) { * hend = '\\0' ; agoo_log_cat ( & agoo_req_cat , ""%s<S2SV_blank>%llu:<S2SV_blank>%s"" , agoo_con_kind_str ( c -> bind -> kind ) , ( unsigned long long ) c -> id , c -> buf ) ; * hend = '\\r' ; } for ( b = c -> buf ; '<S2SV_blank>' != * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } switch ( toupper ( * c -> buf ) ) { case 'G' : if ( 3 != b - c -> buf || 0 != strncmp ( ""GET"" , c -> buf , 3 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_GET ; break ; case 'P' : { const char * v ; int vlen = 0 ; char * vend ; if ( 3 == b - c -> buf && 0 == strncmp ( ""PUT"" , c -> buf , 3 ) ) { method = AGOO_PUT ; } else if ( 4 == b - c -> buf && 0 == strncmp ( ""POST"" , c -> buf , 4 ) ) { method = AGOO_POST ; } else { return bad_request ( c , 400 , __LINE__ ) ; } if ( NULL == ( v = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Content-Length"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } clen = ( size_t ) strtoul ( v , & vend , 10 ) ; if ( vend != v + vlen ) { return bad_request ( c , 411 , __LINE__ ) ; } break ; } case 'D' : if ( 6 != b - c -> buf || 0 != strncmp ( ""DELETE"" , c -> buf , 6 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_DELETE ; break ; case 'H' : if ( 4 != b - c -> buf || 0 != strncmp ( ""HEAD"" , c -> buf , 4 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_HEAD ; break ; case 'O' : if ( 7 != b - c -> buf || 0 != strncmp ( ""OPTIONS"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_OPTIONS ; break ; case 'C' : if ( 7 != b - c -> buf || 0 != strncmp ( ""CONNECT"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_CONNECT ; break ; default : return bad_request ( c , 400 , __LINE__ ) ; } for ( ; '<S2SV_blank>' == * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } path . start = b ; for ( ; '<S2SV_blank>' != * b ; b ++ ) { switch ( * b ) { case '?' : path . end = b ; query = b + 1 ; break ; case '\\0' : return bad_request ( c , 400 , __LINE__ ) ; default : break ; } } if ( NULL == query ) { path . end = b ; query = b ; qend = b ; } else { qend = b ; } mlen = hend - c -> buf + 4 + clen ; * mlenp = mlen ; if ( AGOO_GET == method ) { char root_buf [ 20148 ] ; const char * root = NULL ; if ( NULL != ( p = agoo_group_get ( & err , path . start , ( int ) ( path . end - path . start ) ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( agoo_domain_use ( ) ) { const char * host ; int vlen = 0 ; if ( NULL == ( host = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Host"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } ( ( char * ) host ) [ vlen ] = '\\0' ; root = agoo_domain_resolve ( host , root_buf , sizeof ( root_buf ) ) ; ( ( char * ) host ) [ vlen ] = '\\r' ; } if ( agoo_server . root_first && NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { if ( NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == agoo_server . hook404 ) { return bad_request ( c , 404 , __LINE__ ) ; } hook = agoo_server . hook404 ; } } else if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { return bad_request ( c , 404 , __LINE__ ) ; } if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { return bad_request ( c , 413 , __LINE__ ) ; } if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\\0' ; c -> req -> method = method ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = NULL ; <S2SV_StartBug> c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ; <S2SV_EndBug> c -> req -> path . len = ( int ) ( path . end - path . start ) ; c -> req -> query . start = c -> req -> msg + ( query - c -> buf ) ; c -> req -> query . len = ( int ) ( qend - query ) ; c -> req -> query . start [ c -> req -> query . len ] = '\\0' ; c -> req -> body . start = c -> req -> msg + ( hend - c -> buf + 4 ) ; c -> req -> body . len = ( unsigned int ) clen ; b = strstr ( b , ""\\r\\n"" ) ; c -> req -> header . start = c -> req -> msg + ( b + 2 - c -> buf ) ; if ( b < hend ) { c -> req -> header . len = ( unsigned int ) ( hend - b - 2 ) ; } else { c -> req -> header . len = 0 ; } c -> req -> res = NULL ; c -> req -> hook = hook ; return HEAD_OK ; }
","<S2SV_ModStart> = NULL ; memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;
",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z,229,<S2SV_ModStart> { if ( <S2SV_ModEnd> b -> buf,0
616,CWE-119,"CWE-119 <S2SV_StartBug> void vp9_fht16x16_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct16x16_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> const transform_2d ht = FHT_16 [ tx_type ] ; for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) <S2SV_StartBug> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <S2SV_EndBug> } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j + i * 16 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) output [ j + i * 16 ] = temp_out [ j ] ; } } }
","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> DCT_DCT ) { vpx_fdct16x16_c <S2SV_ModEnd> ( input , <S2SV_ModStart> } else { tran_low_t <S2SV_ModEnd> out [ 256 <S2SV_ModStart> 256 ] ; <S2SV_ModEnd> int i , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> temp_in [ 16 <S2SV_ModStart> ++ j ) out <S2SV_ModEnd> [ j *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,230,,0
617,CWE-74,"CWE-74 static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( g_str_has_prefix ( arg , ""@@"" ) ) <S2SV_StartBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; <S2SV_EndBug> else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }
","<S2SV_ModStart> ""@@"" ) ) { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" <S2SV_ModEnd> ) , arg <S2SV_ModStart> arg ) ; goto out ; }
",flatpak@flatpak/a7401e638bf0c03102039e216ab1081922f140ae,CVE-2021-21381,https://github.com/flatpak/flatpak/commit/a7401e638bf0c03102039e216ab1081922f140ae,2021-03-11T17:15Z,231,,0
620,CWE-284,"CWE-284 bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ; <S2SV_StartBug> char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! temp_filename ) { <S2SV_EndBug> LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ; <S2SV_StartBug> fprintf ( fp , ""[%s]\\n"" , section -> name ) ; <S2SV_EndBug> for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ; <S2SV_StartBug> fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ; <S2SV_EndBug> } if ( list_next ( node ) != list_end ( config -> sections ) ) <S2SV_StartBug> fputc ( '\\n' , fp ) ; <S2SV_EndBug> } fflush ( fp ) ; <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>file<S2SV_blank>permissions<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>commit<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> return true ; <S2SV_StartBug> error : ; <S2SV_EndBug> unlink ( temp_filename ) ; <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> return false ; }
","<S2SV_ModStart> '\\0' ) ; int dir_fd = - 1 ; FILE * fp = NULL ; static const char * temp_file_ext = "".new"" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * <S2SV_ModEnd> temp_filename = osi_calloc <S2SV_ModStart> = osi_calloc ( temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! directoryname ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> fp = fopen <S2SV_ModStart> node ) ; if ( <S2SV_ModStart> -> name ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> for ( const <S2SV_ModStart> enode ) ; if ( <S2SV_ModStart> -> value ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> sections ) ) { if ( <S2SV_ModStart> , fp ) == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( <S2SV_ModEnd> fclose ( fp <S2SV_ModStart> ( fp ) == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModStart> error ; } if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModStart> osi_free ( temp_filename ) ; osi_free ( temp_dirname <S2SV_ModStart> ; error : <S2SV_ModEnd> unlink ( temp_filename <S2SV_ModStart> temp_filename ) ; if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; <S2SV_ModStart> osi_free ( temp_filename ) ; osi_free ( temp_dirname
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,232,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
621,CWE-000,"CWE-000 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> case 1 : if ( pc -> lengthComponentIdent > 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , ""../"" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""./"" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <S2SV_StartBug> case 5 : <S2SV_EndBug> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }
","<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (
",torvalds@linux/e237ec37ec154564f8690c5bd1795339955eeef9,CVE-2014-9730,https://github.com/torvalds/linux/commit/e237ec37ec154564f8690c5bd1795339955eeef9,2015-08-31T10:59Z,233,<S2SV_ModStart> break ; } <S2SV_ModEnd> } if (,0
623,CWE-125,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; <S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> while ( len > 0 ) { <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> return ; } <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z,234,<S2SV_ModStart> ) ) ; ND_TCHECK2 ( tptr + 4 ) ;,0
624,CWE-000,"CWE-000 void xmlParsePI ( xmlParserCtxtPtr ctxt ) { xmlChar * buf = NULL ; int len = 0 ; int size = XML_PARSER_BUFFER_SIZE ; int cur , l ; const xmlChar * target ; xmlParserInputState state ; int count = 0 ; if ( ( RAW == '<' ) && ( NXT ( 1 ) == '?' ) ) { xmlParserInputPtr input = ctxt -> input ; state = ctxt -> instate ; ctxt -> instate = XML_PARSER_PI ; SKIP ( 2 ) ; SHRINK ; target = xmlParsePITarget ( ctxt ) ; if ( target != NULL ) { if ( ( RAW == '?' ) && ( NXT ( 1 ) == '>' ) ) { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , ""PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n"" ) ; } SKIP ( 2 ) ; if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , <S2SV_StartBug> target , NULL ) ; <S2SV_EndBug> ctxt -> instate = state ; return ; } buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) { xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } cur = CUR ; if ( ! IS_BLANK ( cur ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_SPACE_REQUIRED , ""ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>space<S2SV_blank>expected\\n"" , target ) ; } SKIP_BLANKS ; cur = CUR_CHAR ( l ) ; while ( IS_CHAR ( cur ) && ( ( cur != '?' ) || ( NXT ( 1 ) != '>' ) ) ) { if ( len + 5 >= size ) { xmlChar * tmp ; size *= 2 ; tmp = ( xmlChar * ) xmlRealloc ( buf , size * sizeof ( xmlChar ) ) ; if ( tmp == NULL ) { xmlErrMemory ( ctxt , NULL ) ; xmlFree ( buf ) ; ctxt -> instate = state ; return ; } buf = tmp ; } count ++ ; if ( count > 50 ) { GROW ; count = 0 ; } COPY_BUF ( l , buf , len , cur ) ; NEXTL ( l ) ; cur = CUR_CHAR ( l ) ; if ( cur == 0 ) { SHRINK ; GROW ; cur = CUR_CHAR ( l ) ; } } buf [ len ] = 0 ; if ( cur != '?' ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , ""ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>never<S2SV_blank>end<S2SV_blank>...\\n"" , target ) ; } else { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , ""PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n"" ) ; } SKIP ( 2 ) ; # ifdef LIBXML_CATALOG_ENABLED if ( ( ( state == XML_PARSER_MISC ) || ( state == XML_PARSER_START ) ) && ( xmlStrEqual ( target , XML_CATALOG_PI ) ) ) { xmlCatalogAllow allow = xmlCatalogGetDefaults ( ) ; if ( ( allow == XML_CATA_ALLOW_DOCUMENT ) || ( allow == XML_CATA_ALLOW_ALL ) ) xmlParseCatalogPI ( ctxt , buf ) ; } # endif if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , buf ) ; } xmlFree ( buf ) ; } else { xmlFatalErr ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; } <S2SV_StartBug> ctxt -> instate = state ; <S2SV_EndBug> } }
","<S2SV_ModStart> NULL ) ; if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> ) ; } if ( <S2SV_ModStart> ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate
",chromium@chromium/44a637b47793512bfb1d2589d43b8dc492a97629,,https://github.com/chromium/chromium/commit/44a637b47793512bfb1d2589d43b8dc492a97629, ,235,,0
627,CWE-119,"CWE-119 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , ""cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x"" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }
","<S2SV_ModStart> int tagval ; struct stream packet ; <S2SV_ModStart> length ) ; packet = * s ; <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p (
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z,236,<S2SV_ModStart> int tagval ; struct stream packet ; <S2SV_ModStart> length ) ; packet = * s ; if (!,0
630,CWE-352,"CWE-352 static void _send ( Socket_T S , const char * request , StringBuffer_T data ) { _argument ( data , ""format"" , ""text"" ) ; char * _auth = _getBasicAuthHeader ( ) ; <S2SV_StartBug> int rv = Socket_print ( S , <S2SV_EndBug> ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" <S2SV_StartBug> ""Content-Length:<S2SV_blank>%d\\r\\n"" <S2SV_EndBug> ""%s"" ""\\r\\n"" ""%s"" , <S2SV_StartBug> request , <S2SV_EndBug> StringBuffer_length ( data ) , _auth ? _auth : """" , StringBuffer_toString ( data ) ) ; FREE ( _auth ) ; if ( rv < 0 ) THROW ( IOException , ""Monit:<S2SV_blank>cannot<S2SV_blank>send<S2SV_blank>command<S2SV_blank>to<S2SV_blank>the<S2SV_blank>monit<S2SV_blank>daemon<S2SV_blank>--<S2SV_blank>%s"" , STRERROR ) ; }
","<S2SV_ModStart> ( ) ; MD_T token ; StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ; <S2SV_ModStart> , ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""Cookie:<S2SV_blank>securitytoken=%s\\r\\n"" <S2SV_ModStart> ""%s"" , request , token
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,237,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void <S2SV_ModEnd> char *,0
631,CWE-269,"CWE-269 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n"" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> errExit ( ""chown"" ) ; <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> errExit ( ""chmod"" ) ; unlink ( src ) ; }
","<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) <S2SV_ModEnd> , S_IRUSR | <S2SV_ModStart> | S_IWUSR ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ) ; unlink
",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z,238,"<S2SV_ModStart> ) ; } copy_as_user <S2SV_ModEnd> ( src, <S2SV_ModStart> ( src, <S2SV_ModEnd> ) ; unlink",0
632,CWE-401,"CWE-401 static struct fc_host_statistics * bfad_im_get_stats ( struct Scsi_Host * shost ) { struct bfad_im_port_s * im_port = ( struct bfad_im_port_s * ) shost -> hostdata [ 0 ] ; struct bfad_s * bfad = im_port -> bfad ; struct bfad_hal_comp fcomp ; union bfa_port_stats_u * fcstats ; struct fc_host_statistics * hstats ; bfa_status_t rc ; unsigned long flags ; fcstats = kzalloc ( sizeof ( union bfa_port_stats_u ) , GFP_KERNEL ) ; if ( fcstats == NULL ) return NULL ; hstats = & bfad -> link_stats ; init_completion ( & fcomp . comp ) ; spin_lock_irqsave ( & bfad -> bfad_lock , flags ) ; memset ( hstats , 0 , sizeof ( struct fc_host_statistics ) ) ; rc = bfa_port_get_stats ( BFA_FCPORT ( & bfad -> bfa ) , fcstats , bfad_hcb_comp , & fcomp ) ; spin_unlock_irqrestore ( & bfad -> bfad_lock , flags ) ; <S2SV_StartBug> if ( rc != BFA_STATUS_OK ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> wait_for_completion ( & fcomp . comp ) ; <S2SV_EndBug> hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ; hstats -> tx_frames = fcstats -> fc . tx_frames ; hstats -> tx_words = fcstats -> fc . tx_words ; hstats -> rx_frames = fcstats -> fc . rx_frames ; hstats -> rx_words = fcstats -> fc . rx_words ; hstats -> lip_count = fcstats -> fc . lip_count ; hstats -> nos_count = fcstats -> fc . nos_count ; hstats -> error_frames = fcstats -> fc . error_frames ; hstats -> dumped_frames = fcstats -> fc . dropped_frames ; hstats -> link_failure_count = fcstats -> fc . link_failures ; hstats -> loss_of_sync_count = fcstats -> fc . loss_of_syncs ; hstats -> loss_of_signal_count = fcstats -> fc . loss_of_signals ; hstats -> prim_seq_protocol_err_count = fcstats -> fc . primseq_errs ; hstats -> invalid_crc_count = fcstats -> fc . invalid_crcs ; kfree ( fcstats ) ; return hstats ; }
","<S2SV_ModStart> != BFA_STATUS_OK ) { kfree ( fcstats ) ; <S2SV_ModStart> return NULL ; }
",torvalds@linux/0e62395da2bd5166d7c9e14cbc7503b256a34cb0,CVE-2019-19066,https://github.com/torvalds/linux/commit/0e62395da2bd5166d7c9e14cbc7503b256a34cb0,2019-11-18T06:15Z,239,<S2SV_ModStart> ) ) ; rc = NULL ;,0
633,CWE-20,"CWE-20 static inline void VectorClamp3 ( DDSVector3 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,240,"<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f, <S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f,",0
636,CWE-416,"CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }
","<S2SV_ModStart> -> sasl_username = g_strdup ( <S2SV_ModStart> src -> sasl_username ) <S2SV_ModStart> -> sasl_password = g_strdup ( <S2SV_ModStart> src -> sasl_password )
",irssi@irssi/d23b0d22cc611e43c88d99192a59f413f951a955,CVE-2019-13045,https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955,2019-06-29T14:15Z,241,<S2SV_ModStart> ( src -> sas_username ) <S2SV_ModEnd> ; } else,0
640,CWE-119,"CWE-119 static void update_alt_ref_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && cpi -> frames_till_gf_update_due ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; cpi -> gf_overspend_bits += cpi -> projected_frame_size ; cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cpi -> frames_since_golden = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 1 ; }
","<S2SV_ModStart> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,242,<S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->,0
642,CWE-400,"CWE-400 static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; <S2SV_StartBug> size_t i , tcount , o , datao ; <S2SV_EndBug> if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Invalid<S2SV_blank>zero-length<S2SV_blank>tag<S2SV_blank>size"" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } <S2SV_StartBug> ++ tcount ; <S2SV_EndBug> } n -> count = tcount ; }
","<S2SV_ModStart> o , datao ; long failsafe_size = 0 <S2SV_ModStart> ) ; } failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ; if ( failsafe_size > FAILSAFE_SIZE_MAX ) { exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ; exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)"" , failsafe_size , FAILSAFE_SIZE_MAX ) ; break ; }
",libexif@libexif/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab,CVE-2020-13114,https://github.com/libexif/libexif/commit/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab,2020-05-21T16:15Z,243,,0
645,CWE-362,"CWE-362 static int myisamchk ( MI_CHECK * param , char * filename ) { int error , lock_type , recreate ; int rep_quick = param -> testflag & ( T_QUICK | T_FORCE_UNIQUENESS ) ; MI_INFO * info ; File datafile ; char llbuff [ 22 ] , llbuff2 [ 22 ] ; my_bool state_updated = 0 ; MYISAM_SHARE * share ; DBUG_ENTER ( ""myisamchk"" ) ; param -> out_flag = error = param -> warning_printed = param -> error_printed = recreate = 0 ; datafile = 0 ; param -> isam_file_name = filename ; if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) { param -> error_printed = 1 ; switch ( my_errno ) { case HA_ERR_CRASHED : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>correct<S2SV_blank>index<S2SV_blank>definition.<S2SV_blank>You<S2SV_blank>need<S2SV_blank>to<S2SV_blank>recreate<S2SV_blank>it<S2SV_blank>before<S2SV_blank>you<S2SV_blank>can<S2SV_blank>do<S2SV_blank>a<S2SV_blank>repair"" , filename ) ; break ; case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>MyISAM-table"" , filename ) ; break ; case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>crashed"" , filename ) ; break ; case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>crashed<S2SV_blank>after<S2SV_blank>last<S2SV_blank>repair"" , filename ) ; break ; case HA_ERR_OLD_FILE : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>an<S2SV_blank>old<S2SV_blank>type<S2SV_blank>of<S2SV_blank>MyISAM-table"" , filename ) ; break ; case HA_ERR_END_OF_FILE : mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>read<S2SV_blank>complete<S2SV_blank>header<S2SV_blank>from<S2SV_blank>\'%s\'"" , filename ) ; break ; case EAGAIN : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>locked.<S2SV_blank>Use<S2SV_blank>-w<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>until<S2SV_blank>unlocked"" , filename ) ; break ; case ENOENT : mi_check_print_error ( param , ""File<S2SV_blank>\'%s\'<S2SV_blank>doesn\'t<S2SV_blank>exist"" , filename ) ; break ; case EACCES : mi_check_print_error ( param , ""You<S2SV_blank>don\'t<S2SV_blank>have<S2SV_blank>permission<S2SV_blank>to<S2SV_blank>use<S2SV_blank>\'%s\'"" , filename ) ; break ; default : mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>opening<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'"" , my_errno , filename ) ; break ; } DBUG_RETURN ( 1 ) ; } share = info -> s ; share -> options &= ~ HA_OPTION_READ_ONLY_DATA ; share -> tot_locks -= share -> r_locks ; share -> r_locks = 0 ; if ( param -> testflag & ( T_FAST | T_CHECK_ONLY_CHANGED ) ) { my_bool need_to_check = mi_is_crashed ( info ) || share -> state . open_count != 0 ; if ( ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS ) ) && ( ( share -> state . changed & ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) || ! ( param -> testflag & T_CHECK_ONLY_CHANGED ) ) ) ) need_to_check = 1 ; if ( info -> s -> base . keys && info -> state -> records ) { if ( ( param -> testflag & T_STATISTICS ) && ( share -> state . changed & STATE_NOT_ANALYZED ) ) need_to_check = 1 ; if ( ( param -> testflag & T_SORT_INDEX ) && ( share -> state . changed & STATE_NOT_SORTED_PAGES ) ) need_to_check = 1 ; if ( ( param -> testflag & T_REP_BY_SORT ) && ( share -> state . changed & STATE_NOT_OPTIMIZED_KEYS ) ) need_to_check = 1 ; } if ( ( param -> testflag & T_CHECK_ONLY_CHANGED ) && ( share -> state . changed & ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ) ) need_to_check = 1 ; if ( ! need_to_check ) { if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( ""MyISAM<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>already<S2SV_blank>checked\\n"" , filename ) ; if ( mi_close ( info ) ) { mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>closing<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'"" , my_errno , filename ) ; DBUG_RETURN ( 1 ) ; } DBUG_RETURN ( 0 ) ; } } if ( ( param -> testflag & ( T_REP_ANY | T_STATISTICS | T_SORT_RECORDS | T_SORT_INDEX ) ) && ( ( ( param -> testflag & T_UNPACK ) && share -> data_file_type == COMPRESSED_RECORD ) || mi_uint2korr ( share -> state . header . state_info_length ) != MI_STATE_INFO_SIZE || mi_uint2korr ( share -> state . header . base_info_length ) != MI_BASE_INFO_SIZE || mi_is_any_intersect_keys_active ( param -> keys_in_use , share -> base . keys , ~ share -> state . key_map ) || test_if_almost_full ( info ) || info -> s -> state . header . file_version [ 3 ] != myisam_file_magic [ 3 ] || ( set_collation && set_collation -> number != share -> state . header . language ) || myisam_block_size != MI_KEY_BLOCK_LENGTH ) ) { if ( set_collation ) param -> language = set_collation -> number ; if ( recreate_table ( param , & info , filename ) ) { ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fixed<S2SV_blank>because<S2SV_blank>of<S2SV_blank>errors\\n"" , filename ) ; return ( - 1 ) ; } recreate = 1 ; if ( ! ( param -> testflag & T_REP_ANY ) ) { param -> testflag |= T_REP_BY_SORT ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>old<S2SV_blank>table-format.<S2SV_blank>Recreating<S2SV_blank>index\\n"" , filename ) ; rep_quick |= T_QUICK ; } share = info -> s ; share -> tot_locks -= share -> r_locks ; share -> r_locks = 0 ; } if ( param -> testflag & T_DESCRIPT ) { param -> total_files ++ ; param -> total_records += info -> state -> records ; param -> total_deleted += info -> state -> del ; descript ( param , info , filename ) ; } else { if ( ! stopwords_inited ++ ) ft_init_stopwords ( ) ; if ( ! ( param -> testflag & T_READONLY ) ) lock_type = F_WRLCK ; else lock_type = F_RDLCK ; if ( info -> lock_type == F_RDLCK ) info -> lock_type = F_UNLCK ; if ( _mi_readinfo ( info , lock_type , 0 ) ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>lock<S2SV_blank>indexfile<S2SV_blank>of<S2SV_blank>\'%s\',<S2SV_blank>error:<S2SV_blank>%d"" , filename , my_errno ) ; param -> error_printed = 0 ; goto end2 ; } mi_lock_database ( info , F_EXTRA_LCK ) ; datafile = info -> dfile ; if ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX ) ) { if ( param -> testflag & T_REP_ANY ) { ulonglong tmp = share -> state . key_map ; mi_copy_keys_active ( share -> state . key_map , share -> base . keys , param -> keys_in_use ) ; if ( tmp != share -> state . key_map ) info -> update |= HA_STATE_CHANGED ; } if ( rep_quick && chk_del ( param , info , param -> testflag & ~ T_VERBOSE ) ) { if ( param -> testflag & T_FORCE_CREATE ) { rep_quick = 0 ; mi_check_print_info ( param , ""Creating<S2SV_blank>new<S2SV_blank>data<S2SV_blank>file\\n"" ) ; } else { error = 1 ; mi_check_print_error ( param , ""Quick-recover<S2SV_blank>aborted;<S2SV_blank>Run<S2SV_blank>recovery<S2SV_blank>without<S2SV_blank>switch<S2SV_blank>\'q\'"" ) ; } } if ( ! error ) { if ( ( param -> testflag & ( T_REP_BY_SORT | T_REP_PARALLEL ) ) && ( mi_is_any_key_active ( share -> state . key_map ) || ( rep_quick && ! param -> keys_in_use && ! recreate ) ) && mi_test_if_sort_rep ( info , info -> state -> records , info -> s -> state . key_map , param -> force_sort ) ) { if ( param -> testflag & T_REP_BY_SORT ) <S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , rep_quick ) ; <S2SV_EndBug> else <S2SV_StartBug> error = mi_repair_parallel ( param , info , filename , rep_quick ) ; <S2SV_EndBug> state_updated = 1 ; } else if ( param -> testflag & T_REP_ANY ) <S2SV_StartBug> error = mi_repair ( param , info , filename , rep_quick ) ; <S2SV_EndBug> } if ( ! error && param -> testflag & T_SORT_RECORDS ) { # ifndef TO_BE_REMOVED if ( param -> out_flag & O_NEW_DATA ) { ( void ) my_close ( info -> dfile , MYF ( MY_WME ) ) ; error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ; if ( mi_open_datafile ( info , info -> s , NULL , - 1 ) ) error = 1 ; param -> out_flag &= ~ O_NEW_DATA ; param -> read_cache . file = info -> dfile ; } # endif if ( ! error ) { uint key ; my_bool update_index = 1 ; for ( key = 0 ; key < share -> base . keys ; key ++ ) if ( share -> keyinfo [ key ] . flag & ( HA_BINARY_PACK_KEY | HA_FULLTEXT ) ) update_index = 0 ; error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ; datafile = info -> dfile ; if ( ! error && ! update_index ) { if ( param -> verbose ) puts ( ""Table<S2SV_blank>had<S2SV_blank>a<S2SV_blank>compressed<S2SV_blank>index;<S2SV_blank><S2SV_blank>We<S2SV_blank>must<S2SV_blank>now<S2SV_blank>recreate<S2SV_blank>the<S2SV_blank>index"" ) ; <S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , 1 ) ; <S2SV_EndBug> } } } if ( ! error && param -> testflag & T_SORT_INDEX ) <S2SV_StartBug> error = mi_sort_index ( param , info , filename ) ; <S2SV_EndBug> if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ; else mi_mark_crashed ( info ) ; } else if ( ( param -> testflag & T_CHECK ) || ! ( param -> testflag & T_AUTO_INC ) ) { if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( ""Checking<S2SV_blank>MyISAM<S2SV_blank>file:<S2SV_blank>%s\\n"" , filename ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%7s<S2SV_blank><S2SV_blank><S2SV_blank>Deleted<S2SV_blank>blocks:<S2SV_blank>%7s\\n"" , llstr ( info -> state -> records , llbuff ) , llstr ( info -> state -> del , llbuff2 ) ) ; error = chk_status ( param , info ) ; mi_intersect_keys_active ( share -> state . key_map , param -> keys_in_use ) ; error = chk_size ( param , info ) ; if ( ! error || ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) ) error |= chk_del ( param , info , param -> testflag ) ; if ( ( ! error || ( ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) && ! param -> start_check_pos ) ) ) { error |= chk_key ( param , info ) ; if ( ! error && ( param -> testflag & ( T_STATISTICS | T_AUTO_INC ) ) ) error = update_state_info ( param , info , ( ( param -> testflag & T_STATISTICS ) ? UPDATE_STAT : 0 ) | ( ( param -> testflag & T_AUTO_INC ) ? UPDATE_AUTO_INC : 0 ) ) ; } if ( ( ! rep_quick && ! error ) || ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) ) { if ( param -> testflag & ( T_EXTEND | T_MEDIUM ) ) ( void ) init_key_cache ( dflt_key_cache , opt_key_cache_block_size , param -> use_buffers , 0 , 0 ) ; ( void ) init_io_cache ( & param -> read_cache , datafile , ( uint ) param -> read_buffer_length , READ_CACHE , ( param -> start_check_pos ? param -> start_check_pos : share -> pack . header_length ) , 1 , MYF ( MY_WME ) ) ; lock_memory ( param ) ; if ( ( info -> s -> options & ( HA_OPTION_PACK_RECORD | HA_OPTION_COMPRESS_RECORD ) ) || ( param -> testflag & ( T_EXTEND | T_MEDIUM ) ) ) error |= chk_data_link ( param , info , param -> testflag & T_EXTEND ) ; error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & param -> read_cache ) ; } if ( ! error ) { if ( ( share -> state . changed & STATE_CHANGED ) && ( param -> testflag & T_UPDATE_STATE ) ) info -> update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ; share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ; } else if ( ! mi_is_crashed ( info ) && ( param -> testflag & T_UPDATE_STATE ) ) { mi_mark_crashed ( info ) ; info -> update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ; } } } if ( ( param -> testflag & T_AUTO_INC ) || ( ( param -> testflag & T_REP_ANY ) && info -> s -> base . auto_key ) ) update_auto_increment_key ( param , info , ( my_bool ) ! test ( param -> testflag & T_AUTO_INC ) ) ; if ( ! ( param -> testflag & T_DESCRIPT ) ) { if ( info -> update & HA_STATE_CHANGED && ! ( param -> testflag & T_READONLY ) ) error |= update_state_info ( param , info , UPDATE_OPEN_COUNT | ( ( ( param -> testflag & T_REP_ANY ) ? UPDATE_TIME : 0 ) | ( state_updated ? UPDATE_STAT : 0 ) | ( ( param -> testflag & T_SORT_RECORDS ) ? UPDATE_SORT : 0 ) ) ) ; ( void ) lock_file ( param , share -> kfile , 0L , F_UNLCK , ""indexfile"" , filename ) ; info -> update &= ~ HA_STATE_CHANGED ; } mi_lock_database ( info , F_UNLCK ) ; end2 : if ( mi_close ( info ) ) { mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>closing<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'"" , my_errno , filename ) ; DBUG_RETURN ( 1 ) ; } if ( error == 0 ) { if ( param -> out_flag & O_NEW_DATA ) error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , ( ( param -> testflag & T_BACKUP_DATA ) ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) ; if ( param -> out_flag & O_NEW_INDEX ) error |= change_to_newfile ( filename , MI_NAME_IEXT , INDEX_TMP_EXT , MYF ( 0 ) ) ; } ( void ) fflush ( stdout ) ; ( void ) fflush ( stderr ) ; if ( param -> error_printed ) { if ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX ) ) { ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fixed<S2SV_blank>because<S2SV_blank>of<S2SV_blank>errors\\n"" , filename ) ; if ( param -> testflag & T_REP_ANY ) ( void ) fprintf ( stderr , ""Try<S2SV_blank>fixing<S2SV_blank>it<S2SV_blank>by<S2SV_blank>using<S2SV_blank>the<S2SV_blank>--safe-recover<S2SV_blank>(-o),<S2SV_blank>the<S2SV_blank>--force<S2SV_blank>(-f)<S2SV_blank>option<S2SV_blank>or<S2SV_blank>by<S2SV_blank>not<S2SV_blank>using<S2SV_blank>the<S2SV_blank>--quick<S2SV_blank>(-q)<S2SV_blank>flag\\n"" ) ; } else if ( ! ( param -> error_printed & 2 ) && ! ( param -> testflag & T_FORCE_CREATE ) ) ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>corrupted\\nFix<S2SV_blank>it<S2SV_blank>using<S2SV_blank>switch<S2SV_blank>\\""-r\\""<S2SV_blank>or<S2SV_blank>\\""-o\\""\\n"" , filename ) ; } else if ( param -> warning_printed && ! ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX | T_FORCE_CREATE ) ) ) ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>usable<S2SV_blank>but<S2SV_blank>should<S2SV_blank>be<S2SV_blank>fixed\\n"" , filename ) ; ( void ) fflush ( stderr ) ; DBUG_RETURN ( error ) ; }
","<S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , 1 , FALSE <S2SV_ModStart> info , filename , FALSE
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,244,,0
646,CWE-89,"CWE-89 char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z,245,<S2SV_ModStart> len ) { size_t <S2SV_ModEnd> len = 0 <S2SV_ModStart> ; if ( len > sizeof ( size ) ) return NULL ; <S2SV_ModStart> ) ; if ( len < 0 ) return NULL ; <S2SV_ModEnd> return NULL ;,0
647,CWE-416,"CWE-416 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z,246,<S2SV_ModStart> = 0 ;,0
650,CWE-415,"CWE-415 void init_usm ( void ) { struct snmp_secmod_def * def ; char * type ; DEBUGMSGTL ( ( ""init_usm"" , ""unit_usm:<S2SV_blank>%"" NETSNMP_PRIo ""u<S2SV_blank>%"" NETSNMP_PRIo ""u\\n"" , usmNoPrivProtocol [ 0 ] , usmNoPrivProtocol [ 1 ] ) ) ; sc_init ( ) ; def = SNMP_MALLOC_STRUCT ( snmp_secmod_def ) ; if ( def == NULL ) return ; def -> encode_reverse = usm_secmod_rgenerate_out_msg ; def -> encode_forward = usm_secmod_generate_out_msg ; def -> decode = usm_secmod_process_in_msg ; <S2SV_StartBug> def -> pdu_free_state_ref = usm_free_usmStateReference ; <S2SV_EndBug> def -> session_setup = usm_session_init ; def -> handle_report = usm_handle_report ; def -> probe_engineid = usm_discover_engineid ; def -> post_probe_engineid = usm_create_user_from_session_hook ; if ( register_sec_mod ( USM_SEC_MODEL_NUMBER , ""usm"" , def ) != SNMPERR_SUCCESS ) { SNMP_FREE ( def ) ; snmp_log ( LOG_ERR , ""could<S2SV_blank>not<S2SV_blank>register<S2SV_blank>usm<S2SV_blank>sec<S2SV_blank>mod\\n"" ) ; return ; } snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_POST_PREMIB_READ_CONFIG , init_usm_post_config , NULL ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , deinit_usm_post_config , NULL ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , free_engineID , NULL ) ; register_config_handler ( ""snmp"" , ""defAuthType"" , snmpv3_authtype_conf , NULL , ""MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224"" ) ; register_config_handler ( ""snmp"" , ""defPrivType"" , snmpv3_privtype_conf , NULL , ""DES"" # ifdef HAVE_AES ""|AES|AES-128"" # ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04 ""|AES-192|AES-256"" # endif # else ""<S2SV_blank>(AES<S2SV_blank>support<S2SV_blank>not<S2SV_blank>available)"" # endif ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , free_enginetime_on_shutdown , NULL ) ; type = netsnmp_ds_get_string ( NETSNMP_DS_LIBRARY_ID , NETSNMP_DS_LIB_APPTYPE ) ; register_config_handler ( type , ""userSetAuthPass"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetPrivPass"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetAuthKey"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetPrivKey"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetAuthLocalKey"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetPrivLocalKey"" , usm_set_password , NULL , NULL ) ; }
","<S2SV_ModStart> ; def -> pdu_clone = usm_clone ; def ->
",net-snmp@net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,CVE-2019-20892,https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,2020-06-25T10:15Z,247,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( i,0
652,CWE-674,"CWE-674 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z,248,<S2SV_ModStart> pos ) ; if ( e == NULL ) return ;,0
655,CWE-269,"CWE-269 int fixExec2Error ( int action , u_char * var_val , u_char var_val_type , size_t var_val_len , u_char * statP , oid * name , size_t name_len ) { netsnmp_old_extend * exten = NULL ; unsigned int idx ; idx = name [ name_len - 1 ] - 1 ; exten = & compatability_entries [ idx ] ; <S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> switch ( action ) { case MODE_SET_RESERVE1 : if ( var_val_type != ASN_INTEGER ) { snmp_log ( LOG_ERR , ""Wrong<S2SV_blank>type<S2SV_blank>!=<S2SV_blank>int\\n"" ) ; return SNMP_ERR_WRONGTYPE ; } idx = * ( ( long * ) var_val ) ; if ( idx != 1 ) { snmp_log ( LOG_ERR , ""Wrong<S2SV_blank>value<S2SV_blank>!=<S2SV_blank>1\\n"" ) ; return SNMP_ERR_WRONGVALUE ; } if ( ! exten || ! exten -> efix_entry ) { snmp_log ( LOG_ERR , ""No<S2SV_blank>command<S2SV_blank>to<S2SV_blank>run\\n"" ) ; return SNMP_ERR_GENERR ; } return SNMP_ERR_NOERROR ; case MODE_SET_COMMIT : netsnmp_cache_check_and_reload ( exten -> efix_entry -> cache ) ; } # endif return SNMP_ERR_NOERROR ; }
","<S2SV_ModStart> ] ; # if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> switch ( action
",net-snmp@net-snmp/77f6c60f57dba0aaea5d8ef1dd94bcd0c8e6d205,CVE-2020-15862,https://github.com/net-snmp/net-snmp/commit/77f6c60f57dba0aaea5d8ef1dd94bcd0c8e6d205,2020-08-20T01:17Z,249,<S2SV_ModStart> <S2SV_null> <S2SV_null> < 0,0
656,CWE-125,"CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
",ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z,250,<S2SV_ModStart> ( size_t ) <S2SV_ModEnd> ; if (,0
657,CWE-20,"CWE-20 int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,251,<S2SV_ModStart> ) ) { mutex_lock ( & timer_lock ) ; <S2SV_ModStart> ; } <S2SV_null>,0
661,CWE-119,"CWE-119 WORD32 ih264d_parse_islice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_dec -> ps_bitstrm -> u4_ofst ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <S2SV_EndBug> ps_dec ) ; else ps_dec -> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) return ERROR_INV_RANGE_QP_T ; ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_qp_delta"" , ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , u4_temp ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , ps_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , ps_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } } else { ps_slice -> u1_disable_dblk_filter_idc = 0 ; ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; ret = ih264d_parse_islice_data_cabac ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; SWITCHONTRACE ; SWITCHOFFTRACECABAC ; } else { if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; ret = ih264d_parse_islice_data_cavlc ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; } return OK ; }
","<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_dec ->
",external@libavc/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,CVE-2016-0842,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,2016-04-18T00:59Z,252,,0
664,CWE-415,"CWE-415 void DDGifSlurp ( GifInfo * info , bool decode , bool exitAfterFrame ) { GifRecordType RecordType ; GifByteType * ExtData ; int ExtFunction ; GifFileType * gifFilePtr ; gifFilePtr = info -> gifFilePtr ; uint_fast32_t lastAllocatedGCBIndex = 0 ; do { if ( DGifGetRecordType ( gifFilePtr , & RecordType ) == GIF_ERROR ) { break ; } bool isInitialPass = ! decode && ! exitAfterFrame ; switch ( RecordType ) { case IMAGE_DESC_RECORD_TYPE : if ( DGifGetImageDesc ( gifFilePtr , isInitialPass ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { int_fast32_t widthOverflow = gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; int_fast32_t heightOverflow = gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( widthOverflow > 0 || heightOverflow > 0 ) { gifFilePtr -> SWidth += widthOverflow ; gifFilePtr -> SHeight += heightOverflow ; } SavedImage * sp = & gifFilePtr -> SavedImages [ gifFilePtr -> ImageCount - 1 ] ; int_fast32_t topOverflow = gifFilePtr -> Image . Top + gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( topOverflow > 0 ) { sp -> ImageDesc . Top -= topOverflow ; } int_fast32_t leftOverflow = gifFilePtr -> Image . Left + gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; if ( leftOverflow > 0 ) { sp -> ImageDesc . Left -= leftOverflow ; } if ( ! updateGCB ( info , & lastAllocatedGCBIndex ) ) { break ; } } if ( decode ) { <S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ; <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug> if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) { void * tmpRasterBits = reallocarray ( info -> rasterBits , newRasterSize , sizeof ( GifPixelType ) ) ; if ( tmpRasterBits == NULL ) { gifFilePtr -> Error = D_GIF_ERR_NOT_ENOUGH_MEM ; break ; } info -> rasterBits = tmpRasterBits ; info -> rasterSize = newRasterSize ; } if ( gifFilePtr -> Image . Interlace ) { uint_fast16_t i , j ; uint_fast8_t InterlacedOffset [ ] = { 0 , 4 , 2 , 1 } ; uint_fast8_t InterlacedJumps [ ] = { 8 , 8 , 4 , 2 } ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = InterlacedOffset [ i ] ; j < gifFilePtr -> Image . Height ; j += InterlacedJumps [ i ] ) { if ( DGifGetLine ( gifFilePtr , info -> rasterBits + j * gifFilePtr -> Image . Width , gifFilePtr -> Image . Width ) == GIF_ERROR ) break ; } } else { if ( DGifGetLine ( gifFilePtr , info -> rasterBits , gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ) == GIF_ERROR ) { break ; } } if ( info -> sampleSize > 1 ) { unsigned char * dst = info -> rasterBits ; unsigned char * src = info -> rasterBits ; unsigned char * const srcEndImage = info -> rasterBits + gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; do { unsigned char * srcNextLineStart = src + gifFilePtr -> Image . Width * info -> sampleSize ; unsigned char * const srcEndLine = src + gifFilePtr -> Image . Width ; unsigned char * dstEndLine = dst + gifFilePtr -> Image . Width / info -> sampleSize ; do { * dst = * src ; dst ++ ; src += info -> sampleSize ; } while ( src < srcEndLine ) ; dst = dstEndLine ; src = srcNextLineStart ; } while ( src < srcEndImage ) ; } return ; } else { do { if ( DGifGetCodeNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) ; if ( exitAfterFrame ) { return ; } } break ; case EXTENSION_RECORD_TYPE : if ( DGifGetExtension ( gifFilePtr , & ExtFunction , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { updateGCB ( info , & lastAllocatedGCBIndex ) ; if ( readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) { if ( DGifGetExtensionNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass && readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } break ; case TERMINATE_RECORD_TYPE : break ; default : break ; } } while ( RecordType != TERMINATE_RECORD_TYPE ) ; info -> rewindFunction ( info ) ; }
","<S2SV_ModStart> decode ) { <S2SV_ModEnd> const uint_fast32_t newRasterSize <S2SV_ModStart> Image . Height ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight
",koral--@android-gif-drawable/cc5b4f8e43463995a84efd594f89a21f906c2d20,CVE-2019-11932,https://github.com/koral--/android-gif-drawable/commit/cc5b4f8e43463995a84efd594f89a21f906c2d20,2019-10-03T22:15Z,253,<S2SV_ModStart> ; size_t format = 0,0
666,CWE-287,"CWE-287 ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree<S2SV_blank>search<S2SV_blank>(%s):<S2SV_blank>done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>been<S2SV_blank>granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
","<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
",cherokee@webserver/fbda667221c51f0aa476a02366e0cf66cb012f88,CVE-2014-4668,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,2014-07-02T04:14Z,254,<S2SV_ModStart> ) return ret <S2SV_ModEnd> ; if (,0
667,CWE-252,"CWE-252 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
",ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c,CVE-2018-16643,https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c,2018-09-06T22:29Z,255,"<S2SV_ModStart>, message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart>, file )!= c ) break",1
670,CWE-617,"CWE-617 void pci_lintr_release ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int pin ; bi = pci_businfo [ dev -> bus ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> si = & bi -> slotinfo [ dev -> slot ] ; for ( pin = 1 ; pin < 4 ; pin ++ ) { si -> si_intpins [ pin ] . ii_count = 0 ; si -> si_intpins [ pin ] . ii_pirq_pin = 0 ; si -> si_intpins [ pin ] . ii_ioapic_irq = 0 ; } }
","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> si = &
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,256,<S2SV_ModStart> bus ] ; <S2SV_ModEnd> if ( bi,0
671,CWE-20,"CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,257,"<S2SV_ModStart>, size ) ; msg -> msg_namelen = 0",0
673,CWE-119,"CWE-119 static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\n' ) s [ len - 1 ] = '\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , ""/FontName"" , 9 ) == 0 ) { <S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> if ( * s == '/' ) { const char * t = ++ s ; <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }
","<S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> ! isspace ( ( unsigned char )
",kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z,258,<S2SV_ModStart> ; if ( ( s ++ ),0
676,CWE-284,"CWE-284 static void uipc_read_task ( void * arg ) { int ch_id ; int result ; UNUSED ( arg ) ; prctl ( PR_SET_NAME , ( unsigned long ) ""uipc-main"" , 0 , 0 , 0 ) ; raise_priority_a2dp ( TASK_UIPC_READ ) ; while ( uipc_main . running ) { uipc_main . read_set = uipc_main . active_set ; <S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug> if ( result == 0 ) { BTIF_TRACE_EVENT ( ""select<S2SV_blank>timeout"" ) ; continue ; } else if ( result < 0 ) { BTIF_TRACE_EVENT ( ""select<S2SV_blank>failed<S2SV_blank>%s"" , strerror ( errno ) ) ; continue ; } UIPC_LOCK ( ) ; uipc_check_interrupt_locked ( ) ; uipc_check_task_flags_locked ( ) ; uipc_check_fd_locked ( UIPC_CH_ID_AV_AUDIO ) ; for ( ch_id = 0 ; ch_id < UIPC_CH_NUM ; ch_id ++ ) { if ( ch_id != UIPC_CH_ID_AV_AUDIO ) uipc_check_fd_locked ( ch_id ) ; } UIPC_UNLOCK ( ) ; } BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>EXITING"" ) ; uipc_main_cleanup ( ) ; uipc_main . tid = 0 ; BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>DONE"" ) ; }
","<S2SV_ModStart> ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,259,"<S2SV_ModStart> NULL ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart>, NULL ) )",0
678,CWE-617,"CWE-617 int pci_emul_add_msixcap ( struct pci_vdev * dev , int msgnum , int barnum ) { uint32_t tab_size ; struct msixcap msixcap ; <S2SV_StartBug> assert ( msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES ) ; <S2SV_EndBug> assert ( barnum >= 0 && barnum <= PCIR_MAX_BAR_0 ) ; tab_size = msgnum * MSIX_TABLE_ENTRY_SIZE ; tab_size = roundup2 ( tab_size , 4096 ) ; dev -> msix . table_bar = barnum ; dev -> msix . pba_bar = barnum ; dev -> msix . table_offset = 0 ; dev -> msix . table_count = msgnum ; dev -> msix . pba_offset = tab_size ; dev -> msix . pba_size = PBA_SIZE ( msgnum ) ; <S2SV_StartBug> pci_msix_table_init ( dev , msgnum ) ; <S2SV_EndBug> pci_populate_msixcap ( & msixcap , msgnum , barnum , tab_size ) ; pci_emul_alloc_bar ( dev , barnum , PCIBAR_MEM32 , tab_size + dev -> msix . pba_size ) ; return ( pci_emul_add_capability ( dev , ( u_char * ) & msixcap , sizeof ( msixcap ) ) ) ; }
","<S2SV_ModStart> msixcap msixcap ; if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) { pr_err ( ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> tab_size = msgnum <S2SV_ModStart> msgnum ) ; if ( <S2SV_ModStart> , msgnum ) != 0 ) return - 1
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z,260,<S2SV_ModStart> size ) ; if <S2SV_ModEnd> ( msg,0
681,CWE-200,"CWE-200 static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; debug ( ""%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu"" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( ""signature:"" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { error ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>format"" ) ; goto done ; } if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes"" , __func__ , sshkey_type ( key ) ) ; goto done ; } <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""hostbased"" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( ""%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif auth2_record_info ( authctxt , ""client<S2SV_blank>user<S2SV_blank>\\""%.100s\\"",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\""%.100s\\"""" , cuser , chost ) ; authenticated = 0 ; if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ; auth2_record_key ( authctxt , authenticated , key ) ; sshbuf_free ( b ) ; done : debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d"" , __func__ , authenticated ) ; sshkey_free ( key ) ; free ( pkalg ) ; free ( pkblob ) ; free ( cuser ) ; free ( chost ) ; free ( sig ) ; return authenticated ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if (
",openbsd@src/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,CVE-2018-15473,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,2018-08-17T19:29Z,261,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( (,0
682,CWE-119,"CWE-119 <S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> return data > max ? max : data ; }
","<S2SV_ModStart> decode_unsigned_max ( struct vpx_read_bit_buffer <S2SV_ModEnd> * rb , <S2SV_ModStart> int data = vpx_rb_read_literal <S2SV_ModEnd> ( rb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,262,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> vpx_read_literal <S2SV_ModEnd> ( rb,",0
684,CWE-000,"CWE-000 krb5_error_code pkinit_check_kdc_pkid ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , pkinit_identity_crypto_context id_cryptoctx , unsigned char * pdid_buf , unsigned int pkid_len , int * valid_kdcPkId ) { krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED ; PKCS7_ISSUER_AND_SERIAL * is = NULL ; const unsigned char * p = pdid_buf ; int status = 1 ; X509 * kdc_cert = sk_X509_value ( id_cryptoctx -> my_certs , id_cryptoctx -> cert_index ) ; * valid_kdcPkId = 0 ; pkiDebug ( ""found<S2SV_blank>kdcPkId<S2SV_blank>in<S2SV_blank>AS<S2SV_blank>REQ\\n"" ) ; is = d2i_PKCS7_ISSUER_AND_SERIAL ( NULL , & p , ( int ) pkid_len ) ; if ( is == NULL ) <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ; if ( ! status ) { status = ASN1_INTEGER_cmp ( X509_get_serialNumber ( kdc_cert ) , is -> serial ) ; if ( ! status ) * valid_kdcPkId = 1 ; } retval = 0 ; <S2SV_StartBug> cleanup : <S2SV_EndBug> X509_NAME_free ( is -> issuer ) ; ASN1_INTEGER_free ( is -> serial ) ; free ( is ) ; return retval ; }
","<S2SV_ModStart> == NULL ) return retval <S2SV_ModEnd> ; status = <S2SV_ModStart> = 0 ; <S2SV_ModEnd> X509_NAME_free ( is
",krb5@krb5/f249555301940c6df3a2cdda13b56b5674eebc2e,CVE-2013-1415,https://github.com/krb5/krb5/commit/f249555301940c6df3a2cdda13b56b5674eebc2e,2013-03-05T05:05Z,263,<S2SV_ModStart> ; if ( <S2SV_ModEnd> == NULL ),0
687,CWE-264,"CWE-264 static int dccp_v6_send_response ( const struct sock * sk , struct request_sock * req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; int err = - 1 ; struct dst_entry * dst ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowlabel = 0 ; fl6 . flowi6_oif = ireq -> ir_iif ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto done ; } skb = dccp_make_response ( sk , dst , req ) ; if ( skb != NULL ) { struct dccp_hdr * dh = dccp_hdr ( skb ) ; dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> err = net_xmit_eval ( err ) ; } done : dst_release ( dst ) ; return err ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock ( <S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass <S2SV_ModStart> np -> tclass ) ; rcu_read_unlock (
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,264,"<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6, rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> np -> opt ) ; rcu_read_unlock ( <S2SV_ModStart> np -> opt ) ; rcu_read_unlock ( ) ;",0
688,CWE-119,"CWE-119 <S2SV_StartBug> static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . lossless ) { <S2SV_EndBug> return ONLY_4X4 ; <S2SV_StartBug> } else if ( cpi -> common . current_video_frame == 0 ) { <S2SV_EndBug> return TX_MODE_SELECT ; } else { <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) { <S2SV_EndBug> return ALLOW_32X32 ; <S2SV_StartBug> } else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) { <S2SV_EndBug> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ; } else { unsigned int total = 0 ; int i ; for ( i = 0 ; i < TX_SIZES ; ++ i ) total += cpi -> tx_stepdown_count [ i ] ; if ( total ) { const double fraction = ( double ) cpi -> tx_stepdown_count [ 0 ] / total ; return fraction > 0.90 ? ALLOW_32X32 : TX_MODE_SELECT ; } else { return cpi -> common . tx_mode ; } <S2SV_StartBug> } <S2SV_EndBug> } }
","<S2SV_ModStart> VP9_COMP * cpi , MACROBLOCKD * const xd <S2SV_ModStart> { if ( xd -> lossless ) <S2SV_ModEnd> return ONLY_4X4 ; <S2SV_ModStart> return ONLY_4X4 ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> -> common . frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> == USE_LARGESTALL ) <S2SV_ModEnd> return ALLOW_32X32 ; <S2SV_ModStart> return ALLOW_32X32 ; <S2SV_ModEnd> else if ( <S2SV_ModStart> tx_size_search_method == USE_FULL_RD || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ; else <S2SV_ModEnd> return cpi -> <S2SV_ModStart> tx_mode ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,265,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>,0
690,CWE-134,"CWE-134 int print_calc ( image_desc_t * im ) { long i , ii , validsteps ; double printval ; struct tm tmvdef ; int graphelement = 0 ; long vidx ; int max_ii ; double magfact = - 1 ; char * si_symb = """" ; char * percent_s ; int prline_cnt = 0 ; time_t now = time ( NULL ) ; localtime_r ( & now , & tmvdef ) ; for ( i = 0 ; i < im -> gdes_c ; i ++ ) { vidx = im -> gdes [ i ] . vidx ; switch ( im -> gdes [ i ] . gf ) { case GF_PRINT : case GF_GPRINT : if ( im -> gdes [ vidx ] . gf == GF_VDEF ) { printval = im -> gdes [ vidx ] . vf . val ; localtime_r ( & im -> gdes [ vidx ] . vf . when , & tmvdef ) ; } else { max_ii = ( ( im -> gdes [ vidx ] . end - im -> gdes [ vidx ] . start ) / im -> gdes [ vidx ] . step * im -> gdes [ vidx ] . ds_cnt ) ; printval = DNAN ; validsteps = 0 ; for ( ii = im -> gdes [ vidx ] . ds ; ii < max_ii ; ii += im -> gdes [ vidx ] . ds_cnt ) { if ( ! finite ( im -> gdes [ vidx ] . data [ ii ] ) ) continue ; if ( isnan ( printval ) ) { printval = im -> gdes [ vidx ] . data [ ii ] ; validsteps ++ ; continue ; } switch ( im -> gdes [ i ] . cf ) { case CF_HWPREDICT : case CF_MHWPREDICT : case CF_DEVPREDICT : case CF_DEVSEASONAL : case CF_SEASONAL : case CF_AVERAGE : validsteps ++ ; printval += im -> gdes [ vidx ] . data [ ii ] ; break ; case CF_MINIMUM : printval = min ( printval , im -> gdes [ vidx ] . data [ ii ] ) ; break ; case CF_FAILURES : case CF_MAXIMUM : printval = max ( printval , im -> gdes [ vidx ] . data [ ii ] ) ; break ; case CF_LAST : printval = im -> gdes [ vidx ] . data [ ii ] ; } } if ( im -> gdes [ i ] . cf == CF_AVERAGE || im -> gdes [ i ] . cf > CF_LAST ) { if ( validsteps > 1 ) { printval = ( printval / validsteps ) ; } } } if ( ! im -> gdes [ i ] . strftm && ( percent_s = strstr ( im -> gdes [ i ] . format , ""%S"" ) ) != NULL ) { if ( magfact < 0.0 ) { auto_scale ( im , & printval , & si_symb , & magfact ) ; if ( printval == 0.0 ) magfact = - 1.0 ; } else { printval /= magfact ; } * ( ++ percent_s ) = 's' ; } else if ( ! im -> gdes [ i ] . strftm && strstr ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) { auto_scale ( im , & printval , & si_symb , & magfact ) ; } if ( im -> gdes [ i ] . gf == GF_PRINT ) { rrd_infoval_t prline ; if ( im -> gdes [ i ] . strftm ) { prline . u_str = ( char * ) malloc ( ( FMT_LEG_LEN + 2 ) * sizeof ( char ) ) ; if ( im -> gdes [ vidx ] . vf . never == 1 ) { time_clean ( prline . u_str , im -> gdes [ i ] . format ) ; } else { strftime ( prline . u_str , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ; } <S2SV_StartBug> } else if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>PRINT<S2SV_blank>in<S2SV_blank>\'%s\'"" , im -> gdes [ i ] . format ) ; return - 1 ; } else { prline . u_str = sprintf_alloc ( im -> gdes [ i ] . format , printval , si_symb ) ; } grinfo_push ( im , sprintf_alloc ( ""print[%ld]"" , prline_cnt ++ ) , RD_I_STR , prline ) ; free ( prline . u_str ) ; } else { if ( im -> gdes [ i ] . strftm ) { if ( im -> gdes [ vidx ] . vf . never == 1 ) { time_clean ( im -> gdes [ i ] . legend , im -> gdes [ i ] . format ) ; } else { strftime ( im -> gdes [ i ] . legend , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ; } } else { <S2SV_StartBug> if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>GPRINT<S2SV_blank>in<S2SV_blank>\'%s\'"" , im -> gdes [ i ] . format ) ; return - 1 ; } snprintf ( im -> gdes [ i ] . legend , FMT_LEG_LEN - 2 , im -> gdes [ i ] . format , printval , si_symb ) ; } graphelement = 1 ; } break ; case GF_LINE : case GF_AREA : case GF_GRAD : case GF_TICK : graphelement = 1 ; break ; case GF_HRULE : if ( isnan ( im -> gdes [ i ] . yrule ) ) { im -> gdes [ i ] . yrule = im -> gdes [ vidx ] . vf . val ; } ; graphelement = 1 ; break ; case GF_VRULE : if ( im -> gdes [ i ] . xrule == 0 ) { im -> gdes [ i ] . xrule = im -> gdes [ vidx ] . vf . when ; } ; graphelement = 1 ; break ; case GF_COMMENT : case GF_TEXTALIGN : case GF_DEF : case GF_CDEF : case GF_VDEF : # ifdef WITH_PIECHART case GF_PART : # endif case GF_SHIFT : case GF_XPORT : break ; case GF_STACK : rrd_set_error ( ""STACK<S2SV_blank>should<S2SV_blank>already<S2SV_blank>be<S2SV_blank>turned<S2SV_blank>into<S2SV_blank>LINE<S2SV_blank>or<S2SV_blank>AREA<S2SV_blank>here"" ) ; return - 1 ; break ; case GF_XAXIS : case GF_YAXIS : break ; } } return graphelement ; }
","<S2SV_ModStart> else if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> { if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
",oetiker@rrdtool-1.x/64ed5314af1255ab6dded45f70b39cdeab5ae2ec,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/64ed5314af1255ab6dded45f70b39cdeab5ae2ec,2020-02-12T02:15Z,266,<S2SV_ModStart> ) { if <S2SV_ModEnd> return - 1,0
692,CWE-119,"CWE-119 static int compare_tile_buffers ( const void * a , const void * b ) { const TileBuffer * const buf1 = ( const TileBuffer * ) a ; const TileBuffer * const buf2 = ( const TileBuffer * ) b ; <S2SV_StartBug> if ( buf1 -> size < buf2 -> size ) { <S2SV_EndBug> return 1 ; } else if ( buf1 -> size == buf2 -> size ) { return 0 ; } else { return - 1 ; } }
","<S2SV_ModStart> ) b ; return ( int ) ( buf2 -> size - <S2SV_ModEnd> buf1 -> size <S2SV_ModStart> buf1 -> size ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,267,,0
694,CWE-189,"CWE-189 struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; <S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }
","<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL
",torvalds@linux/d157bd761585605b7882935ffb86286919f62ea1,CVE-2016-3135,https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1,2016-04-27T17:59Z,268,<S2SV_ModStart> = size_t <S2SV_ModEnd> ; size_t,0
696,CWE-000,"CWE-000 static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; <S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }
","<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
",torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z,269,<S2SV_ModStart> ( sk ) return - EINVAL,0
697,CWE-400,"CWE-400 asmlinkage void do_page_fault ( struct pt_regs * regs , unsigned long writeaccess , unsigned long textaccess , unsigned long address ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; const struct exception_table_entry * fixup ; pte_t * pte ; int fault ; tsk = current ; mm = tsk -> mm ; local_irq_enable ( ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> if ( in_atomic ( ) || ! mm ) goto no_context ; down_read ( & mm -> mmap_sem ) ; vma = find_vma ( mm , address ) ; if ( ! vma ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } if ( vma -> vm_start <= address ) { goto good_area ; } if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; print_vma ( vma ) ; # endif goto bad_area ; } if ( expand_stack ( vma , address ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } good_area : if ( textaccess ) { if ( ! ( vma -> vm_flags & VM_EXEC ) ) goto bad_area ; } else { if ( writeaccess ) { if ( ! ( vma -> vm_flags & VM_WRITE ) ) goto bad_area ; } else { if ( ! ( vma -> vm_flags & VM_READ ) ) goto bad_area ; } } fault = handle_mm_fault ( mm , vma , address , writeaccess ? FAULT_FLAG_WRITE : 0 ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) { if ( fault & VM_FAULT_OOM ) goto out_of_memory ; else if ( fault & VM_FAULT_SIGBUS ) goto do_sigbus ; BUG ( ) ; } if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } pte = lookup_pte ( mm , address ) ; if ( ! pte ) { goto no_pte ; } __do_tlb_refill ( address , textaccess , pte ) ; no_pte : up_read ( & mm -> mmap_sem ) ; return ; bad_area : # ifdef DEBUG_FAULT printk ( ""fault:bad<S2SV_blank>area\\n"" ) ; # endif up_read ( & mm -> mmap_sem ) ; if ( user_mode ( regs ) ) { static int count = 0 ; siginfo_t info ; if ( count < 4 ) { count ++ ; printk ( ""user<S2SV_blank>mode<S2SV_blank>bad_area<S2SV_blank>address=%08lx<S2SV_blank>pid=%d<S2SV_blank>(%s)<S2SV_blank>pc=%08lx\\n"" , address , task_pid_nr ( current ) , current -> comm , ( unsigned long ) regs -> pc ) ; # if 0 show_regs ( regs ) ; # endif } if ( is_global_init ( tsk ) ) { panic ( ""INIT<S2SV_blank>had<S2SV_blank>user<S2SV_blank>mode<S2SV_blank>bad_area\\n"" ) ; } tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; info . si_signo = SIGSEGV ; info . si_errno = 0 ; info . si_addr = ( void * ) address ; force_sig_info ( SIGSEGV , & info , tsk ) ; return ; } no_context : # ifdef DEBUG_FAULT printk ( ""fault:No<S2SV_blank>context\\n"" ) ; # endif fixup = search_exception_tables ( regs -> pc ) ; if ( fixup ) { regs -> pc = fixup -> fixup ; return ; } if ( address < PAGE_SIZE ) printk ( KERN_ALERT ""Unable<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>kernel<S2SV_blank>NULL<S2SV_blank>pointer<S2SV_blank>dereference"" ) ; else printk ( KERN_ALERT ""Unable<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>kernel<S2SV_blank>paging<S2SV_blank>request"" ) ; printk ( ""<S2SV_blank>at<S2SV_blank>virtual<S2SV_blank>address<S2SV_blank>%08lx\\n"" , address ) ; printk ( KERN_ALERT ""pc<S2SV_blank>=<S2SV_blank>%08Lx%08Lx\\n"" , regs -> pc >> 32 , regs -> pc & 0xffffffff ) ; die ( ""Oops"" , regs , writeaccess ) ; do_exit ( SIGKILL ) ; out_of_memory : up_read ( & mm -> mmap_sem ) ; if ( ! user_mode ( regs ) ) goto no_context ; pagefault_out_of_memory ( ) ; return ; do_sigbus : printk ( ""fault:Do<S2SV_blank>sigbus\\n"" ) ; up_read ( & mm -> mmap_sem ) ; tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; tsk -> thread . trap_no = 14 ; force_sig ( SIGBUS , tsk ) ; if ( ! user_mode ( regs ) ) goto no_context ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,270,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",0
698,CWE-000,"CWE-000 static int em_grp45 ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; switch ( ctxt -> modrm_reg ) { case 2 : { long int old_eip ; old_eip = ctxt -> _eip ; <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; break ; } case 4 : <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> break ; case 5 : rc = em_jmp_far ( ctxt ) ; break ; case 6 : rc = em_push ( ctxt ) ; break ; } return rc ; }
","<S2SV_ModStart> -> _eip ; rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> case 4 : rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val )
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z,271,"<S2SV_ModStart> ; rc = assign_eip_near ( ctxt, <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src. val ) ; if ( rc!= X86EMUL_CONTINUE ) break",0
699,CWE-77,"CWE-77 static void cmd_parse_lsub ( struct ImapData * idata , char * s ) { char buf [ STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct Url url ; struct ImapList list ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_LIST ) { cmd_parse_list ( idata , s ) ; return ; } if ( ! ImapCheckSubscribed ) return ; idata -> cmdtype = IMAP_CT_LIST ; idata -> cmddata = & list ; cmd_parse_list ( idata , s ) ; idata -> cmddata = NULL ; if ( ! list . name || list . noselect ) return ; mutt_debug ( 3 , ""Subscribing<S2SV_blank>to<S2SV_blank>%s\\n"" , list . name ) ; mutt_str_strfcpy ( buf , ""mailboxes<S2SV_blank>\\"""" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata -> conn -> account , & url ) ; <S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '\\0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 ) url . user = NULL ; url_tostring ( & url , buf + 11 , sizeof ( buf ) - 11 , 0 ) ; mutt_str_strcat ( buf , sizeof ( buf ) , ""\\"""" ) ; mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; if ( mutt_parse_rc_line ( buf , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n"" , errstr ) ; FREE ( & token . data ) ; }
","<S2SV_ModStart> list . name , true
",neomutt@neomutt/e52393740334443ae0206cab2d7caef381646725,CVE-2018-14357,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,2018-07-17T17:29Z,272,"<S2SV_ModStart> list. name, true",1
702,CWE-000,"CWE-000 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
","<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
",torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z,273,<S2SV_ModStart> = 0 ;,0
704,CWE-772,"CWE-772 int button_open ( Button * b ) { char * p , name [ 256 ] ; int r ; assert ( b ) ; b -> fd = safe_close ( b -> fd ) ; p = strjoina ( ""/dev/input/"" , b -> name ) ; b -> fd = open ( p , O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK ) ; if ( b -> fd < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m"" , p ) ; r = button_suitable ( b ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>input<S2SV_blank>device<S2SV_blank>is<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us:<S2SV_blank>%m"" ) ; if ( r == 0 ) return log_debug_errno ( SYNTHETIC_ERRNO ( EADDRNOTAVAIL ) , ""Device<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>expose<S2SV_blank>keys<S2SV_blank>or<S2SV_blank>switches<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us,<S2SV_blank>ignoring."" , p ) ; if ( ioctl ( b -> fd , EVIOCGNAME ( sizeof ( name ) ) , name ) < 0 ) { r = log_error_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>input<S2SV_blank>name:<S2SV_blank>%m"" ) ; goto fail ; } ( void ) button_set_mask ( b ) ; <S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug> if ( r < 0 ) { log_error_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>button<S2SV_blank>event:<S2SV_blank>%m"" ) ; goto fail ; } log_info ( ""Watching<S2SV_blank>system<S2SV_blank>buttons<S2SV_blank>on<S2SV_blank>/dev/input/%s<S2SV_blank>(%s)"" , b -> name , name ) ; return 0 ; fail : b -> fd = safe_close ( b -> fd ) ; return r ; }
","<S2SV_ModStart> b ) ; b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;
",systemd@systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,CVE-2019-20386,https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,2020-01-21T06:15Z,274,<S2SV_ModStart> ; r = TEMP_FAILURE_RETRY (,0
705,CWE-119,"CWE-119 int test ( char * URL ) { int errors = 0 ; ( void ) URL ; errors += test_weird_arguments ( ) ; errors += test_unsigned_short_formatting ( ) ; errors += test_signed_short_formatting ( ) ; errors += test_unsigned_int_formatting ( ) ; errors += test_signed_int_formatting ( ) ; errors += test_unsigned_long_formatting ( ) ; errors += test_signed_long_formatting ( ) ; errors += test_curl_off_t_formatting ( ) ; errors += test_string_formatting ( ) ; <S2SV_StartBug> if ( errors ) <S2SV_EndBug> return TEST_ERR_MAJOR_BAD ; else return 0 ; }
","<S2SV_ModStart> ( ) ; errors += test_float_formatting ( ) ;
",curl@curl/3ab3c16db6a5674f53cf23d56512a405fde0b2c9,CVE-2016-9586,https://github.com/curl/curl/commit/curl-7_51_0-162-g3ab3c16,2018-04-23T18:29Z,275,,0
707,CWE-000,"CWE-000 static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
",torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z,276,"<S2SV_ModStart>, cmd, cmd",0
708,CWE-125,"CWE-125 static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,277,"<S2SV_ModStart>, annotation, type_comment,",0
710,CWE-20,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
","<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
",torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e,CVE-2017-17805,https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e,2017-12-20T23:29Z,278,<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk,1
713,CWE-787,"CWE-787 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; <S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
",ImageMagick@ImageMagick/998c687fb83993c13fa711d75f59a95b38ceab77,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77,2017-04-20T18:59Z,279,<S2SV_ModStart> Rec. RecordLength ) ; if ( status == MagickFalse ) break,0
714,CWE-264,"CWE-264 static int em_loop ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ; if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
","<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ) ) ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z,280,<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ) ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>,0
715,CWE-119,"CWE-119 void cJSON_AddItemReferenceToArray ( cJSON * array , cJSON * item ) { cJSON_AddItemToArray ( array , create_reference ( item ) ) ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,281,,1
716,CWE-476,"CWE-476 static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
","<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
",torvalds@linux/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,CVE-2018-10074,https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,2018-04-12T18:29Z,282,<S2SV_ModStart>,0
717,CWE-119,"CWE-119 static void header_seek ( SF_PRIVATE * psf , sf_count_t position , int whence ) { switch ( whence ) { case SEEK_SET : <S2SV_StartBug> if ( position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { psf_fseek ( psf , position , whence ) ; return ; } ; <S2SV_StartBug> if ( position > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ; <S2SV_EndBug> psf -> headindex = position ; break ; case SEEK_CUR : <S2SV_StartBug> if ( psf -> headindex + position < 0 ) <S2SV_EndBug> break ; <S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { psf_fseek ( psf , position , whence ) ; return ; } ; <S2SV_StartBug> if ( psf -> headindex + position <= psf -> headend ) <S2SV_EndBug> { psf -> headindex += position ; break ; } ; <S2SV_StartBug> if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> psf_fseek ( psf , position , SEEK_CUR ) ; break ; } ; <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> break ; case SEEK_END : default : psf_log_printf ( psf , ""Bad<S2SV_blank>whence<S2SV_blank>param<S2SV_blank>in<S2SV_blank>header_seek().\\n"" ) ; break ; } ; return ; }
","<S2SV_ModStart> : if ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( position > psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> > psf -> header . end ) psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> - psf -> header . end , psf ) ; psf -> header . indx <S2SV_ModEnd> = position ; <S2SV_ModStart> ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( psf -> header . indx <S2SV_ModEnd> + position < <S2SV_ModStart> ( psf -> header . indx >= psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position <= <S2SV_ModStart> <= psf -> header . end ) { psf -> header . indx <S2SV_ModEnd> += position ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position > <S2SV_ModStart> + position > psf -> header . len ) { psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; psf_fseek ( <S2SV_ModStart> ; psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx ) , psf ) ; psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,283,<S2SV_ModStart> psf -> header. end <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr,0
724,CWE-119,"CWE-119 IHEVCD_ERROR_T ihevcd_cabac_init ( cab_ctxt_t * ps_cabac , bitstrm_t * ps_bitstrm , WORD32 qp , WORD32 cabac_init_idc , const UWORD8 * pu1_init_ctxt ) { ASSERT ( ps_cabac != NULL ) ; ASSERT ( ps_bitstrm != NULL ) ; ASSERT ( ( qp >= 0 ) && ( qp < 52 ) ) ; ASSERT ( ( cabac_init_idc >= 0 ) && ( cabac_init_idc < 3 ) ) ; UNUSED ( qp ) ; UNUSED ( cabac_init_idc ) ; # if FULLRANGE ps_cabac -> u4_range = ( UWORD32 ) 510 << RANGE_SHIFT ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , ( 9 + RANGE_SHIFT ) ) ; # else ps_cabac -> u4_range = ( UWORD32 ) 510 ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , 9 ) ; # endif memcpy ( ps_cabac -> au1_ctxt_models , pu1_init_ctxt , IHEVC_CAB_CTXT_END ) ; DEBUG_RANGE_OFST ( ""init"" , ps_cabac -> u4_range , ps_cabac -> u4_ofst ) ; <S2SV_StartBug> return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; <S2SV_EndBug> }
","<S2SV_ModStart> u4_ofst ) ; if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; }
",external@libhevc/bcfc7124f6ef9f1ec128fb2e90de774a5b33d199,CVE-2017-0589,https://android.googlesource.com/platform/external/libhevc/+/bcfc7124f6ef9f1ec128fb2e90de774a5b33d199,2017-05-12T15:29Z,284,,0
727,CWE-908,"CWE-908 static int md_analyze_line ( MD_CTX * ctx , OFF beg , OFF * p_end , const MD_LINE_ANALYSIS * pivot_line , MD_LINE_ANALYSIS * line ) { unsigned total_indent = 0 ; int n_parents = 0 ; int n_brothers = 0 ; int n_children = 0 ; MD_CONTAINER container = { 0 } ; int prev_line_has_list_loosening_effect = ctx -> last_line_has_list_loosening_effect ; OFF off = beg ; OFF hr_killer = 0 ; int ret = 0 ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; while ( n_parents < ctx -> n_containers ) { MD_CONTAINER * c = & ctx -> containers [ n_parents ] ; if ( c -> ch == _T ( '>' ) && line -> indent < ctx -> code_indent_offset && off < ctx -> size && CH ( off ) == _T ( '>' ) ) { off ++ ; total_indent ++ ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; if ( line -> indent > 0 ) line -> indent -- ; line -> beg = off ; } else if ( c -> ch != _T ( '>' ) && line -> indent >= c -> contents_indent ) { line -> indent -= c -> contents_indent ; } else { break ; } n_parents ++ ; } if ( off >= ctx -> size || ISNEWLINE ( off ) ) { if ( n_brothers + n_children == 0 ) { while ( n_parents < ctx -> n_containers && ctx -> containers [ n_parents ] . ch != _T ( '>' ) ) n_parents ++ ; } } while ( TRUE ) { if ( pivot_line -> type == MD_LINE_FENCEDCODE ) { line -> beg = off ; if ( line -> indent < ctx -> code_indent_offset ) { if ( md_is_closing_code_fence ( ctx , CH ( pivot_line -> beg ) , off , & off ) ) { line -> type = MD_LINE_BLANK ; ctx -> last_line_has_list_loosening_effect = FALSE ; break ; } } if ( n_parents == ctx -> n_containers ) { if ( line -> indent > pivot_line -> indent ) line -> indent -= pivot_line -> indent ; else line -> indent = 0 ; line -> type = MD_LINE_FENCEDCODE ; break ; } } if ( pivot_line -> type == MD_LINE_HTML && ctx -> html_block_type > 0 ) { if ( n_parents < ctx -> n_containers ) { ctx -> html_block_type = 0 ; } else { int html_block_type ; html_block_type = md_is_html_block_end_condition ( ctx , off , & off ) ; if ( html_block_type > 0 ) { MD_ASSERT ( html_block_type == ctx -> html_block_type ) ; ctx -> html_block_type = 0 ; if ( html_block_type == 6 || html_block_type == 7 ) { line -> type = MD_LINE_BLANK ; line -> indent = 0 ; break ; } } line -> type = MD_LINE_HTML ; n_parents = ctx -> n_containers ; break ; } } if ( off >= ctx -> size || ISNEWLINE ( off ) ) { if ( pivot_line -> type == MD_LINE_INDENTEDCODE && n_parents == ctx -> n_containers ) { line -> type = MD_LINE_INDENTEDCODE ; if ( line -> indent > ctx -> code_indent_offset ) line -> indent -= ctx -> code_indent_offset ; else line -> indent = 0 ; ctx -> last_line_has_list_loosening_effect = FALSE ; } else { line -> type = MD_LINE_BLANK ; ctx -> last_line_has_list_loosening_effect = ( n_parents > 0 && n_brothers + n_children == 0 && ctx -> containers [ n_parents - 1 ] . ch != _T ( '>' ) ) ; # if 1 if ( n_parents > 0 && ctx -> containers [ n_parents - 1 ] . ch != _T ( '>' ) && n_brothers + n_children == 0 && ctx -> current_block == NULL && ctx -> n_block_bytes > ( int ) sizeof ( MD_BLOCK ) ) { MD_BLOCK * top_block = ( MD_BLOCK * ) ( ( char * ) ctx -> block_bytes + ctx -> n_block_bytes - sizeof ( MD_BLOCK ) ) ; if ( top_block -> type == MD_BLOCK_LI ) ctx -> last_list_item_starts_with_two_blank_lines = TRUE ; } # endif } break ; } else { # if 1 ctx -> last_line_has_list_loosening_effect = FALSE ; if ( ctx -> last_list_item_starts_with_two_blank_lines ) { if ( n_parents > 0 && ctx -> containers [ n_parents - 1 ] . ch != _T ( '>' ) && n_brothers + n_children == 0 && ctx -> current_block == NULL && ctx -> n_block_bytes > ( int ) sizeof ( MD_BLOCK ) ) { MD_BLOCK * top_block = ( MD_BLOCK * ) ( ( char * ) ctx -> block_bytes + ctx -> n_block_bytes - sizeof ( MD_BLOCK ) ) ; if ( top_block -> type == MD_BLOCK_LI ) n_parents -- ; } ctx -> last_list_item_starts_with_two_blank_lines = FALSE ; } # endif } if ( line -> indent < ctx -> code_indent_offset && pivot_line -> type == MD_LINE_TEXT <S2SV_StartBug> && ( CH ( off ) == _T ( '=' ) || CH ( off ) == _T ( '-' ) ) <S2SV_EndBug> && ( n_parents == ctx -> n_containers ) ) { unsigned level ; if ( md_is_setext_underline ( ctx , off , & off , & level ) ) { line -> type = MD_LINE_SETEXTUNDERLINE ; line -> data = level ; break ; } } <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && ISANYOF ( off , _T ( ""-_*"" ) ) && off >= hr_killer ) { <S2SV_EndBug> if ( md_is_hr_line ( ctx , off , & off , & hr_killer ) ) { line -> type = MD_LINE_HR ; break ; } } if ( n_parents < ctx -> n_containers && n_brothers + n_children == 0 ) { OFF tmp ; if ( md_is_container_mark ( ctx , line -> indent , off , & tmp , & container ) && md_is_container_compatible ( & ctx -> containers [ n_parents ] , & container ) ) { pivot_line = & md_dummy_blank_line ; off = tmp ; total_indent += container . contents_indent - container . mark_indent ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; if ( off >= ctx -> size || ISNEWLINE ( off ) ) { container . contents_indent ++ ; } else if ( line -> indent <= ctx -> code_indent_offset ) { container . contents_indent += line -> indent ; line -> indent = 0 ; } else { container . contents_indent += 1 ; line -> indent -- ; } ctx -> containers [ n_parents ] . mark_indent = container . mark_indent ; ctx -> containers [ n_parents ] . contents_indent = container . contents_indent ; n_brothers ++ ; continue ; } } if ( line -> indent >= ctx -> code_indent_offset && ( pivot_line -> type == MD_LINE_BLANK || pivot_line -> type == MD_LINE_INDENTEDCODE ) ) { line -> type = MD_LINE_INDENTEDCODE ; MD_ASSERT ( line -> indent >= ctx -> code_indent_offset ) ; line -> indent -= ctx -> code_indent_offset ; line -> data = 0 ; break ; } if ( line -> indent < ctx -> code_indent_offset && md_is_container_mark ( ctx , line -> indent , off , & off , & container ) ) { if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && ( off >= ctx -> size || ISNEWLINE ( off ) ) && container . ch != _T ( '>' ) ) { } else if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && <S2SV_StartBug> ( container . ch == _T ( '.' ) || container . ch == _T ( ')' ) ) && container . start != 1 ) <S2SV_EndBug> { } else { total_indent += container . contents_indent - container . mark_indent ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; line -> data = container . ch ; if ( off >= ctx -> size || ISNEWLINE ( off ) ) { container . contents_indent ++ ; } else if ( line -> indent <= ctx -> code_indent_offset ) { container . contents_indent += line -> indent ; line -> indent = 0 ; } else { container . contents_indent += 1 ; line -> indent -- ; } if ( n_brothers + n_children == 0 ) pivot_line = & md_dummy_blank_line ; if ( n_children == 0 ) MD_CHECK ( md_leave_child_containers ( ctx , n_parents + n_brothers ) ) ; n_children ++ ; MD_CHECK ( md_push_container ( ctx , & container ) ) ; continue ; } } if ( pivot_line -> type == MD_LINE_TABLE && n_parents == ctx -> n_containers ) { line -> type = MD_LINE_TABLE ; break ; } <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && CH ( off ) == _T ( '#' ) ) { <S2SV_EndBug> unsigned level ; if ( md_is_atxheader_line ( ctx , off , & line -> beg , & off , & level ) ) { line -> type = MD_LINE_ATXHEADER ; line -> data = level ; break ; } } <S2SV_StartBug> if ( CH ( off ) == _T ( '`' ) || CH ( off ) == _T ( '~' ) ) { <S2SV_EndBug> if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( CH ( off ) == _T ( '<' ) && ! ( ctx -> parser . flags & MD_FLAG_NOHTMLBLOCKS ) ) { ctx -> html_block_type = md_is_html_block_start_condition ( ctx , off ) ; if ( ctx -> html_block_type == 7 && pivot_line -> type == MD_LINE_TEXT ) ctx -> html_block_type = 0 ; if ( ctx -> html_block_type > 0 ) { if ( md_is_html_block_end_condition ( ctx , off , & off ) == ctx -> html_block_type ) { ctx -> html_block_type = 0 ; } line -> type = MD_LINE_HTML ; break ; } } <S2SV_StartBug> if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT && <S2SV_EndBug> <S2SV_StartBug> ( CH ( off ) == _T ( '|' ) || CH ( off ) == _T ( '-' ) || CH ( off ) == _T ( ':' ) ) && <S2SV_EndBug> n_parents == ctx -> n_containers ) { unsigned col_count ; if ( ctx -> current_block != NULL && ctx -> current_block -> n_lines == 1 && md_is_table_underline ( ctx , off , & off , & col_count ) ) { line -> data = col_count ; line -> type = MD_LINE_TABLEUNDERLINE ; break ; } } line -> type = MD_LINE_TEXT ; if ( pivot_line -> type == MD_LINE_TEXT && n_brothers + n_children == 0 ) { n_parents = ctx -> n_containers ; } if ( ( ctx -> parser . flags & MD_FLAG_TASKLISTS ) && n_brothers + n_children > 0 && ISANYOF_ ( ctx -> containers [ ctx -> n_containers - 1 ] . ch , _T ( ""-+*.)"" ) ) ) { OFF tmp = off ; while ( tmp < ctx -> size && tmp < off + 3 && ISBLANK ( tmp ) ) tmp ++ ; if ( tmp + 2 < ctx -> size && CH ( tmp ) == _T ( '[' ) && ISANYOF ( tmp + 1 , _T ( ""xX<S2SV_blank>"" ) ) && CH ( tmp + 2 ) == _T ( ']' ) && ( tmp + 3 == ctx -> size || ISBLANK ( tmp + 3 ) || ISNEWLINE ( tmp + 3 ) ) ) { MD_CONTAINER * task_container = ( n_children > 0 ? & ctx -> containers [ ctx -> n_containers - 1 ] : & container ) ; task_container -> is_task = TRUE ; task_container -> task_mark_off = tmp + 1 ; off = tmp + 3 ; while ( ISWHITESPACE ( off ) ) off ++ ; line -> beg = off ; } } break ; } # if defined __linux__ && ! defined MD4C_USE_UTF16 if ( ctx -> doc_ends_with_newline && off < ctx -> size ) { while ( TRUE ) { off += ( OFF ) strcspn ( STR ( off ) , ""\\r\\n"" ) ; if ( CH ( off ) == _T ( '\\0' ) ) off ++ ; else break ; } } else # endif { while ( off + 3 < ctx -> size && ! ISNEWLINE ( off + 0 ) && ! ISNEWLINE ( off + 1 ) && ! ISNEWLINE ( off + 2 ) && ! ISNEWLINE ( off + 3 ) ) off += 4 ; while ( off < ctx -> size && ! ISNEWLINE ( off ) ) off ++ ; } line -> end = off ; if ( line -> type == MD_LINE_ATXHEADER ) { OFF tmp = line -> end ; while ( tmp > line -> beg && CH ( tmp - 1 ) == _T ( '<S2SV_blank>' ) ) tmp -- ; while ( tmp > line -> beg && CH ( tmp - 1 ) == _T ( '#' ) ) tmp -- ; if ( tmp == line -> beg || CH ( tmp - 1 ) == _T ( '<S2SV_blank>' ) || ( ctx -> parser . flags & MD_FLAG_PERMISSIVEATXHEADERS ) ) line -> end = tmp ; } if ( line -> type != MD_LINE_INDENTEDCODE && line -> type != MD_LINE_FENCEDCODE ) { while ( line -> end > line -> beg && CH ( line -> end - 1 ) == _T ( '<S2SV_blank>' ) ) line -> end -- ; } if ( off < ctx -> size && CH ( off ) == _T ( '\\r' ) ) off ++ ; if ( off < ctx -> size && CH ( off ) == _T ( '\\n' ) ) off ++ ; * p_end = off ; if ( prev_line_has_list_loosening_effect && line -> type != MD_LINE_BLANK && n_parents + n_brothers > 0 ) { MD_CONTAINER * c = & ctx -> containers [ n_parents + n_brothers - 1 ] ; if ( c -> ch != _T ( '>' ) ) { MD_BLOCK * block = ( MD_BLOCK * ) ( ( ( char * ) ctx -> block_bytes ) + c -> block_byte_off ) ; block -> flags |= MD_BLOCK_LOOSE_LIST ; } } if ( n_children == 0 && n_parents + n_brothers < ctx -> n_containers ) MD_CHECK ( md_leave_child_containers ( ctx , n_parents + n_brothers ) ) ; if ( n_brothers > 0 ) { MD_ASSERT ( n_brothers == 1 ) ; MD_CHECK ( md_push_container_bytes ( ctx , MD_BLOCK_LI , ctx -> containers [ n_parents ] . task_mark_off , ( ctx -> containers [ n_parents ] . is_task ? CH ( ctx -> containers [ n_parents ] . task_mark_off ) : 0 ) , MD_BLOCK_CONTAINER_CLOSER ) ) ; MD_CHECK ( md_push_container_bytes ( ctx , MD_BLOCK_LI , container . task_mark_off , ( container . is_task ? CH ( container . task_mark_off ) : 0 ) , MD_BLOCK_CONTAINER_OPENER ) ) ; ctx -> containers [ n_parents ] . is_task = container . is_task ; ctx -> containers [ n_parents ] . task_mark_off = container . task_mark_off ; } if ( n_children > 0 ) MD_CHECK ( md_enter_child_containers ( ctx , n_children ) ) ; abort : return ret ; }
","<S2SV_ModStart> == MD_LINE_TEXT && off < ctx -> size && ISANYOF2 ( off , <S2SV_ModEnd> _T ( '=' <S2SV_ModStart> ( '=' ) , <S2SV_ModEnd> _T ( '-' <S2SV_ModStart> ctx -> code_indent_offset && off < ctx -> size <S2SV_ModEnd> && off >= <S2SV_ModStart> off >= hr_killer && ISANYOF ( off , _T ( ""-_*"" ) ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> -> n_containers && ISANYOF2_ <S2SV_ModStart> container . ch , <S2SV_ModEnd> _T ( '.' <S2SV_ModStart> ( '.' ) , <S2SV_ModEnd> _T ( ')' <S2SV_ModStart> -> code_indent_offset && off < ctx -> size && <S2SV_ModStart> } if ( off < ctx -> size && ISANYOF2 ( off , _T ( '`' ) , _T ( '~' ) ) ) { if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( off < ctx -> size && <S2SV_ModStart> == _T ( <S2SV_ModEnd> '<' ) && <S2SV_ModStart> type == MD_LINE_TEXT && off < ctx -> size && ISANYOF3 ( off , <S2SV_ModEnd> _T ( '|' <S2SV_ModStart> ( '|' ) , <S2SV_ModEnd> _T ( '-' <S2SV_ModStart> ( '-' ) , <S2SV_ModEnd> _T ( ':' <S2SV_ModStart> ':' ) ) && <S2SV_ModEnd> n_parents == ctx
",mity@md4c/4fc808d8fe8d8904f8525bb4231d854f45e23a19,CVE-2021-30027,https://github.com/mity/md4c/commit/4fc808d8fe8d8904f8525bb4231d854f45e23a19,2021-04-29T15:15Z,285,,0
736,CWE-264,"CWE-264 void perf_event_disable ( struct perf_event * event ) { <S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> struct task_struct * task = ctx -> task ; if ( ! task ) { cpu_function_call ( event -> cpu , __perf_event_disable , event ) ; return ; } retry : if ( ! task_function_call ( task , __perf_event_disable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state == PERF_EVENT_STATE_ACTIVE ) { raw_spin_unlock_irq ( & ctx -> lock ) ; task = ctx -> task ; goto retry ; } if ( event -> state == PERF_EVENT_STATE_INACTIVE ) { update_group_times ( event ) ; <S2SV_StartBug> event -> state = PERF_EVENT_STATE_OFF ; <S2SV_EndBug> } raw_spin_unlock_irq ( & ctx -> lock ) ; }
","<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z,286,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> perf_event_event_event_event_event ( event <S2SV_ModStart> event_event_event_event_event_event ( event <S2SV_ModEnd> ) ; return,0
739,CWE-119,"CWE-119 static void set_ppflags ( const vpx_codec_alg_priv_t * ctx , vp9_ppflags_t * flags ) { flags -> post_proc_flag = <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ; flags -> deblocking_level = ctx -> postproc_cfg . deblocking_level ; flags -> noise_level = ctx -> postproc_cfg . noise_level ; <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ; flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ; flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ; flags -> display_mv_flag = ctx -> dbg_display_mv_flag ; # endif }
","<S2SV_ModStart> -> post_proc_flag = <S2SV_ModEnd> ctx -> postproc_cfg <S2SV_ModStart> . noise_level ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,287,<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( flags,0
744,CWE-125,"CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else <S2SV_StartBug> { <S2SV_EndBug> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : { <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }
","<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z,288,"<S2SV_ModStart> ( tptr, tptr <S2SV_ModEnd> ) ) {",0
746,CWE-119,"CWE-119 int vp8_receive_raw_frame ( VP8_COMP * cpi , unsigned int frame_flags , YV12_BUFFER_CONFIG * sd , int64_t time_stamp , int64_t end_time ) { <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> int64_t store_reg [ 8 ] ; # if CONFIG_RUNTIME_CPU_DETECT VP8_COMMON * cm = & cpi -> common ; # endif # endif struct vpx_usec_timer timer ; int res = 0 ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & timer ) ; if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) { assert ( cpi -> oxcf . lag_in_frames < 2 ) ; dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; } if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ; vpx_usec_timer_mark ( & timer ) ; cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return res ; }
","<S2SV_ModStart> end_time ) { <S2SV_ModEnd> struct vpx_usec_timer timer <S2SV_ModStart> = 0 ; <S2SV_ModEnd> vpx_usec_timer_start ( & <S2SV_ModStart> timer ) ; <S2SV_ModEnd> return res ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,289,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( cm <S2SV_ModStart> = 0 ; <S2SV_ModEnd> return 0 ;,0
747,CWE-269,"CWE-269 static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug> errExit ( ""fchown"" ) ; if ( chmod ( dest , 0600 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> ( stderr , ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) , 0600 ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ) ; return
",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z,290,"<S2SV_ModStart> ( src, NULL <S2SV_ModEnd> ) ; if",0
750,CWE-908,"CWE-908 static int ext4_ext_split ( handle_t * handle , struct inode * inode , unsigned int flags , struct ext4_ext_path * path , struct ext4_extent * newext , int at ) { struct buffer_head * bh = NULL ; int depth = ext_depth ( inode ) ; struct ext4_extent_header * neh ; struct ext4_extent_idx * fidx ; int i = at , k , m , a ; ext4_fsblk_t newblock , oldblock ; __le32 border ; ext4_fsblk_t * ablocks = NULL ; int err = 0 ; <S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ; return - EFSCORRUPTED ; } if ( path [ depth ] . p_ext != EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) { border = path [ depth ] . p_ext [ 1 ] . ee_block ; ext_debug ( ""leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>split."" ""<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , le32_to_cpu ( border ) ) ; } else { border = newext -> ee_block ; ext_debug ( ""leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>added."" ""<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , le32_to_cpu ( border ) ) ; } ablocks = kcalloc ( depth , sizeof ( ext4_fsblk_t ) , GFP_NOFS ) ; if ( ! ablocks ) return - ENOMEM ; ext_debug ( ""allocate<S2SV_blank>%d<S2SV_blank>blocks<S2SV_blank>for<S2SV_blank>indexes/leaf\\n"" , depth - at ) ; for ( a = 0 ; a < depth - at ; a ++ ) { newblock = ext4_ext_new_meta_block ( handle , inode , path , newext , & err , flags ) ; if ( newblock == 0 ) goto cleanup ; ablocks [ a ] = newblock ; } newblock = ablocks [ -- a ] ; if ( unlikely ( newblock == 0 ) ) { EXT4_ERROR_INODE ( inode , ""newblock<S2SV_blank>==<S2SV_blank>0!"" ) ; err = - EFSCORRUPTED ; goto cleanup ; } bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = 0 ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_depth = 0 ; if ( unlikely ( path [ depth ] . p_hdr -> eh_entries != path [ depth ] . p_hdr -> eh_max ) ) { EXT4_ERROR_INODE ( inode , ""eh_entries<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>eh_max<S2SV_blank>%d!"" , path [ depth ] . p_hdr -> eh_entries , path [ depth ] . p_hdr -> eh_max ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) - path [ depth ] . p_ext ++ ; ext4_ext_show_move ( inode , path , newblock , depth ) ; if ( m ) { struct ext4_extent * ex ; ex = EXT_FIRST_EXTENT ( neh ) ; memmove ( ex , path [ depth ] . p_ext , sizeof ( struct ext4_extent ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ depth ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; } k = depth - at - 1 ; if ( unlikely ( k < 0 ) ) { EXT4_ERROR_INODE ( inode , ""k<S2SV_blank>%d<S2SV_blank><<S2SV_blank>0!"" , k ) ; err = - EFSCORRUPTED ; goto cleanup ; } if ( k ) ext_debug ( ""create<S2SV_blank>%d<S2SV_blank>intermediate<S2SV_blank>indices\\n"" , k ) ; i = depth - 1 ; while ( k -- ) { oldblock = newblock ; newblock = ablocks [ -- a ] ; bh = sb_getblk ( inode -> i_sb , newblock ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; neh -> eh_depth = cpu_to_le16 ( depth - i ) ; fidx = EXT_FIRST_INDEX ( neh ) ; fidx -> ei_block = border ; ext4_idx_store_pblock ( fidx , oldblock ) ; ext_debug ( ""int.index<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>(block<S2SV_blank>%llu):<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%llu\\n"" , i , newblock , le32_to_cpu ( border ) , oldblock ) ; if ( unlikely ( EXT_MAX_INDEX ( path [ i ] . p_hdr ) != EXT_LAST_INDEX ( path [ i ] . p_hdr ) ) ) { EXT4_ERROR_INODE ( inode , ""EXT_MAX_INDEX<S2SV_blank>!=<S2SV_blank>EXT_LAST_INDEX<S2SV_blank>ee_block<S2SV_blank>%d!"" , le32_to_cpu ( path [ i ] . p_ext -> ee_block ) ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_INDEX ( path [ i ] . p_hdr ) - path [ i ] . p_idx ++ ; ext_debug ( ""cur<S2SV_blank>0x%p,<S2SV_blank>last<S2SV_blank>0x%p\\n"" , path [ i ] . p_idx , EXT_MAX_INDEX ( path [ i ] . p_hdr ) ) ; ext4_ext_show_move ( inode , path , newblock , i ) ; if ( m ) { memmove ( ++ fidx , path [ i ] . p_idx , sizeof ( struct ext4_extent_idx ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + i ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ i ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + i ) ; if ( err ) goto cleanup ; } i -- ; } err = ext4_ext_insert_index ( handle , inode , path + at , le32_to_cpu ( border ) , newblock ) ; cleanup : if ( bh ) { if ( buffer_locked ( bh ) ) unlock_buffer ( bh ) ; brelse ( bh ) ; } if ( err ) { for ( i = 0 ; i < depth ; i ++ ) { if ( ! ablocks [ i ] ) continue ; ext4_free_blocks ( handle , inode , NULL , ablocks [ i ] , 1 , EXT4_FREE_BLOCKS_METADATA ) ; } } kfree ( ablocks ) ; return err ; }
","<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;
",torvalds@linux/592acbf16821288ecdc4192c47e3774a4c48bb64,CVE-2019-11833,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,2019-05-15T13:29Z,291,"<S2SV_ModStart> ) ; } memset <S2SV_ModEnd> ( inode,",0
751,CWE-787,"CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ; break ; <S2SV_ModEnd> } } if <S2SV_ModStart> 1 ; } }
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,292,,0
757,CWE-264,"CWE-264 static authz_status lua_authz_check ( request_rec * r , const char * require_line , const void * parsed_require_line ) { apr_pool_t * pool ; ap_lua_vm_spec * spec ; lua_State * L ; ap_lua_server_cfg * server_cfg = ap_get_module_config ( r -> server -> module_config , & lua_module ) ; const ap_lua_dir_cfg * cfg = ap_get_module_config ( r -> per_dir_config , & lua_module ) ; <S2SV_StartBug> const lua_authz_provider_spec * prov_spec = parsed_require_line ; <S2SV_EndBug> int result ; int nargs = 0 ; spec = create_vm_spec ( & pool , r , cfg , server_cfg , prov_spec -> file_name , NULL , 0 , prov_spec -> function_name , ""authz<S2SV_blank>provider"" ) ; L = ap_lua_get_lua_state ( pool , spec , r ) ; if ( L == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) ""Unable<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>VM<S2SV_blank>for<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s"" , prov_spec -> name ) ; return AUTHZ_GENERAL_ERROR ; } lua_getglobal ( L , prov_spec -> function_name ) ; if ( ! lua_isfunction ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) ""Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>function<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>function)"" , prov_spec -> function_name , prov_spec -> file_name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } ap_lua_run_lua_request ( L , r ) ; <S2SV_StartBug> if ( prov_spec -> args ) { <S2SV_EndBug> int i ; <S2SV_StartBug> if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) { <S2SV_EndBug> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments"" , prov_spec -> name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } <S2SV_StartBug> for ( i = 0 ; i < prov_spec -> args -> nelts ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ; <S2SV_EndBug> lua_pushstring ( L , arg ) ; } <S2SV_StartBug> nargs = prov_spec -> args -> nelts ; <S2SV_EndBug> } if ( lua_pcall ( L , 1 + nargs , 1 , 0 ) ) { const char * err = lua_tostring ( L , - 1 ) ; ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02316 ) ""Error<S2SV_blank>executing<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>%s"" , prov_spec -> name , err ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } if ( ! lua_isnumber ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02317 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s<S2SV_blank>did<S2SV_blank>not<S2SV_blank>return<S2SV_blank>integer"" , prov_spec -> name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } result = lua_tointeger ( L , - 1 ) ; ap_lua_release_state ( L , spec , r ) ; switch ( result ) { case AUTHZ_DENIED : case AUTHZ_GRANTED : case AUTHZ_NEUTRAL : case AUTHZ_GENERAL_ERROR : case AUTHZ_DENIED_NO_USER : return result ; default : ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02318 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>invalid<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d"" , prov_spec -> name , result ) ; } return AUTHZ_GENERAL_ERROR ; }
","<S2SV_ModStart> ) ; const lua_authz_provider_func * prov_func = parsed_require_line ; const <S2SV_ModStart> * prov_spec = prov_func -> spec <S2SV_ModEnd> ; int result <S2SV_ModStart> ; if ( prov_func <S2SV_ModEnd> -> args ) <S2SV_ModStart> ( L , prov_func <S2SV_ModEnd> -> args -> <S2SV_ModStart> ; i < prov_func <S2SV_ModEnd> -> args -> <S2SV_ModStart> = APR_ARRAY_IDX ( prov_func <S2SV_ModEnd> -> args , <S2SV_ModStart> } nargs = prov_func <S2SV_ModEnd> -> args ->
",apache@httpd/3f1693d558d0758f829c8b53993f1749ddf6ffcb,CVE-2014-8109,https://github.com/apache/httpd/commit/3f1693d558d0758f829c8b53993f1749ddf6ffcb,2014-12-29T23:59Z,293,<S2SV_ModStart> arg ) ; if ( l == NULL ) { <S2SV_ModStart> return APLOG_ERROR ; },0
761,CWE-119,"CWE-119 static Image * ReadDPXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char magick [ 4 ] , value [ MaxTextExtent ] ; DPXInfo dpx ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t extent , samples_per_pixel ; ssize_t count , n , row , y ; unsigned char component_type ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( magick , ""SDPX"" , 4 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""XPDS"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> endian = LSBEndian ; if ( LocaleNCompare ( magick , ""SDPX"" , 4 ) == 0 ) image -> endian = MSBEndian ; ( void ) ResetMagickMemory ( & dpx , 0 , sizeof ( dpx ) ) ; dpx . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . file . version ) , ( unsigned char * ) dpx . file . version ) ; ( void ) FormatImageProperty ( image , ""dpx:file.version"" , ""%.8s"" , dpx . file . version ) ; dpx . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; dpx . file . ditto_key = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . file . ditto_key != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:file.ditto.key"" , ""%u"" , dpx . file . ditto_key ) ; dpx . file . generic_size = ReadBlobLong ( image ) ; offset += 4 ; dpx . file . industry_size = ReadBlobLong ( image ) ; offset += 4 ; dpx . file . user_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . file . filename ) , ( unsigned char * ) dpx . file . filename ) ; ( void ) FormatImageProperty ( image , ""dpx:file.filename"" , ""%.100s"" , dpx . file . filename ) ; ( void ) FormatImageProperty ( image , ""document"" , ""%.100s"" , dpx . file . filename ) ; offset += ReadBlob ( image , sizeof ( dpx . file . timestamp ) , ( unsigned char * ) dpx . file . timestamp ) ; if ( * dpx . file . timestamp != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:file.timestamp"" , ""%.24s"" , dpx . file . timestamp ) ; offset += ReadBlob ( image , sizeof ( dpx . file . creator ) , ( unsigned char * ) dpx . file . creator ) ; if ( * dpx . file . creator == '\\0' ) { ( void ) FormatImageProperty ( image , ""dpx:file.creator"" , ""%.100s"" , GetMagickVersion ( ( size_t * ) NULL ) ) ; ( void ) FormatImageProperty ( image , ""software"" , ""%.100s"" , GetMagickVersion ( ( size_t * ) NULL ) ) ; } else { ( void ) FormatImageProperty ( image , ""dpx:file.creator"" , ""%.100s"" , dpx . file . creator ) ; ( void ) FormatImageProperty ( image , ""software"" , ""%.100s"" , dpx . file . creator ) ; } offset += ReadBlob ( image , sizeof ( dpx . file . project ) , ( unsigned char * ) dpx . file . project ) ; if ( * dpx . file . project != '\\0' ) { ( void ) FormatImageProperty ( image , ""dpx:file.project"" , ""%.200s"" , dpx . file . project ) ; ( void ) FormatImageProperty ( image , ""comment"" , ""%.100s"" , dpx . file . project ) ; } offset += ReadBlob ( image , sizeof ( dpx . file . copyright ) , ( unsigned char * ) dpx . file . copyright ) ; if ( * dpx . file . copyright != '\\0' ) { ( void ) FormatImageProperty ( image , ""dpx:file.copyright"" , ""%.200s"" , dpx . file . copyright ) ; ( void ) FormatImageProperty ( image , ""copyright"" , ""%.100s"" , dpx . file . copyright ) ; } dpx . file . encrypt_key = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . file . encrypt_key != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:file.encrypt_key"" , ""%u"" , dpx . file . encrypt_key ) ; offset += ReadBlob ( image , sizeof ( dpx . file . reserve ) , ( unsigned char * ) dpx . file . reserve ) ; dpx . image . orientation = ReadBlobShort ( image ) ; if ( dpx . image . orientation > 7 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset += 2 ; if ( dpx . image . orientation != ( unsigned short ) ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , dpx . image . orientation ) ; switch ( dpx . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } dpx . image . number_elements = ReadBlobShort ( image ) ; if ( dpx . image . number_elements > MaxNumberImageElements ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset += 2 ; dpx . image . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; image -> columns = dpx . image . pixels_per_line ; dpx . image . lines_per_element = ReadBlobLong ( image ) ; offset += 4 ; image -> rows = dpx . image . lines_per_element ; for ( i = 0 ; i < 8 ; i ++ ) { char property [ MaxTextExtent ] ; dpx . image . image_element [ i ] . data_sign = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . low_data = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . low_quantity = ReadBlobFloat ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . high_data = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . high_quantity = ReadBlobFloat ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . descriptor = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; dpx . image . image_element [ i ] . transfer_characteristic = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) FormatLocaleString ( property , MaxTextExtent , ""dpx:image.element[%lu].transfer-characteristic"" , ( long ) i ) ; ( void ) FormatImageProperty ( image , property , ""%s"" , GetImageTransferCharacteristic ( ( DPXTransferCharacteristic ) dpx . image . image_element [ i ] . transfer_characteristic ) ) ; offset ++ ; dpx . image . image_element [ i ] . colorimetric = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; dpx . image . image_element [ i ] . bit_size = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; dpx . image . image_element [ i ] . packing = ReadBlobShort ( image ) ; offset += 2 ; dpx . image . image_element [ i ] . encoding = ReadBlobShort ( image ) ; offset += 2 ; dpx . image . image_element [ i ] . data_offset = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . end_of_line_padding = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . end_of_image_padding = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . image . image_element [ i ] . description ) , ( unsigned char * ) dpx . image . image_element [ i ] . description ) ; } ( void ) SetImageColorspace ( image , RGBColorspace ) ; offset += ReadBlob ( image , sizeof ( dpx . image . reserve ) , ( unsigned char * ) dpx . image . reserve ) ; if ( dpx . file . image_offset >= 1664U ) { dpx . orientation . x_offset = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . x_offset != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.x_offset"" , ""%u"" , dpx . orientation . x_offset ) ; dpx . orientation . y_offset = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . y_offset != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.y_offset"" , ""%u"" , dpx . orientation . y_offset ) ; dpx . orientation . x_center = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . orientation . x_center ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:orientation.x_center"" , ""%g"" , dpx . orientation . x_center ) ; dpx . orientation . y_center = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . orientation . y_center ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:orientation.y_center"" , ""%g"" , dpx . orientation . y_center ) ; dpx . orientation . x_size = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . x_size != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.x_size"" , ""%u"" , dpx . orientation . x_size ) ; dpx . orientation . y_size = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . y_size != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.y_size"" , ""%u"" , dpx . orientation . y_size ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . filename ) , ( unsigned char * ) dpx . orientation . filename ) ; if ( * dpx . orientation . filename != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.filename"" , ""%.100s"" , dpx . orientation . filename ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . timestamp ) , ( unsigned char * ) dpx . orientation . timestamp ) ; if ( * dpx . orientation . timestamp != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.timestamp"" , ""%.24s"" , dpx . orientation . timestamp ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . device ) , ( unsigned char * ) dpx . orientation . device ) ; if ( * dpx . orientation . device != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.device"" , ""%.32s"" , dpx . orientation . device ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . serial ) , ( unsigned char * ) dpx . orientation . serial ) ; if ( * dpx . orientation . serial != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.serial"" , ""%.32s"" , dpx . orientation . serial ) ; for ( i = 0 ; i < 4 ; i ++ ) { dpx . orientation . border [ i ] = ReadBlobShort ( image ) ; offset += 2 ; } if ( ( dpx . orientation . border [ 0 ] != ( unsigned short ) ( ~ 0 ) ) && ( dpx . orientation . border [ 1 ] != ( unsigned short ) ( ~ 0 ) ) ) ( void ) FormatImageProperty ( image , ""dpx:orientation.border"" , ""%dx%d%+d%+d"" , dpx . orientation . border [ 0 ] , dpx . orientation . border [ 1 ] , dpx . orientation . border [ 2 ] , dpx . orientation . border [ 3 ] ) ; for ( i = 0 ; i < 2 ; i ++ ) { dpx . orientation . aspect_ratio [ i ] = ReadBlobLong ( image ) ; offset += 4 ; } if ( ( dpx . orientation . aspect_ratio [ 0 ] != ~ 0U ) && ( dpx . orientation . aspect_ratio [ 1 ] != ~ 0U ) ) ( void ) FormatImageProperty ( image , ""dpx:orientation.aspect_ratio"" , ""%ux%u"" , dpx . orientation . aspect_ratio [ 0 ] , dpx . orientation . aspect_ratio [ 1 ] ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . reserve ) , ( unsigned char * ) dpx . orientation . reserve ) ; } if ( dpx . file . image_offset >= 1920U ) { offset += ReadBlob ( image , sizeof ( dpx . film . id ) , ( unsigned char * ) dpx . film . id ) ; if ( * dpx . film . id != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%.2s"" , dpx . film . id ) ; offset += ReadBlob ( image , sizeof ( dpx . film . type ) , ( unsigned char * ) dpx . film . type ) ; if ( * dpx . film . type != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%.2s"" , dpx . film . type ) ; offset += ReadBlob ( image , sizeof ( dpx . film . offset ) , ( unsigned char * ) dpx . film . offset ) ; if ( * dpx . film . offset != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%.2s"" , dpx . film . offset ) ; offset += ReadBlob ( image , sizeof ( dpx . film . prefix ) , ( unsigned char * ) dpx . film . prefix ) ; if ( * dpx . film . prefix != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.6s"" , dpx . film . prefix ) ; offset += ReadBlob ( image , sizeof ( dpx . film . count ) , ( unsigned char * ) dpx . film . count ) ; if ( * dpx . film . count != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.count"" , ""%.4s"" , dpx . film . count ) ; offset += ReadBlob ( image , sizeof ( dpx . film . format ) , ( unsigned char * ) dpx . film . format ) ; if ( * dpx . film . format != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.format"" , ""%.4s"" , dpx . film . format ) ; dpx . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . film . frame_position != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%u"" , dpx . film . frame_position ) ; dpx . film . sequence_extent = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . film . sequence_extent != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:film.sequence_extent"" , ""%u"" , dpx . film . sequence_extent ) ; dpx . film . held_count = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . film . held_count != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:film.held_count"" , ""%u"" , dpx . film . held_count ) ; dpx . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , dpx . film . frame_rate ) ; dpx . film . shutter_angle = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . film . shutter_angle ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.shutter_angle"" , ""%g"" , dpx . film . shutter_angle ) ; offset += ReadBlob ( image , sizeof ( dpx . film . frame_id ) , ( unsigned char * ) dpx . film . frame_id ) ; if ( * dpx . film . frame_id != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_id"" , ""%.32s"" , dpx . film . frame_id ) ; offset += ReadBlob ( image , sizeof ( dpx . film . slate ) , ( unsigned char * ) dpx . film . slate ) ; if ( * dpx . film . slate != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.slate"" , ""%.100s"" , dpx . film . slate ) ; offset += ReadBlob ( image , sizeof ( dpx . film . reserve ) , ( unsigned char * ) dpx . film . reserve ) ; } if ( dpx . file . image_offset >= 2048U ) { dpx . television . time_code = ( unsigned int ) ReadBlobLong ( image ) ; offset += 4 ; TimeCodeToString ( dpx . television . time_code , value ) ; ( void ) SetImageProperty ( image , ""dpx:television.time.code"" , value ) ; dpx . television . user_bits = ( unsigned int ) ReadBlobLong ( image ) ; offset += 4 ; TimeCodeToString ( dpx . television . user_bits , value ) ; ( void ) SetImageProperty ( image , ""dpx:television.user.bits"" , value ) ; dpx . television . interlace = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . interlace != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.interlace"" , ""%.20g"" , ( double ) dpx . television . interlace ) ; dpx . television . field_number = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . field_number != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.field_number"" , ""%.20g"" , ( double ) dpx . television . field_number ) ; dpx . television . video_signal = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . video_signal != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.video_signal"" , ""%.20g"" , ( double ) dpx . television . video_signal ) ; dpx . television . padding = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . padding != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.padding"" , ""%d"" , dpx . television . padding ) ; dpx . television . horizontal_sample_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . horizontal_sample_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.horizontal_sample_rate"" , ""%g"" , dpx . television . horizontal_sample_rate ) ; dpx . television . vertical_sample_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . vertical_sample_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.vertical_sample_rate"" , ""%g"" , dpx . television . vertical_sample_rate ) ; dpx . television . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.frame_rate"" , ""%g"" , dpx . television . frame_rate ) ; dpx . television . time_offset = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . time_offset ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.time_offset"" , ""%g"" , dpx . television . time_offset ) ; dpx . television . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . gamma ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.gamma"" , ""%g"" , dpx . television . gamma ) ; dpx . television . black_level = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . black_level ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.black_level"" , ""%g"" , dpx . television . black_level ) ; dpx . television . black_gain = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . black_gain ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.black_gain"" , ""%g"" , dpx . television . black_gain ) ; dpx . television . break_point = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . break_point ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.break_point"" , ""%g"" , dpx . television . break_point ) ; dpx . television . white_level = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . white_level ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.white_level"" , ""%g"" , dpx . television . white_level ) ; dpx . television . integration_times = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . integration_times ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.integration_times"" , ""%g"" , dpx . television . integration_times ) ; offset += ReadBlob ( image , sizeof ( dpx . television . reserve ) , ( unsigned char * ) dpx . television . reserve ) ; } if ( dpx . file . image_offset > 2080U ) { offset += ReadBlob ( image , sizeof ( dpx . user . id ) , ( unsigned char * ) dpx . user . id ) ; if ( * dpx . user . id != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:user.id"" , ""%.32s"" , dpx . user . id ) ; if ( ( dpx . file . user_size != ~ 0U ) && ( ( size_t ) dpx . file . user_size > sizeof ( dpx . user . id ) ) ) { StringInfo * profile ; profile = BlobToStringInfo ( ( const void * ) NULL , dpx . file . user_size - sizeof ( dpx . user . id ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user-data"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } } for ( ; offset < ( MagickOffsetType ) dpx . file . image_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; <S2SV_StartBug> return ( GetFirstImageInList ( image ) ) ; <S2SV_EndBug> } for ( n = 0 ; n < ( ssize_t ) dpx . image . number_elements ; n ++ ) { if ( ( dpx . image . image_element [ n ] . data_offset != ~ 0U ) && ( dpx . image . image_element [ n ] . data_offset != 0U ) ) { MagickOffsetType data_offset ; data_offset = ( MagickOffsetType ) dpx . image . image_element [ n ] . data_offset ; if ( data_offset < offset ) offset = SeekBlob ( image , data_offset , SEEK_SET ) ; else for ( ; offset < data_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; if ( offset != data_offset ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } SetPrimaryChromaticity ( ( DPXColorimetric ) dpx . image . image_element [ n ] . colorimetric , & image -> chromaticity ) ; image -> depth = dpx . image . image_element [ n ] . bit_size ; samples_per_pixel = 1 ; quantum_type = GrayQuantum ; component_type = dpx . image . image_element [ n ] . descriptor ; switch ( component_type ) { case CbYCrY422ComponentType : { samples_per_pixel = 2 ; quantum_type = CbYCrYQuantum ; break ; } case CbYACrYA4224ComponentType : case CbYCr444ComponentType : { samples_per_pixel = 3 ; quantum_type = CbYCrQuantum ; break ; } case RGBComponentType : { samples_per_pixel = 3 ; quantum_type = RGBQuantum ; break ; } case ABGRComponentType : case RGBAComponentType : { image -> matte = MagickTrue ; samples_per_pixel = 4 ; quantum_type = RGBAQuantum ; break ; } default : break ; } switch ( component_type ) { case CbYCrY422ComponentType : case CbYACrYA4224ComponentType : case CbYCr444ComponentType : { ( void ) SetImageColorspace ( image , Rec709YCbCrColorspace ) ; break ; } case LumaComponentType : { ( void ) SetImageColorspace ( image , GRAYColorspace ) ; break ; } default : { ( void ) SetImageColorspace ( image , RGBColorspace ) ; if ( dpx . image . image_element [ n ] . transfer_characteristic == LogarithmicColorimetric ) ( void ) SetImageColorspace ( image , LogColorspace ) ; if ( dpx . image . image_element [ n ] . transfer_characteristic == PrintingDensityColorimetric ) ( void ) SetImageColorspace ( image , LogColorspace ) ; break ; } } extent = GetBytesPerRow ( image -> columns , samples_per_pixel , image -> depth , dpx . image . image_element [ n ] . packing == 0 ? MagickFalse : MagickTrue ) ; status = MagickTrue ; row = 0 ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; SetQuantumQuantum ( quantum_info , 32 ) ; SetQuantumPack ( quantum_info , dpx . image . image_element [ n ] . packing == 0 ? MagickTrue : MagickFalse ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { MagickBooleanType sync ; register PixelPacket * q ; size_t length ; ssize_t count , offset ; unsigned char * pixels ; if ( status == MagickFalse ) continue ; pixels = GetQuantumPixels ( quantum_info ) ; { count = ReadBlob ( image , extent , pixels ) ; if ( ( image -> progress_monitor != ( MagickProgressMonitor ) NULL ) && ( image -> previous == ( Image * ) NULL ) ) { MagickBooleanType proceed ; proceed = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) row , image -> rows ) ; if ( proceed == MagickFalse ) status = MagickFalse ; } offset = row ++ ; } if ( count != ( ssize_t ) extent ) status = MagickFalse ; q = QueueAuthenticPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } length = ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; ( void ) length ; sync = SyncAuthenticPixels ( image , exception ) ; if ( sync == MagickFalse ) status = MagickFalse ; } quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; SetQuantumImageType ( image , quantum_type ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,294,"<S2SV_ModStart> ) ; } status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",0
763,CWE-522,"CWE-522 int credential_from_url_gently ( struct credential * c , const char * url , int quiet ) { const char * at , * colon , * cp , * slash , * host , * proto_end ; credential_clear ( c ) ; proto_end = strstr ( url , ""://"" ) ; <S2SV_StartBug> if ( ! proto_end ) <S2SV_EndBug> return 0 ; cp = proto_end + 3 ; at = strchr ( cp , '@' ) ; colon = strchr ( cp , ':' ) ; slash = strchrnul ( cp , '/' ) ; if ( ! at || slash <= at ) { host = cp ; } else if ( ! colon || at <= colon ) { c -> username = url_decode_mem ( cp , at - cp ) ; host = at + 1 ; } else { c -> username = url_decode_mem ( cp , colon - cp ) ; c -> password = url_decode_mem ( colon + 1 , at - ( colon + 1 ) ) ; host = at + 1 ; } if ( proto_end - url > 0 ) c -> protocol = xmemdupz ( url , proto_end - url ) ; c -> host = url_decode_mem ( host , slash - host ) ; while ( * slash == '/' ) slash ++ ; if ( * slash ) { char * p ; c -> path = url_decode ( slash ) ; p = c -> path + strlen ( c -> path ) - 1 ; while ( p > c -> path && * p == '/' ) * p -- = '\\0' ; } if ( check_url_component ( url , quiet , ""username"" , c -> username ) < 0 || check_url_component ( url , quiet , ""password"" , c -> password ) < 0 || check_url_component ( url , quiet , ""protocol"" , c -> protocol ) < 0 || check_url_component ( url , quiet , ""host"" , c -> host ) < 0 || check_url_component ( url , quiet , ""path"" , c -> path ) < 0 ) return - 1 ; return 0 ; }
","<S2SV_ModStart> ! proto_end ) { if ( ! quiet ) warning ( _ ( ""url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s"" ) , url ) ; return - 1 ; } <S2SV_ModEnd> cp = proto_end
",git@git/c44088ecc4b0722636e0a305f9608d3047197282,CVE-2020-11008,https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282,2020-04-21T19:15Z,295,,0
773,CWE-000,"CWE-000 int fdt_find_regions ( const void * fdt , char * const inc [ ] , int inc_count , char * const exc_prop [ ] , int exc_prop_count , struct fdt_region region [ ] , int max_regions , char * path , int path_len , int add_string_tab ) { int stack [ FDT_MAX_DEPTH ] = { 0 } ; char * end ; int nextoffset = 0 ; uint32_t tag ; int count = 0 ; int start = - 1 ; int depth = - 1 ; int want = 0 ; int base = fdt_off_dt_struct ( fdt ) ; <S2SV_StartBug> end = path ; <S2SV_EndBug> * end = '\\0' ; do { const struct fdt_property * prop ; const char * name ; const char * str ; int include = 0 ; int stop_at = 0 ; int offset ; int len ; offset = nextoffset ; tag = fdt_next_tag ( fdt , offset , & nextoffset ) ; stop_at = nextoffset ; <S2SV_StartBug> switch ( tag ) { <S2SV_EndBug> case FDT_PROP : include = want >= 2 ; stop_at = offset ; prop = fdt_get_property_by_offset ( fdt , offset , NULL ) ; str = fdt_string ( fdt , fdt32_to_cpu ( prop -> nameoff ) ) ; if ( ! str ) return - FDT_ERR_BADSTRUCTURE ; if ( str_in_list ( str , exc_prop , exc_prop_count ) ) include = 0 ; break ; case FDT_NOP : include = want >= 2 ; stop_at = offset ; break ; case FDT_BEGIN_NODE : depth ++ ; if ( depth == FDT_MAX_DEPTH ) return - FDT_ERR_BADSTRUCTURE ; <S2SV_StartBug> name = fdt_get_name ( fdt , offset , & len ) ; <S2SV_EndBug> if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ; if ( end != path + 1 ) * end ++ = '/' ; strcpy ( end , name ) ; end += len ; stack [ depth ] = want ; if ( want == 1 ) stop_at = offset ; if ( str_in_list ( path , inc , inc_count ) ) want = 2 ; else if ( want ) want -- ; else stop_at = offset ; include = want ; break ; case FDT_END_NODE : if ( depth < 0 ) return - FDT_ERR_BADSTRUCTURE ; include = want ; want = stack [ depth -- ] ; while ( end > path && * -- end != '/' ) ; * end = '\\0' ; <S2SV_StartBug> break ; <S2SV_EndBug> case FDT_END : include = 1 ; break ; } if ( include && start == - 1 ) { if ( count && count <= max_regions && offset == region [ count - 1 ] . offset + region [ count - 1 ] . size - base ) start = region [ -- count ] . offset - base ; else start = offset ; } if ( ! include && start != - 1 ) { if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = stop_at - start ; } count ++ ; start = - 1 ; } } while ( tag != FDT_END ) ; if ( nextoffset != fdt_size_dt_struct ( fdt ) ) return - FDT_ERR_BADLAYOUT ; if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = nextoffset - start ; if ( add_string_tab ) region [ count ] . size += fdt_size_dt_strings ( fdt ) ; } count ++ ; return count ; }
","<S2SV_ModStart> fdt ) ; bool expect_end = false ; <S2SV_ModStart> = nextoffset ; if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> & len ) ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> = '\\0' ; if ( depth == - 1 ) expect_end = true ;
",u-boot@u-boot/8a7d4cf9820ea16fabd25a6379351b4dc291204b,CVE-2021-27097,https://github.com/u-boot/u-boot/commit/8a7d4cf9820ea16fabd25a6379351b4dc291204b,2021-02-17T23:15Z,296,<S2SV_ModStart> return - 1 ; if ( len < 0 ) return - 1,0
776,CWE-20,"CWE-20 int serverCron ( struct aeEventLoop * eventLoop , long long id , void * clientData ) { int j , loops = server . cronloops ++ ; REDIS_NOTUSED ( eventLoop ) ; REDIS_NOTUSED ( id ) ; REDIS_NOTUSED ( clientData ) ; server . unixtime = time ( NULL ) ; updateLRUClock ( ) ; if ( server . shutdown_asap ) { if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ; redisLog ( REDIS_WARNING , ""SIGTERM<S2SV_blank>received<S2SV_blank>but<S2SV_blank>errors<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>shut<S2SV_blank>down<S2SV_blank>the<S2SV_blank>server,<S2SV_blank>check<S2SV_blank>the<S2SV_blank>logs<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information"" ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long size , used , vkeys ; size = dictSlots ( server . db [ j ] . dict ) ; used = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( ! ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE , ""DB<S2SV_blank>%d:<S2SV_blank>%lld<S2SV_blank>keys<S2SV_blank>(%lld<S2SV_blank>volatile)<S2SV_blank>in<S2SV_blank>%lld<S2SV_blank>slots<S2SV_blank>HT."" , j , used , vkeys , size ) ; } } if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) { if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ; if ( server . activerehashing ) incrementallyRehash ( ) ; } if ( ! ( loops % 50 ) ) { redisLog ( REDIS_VERBOSE , ""%d<S2SV_blank>clients<S2SV_blank>connected<S2SV_blank>(%d<S2SV_blank>slaves),<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>use"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ; } if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ; if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) { int statloc ; pid_t pid ; if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) != 0 ) { if ( pid == server . bgsavechildpid ) { backgroundSaveDoneHandler ( statloc ) ; } else { backgroundRewriteDoneHandler ( statloc ) ; } updateDictResizePolicy ( ) ; } } else { time_t now = time ( NULL ) ; for ( j = 0 ; j < server . saveparamslen ; j ++ ) { struct saveparam * sp = server . saveparams + j ; if ( server . dirty >= sp -> changes && now - server . lastsave > sp -> seconds ) { redisLog ( REDIS_NOTICE , ""%d<S2SV_blank>changes<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>seconds.<S2SV_blank>Saving..."" , sp -> changes , sp -> seconds ) ; rdbSaveBackground ( server . dbfilename ) ; break ; } } } if ( server . masterhost == NULL ) activeExpireCycle ( ) ; <S2SV_StartBug> if ( vmCanSwapOut ( ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( server . vm_enabled && zmalloc_used_memory ( ) > <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory ) <S2SV_EndBug> { int retval = ( server . vm_max_threads == 0 ) ? vmSwapOneObjectBlocking ( ) : vmSwapOneObjectThreaded ( ) ; if ( retval == REDIS_ERR && ! ( loops % 300 ) && zmalloc_used_memory ( ) > ( server . vm_max_memory + server . vm_max_memory / 10 ) ) { redisLog ( REDIS_WARNING , ""WARNING:<S2SV_blank>vm-max-memory<S2SV_blank>limit<S2SV_blank>exceeded<S2SV_blank>by<S2SV_blank>more<S2SV_blank>than<S2SV_blank>10%%<S2SV_blank>but<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>swap<S2SV_blank>more<S2SV_blank>objects<S2SV_blank>out!"" ) ; } if ( retval == REDIS_ERR || server . vm_max_threads > 0 ) break ; } } if ( ! ( loops % 10 ) ) replicationCron ( ) ; return 100 ; }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> while ( server <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && zmalloc_used_memory ( <S2SV_ModStart> > server . cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> } if (
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,297,<S2SV_ModStart> ( server. ds_enabled <S2SV_ModEnd> ) ) {,0
779,CWE-835,"CWE-835 static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( ""GsmXSMPClient:<S2SV_blank>Setting<S2SV_blank>up<S2SV_blank>new<S2SV_blank>connection"" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; <S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( ""GsmXSMPClient:<S2SV_blank>New<S2SV_blank>client<S2SV_blank>\'%s\'"" , client -> priv -> description ) ; }
","<S2SV_ModStart> channel ) ; <S2SV_ModEnd> set_description ( client
",GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z,298,,0
780,CWE-200,"CWE-200 long vorbis_book_decodev_add ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] += v [ j ] ; } } return 0 ; }
","<S2SV_ModStart> book -> dim && i < n
",external@tremolo/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,CVE-2017-0814,https://android.googlesource.com/platform/external/tremolo/+/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,2017-10-04T01:29Z,299,,0
781,CWE-20,"CWE-20 void BezierCircle ( double r , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - r , - r , r * BzK , - r * BzK , r , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , r * BzK , r , r , r * BzK , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , r , - r * BzK , r * BzK , - r , - r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - r * BzK , - r , - r , - r * BzK , - r , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,300,<S2SV_ModStart> y3 ) { sendClean ( outputbuffer ) ;,0
785,CWE-119,"CWE-119 void vp9_setup_scale_factors_for_frame ( struct scale_factors * sf , int other_w , int other_h , int this_w , int this_h ) { <S2SV_StartBug> if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) { <S2SV_EndBug> sf -> x_scale_fp = REF_INVALID_SCALE ; sf -> y_scale_fp = REF_INVALID_SCALE ; return ; } sf -> x_scale_fp = get_fixed_point_scale_factor ( other_w , this_w ) ; sf -> y_scale_fp = get_fixed_point_scale_factor ( other_h , this_h ) ; sf -> x_step_q4 = scaled_x ( 16 , sf ) ; sf -> y_step_q4 = scaled_y ( 16 , sf ) ; if ( vp9_is_scaled ( sf ) ) { sf -> scale_value_x = scaled_x ; sf -> scale_value_y = scaled_y ; } else { sf -> scale_value_x = unscaled_value ; sf -> scale_value_y = unscaled_value ; } if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; } else { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_vert ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; } else { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8 ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ; } } sf -> predict [ 1 ] [ 1 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ; }
","<S2SV_ModStart> this_h ) { # endif <S2SV_ModStart> if ( ! valid_ref_frame_size <S2SV_ModEnd> ( other_w , <S2SV_ModStart> 0 ] = vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> ; } else <S2SV_ModStart> 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> ; } } <S2SV_ModStart> 0 ] = vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> ; } else <S2SV_ModStart> 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,301,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
787,CWE-399,"CWE-399 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,302,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",1
790,CWE-552,"CWE-552 static ssize_t _hostsock_recv ( oe_fd_t * sock_ , void * buf , size_t count , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( buf ) { if ( oe_memset_s ( buf , count , 0 , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( oe_syscall_recv_ocall ( & ret , sock -> host_fd , buf , count , flags ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,303,<S2SV_ModStart> (! buf || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;,0
791,CWE-416,"CWE-416 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,304,<S2SV_ModStart> ; opt = rcu_dereference ( <S2SV_ModStart> ( sk ),0
793,CWE-416,"CWE-416 static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen , unsigned int flags ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; int len ; int val ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; switch ( optname ) { case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; val = sk -> sk_family ; break ; case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ; if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ; if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ; lock_sock ( sk ) ; err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IPV6_2292PKTOPTIONS : { struct msghdr msg ; struct sk_buff * skb ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = flags ; lock_sock ( sk ) ; skb = np -> pktoptions ; if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ; release_sock ( sk ) ; if ( ! skb ) { if ( np -> rxopt . bits . rxinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxhlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxtclass ) { int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ; put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ; } if ( np -> rxopt . bits . rxoinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxohlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxflow ) { __be32 flowinfo = np -> rcv_flowinfo ; put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ; } } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IPV6_MTU : { struct dst_entry * dst ; val = 0 ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! val ) return - ENOTCONN ; break ; } case IPV6_V6ONLY : val = sk -> sk_ipv6only ; break ; case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ; break ; case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ; break ; case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ; break ; case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ; break ; case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ; break ; case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> optname , optval , len ) ; release_sock ( sk ) ; if ( len < 0 ) return len ; return put_user ( len , optlen ) ; } case IPV6_RECVHOPOPTS : val = np -> rxopt . bits . hopopts ; break ; case IPV6_2292HOPOPTS : val = np -> rxopt . bits . ohopopts ; break ; case IPV6_RECVDSTOPTS : val = np -> rxopt . bits . dstopts ; break ; case IPV6_2292DSTOPTS : val = np -> rxopt . bits . odstopts ; break ; case IPV6_TCLASS : val = np -> tclass ; break ; case IPV6_RECVTCLASS : val = np -> rxopt . bits . rxtclass ; break ; case IPV6_FLOWINFO : val = np -> rxopt . bits . rxflow ; break ; case IPV6_RECVPATHMTU : val = np -> rxopt . bits . rxpmtu ; break ; case IPV6_PATHMTU : { struct dst_entry * dst ; struct ip6_mtuinfo mtuinfo ; if ( len < sizeof ( mtuinfo ) ) return - EINVAL ; len = sizeof ( mtuinfo ) ; memset ( & mtuinfo , 0 , sizeof ( mtuinfo ) ) ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) mtuinfo . ip6m_mtu = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! mtuinfo . ip6m_mtu ) return - ENOTCONN ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & mtuinfo , len ) ) return - EFAULT ; return 0 ; } case IPV6_TRANSPARENT : val = inet_sk ( sk ) -> transparent ; break ; case IPV6_RECVORIGDSTADDR : val = np -> rxopt . bits . rxorigdstaddr ; break ; case IPV6_UNICAST_HOPS : case IPV6_MULTICAST_HOPS : { struct dst_entry * dst ; if ( optname == IPV6_UNICAST_HOPS ) val = np -> hop_limit ; else val = np -> mcast_hops ; if ( val < 0 ) { rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = ip6_dst_hoplimit ( dst ) ; rcu_read_unlock ( ) ; } if ( val < 0 ) val = sock_net ( sk ) -> ipv6 . devconf_all -> hop_limit ; break ; } case IPV6_MULTICAST_LOOP : val = np -> mc_loop ; break ; case IPV6_MULTICAST_IF : val = np -> mcast_oif ; break ; case IPV6_UNICAST_IF : val = ( __force int ) htonl ( ( __u32 ) np -> ucast_oif ) ; break ; case IPV6_MTU_DISCOVER : val = np -> pmtudisc ; break ; case IPV6_RECVERR : val = np -> recverr ; break ; case IPV6_FLOWINFO_SEND : val = np -> sndflow ; break ; case IPV6_FLOWLABEL_MGR : { struct in6_flowlabel_req freq ; int flags ; if ( len < sizeof ( freq ) ) return - EINVAL ; if ( copy_from_user ( & freq , optval , sizeof ( freq ) ) ) return - EFAULT ; if ( freq . flr_action != IPV6_FL_A_GET ) return - EINVAL ; len = sizeof ( freq ) ; flags = freq . flr_flags ; memset ( & freq , 0 , sizeof ( freq ) ) ; val = ipv6_flowlabel_opt_get ( sk , & freq , flags ) ; if ( val < 0 ) return val ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & freq , len ) ) return - EFAULT ; return 0 ; } case IPV6_ADDR_PREFERENCES : val = 0 ; if ( np -> srcprefs & IPV6_PREFER_SRC_TMP ) val |= IPV6_PREFER_SRC_TMP ; else if ( np -> srcprefs & IPV6_PREFER_SRC_PUBLIC ) val |= IPV6_PREFER_SRC_PUBLIC ; else { val |= IPV6_PREFER_SRC_PUBTMP_DEFAULT ; } if ( np -> srcprefs & IPV6_PREFER_SRC_COA ) val |= IPV6_PREFER_SRC_COA ; else val |= IPV6_PREFER_SRC_HOME ; break ; case IPV6_MINHOPCOUNT : val = np -> min_hopcount ; break ; case IPV6_DONTFRAG : val = np -> dontfrag ; break ; case IPV6_AUTOFLOWLABEL : val = np -> autoflowlabel ; break ; default : return - ENOPROTOOPT ; } len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; <S2SV_ModStart> sk ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,305,<S2SV_ModStart> ; if ( opt <S2SV_ModEnd> opt. opt,0
794,CWE-119,"CWE-119 static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ; <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> sctp_v6_protosw_exit ( ) ; <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }
","<S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops <S2SV_ModEnd> ) ; sctp_v6_protosw_exit <S2SV_ModStart> ; sctp_v4_protosw_exit ( ) ; unregister_pernet_subsys ( & sctp_defaults_ops
",torvalds@linux/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,CVE-2015-5283,https://github.com/torvalds/linux/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,2015-10-19T10:59Z,306,<S2SV_ModStart> ; sctp_sock <S2SV_ModEnd> ( ),0
798,CWE-119,"CWE-119 <S2SV_StartBug> static void show_psnr ( struct stream_state * stream ) { <S2SV_EndBug> int i ; double ovpsnr ; if ( ! stream -> psnr_count ) return ; fprintf ( stderr , ""Stream<S2SV_blank>%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)"" , stream -> index ) ; <S2SV_StartBug> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , <S2SV_EndBug> ( double ) stream -> psnr_sse_total ) ; fprintf ( stderr , ""<S2SV_blank>%.3f"" , ovpsnr ) ; for ( i = 0 ; i < 4 ; i ++ ) { fprintf ( stderr , ""<S2SV_blank>%.3f"" , stream -> psnr_totals [ i ] / stream -> psnr_count ) ; } fprintf ( stderr , ""\\n"" ) ; }
","<S2SV_ModStart> stream_state * stream , double peak <S2SV_ModStart> -> psnr_samples_total , peak <S2SV_ModEnd> , ( double
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,307,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
800,CWE-362,"CWE-362 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }
","<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (
",torvalds@linux/b90cd6f2b905905fb42671009dc0e27c310a16ae,CVE-2018-20836,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,2019-05-07T14:29Z,308,<S2SV_ModStart> task ) { <S2SV_ModEnd> timer_timer ( &,0
801,CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,309,"<S2SV_ModStart> ; if ( safe_name <S2SV_ModEnd> ( dst_name,",0
804,CWE-20,"CWE-20 error_t ksz8851Init ( NetInterface * interface ) { Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; TRACE_INFO ( ""Initializing<S2SV_blank>KSZ8851<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; # if ( KSZ8851_SPI_SUPPORT == ENABLED ) interface -> spiDriver -> init ( ) ; # endif interface -> extIntDriver -> init ( ) ; <S2SV_StartBug> TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1ILR ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1IHR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID ) <S2SV_EndBug> { return ERROR_WRONG_IDENTIFIER ; } ksz8851DumpReg ( interface ) ; context -> frameId = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> txBuffer == NULL || context -> rxBuffer == NULL ) { memPoolFree ( context -> txBuffer ) ; memPoolFree ( context -> rxBuffer ) ; return ERROR_OUT_OF_MEMORY ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ; <S2SV_EndBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXFDPR , TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXPAFMA | RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXME | RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR2 , RXCR2_SRDBL2 | RXCR2_IUFFP | RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXQCR , RXQCR_RXFCTE | RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFCTR , 1 ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS | <S2SV_EndBug> ISR_RXIS | ISR_RXOIS | ISR_TXPSIS | ISR_RXPSIS | ISR_TXSAIS | ISR_RXWFDIS | ISR_RXMPDIS | ISR_LDIS | ISR_EDIS | ISR_SPIBEIS ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ; <S2SV_EndBug> osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_CIDER <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1ILR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1IHR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , KSZ8851_MARH <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARM <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARL <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> ) ; osSetEvent
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,310,"<S2SV_ModStart> ( interface, KSZ8851_MAHTR <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface -> <S2SV_ModStart> ( interface, KSZ8851_MAHTR1 <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface, KSZ8851_MAHTR1 <S2SV_ModEnd> ) ; }",0
809,CWE-119,"CWE-119 void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { const MACROBLOCKD * const xd = & x -> e_mbd ; struct encode_b_args arg = { x , NULL , & xd -> mi [ 0 ] -> mbmi . skip } ; <S2SV_StartBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , <S2SV_EndBug> & arg ) ; }
","<S2SV_ModStart> , plane , vp9_encode_block_intra <S2SV_ModEnd> , & arg
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,311,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
811,CWE-190,"CWE-190 int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len ) { unsigned char * op ; const unsigned char * ip ; size_t t , next ; size_t state = 0 ; const unsigned char * m_pos ; const unsigned char * const ip_end = in + in_len ; unsigned char * const op_end = out + * out_len ; op = out ; ip = in ; if ( unlikely ( in_len < 3 ) ) goto input_overrun ; if ( * ip > 17 ) { t = * ip ++ - 17 ; if ( t < 4 ) { next = t ; goto match_next ; } goto copy_literal_run ; } for ( ; ; ) { t = * ip ++ ; if ( t < 16 ) { if ( likely ( state == 0 ) ) { if ( unlikely ( t == 0 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 15 + * ip ++ ; } t += 3 ; copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> const unsigned char * ie = ip + t ; unsigned char * oe = op + t ; do { COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; } while ( ip < ie ) ; ip = ie ; op = oe ; } else # endif { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> do { * op ++ = * ip ++ ; } while ( -- t > 0 ) ; } state = 4 ; continue ; } else if ( state != 4 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; TEST_LB ( m_pos ) ; <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; goto match_next ; } else { next = t & 3 ; m_pos = op - ( 1 + M2_MAX_OFFSET ) ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; t = 3 ; } } else if ( t >= 64 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= ( t >> 2 ) & 7 ; m_pos -= * ip ++ << 3 ; t = ( t >> 5 ) - 1 + ( 3 - 1 ) ; } else if ( t >= 32 ) { t = ( t & 31 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 31 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } m_pos = op - 1 ; next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; } else { m_pos = op ; m_pos -= ( t & 8 ) << 11 ; t = ( t & 7 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 7 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; if ( m_pos == op ) goto eof_found ; m_pos -= 0x4000 ; } TEST_LB ( m_pos ) ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( op - m_pos >= 8 ) { unsigned char * oe = op + t ; <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> do { COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; } while ( op < oe ) ; op = oe ; <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> state = next ; COPY4 ( op , ip ) ; op += next ; ip += next ; continue ; } } else { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } } else # endif { unsigned char * oe = op + t ; <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; m_pos += 2 ; do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } match_next : state = next ; t = next ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> COPY4 ( op , ip ) ; op += t ; ip += t ; } else # endif { <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> while ( t > 0 ) { * op ++ = * ip ++ ; t -- ; } } } eof_found : * out_len = op - out ; return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; input_overrun : * out_len = op - out ; return LZO_E_INPUT_OVERRUN ; output_overrun : * out_len = op - out ; return LZO_E_OUTPUT_OVERRUN ; lookbehind_overrun : * out_len = op - out ; return LZO_E_LOOKBEHIND_OVERRUN ; }
","<S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> HAVE_IP ( t , <S2SV_ModEnd> 15 ) && <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> HAVE_OP ( 4 , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( t , 0
",torvalds@linux/206a81c18401c0cde6e579164f752c4b147324ce,CVE-2014-4608,https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce,2014-07-03T04:22Z,312,"<S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP ( 0 <S2SV_ModStart> NEED_IP ( 1, 0 <S2SV_ModStart> NEED_IP",0
812,CWE-000,"CWE-000 int fit_image_load ( bootm_headers_t * images , ulong addr , const char * * fit_unamep , const char * * fit_uname_configp , int arch , int image_type , int bootstage_id , enum fit_load_op load_op , ulong * datap , ulong * lenp ) { int cfg_noffset , noffset ; const char * fit_uname ; const char * fit_uname_config ; const char * fit_base_uname_config ; const void * fit ; void * buf ; void * loadbuf ; size_t size ; int type_ok , os_ok ; ulong load , load_end , data , len ; uint8_t os , comp ; # ifndef USE_HOSTCC uint8_t os_arch ; # endif const char * prop_name ; int ret ; fit = map_sysmem ( addr , 0 ) ; fit_uname = fit_unamep ? * fit_unamep : NULL ; fit_uname_config = fit_uname_configp ? * fit_uname_configp : NULL ; fit_base_uname_config = NULL ; prop_name = fit_get_image_type_property ( image_type ) ; printf ( ""##<S2SV_blank>Loading<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>FIT<S2SV_blank>Image<S2SV_blank>at<S2SV_blank>%08lx<S2SV_blank>...\\n"" , prop_name , addr ) ; bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ; <S2SV_StartBug> if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!\\n"" , prop_name ) ; <S2SV_EndBug> bootstage_error ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ; <S2SV_StartBug> return - ENOEXEC ; <S2SV_EndBug> } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_FORMAT_OK ) ; if ( fit_uname ) { bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_UNIT_NAME ) ; noffset = fit_image_get_node ( fit , fit_uname ) ; } else { bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME ) ; if ( IMAGE_ENABLE_BEST_MATCH && ! fit_uname_config ) { cfg_noffset = fit_conf_find_compat ( fit , gd_fdt_blob ( ) ) ; } else { cfg_noffset = fit_conf_get_node ( fit , fit_uname_config ) ; } if ( cfg_noffset < 0 ) { puts ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>configuration<S2SV_blank>node\\n"" ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME ) ; return - ENOENT ; } fit_base_uname_config = fdt_get_name ( fit , cfg_noffset , NULL ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Using<S2SV_blank>\'%s\'<S2SV_blank>configuration\\n"" , fit_base_uname_config ) ; if ( image_type == IH_TYPE_KERNEL ) images -> fit_uname_cfg = fit_base_uname_config ; if ( FIT_IMAGE_ENABLE_VERIFY && images -> verify ) { puts ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Verifying<S2SV_blank>Hash<S2SV_blank>Integrity<S2SV_blank>...<S2SV_blank>"" ) ; if ( fit_config_verify ( fit , cfg_noffset ) ) { puts ( ""Bad<S2SV_blank>Data<S2SV_blank>Hash\\n"" ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_HASH ) ; return - EACCES ; } puts ( ""OK\\n"" ) ; } bootstage_mark ( BOOTSTAGE_ID_FIT_CONFIG ) ; noffset = fit_conf_get_prop_node ( fit , cfg_noffset , prop_name ) ; fit_uname = fit_get_name ( fit , noffset , NULL ) ; } if ( noffset < 0 ) { printf ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>subimage<S2SV_blank>node<S2SV_blank>type<S2SV_blank>\'%s\'\\n"" , prop_name ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_SUBNODE ) ; return - ENOENT ; } printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Trying<S2SV_blank>\'%s\'<S2SV_blank>%s<S2SV_blank>subimage\\n"" , fit_uname , prop_name ) ; ret = fit_image_select ( fit , noffset , images -> verify ) ; if ( ret ) { bootstage_error ( bootstage_id + BOOTSTAGE_SUB_HASH ) ; return ret ; } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH ) ; if ( ! host_build ( ) && IS_ENABLED ( CONFIG_SANDBOX ) ) { if ( ! fit_image_check_target_arch ( fit , noffset ) ) { puts ( ""Unsupported<S2SV_blank>Architecture\\n"" ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH ) ; return - ENOEXEC ; } } # ifndef USE_HOSTCC fit_image_get_arch ( fit , noffset , & os_arch ) ; images -> os . arch = os_arch ; # endif bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_CHECK_ALL ) ; type_ok = fit_image_check_type ( fit , noffset , image_type ) || fit_image_check_type ( fit , noffset , IH_TYPE_FIRMWARE ) || ( image_type == IH_TYPE_KERNEL && fit_image_check_type ( fit , noffset , IH_TYPE_KERNEL_NOLOAD ) ) ; os_ok = image_type == IH_TYPE_FLATDT || image_type == IH_TYPE_FPGA || fit_image_check_os ( fit , noffset , IH_OS_LINUX ) || fit_image_check_os ( fit , noffset , IH_OS_U_BOOT ) || fit_image_check_os ( fit , noffset , IH_OS_OPENRTOS ) || fit_image_check_os ( fit , noffset , IH_OS_EFI ) || fit_image_check_os ( fit , noffset , IH_OS_VXWORKS ) ; if ( ( ! type_ok || ! os_ok ) && image_type != IH_TYPE_LOADABLE ) { fit_image_get_os ( fit , noffset , & os ) ; printf ( ""No<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>Image\\n"" , genimg_get_os_name ( os ) , genimg_get_arch_name ( arch ) , genimg_get_type_name ( image_type ) ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_CHECK_ALL ) ; return - EIO ; } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK ) ; if ( fit_image_get_data_and_size ( fit , noffset , ( const void * * ) & buf , & size ) ) { printf ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>subimage<S2SV_blank>data!\\n"" , prop_name ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_GET_DATA ) ; return - ENOENT ; } if ( IS_ENABLED ( CONFIG_FIT_CIPHER ) && IMAGE_ENABLE_DECRYPT ) { puts ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Decrypting<S2SV_blank>Data<S2SV_blank>...<S2SV_blank>"" ) ; if ( fit_image_uncipher ( fit , noffset , & buf , & size ) ) { puts ( ""Error\\n"" ) ; return - EACCES ; } puts ( ""OK\\n"" ) ; } if ( ! host_build ( ) && IS_ENABLED ( CONFIG_FIT_IMAGE_POST_PROCESS ) ) board_fit_image_post_process ( & buf , & size ) ; len = ( ulong ) size ; bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK ) ; data = map_to_sysmem ( buf ) ; load = data ; if ( load_op == FIT_LOAD_IGNORED ) { } else if ( fit_image_get_load ( fit , noffset , & load ) ) { if ( load_op == FIT_LOAD_REQUIRED ) { printf ( ""Can\'t<S2SV_blank>get<S2SV_blank>%s<S2SV_blank>subimage<S2SV_blank>load<S2SV_blank>address!\\n"" , prop_name ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_LOAD ) ; return - EBADF ; } } else if ( load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load ) { ulong image_start , image_end ; image_start = addr ; image_end = addr + fit_get_size ( fit ) ; load_end = load + len ; if ( image_type != IH_TYPE_KERNEL && load < image_end && load_end > image_start ) { printf ( ""Error:<S2SV_blank>%s<S2SV_blank>overwritten\\n"" , prop_name ) ; return - EXDEV ; } printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Loading<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>0x%08lx<S2SV_blank>to<S2SV_blank>0x%08lx\\n"" , prop_name , data , load ) ; } else { load = data ; } comp = IH_COMP_NONE ; loadbuf = buf ; if ( ! fit_image_get_comp ( fit , noffset , & comp ) && comp != IH_COMP_NONE && ! ( image_type == IH_TYPE_KERNEL || image_type == IH_TYPE_KERNEL_NOLOAD || image_type == IH_TYPE_RAMDISK ) ) { ulong max_decomp_len = len * 20 ; if ( load == data ) { loadbuf = malloc ( max_decomp_len ) ; load = map_to_sysmem ( loadbuf ) ; } else { loadbuf = map_sysmem ( load , max_decomp_len ) ; } if ( image_decomp ( comp , load , data , image_type , loadbuf , buf , len , max_decomp_len , & load_end ) ) { printf ( ""Error<S2SV_blank>decompressing<S2SV_blank>%s\\n"" , prop_name ) ; return - ENOEXEC ; } len = load_end - load ; } else if ( load != data ) { loadbuf = map_sysmem ( load , len ) ; memcpy ( loadbuf , buf , len ) ; } if ( image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE ) puts ( ""WARNING:<S2SV_blank>\'compression\'<S2SV_blank>nodes<S2SV_blank>for<S2SV_blank>ramdisks<S2SV_blank>are<S2SV_blank>deprecated,"" ""<S2SV_blank>please<S2SV_blank>fix<S2SV_blank>your<S2SV_blank>.its<S2SV_blank>file!\\n"" ) ; if ( image_type == IH_TYPE_FLATDT && fdt_check_header ( loadbuf ) ) { puts ( ""Subimage<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>FDT"" ) ; return - ENOEXEC ; } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_LOAD ) ; * datap = load ; * lenp = len ; if ( fit_unamep ) * fit_unamep = ( char * ) fit_uname ; if ( fit_uname_configp ) * fit_uname_configp = ( char * ) ( fit_uname_config ? : fit_base_uname_config ) ; return noffset ; }
","<S2SV_ModStart> BOOTSTAGE_SUB_FORMAT ) ; ret = <S2SV_ModEnd> fit_check_format ( fit <S2SV_ModStart> , IMAGE_SIZE_INVAL ) ; if ( ret <S2SV_ModStart> { printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\n"" , prop_name , ret ) ; if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( ""Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\n"" <S2SV_ModEnd> ) ; bootstage_error <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } bootstage_mark
",u-boot@u-boot/3f04db891a353f4b127ed57279279f851c6b4917,CVE-2021-27138,https://github.com/u-boot/u-boot/commit/3f04db891a353f4b127ed57279279f851c6b4917,2021-02-17T23:15Z,313,<S2SV_ModStart> ; if ( <S2SV_ModEnd> == 0 ),0
816,CWE-284,"CWE-284 void close_uinput ( void ) { BTIF_TRACE_DEBUG ( ""%s"" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> close ( uinput_fd ) ; uinput_fd = - 1 ; } }
","<S2SV_ModStart> 0 ) { TEMP_FAILURE_RETRY ( <S2SV_ModStart> uinput_fd , UI_DEV_DESTROY )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,314,"<S2SV_ModStart> ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart>, 0 ) )",0
817,CWE-119,"CWE-119 static int calc_pframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int af_ratio = 10 ; const RATE_CONTROL * const rc = & cpi -> rc ; int target ; # if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) : <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) ; # else <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> # endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ; }
","<S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> <S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> <S2SV_ModStart> = rc -> avg_frame_bandwidth <S2SV_ModEnd> ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,315,<S2SV_ModStart> = rc ; if ( rc -> avg_rate > rc -> avg_rate ) <S2SV_ModEnd> rc ->,0
818,CWE-668,"CWE-668 int main ( int argc , const char * argv [ ] ) { struct group * grent ; const char * cmd ; const char * path ; int i ; struct passwd * pw ; grent = getgrnam ( ABUILD_GROUP ) ; if ( grent == NULL ) errx ( 1 , ""%s:<S2SV_blank>Group<S2SV_blank>not<S2SV_blank>found"" , ABUILD_GROUP ) ; char * name = NULL ; pw = getpwuid ( getuid ( ) ) ; if ( pw ) name = pw -> pw_name ; if ( ! is_in_group ( grent -> gr_gid ) ) { errx ( 1 , ""User<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>member<S2SV_blank>of<S2SV_blank>group<S2SV_blank>%s\\n"" , name ? name : ""(unknown)"" , ABUILD_GROUP ) ; } if ( name == NULL ) warnx ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>username<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d\\n"" , getuid ( ) ) ; setenv ( ""USER"" , name ? : """" , 1 ) ; cmd = strrchr ( argv [ 0 ] , '/' ) ; if ( cmd ) cmd ++ ; else cmd = argv [ 0 ] ; cmd = strchr ( cmd , '-' ) ; if ( cmd == NULL ) errx ( 1 , ""Calling<S2SV_blank>command<S2SV_blank>has<S2SV_blank>no<S2SV_blank>\'-\'"" ) ; cmd ++ ; path = get_command_path ( cmd ) ; if ( path == NULL ) errx ( 1 , ""%s:<S2SV_blank>Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>subcommand"" , cmd ) ; for ( i = 1 ; i < argc ; i ++ ) <S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug> errx ( 1 , ""%s:<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>option"" , ""--allow-untrusted"" ) ; argv [ 0 ] = path ; setuid ( 0 ) ; setgid ( 0 ) ; execv ( path , ( char * const * ) argv ) ; perror ( path ) ; return 1 ; }
","<S2SV_ModStart> i ++ ) check_option ( argv [ i ] <S2SV_ModEnd> ) ; argv
",sroracle@abuild/4f90ce92778d0ee302e288def75591b96a397c8b,CVE-2019-12875,https://github.com/sroracle/abuild/commit/4f90ce92778d0ee302e288def75591b96a397c8b,2019-06-18T19:15Z,316,<S2SV_ModStart> ; if ( res == NULL ) return - 1 ; if (,0
819,CWE-125,"CWE-125 PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Suite_kind : result = PyType_GenericNew ( Suite_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,317,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,1
823,CWE-119,"CWE-119 static void optimize_b ( MACROBLOCK * mb , int ib , int type , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) { BLOCK * b ; BLOCKD * d ; vp8_token_state tokens [ 17 ] [ 2 ] ; unsigned best_mask [ 2 ] ; const short * dequant_ptr ; const short * coeff_ptr ; short * qcoeff_ptr ; short * dqcoeff_ptr ; int eob ; int i0 ; int rc ; int x ; int sz = 0 ; int next ; int rdmult ; int rddiv ; int final_eob ; int rd_cost0 ; int rd_cost1 ; int rate0 ; int rate1 ; int error0 ; int error1 ; int t0 ; int t1 ; int best ; int band ; int pt ; int i ; int err_mult = plane_rd_mult [ type ] ; b = & mb -> block [ ib ] ; d = & mb -> e_mbd . block [ ib ] ; <S2SV_StartBug> # if 0 <S2SV_EndBug> vp8_strict_quantize_b ( b , d ) ; # endif dequant_ptr = d -> dequant ; coeff_ptr = b -> coeff ; qcoeff_ptr = d -> qcoeff ; dqcoeff_ptr = d -> dqcoeff ; i0 = ! type ; eob = * d -> eob ; rdmult = mb -> rdmult * err_mult ; if ( mb -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) rdmult = ( rdmult * 9 ) >> 4 ; rddiv = mb -> rddiv ; best_mask [ 0 ] = best_mask [ 1 ] = 0 ; tokens [ eob ] [ 0 ] . rate = 0 ; tokens [ eob ] [ 0 ] . error = 0 ; tokens [ eob ] [ 0 ] . next = 16 ; tokens [ eob ] [ 0 ] . token = DCT_EOB_TOKEN ; tokens [ eob ] [ 0 ] . qc = 0 ; * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; next = eob ; for ( i = eob ; i -- > i0 ; ) { int base_bits ; int d2 ; int dx ; rc = vp8_default_zig_zag1d [ i ] ; x = qcoeff_ptr [ rc ] ; if ( x ) { int shortcut = 0 ; error0 = tokens [ next ] [ 0 ] . error ; error1 = tokens [ next ] [ 1 ] . error ; rate0 = tokens [ next ] [ 0 ] . rate ; rate1 = tokens [ next ] [ 1 ] . rate ; t0 = ( vp8_dct_value_tokens_ptr + x ) -> Token ; if ( next < 16 ) { band = vp8_coef_bands [ i + 1 ] ; pt = vp8_prev_token_class [ t0 ] ; rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 0 ] . token ] ; rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 1 ] . token ] ; } rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; if ( rd_cost0 == rd_cost1 ) { rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; } best = rd_cost1 < rd_cost0 ; base_bits = * ( vp8_dct_value_cost_ptr + x ) ; dx = dqcoeff_ptr [ rc ] - coeff_ptr [ rc ] ; d2 = dx * dx ; tokens [ i ] [ 0 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; tokens [ i ] [ 0 ] . error = d2 + ( best ? error1 : error0 ) ; tokens [ i ] [ 0 ] . next = next ; tokens [ i ] [ 0 ] . token = t0 ; tokens [ i ] [ 0 ] . qc = x ; best_mask [ 0 ] |= best << i ; rate0 = tokens [ next ] [ 0 ] . rate ; rate1 = tokens [ next ] [ 1 ] . rate ; if ( ( abs ( x ) * dequant_ptr [ rc ] > abs ( coeff_ptr [ rc ] ) ) && ( abs ( x ) * dequant_ptr [ rc ] < abs ( coeff_ptr [ rc ] ) + dequant_ptr [ rc ] ) ) shortcut = 1 ; else shortcut = 0 ; if ( shortcut ) { sz = - ( x < 0 ) ; x -= 2 * sz + 1 ; } if ( ! x ) { t0 = tokens [ next ] [ 0 ] . token == DCT_EOB_TOKEN ? DCT_EOB_TOKEN : ZERO_TOKEN ; t1 = tokens [ next ] [ 1 ] . token == DCT_EOB_TOKEN ? DCT_EOB_TOKEN : ZERO_TOKEN ; } else { t0 = t1 = ( vp8_dct_value_tokens_ptr + x ) -> Token ; } if ( next < 16 ) { band = vp8_coef_bands [ i + 1 ] ; if ( t0 != DCT_EOB_TOKEN ) { pt = vp8_prev_token_class [ t0 ] ; rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 0 ] . token ] ; } if ( t1 != DCT_EOB_TOKEN ) { pt = vp8_prev_token_class [ t1 ] ; rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 1 ] . token ] ; } } rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; if ( rd_cost0 == rd_cost1 ) { rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; } best = rd_cost1 < rd_cost0 ; base_bits = * ( vp8_dct_value_cost_ptr + x ) ; if ( shortcut ) { dx -= ( dequant_ptr [ rc ] + sz ) ^ sz ; d2 = dx * dx ; } tokens [ i ] [ 1 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; tokens [ i ] [ 1 ] . error = d2 + ( best ? error1 : error0 ) ; tokens [ i ] [ 1 ] . next = next ; tokens [ i ] [ 1 ] . token = best ? t1 : t0 ; tokens [ i ] [ 1 ] . qc = x ; best_mask [ 1 ] |= best << i ; next = i ; } else { band = vp8_coef_bands [ i + 1 ] ; t0 = tokens [ next ] [ 0 ] . token ; t1 = tokens [ next ] [ 1 ] . token ; if ( t0 != DCT_EOB_TOKEN ) { tokens [ next ] [ 0 ] . rate += mb -> token_costs [ type ] [ band ] [ 0 ] [ t0 ] ; tokens [ next ] [ 0 ] . token = ZERO_TOKEN ; } if ( t1 != DCT_EOB_TOKEN ) { tokens [ next ] [ 1 ] . rate += mb -> token_costs [ type ] [ band ] [ 0 ] [ t1 ] ; tokens [ next ] [ 1 ] . token = ZERO_TOKEN ; } } } band = vp8_coef_bands [ i + 1 ] ; VP8_COMBINEENTROPYCONTEXTS ( pt , * a , * l ) ; rate0 = tokens [ next ] [ 0 ] . rate ; rate1 = tokens [ next ] [ 1 ] . rate ; error0 = tokens [ next ] [ 0 ] . error ; error1 = tokens [ next ] [ 1 ] . error ; t0 = tokens [ next ] [ 0 ] . token ; t1 = tokens [ next ] [ 1 ] . token ; rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ t0 ] ; rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ t1 ] ; rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; if ( rd_cost0 == rd_cost1 ) { rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; } best = rd_cost1 < rd_cost0 ; final_eob = i0 - 1 ; for ( i = next ; i < eob ; i = next ) { x = tokens [ i ] [ best ] . qc ; if ( x ) final_eob = i ; rc = vp8_default_zig_zag1d [ i ] ; qcoeff_ptr [ rc ] = x ; dqcoeff_ptr [ rc ] = x * dequant_ptr [ rc ] ; next = tokens [ i ] [ best ] . next ; best = ( best_mask [ best ] >> i ) & 1 ; } final_eob ++ ; * a = * l = ( final_eob != ! type ) ; * d -> eob = ( char ) final_eob ; }
","<S2SV_ModStart> ib ] ; <S2SV_ModEnd> dequant_ptr = d
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,318,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
824,CWE-000,"CWE-000 static int process_options ( int argc , char * argv [ ] , char * operation ) { int error = 0 ; int i = 0 ; if ( ( error = handle_options ( & argc , & argv , my_long_options , get_one_option ) ) ) goto exit ; if ( opt_print_defaults ) { error = - 1 ; goto exit ; } if ( opt_basedir ) { i = ( int ) strlength ( opt_basedir ) ; if ( opt_basedir [ i - 1 ] != FN_LIBCHAR || opt_basedir [ i - 1 ] != FN_LIBCHAR2 ) { char buff [ FN_REFLEN ] ; <S2SV_StartBug> strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ; <S2SV_EndBug> # ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ; # else strncat ( buff , FN_DIRSEP , sizeof ( buff ) - strlen ( buff ) - 1 ) ; # endif buff [ sizeof ( buff ) - 1 ] = 0 ; my_free ( opt_basedir ) ; opt_basedir = my_strdup ( buff , MYF ( MY_FAE ) ) ; } } if ( ! opt_no_defaults && ( ( error = get_default_values ( ) ) ) ) { error = - 1 ; goto exit ; } strcpy ( operation , """" ) ; if ( ( error = check_options ( argc , argv , operation ) ) ) { goto exit ; } if ( opt_verbose ) { printf ( ""#<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>basedir<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_basedir ) ; printf ( ""#<S2SV_blank>plugin_dir<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_plugin_dir ) ; printf ( ""#<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>datadir<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_datadir ) ; printf ( ""#<S2SV_blank>plugin_ini<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_plugin_ini ) ; } exit : return error ; }
","<S2SV_ModStart> FN_REFLEN ] ; memset ( buff , 0 , sizeof ( buff ) ) ;
",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z,319,"<S2SV_ModStart> ( buff, sizeof ( buff )",0
827,CWE-119,"CWE-119 int vp8_decode_frame ( VP8D_COMP * pbi ) { vp8_reader * const bc = & pbi -> mbc [ 8 ] ; VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; const unsigned char * data = pbi -> fragments . ptrs [ 0 ] ; const unsigned char * data_end = data + pbi -> fragments . sizes [ 0 ] ; ptrdiff_t first_partition_length_in_bytes ; int i , j , k , l ; const int * const mb_feature_data_bits = vp8_mb_feature_data_bits ; int corrupt_tokens = 0 ; int prev_independent_partitions = pbi -> independent_partitions ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; xd -> corrupted = 0 ; yv12_fb_new -> corrupted = 0 ; if ( data_end - data < 3 ) { if ( ! pbi -> ec_active ) { vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncated<S2SV_blank>packet"" ) ; } pc -> frame_type = INTER_FRAME ; pc -> version = 0 ; pc -> show_frame = 1 ; first_partition_length_in_bytes = 0 ; } else { unsigned char clear_buffer [ 10 ] ; const unsigned char * clear = data ; if ( pbi -> decrypt_cb ) { <S2SV_StartBug> int n = ( int ) ( data_end - data ) ; <S2SV_EndBug> if ( n > 10 ) n = 10 ; pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } pc -> frame_type = ( FRAME_TYPE ) ( clear [ 0 ] & 1 ) ; pc -> version = ( clear [ 0 ] >> 1 ) & 7 ; pc -> show_frame = ( clear [ 0 ] >> 4 ) & 1 ; first_partition_length_in_bytes = ( clear [ 0 ] | ( clear [ 1 ] << 8 ) | ( clear [ 2 ] << 16 ) ) >> 5 ; if ( ! pbi -> ec_active && ( data + first_partition_length_in_bytes > data_end || data + first_partition_length_in_bytes < data ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncated<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>corrupt<S2SV_blank>partition<S2SV_blank>0<S2SV_blank>length"" ) ; data += 3 ; clear += 3 ; vp8_setup_version ( pc ) ; if ( pc -> frame_type == KEY_FRAME ) { if ( ! pbi -> ec_active || data + 3 < data_end ) { if ( clear [ 0 ] != 0x9d || clear [ 1 ] != 0x01 || clear [ 2 ] != 0x2a ) vpx_internal_error ( & pc -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; } if ( ! pbi -> ec_active || data + 6 < data_end ) { pc -> Width = ( clear [ 3 ] | ( clear [ 4 ] << 8 ) ) & 0x3fff ; pc -> horiz_scale = clear [ 4 ] >> 6 ; pc -> Height = ( clear [ 5 ] | ( clear [ 6 ] << 8 ) ) & 0x3fff ; pc -> vert_scale = clear [ 6 ] >> 6 ; } data += 7 ; <S2SV_StartBug> clear += 7 ; <S2SV_EndBug> } else { <S2SV_StartBug> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> } } if ( ( ! pbi -> decoded_key_frame && pc -> frame_type != KEY_FRAME ) ) { return - 1 ; } init_frame ( pbi ) ; if ( vp8dx_start_decode ( bc , data , ( unsigned int ) ( data_end - data ) , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ; if ( pc -> frame_type == KEY_FRAME ) { ( void ) vp8_read_bit ( bc ) ; pc -> clamp_type = ( CLAMP_TYPE ) vp8_read_bit ( bc ) ; } xd -> segmentation_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> segmentation_enabled ) { xd -> update_mb_segmentation_map = ( unsigned char ) vp8_read_bit ( bc ) ; xd -> update_mb_segmentation_data = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> update_mb_segmentation_data ) { xd -> mb_segement_abs_delta = ( unsigned char ) vp8_read_bit ( bc ) ; <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) { for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> segment_feature_data [ i ] [ j ] = ( signed char ) vp8_read_literal ( bc , mb_feature_data_bits [ i ] ) ; if ( vp8_read_bit ( bc ) ) xd -> segment_feature_data [ i ] [ j ] = - xd -> segment_feature_data [ i ] [ j ] ; } else xd -> segment_feature_data [ i ] [ j ] = 0 ; } } } if ( xd -> update_mb_segmentation_map ) { <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) { if ( vp8_read_bit ( bc ) ) xd -> mb_segment_tree_probs [ i ] = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; } } } else { xd -> update_mb_segmentation_map = 0 ; xd -> update_mb_segmentation_data = 0 ; } pc -> filter_type = ( LOOPFILTERTYPE ) vp8_read_bit ( bc ) ; pc -> filter_level = vp8_read_literal ( bc , 6 ) ; pc -> sharpness_level = vp8_read_literal ( bc , 3 ) ; xd -> mode_ref_lf_delta_update = 0 ; xd -> mode_ref_lf_delta_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> mode_ref_lf_delta_enabled ) { xd -> mode_ref_lf_delta_update = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> mode_ref_lf_delta_update ) { for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> ref_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; if ( vp8_read_bit ( bc ) ) xd -> ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] * - 1 ; } } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> mode_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; if ( vp8_read_bit ( bc ) ) xd -> mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] * - 1 ; } } } } setup_token_decoder ( pbi , data + first_partition_length_in_bytes ) ; xd -> current_bc = & pbi -> mbc [ 0 ] ; { int Q , q_update ; Q = vp8_read_literal ( bc , 7 ) ; pc -> base_qindex = Q ; q_update = 0 ; pc -> y1dc_delta_q = get_delta_q ( bc , pc -> y1dc_delta_q , & q_update ) ; pc -> y2dc_delta_q = get_delta_q ( bc , pc -> y2dc_delta_q , & q_update ) ; pc -> y2ac_delta_q = get_delta_q ( bc , pc -> y2ac_delta_q , & q_update ) ; pc -> uvdc_delta_q = get_delta_q ( bc , pc -> uvdc_delta_q , & q_update ) ; pc -> uvac_delta_q = get_delta_q ( bc , pc -> uvac_delta_q , & q_update ) ; if ( q_update ) vp8cx_init_de_quantizer ( pbi ) ; vp8_mb_init_dequantizer ( pbi , & pbi -> mb ) ; } if ( pc -> frame_type != KEY_FRAME ) { pc -> refresh_golden_frame = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_golden_frame = 0 ; # endif pc -> refresh_alt_ref_frame = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_alt_ref_frame = 0 ; # endif pc -> copy_buffer_to_gf = 0 ; if ( ! pc -> refresh_golden_frame ) pc -> copy_buffer_to_gf = vp8_read_literal ( bc , 2 ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> copy_buffer_to_gf = 0 ; # endif pc -> copy_buffer_to_arf = 0 ; if ( ! pc -> refresh_alt_ref_frame ) pc -> copy_buffer_to_arf = vp8_read_literal ( bc , 2 ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> copy_buffer_to_arf = 0 ; # endif pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = vp8_read_bit ( bc ) ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = vp8_read_bit ( bc ) ; } pc -> refresh_entropy_probs = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_entropy_probs = 0 ; # endif if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> } pc -> refresh_last_frame = pc -> frame_type == KEY_FRAME || vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_last_frame = 1 ; # endif if ( 0 ) { FILE * z = fopen ( ""decodestats.stt"" , ""a"" ) ; fprintf ( z , ""%6d<S2SV_blank>F:%d,G:%d,A:%d,L:%d,Q:%d\\n"" , pc -> current_video_frame , pc -> frame_type , pc -> refresh_golden_frame , pc -> refresh_alt_ref_frame , pc -> refresh_last_frame , pc -> base_qindex ) ; fclose ( z ) ; } { pbi -> independent_partitions = 1 ; for ( i = 0 ; i < BLOCK_TYPES ; i ++ ) for ( j = 0 ; j < COEF_BANDS ; j ++ ) for ( k = 0 ; k < PREV_COEF_CONTEXTS ; k ++ ) for ( l = 0 ; l < ENTROPY_NODES ; l ++ ) { vp8_prob * const p = pc -> fc . coef_probs [ i ] [ j ] [ k ] + l ; if ( vp8_read ( bc , vp8_coef_update_probs [ i ] [ j ] [ k ] [ l ] ) ) { * p = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; } if ( k > 0 && * p != pc -> fc . coef_probs [ i ] [ j ] [ k - 1 ] [ l ] ) pbi -> independent_partitions = 0 ; } } <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_decode_mode_mvs ( pbi ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active && pbi -> mvs_corrupt_from_mb < ( unsigned int ) pc -> mb_cols * pc -> mb_rows ) { vp8_estimate_missing_mvs ( pbi ) ; } # endif <S2SV_StartBug> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <S2SV_EndBug> pbi -> frame_corrupt_residual = 0 ; # if CONFIG_MULTITHREAD if ( pbi -> b_multithreaded_rd && pc -> multi_token_partition != ONE_PARTITION ) { unsigned int thread ; vp8mt_decode_mb_rows ( pbi , xd ) ; vp8_yv12_extend_frame_borders ( yv12_fb_new ) ; for ( thread = 0 ; thread < pbi -> decoding_thread_count ; ++ thread ) corrupt_tokens |= pbi -> mb_row_di [ thread ] . mbd . corrupted ; } else # endif { decode_mb_rows ( pbi ) ; corrupt_tokens |= xd -> corrupted ; } yv12_fb_new -> corrupted = vp8dx_bool_error ( bc ) ; yv12_fb_new -> corrupted |= corrupt_tokens ; if ( ! pbi -> decoded_key_frame ) { if ( pc -> frame_type == KEY_FRAME && ! yv12_fb_new -> corrupted ) pbi -> decoded_key_frame = 1 ; else vpx_internal_error ( & pbi -> common . error , VPX_CODEC_CORRUPT_FRAME , ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ; } if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> pbi -> independent_partitions = prev_independent_partitions ; } # ifdef PACKET_TESTING { FILE * f = fopen ( ""decompressor.VP8"" , ""ab"" ) ; unsigned int size = pbi -> bc2 . pos + pbi -> bc . pos + 8 ; fwrite ( ( void * ) & size , 4 , 1 , f ) ; fwrite ( ( void * ) pbi -> Source , size , 1 , f ) ; fclose ( f ) ; } # endif return 0 ; }
","<S2SV_ModStart> ( int ) MIN ( sizeof ( clear_buffer ) , <S2SV_ModEnd> data_end - data <S2SV_ModStart> - data ) <S2SV_ModEnd> ; pbi -> <S2SV_ModStart> += 7 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy <S2SV_ModEnd> ( & xd <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & xd <S2SV_ModStart> bc ) ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> update_mb_segmentation_map ) { memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & pc <S2SV_ModStart> ; } } memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> } # endif memset <S2SV_ModEnd> ( pc -> <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & pc
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,320,<S2SV_ModStart> ; int nbi <S2SV_ModEnd> ; if (,0
828,CWE-772,"CWE-772 getprivs_ret * get_privs_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) { static getprivs_ret ret ; <S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_getprivs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( * arg , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } ret . code = kadm5_get_privs ( ( void * ) handle , & ret . privs ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_privs"" , client_name . value , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> errmsg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,321,"<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <S2SV_ModEnd> free_handle ( handle",0
829,CWE-000,"CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; <S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }
","<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
",torvalds@linux/1be9a950c646c9092fb3618197f7b6bfb50e82aa,CVE-2014-5077,https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa,2014-08-01T11:13Z,322,<S2SV_ModStart> -> peer. auth_capable = new -> peer.,0
834,CWE-119,"CWE-119 void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , <S2SV_StartBug> int * returndistortion , int * returnintra ) <S2SV_EndBug> { BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int_mv best_ref_mv_sb [ 2 ] ; int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; int_mv best_ref_mv ; int_mv * mode_mv ; MB_PREDICTION_MODE this_mode ; int num00 ; int best_mode_index = 0 ; BEST_MODE best_mode ; int i ; int mode_index ; int mdcounts [ 4 ] ; int rate ; RATE_DISTORTION rd ; int uv_intra_rate , uv_intra_distortion , uv_intra_rate_tokenonly ; int uv_intra_tteob = 0 ; int uv_intra_done = 0 ; MB_PREDICTION_MODE uv_intra_mode = 0 ; int_mv mvp ; int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int saddone = 0 ; int sr = 0 ; unsigned char * plane [ 4 ] [ 3 ] ; int ref_frame_map [ 4 ] ; int sign_bias = 0 ; int intra_rd_penalty = 10 * vp8_dc_quant ( cpi -> common . base_qindex , cpi -> common . y1dc_delta_q ) ; # if CONFIG_TEMPORAL_DENOISING <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX , <S2SV_EndBug> <S2SV_StartBug> best_rd_sse = INT_MAX ; <S2SV_EndBug> # endif mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = 0 ; best_mode . rd = INT_MAX ; best_mode . yrd = INT_MAX ; best_mode . intra_rd = INT_MAX ; <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; <S2SV_EndBug> get_reference_search_order ( cpi , ref_frame_map ) ; if ( ref_frame_map [ 1 ] > 0 ) { sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , x -> e_mbd . mode_info_context , mode_mv_sb , best_ref_mv_sb , mdcounts , ref_frame_map [ 1 ] , cpi -> common . ref_frame_sign_bias ) ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; * returnintra = INT_MAX ; x -> mbs_tested_so_far ++ ; x -> skip = 0 ; for ( mode_index = 0 ; mode_index < MAX_MODES ; mode_index ++ ) { int this_rd = INT_MAX ; int disable_skip = 0 ; int other_cost = 0 ; int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ; if ( best_mode . rd <= x -> rd_threshes [ mode_index ] ) continue ; if ( this_ref_frame < 0 ) continue ; rd . rate2 = 0 ; rd . distortion2 = 0 ; this_mode = vp8_mode_order [ mode_index ] ; x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) continue ; } if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) { x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) { sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } } if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) { if ( x -> mbs_tested_so_far <= cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; continue ; } } x -> mode_test_hit_counts [ mode_index ] ++ ; if ( x -> zbin_mode_boost_enabled ) { if ( this_ref_frame == INTRA_FRAME ) x -> zbin_mode_boost = 0 ; else { if ( vp8_mode_order [ mode_index ] == ZEROMV ) { if ( this_ref_frame != LAST_FRAME ) x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ; else x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ; } else if ( vp8_mode_order [ mode_index ] == SPLITMV ) x -> zbin_mode_boost = 0 ; else x -> zbin_mode_boost = MV_ZBIN_BOOST ; } vp8_update_zbin_extra ( cpi , x ) ; } if ( ! uv_intra_done && this_ref_frame == INTRA_FRAME ) { rd_pick_intra_mbuv_mode ( x , & uv_intra_rate , & uv_intra_rate_tokenonly , & uv_intra_distortion ) ; uv_intra_mode = x -> e_mbd . mode_info_context -> mbmi . uv_mode ; for ( i = 16 ; i < 24 ; i ++ ) uv_intra_tteob += x -> e_mbd . eobs [ i ] ; uv_intra_done = 1 ; } switch ( this_mode ) { case B_PRED : { int tmp_rd ; int distortion ; tmp_rd = rd_pick_intra4x4mby_modes ( x , & rate , & rd . rate_y , & distortion , best_mode . yrd ) ; rd . rate2 += rate ; rd . distortion2 += distortion ; if ( tmp_rd < best_mode . yrd ) { rd . rate2 += uv_intra_rate ; rd . rate_uv = uv_intra_rate_tokenonly ; rd . distortion2 += uv_intra_distortion ; rd . distortion_uv = uv_intra_distortion ; } else { this_rd = INT_MAX ; disable_skip = 1 ; } } break ; case SPLITMV : { int tmp_rd ; int this_rd_thresh ; int distortion ; this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 1 ) ? x -> rd_threshes [ THR_NEW1 ] : x -> rd_threshes [ THR_NEW3 ] ; this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 2 ) ? x -> rd_threshes [ THR_NEW2 ] : this_rd_thresh ; tmp_rd = vp8_rd_pick_best_mbsegmentation ( cpi , x , & best_ref_mv , best_mode . yrd , mdcounts , & rate , & rd . rate_y , & distortion , this_rd_thresh ) ; rd . rate2 += rate ; rd . distortion2 += distortion ; if ( tmp_rd < best_mode . yrd ) { rd_inter4x4_uv ( cpi , x , & rd . rate_uv , & rd . distortion_uv , cpi -> common . full_pixel ) ; rd . rate2 += rd . rate_uv ; rd . distortion2 += rd . distortion_uv ; } else { this_rd = INT_MAX ; disable_skip = 1 ; } } break ; case DC_PRED : case V_PRED : case H_PRED : case TM_PRED : { int distortion ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; macro_block_yrd ( x , & rd . rate_y , & distortion ) ; rd . rate2 += rd . rate_y ; rd . distortion2 += distortion ; rd . rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ; rd . rate2 += uv_intra_rate ; rd . rate_uv = uv_intra_rate_tokenonly ; rd . distortion2 += uv_intra_distortion ; rd . distortion_uv = uv_intra_distortion ; } break ; case NEWMV : { int thissme ; int bestsme = INT_MAX ; int step_param = cpi -> sf . first_step ; int further_steps ; int n ; int do_refine = 1 ; int sadpb = x -> sadperbit16 ; int_mv mvp_full ; int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; if ( ! saddone ) { vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ; saddone = 1 ; } vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ; mvp_full . as_mv . col = mvp . as_mv . col >> 3 ; mvp_full . as_mv . row = mvp . as_mv . row >> 3 ; if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ; if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ; if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ; if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ; if ( sr > step_param ) step_param = sr ; { bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; <S2SV_StartBug> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; <S2SV_EndBug> n = 0 ; further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; n = num00 ; num00 = 0 ; if ( n > further_steps ) do_refine = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param + n , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; if ( num00 > ( further_steps - n ) ) do_refine = 0 ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; } } } } if ( do_refine == 1 ) { int search_range ; search_range = 8 ; thissme = cpi -> refining_search_sad ( x , b , d , & d -> bmi . mv , sadpb , search_range , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; } } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & dis , & sse ) ; } mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; rd . rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , x -> mvcost , 96 ) ; } case NEARESTMV : case NEARMV : vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; if ( ( ( this_mode == NEARMV ) || ( this_mode == NEARESTMV ) ) && ( mode_mv [ this_mode ] . as_int == 0 ) ) continue ; case ZEROMV : if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) continue ; vp8_set_mbmode_and_mvs ( x , this_mode , & mode_mv [ this_mode ] ) ; this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ; break ; default : break ; } this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , disable_skip , uv_intra_tteob , intra_rd_penalty , cpi , x ) ; if ( ( x -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && ( this_rd < best_mode . intra_rd ) ) { best_mode . intra_rd = this_rd ; * returnintra = rd . distortion2 ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { unsigned int sse ; vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & sse , mode_mv [ this_mode ] ) ; if ( sse < best_rd_sse ) best_rd_sse = sse ; if ( this_mode == ZEROMV && sse < zero_mv_sse ) { zero_mv_sse = sse ; x -> best_zeromv_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && sse < best_sse ) { best_sse = sse ; vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & best_sse , mode_mv [ this_mode ] ) ; x -> best_sse_inter_mode = NEWMV ; x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ; x -> need_to_clamp_best_mvs = x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ; x -> best_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } } # endif if ( this_rd < best_mode . rd || x -> skip ) { best_mode_index = mode_index ; * returnrate = rd . rate2 ; * returndistortion = rd . distortion2 ; if ( this_mode <= B_PRED ) { x -> e_mbd . mode_info_context -> mbmi . uv_mode = uv_intra_mode ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; } update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ; x -> rd_thresh_mult [ mode_index ] = ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ; } else { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; } x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; if ( x -> skip ) break ; } if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) { int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 2 ) ; x -> rd_thresh_mult [ best_mode_index ] = ( x -> rd_thresh_mult [ best_mode_index ] >= ( MIN_THRESHMULT + best_adjustment ) ) ? x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : MIN_THRESHMULT ; x -> rd_threshes [ best_mode_index ] = ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * x -> rd_thresh_mult [ best_mode_index ] ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> { x -> best_sse_inter_mode = best_mode . mbmode . mode ; x -> best_sse_mv = best_mode . mbmode . mv ; x -> need_to_clamp_best_mvs = best_mode . mbmode . need_to_clamp_mvs ; x -> best_reference_frame = best_mode . mbmode . ref_frame ; best_sse = best_rd_sse ; } vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> if ( best_mode . mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) { int this_rd = INT_MAX ; int disable_skip = 0 ; int other_cost = 0 ; int this_ref_frame = x -> best_zeromv_reference_frame ; rd . rate2 = x -> ref_frame_cost [ this_ref_frame ] + vp8_cost_mv_ref ( ZEROMV , mdcounts ) ; rd . distortion2 = 0 ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ; this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , disable_skip , uv_intra_tteob , intra_rd_penalty , cpi , x ) ; if ( this_rd < best_mode . rd || x -> skip ) { <S2SV_StartBug> best_mode_index = mode_index ; <S2SV_EndBug> * returnrate = rd . rate2 ; * returndistortion = rd . distortion2 ; update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ; } } } # endif if ( cpi -> is_src_frame_alt_ref && ( best_mode . mbmode . mode != ZEROMV || best_mode . mbmode . ref_frame != ALTREF_FRAME ) ) { x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = ALTREF_FRAME ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mb_skip_coeff = ( cpi -> common . mb_no_coeff_skip ) ; x -> e_mbd . mode_info_context -> mbmi . partitioning = 0 ; return ; } <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> if ( best_mode . mbmode . mode == B_PRED ) { for ( i = 0 ; i < 16 ; i ++ ) xd -> mode_info_context -> bmi [ i ] . as_mode = best_mode . bmodes [ i ] . as_mode ; } if ( best_mode . mbmode . mode == SPLITMV ) { for ( i = 0 ; i < 16 ; i ++ ) xd -> mode_info_context -> bmi [ i ] . mv . as_int = best_mode . bmodes [ i ] . mv . as_int ; <S2SV_StartBug> vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ; } if ( sign_bias != cpi -> common . ref_frame_sign_bias [ xd -> mode_info_context -> mbmi . ref_frame ] ) best_ref_mv . as_int = best_ref_mv_sb [ ! sign_bias ] . as_int ; rd_update_mvcount ( x , & best_ref_mv ) ; }
","<S2SV_ModStart> int * returnintra , int mb_row , int mb_col <S2SV_ModStart> int zero_mv_sse = UINT_MAX <S2SV_ModEnd> , best_sse = <S2SV_ModStart> , best_sse = UINT_MAX <S2SV_ModEnd> , best_rd_sse = <S2SV_ModStart> , best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # endif <S2SV_ModStart> = INT_MAX ; memset <S2SV_ModEnd> ( mode_mv_sb , <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( & best_mode <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( & best_mode <S2SV_ModStart> mv . as_int <S2SV_ModEnd> ; further_steps = <S2SV_ModStart> noise_sensitivity ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; <S2SV_ModStart> recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index <S2SV_ModStart> skip ) { <S2SV_ModEnd> * returnrate = <S2SV_ModStart> return ; } memcpy <S2SV_ModEnd> ( & x <S2SV_ModStart> . as_int ; memcpy <S2SV_ModEnd> ( x ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,323,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
836,CWE-119,"CWE-119 hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; <S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug> if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }
","<S2SV_ModStart> . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; }
",libguestfs@hivex/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,2014-12-08T16:59Z,324,<S2SV_ModStart> ; if ( h -> size < 0 ) goto error ; if (,0
838,CWE-200,"CWE-200 WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; <S2SV_StartBug> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <S2SV_EndBug> UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; WORD32 i4_cropped_ht , i4_cropped_wd ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; UWORD32 u4_num_reorder_frames ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>profile_idc"" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>u4_level_idc"" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>seq_parameter_set_id"" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; if ( ps_dec -> i4_header_decoded & 1 ) { * ps_seq = * ps_dec -> ps_cur_sps ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_profile_idc != u1_profile_idc ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_level_idc != u1_level_idc ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_frame_num_minus4"" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_order_cnt_type"" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4"" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>delta_pic_order_always_zero_flag"" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_non_ref_pic"" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_top_to_bottom_field"" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle"" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_ref_frame"" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_num_ref_frames != u4_temp ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames"" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag"" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_width_in_mbs_minus1"" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_frame_mbs_only_flag != u1_frm ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_mbs_only_flag"" , u1_frm ) ; if ( ! u1_frm ) <S2SV_StartBug> { <S2SV_EndBug> u2_pic_ht <<= 1 ; <S2SV_StartBug> ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; <S2SV_EndBug> COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>direct_8x8_inference_flag"" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_flag"" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_left_offset"" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_right_offset"" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_top_offset"" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_bottom_offset"" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>vui_parameters_present_flag"" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) || ( u2_pic_wd < H264_MIN_FRAME_WIDTH ) || ( u2_pic_ht < H264_MIN_FRAME_HEIGHT ) || ( u2_pic_wd * ( UWORD32 ) u2_pic_ht > H264_MAX_FRAME_SIZE ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( 1 == ps_seq -> u1_vui_parameters_present_flag ) && ( 1 == ps_seq -> s_vui . u1_bitstream_restriction_flag ) ) { u4_num_reorder_frames = ps_seq -> s_vui . u4_num_reorder_frames ; } else { u4_num_reorder_frames = - 1 ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( - 1 != ( WORD32 ) u4_num_reorder_frames ) && ( 1 == ps_seq -> u1_vui_parameters_present_flag ) && ( 1 == ps_seq -> s_vui . u1_bitstream_restriction_flag ) && ( ps_seq -> s_vui . u4_num_reorder_frames != u4_num_reorder_frames ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_dec -> u2_disp_height = i4_cropped_ht ; ps_dec -> u2_disp_width = i4_cropped_wd ; ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; ps_dec -> ps_cur_sps = & ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; return OK ; }
","<S2SV_ModStart> u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 <S2SV_ModStart> ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> -> u1_mb_aff_flag = u1_mb_aff_flag <S2SV_ModEnd> ; COPYTHECONTEXT (
",external@libavc/42cf02965b11c397dd37a0063e683cef005bc0ae,CVE-2017-13204,https://android.googlesource.com/platform/external/libavc/+/42cf02965b11c397dd37a0063e683cef005bc0ae,2018-01-12T23:29Z,325,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
840,CWE-119,"CWE-119 static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> VP9_COMP * const cpi = ctx -> cpi ; <S2SV_StartBug> vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( params == NULL ) <S2SV_EndBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> cpi -> svc . spatial_layer_id = params -> spatial_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . temporal_layer_id = params -> temporal_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> lst_fb_idx = params -> lst_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> gld_fb_idx = params -> gld_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> alt_fb_idx = params -> alt_fb_idx ; <S2SV_EndBug> if ( vp9_set_size_literal ( ctx -> cpi , params -> width , params -> height ) != 0 ) return VPX_CODEC_INVALID_PARAM ; ctx -> cfg . rc_max_quantizer = params -> max_quantizer ; ctx -> cfg . rc_min_quantizer = params -> min_quantizer ; set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ; vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> -> cpi ; vpx_svc_extra_cfg_t <S2SV_ModEnd> * const params <S2SV_ModStart> ( args , vpx_svc_extra_cfg_t <S2SV_ModEnd> * ) ; <S2SV_ModStart> * ) ; int sl , tl ; for ( sl = 0 ; sl < <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> max_quantizers [ sl ] ; lc -> min_q <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> min_quantizers [ sl ] ; lc -> scaling_factor_num <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> scaling_factor_num [ sl ] ; lc -> scaling_factor_den <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> return VPX_CODEC_OK ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,326,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>S2SV_null>S2SV_null>S2SV_null>S2SV_null>S2SV_null>S2SV_null>,0
842,CWE-190,"CWE-190 static int tiffcp ( TIFF * in , TIFF * out ) { <S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }
","<S2SV_ModStart> bitspersample , samplesperpixel = 1 <S2SV_ModStart> input_compression , input_photometric = PHOTOMETRIC_MINISBLACK
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f,2016-11-22T19:59Z,327,<S2SV_ModStart> { uint16 bitsize = 0,0
843,CWE-20,"CWE-20 static int check_symlinks ( struct archive_write_disk * a ) { <S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; <S2SV_StartBug> } <S2SV_EndBug> a -> pst = NULL ; <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>remove<S2SV_blank>intervening<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> ( a -> <S2SV_ModStart> name , & error_number , & error_string , a -> flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string ) ; <S2SV_ModStart> = NULL ; return rc ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9,CVE-2016-5418,https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9,2016-09-21T14:25Z,328,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> strncpy <S2SV_ModEnd> ( a -> <S2SV_ModStart> ) { assert ( a -> archive_name_size ) ; if ( a -> archive_size == '\\0' ) ) { archive_error ( a -> archive, ""%s"", a -> archive_name <S2SV_ModEnd> ) ; return (",0
845,CWE-399,"CWE-399 static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; <S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> & ident ) ) ) { if ( ident == TAG_IDENT_FE || ident == TAG_IDENT_EFE ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; } <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; make_bad_inode ( inode ) ; return ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }
","<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
",torvalds@linux/c03aa9f6e1f938618e6db2e23afef0574efeeb65,CVE-2014-6410,https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65,2014-09-28T10:55Z,329,<S2SV_ModStart> struct i_sb ; struct i_sb * i_sb ; struct i_info * i_sb = inode -> i_info -> i_offset ; if ( inode -> i_offset < sizeof ( inode ) -> i_offset ) goto out ; if ( inode -> i_info -> i_len > inode -> i_len ) goto out ; if ( inode -> i_len = inode -> i_sb -> i_sb -> i_sb -> i_sb -> i_sb -> i_sb -> i_len -= sizeof ( struct i_sb ) -> i_sb -> i_sb -> i_offset ; if ( inode -> i_sb -> i_len > inode -> i_len ) goto out ; },0
846,CWE-119,"CWE-119 static void build_masks ( const loop_filter_info_n * const lfi_n , const MODE_INFO * mi , const int shift_y , const int shift_uv , LOOP_FILTER_MASK * lfm ) { const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; <S2SV_StartBug> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ; uint64_t * const int_4x4_y = & lfm -> int_4x4_y ; uint16_t * const left_uv = & lfm -> left_uv [ tx_size_uv ] ; uint16_t * const above_uv = & lfm -> above_uv [ tx_size_uv ] ; uint16_t * const int_4x4_uv = & lfm -> int_4x4_uv ; int i ; if ( ! filter_level ) { return ; } else { const int w = num_8x8_blocks_wide_lookup [ block_size ] ; const int h = num_8x8_blocks_high_lookup [ block_size ] ; int index = shift_y ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> index += 8 ; } } * above_y |= above_prediction_mask [ block_size ] << shift_y ; * above_uv |= above_prediction_mask_uv [ block_size ] << shift_uv ; * left_y |= left_prediction_mask [ block_size ] << shift_y ; * left_uv |= left_prediction_mask_uv [ block_size ] << shift_uv ; if ( mbmi -> skip && is_inter_block ( mbmi ) ) return ; * above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * above_uv |= ( size_mask_uv [ block_size ] & above_64x64_txform_mask_uv [ tx_size_uv ] ) << shift_uv ; * left_y |= ( size_mask [ block_size ] & left_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * left_uv |= ( size_mask_uv [ block_size ] & left_64x64_txform_mask_uv [ tx_size_uv ] ) << shift_uv ; if ( tx_size_y == TX_4X4 ) <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ; }
","<S2SV_ModStart> TX_SIZE tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 <S2SV_ModEnd> ) ; const <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( & lfm <S2SV_ModStart> block_size ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) << shift_y
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,330,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
849,CWE-362,"CWE-362 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
","<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,331,"<S2SV_ModStart> mq_mq_rq_rq ( q,",0
850,CWE-269,"CWE-269 uint32_t virtio_config_readb ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldub_p ( vdev -> config + addr ) ; return val ; }
","<S2SV_ModStart> uint8_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
",qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d,CVE-2013-2016,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,2019-12-30T22:15Z,332,<S2SV_ModStart> uint8_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =,1
851,CWE-400,"CWE-400 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z,333,<S2SV_ModStart> ptr ) ; if ( iter == NULL ) return ;,0
853,CWE-000,"CWE-000 static int sessionCookieDirective ( MaState * state , cchar * key , cchar * value ) { char * options , * option , * ovalue , * tok ; if ( ! maTokenize ( state , value , ""%*"" , & options ) ) { return MPR_ERR_BAD_SYNTAX ; } if ( smatch ( options , ""disable"" ) ) { httpSetAuthSession ( state -> route -> auth , 0 ) ; return 0 ; } else if ( smatch ( options , ""enable"" ) ) { httpSetAuthSession ( state -> route -> auth , 1 ) ; return 0 ; } for ( option = maGetNextArg ( options , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( ! ovalue || * ovalue == '\\0' ) continue ; if ( smatch ( option , ""visible"" ) ) { httpSetRouteSessionVisibility ( state -> route , scaselessmatch ( ovalue , ""visible"" ) ) ; } else if ( smatch ( option , ""name"" ) ) { httpSetRouteCookie ( state -> route , ovalue ) ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>SessionCookie<S2SV_blank>option<S2SV_blank>%s"" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }
","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,334,"<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option,",1
857,CWE-119,"CWE-119 static int fx_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { struct effect_s * effect = ( struct effect_s * ) self ; if ( effect == NULL ) return - EINVAL ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) return - EINVAL ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : { if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_SET_CONFIG<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } * ( int * ) pReplyData = session_set_config ( effect -> session , ( effect_config_t * ) pCmdData ) ; if ( * ( int * ) pReplyData != 0 ) break ; if ( effect -> state != EFFECT_STATE_ACTIVE ) * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; } break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_GET_CONFIG<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } session_get_config ( effect -> session , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || <S2SV_StartBug> * replySize < ( int ) sizeof ( effect_param_t ) ) { <S2SV_EndBug> ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + p -> psize ) ; p = ( effect_param_t * ) pReplyData ; p -> status = - ENOSYS ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( p -> psize != sizeof ( int32_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>param<S2SV_blank>format"" ) ; return - EINVAL ; } * ( int * ) pReplyData = - ENOSYS ; } break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_ENABLE<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_ACTIVE ) ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_DISABLE<S2SV_blank>invalid<S2SV_blank>args"" ) ; return - EINVAL ; } * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; break ; case EFFECT_CMD_SET_DEVICE : case EFFECT_CMD_SET_INPUT_DEVICE : case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != sizeof ( uint32_t ) ) { ALOGV ( ""fx_command()<S2SV_blank>%s<S2SV_blank>invalid<S2SV_blank>args"" , cmdCode == EFFECT_CMD_SET_DEVICE ? ""EFFECT_CMD_SET_DEVICE"" : cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? ""EFFECT_CMD_SET_INPUT_DEVICE"" : cmdCode == EFFECT_CMD_SET_VOLUME ? ""EFFECT_CMD_SET_VOLUME"" : cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? ""EFFECT_CMD_SET_AUDIO_MODE"" : """" ) ; return - EINVAL ; } ALOGV ( ""fx_command()<S2SV_blank>%s<S2SV_blank>value<S2SV_blank>%08x"" , cmdCode == EFFECT_CMD_SET_DEVICE ? ""EFFECT_CMD_SET_DEVICE"" : cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? ""EFFECT_CMD_SET_INPUT_DEVICE"" : cmdCode == EFFECT_CMD_SET_VOLUME ? ""EFFECT_CMD_SET_VOLUME"" : cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? ""EFFECT_CMD_SET_AUDIO_MODE"" : """" , * ( int * ) pCmdData ) ; break ; default : return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> ( int ) sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize -
",hardware@qcom@audio/073a80800f341325932c66818ce4302b312909a4,CVE-2016-3745,https://android.googlesource.com/platform/hardware/qcom/audio/+/073a80800f341325932c66818ce4302b312909a4,2016-07-11T01:59Z,335,,0
858,CWE-399,"CWE-399 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacket<S2SV_blank>begin="" # define EndXMPPacket ""<?xpacket<S2SV_blank>end="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""!PS-"" # define RenderPostscriptText ""<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>"" # define SpotColor ""+<S2SV_blank>"" char command [ MagickPathExtent ] , * density , filename [ MagickPathExtent ] , geometry [ MagickPathExtent ] , input_filename [ MagickPathExtent ] , message [ MagickPathExtent ] , * options , postscript_filename [ MagickPathExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length ; ssize_t count , priority ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> resolution . x == 0.0 ) || ( image -> resolution . y == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution = image -> resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; columns = 0 ; rows = 0 ; priority = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; pages = ( ~ 0UL ) ; skip = MagickFalse ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , ""ps:Level"" , command + 4 , exception ) ; if ( GlobExpression ( command , ""*EPSF-*"" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel ""<S2SV_blank>%lu"" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages ""<S2SV_blank>%lu"" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData ""<S2SV_blank>%lu<S2SV_blank>%lu"" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , ""*Cyan*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Magenta*"" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , ""*Yellow*"" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MagickPathExtent ] , * value ; register char * q ; ( void ) FormatLocaleString ( property , MagickPathExtent , ""ps:SpotColor-%.20g"" , ( double ) ( spotcolor ++ ) ) ; for ( q = command ; * q != '\\0' ; q ++ ) if ( isspace ( ( int ) ( unsigned char ) * q ) != 0 ) break ; value = ConstantString ( q ) ; ( void ) SubstituteString ( & value , ""("" , """" ) ; ( void ) SubstituteString ( & value , "")"" , """" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value , exception ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia ""<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf"" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%gx%g%+.15g%+.15g"" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , ""ps:HiResBoundingBox"" , geometry , exception ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , ""eps:fit-page"" ) ; if ( option != ( char * ) NULL ) { char * page_geometry ; page_geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( page_geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> resolution . y / delta . y ) - 0.5 ) ; page_geometry = DestroyString ( page_geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , ""/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{"" ""dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n"" ""<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n"" , MagickPathExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MagickPathExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MagickPathExtent , ""%g<S2SV_blank>%g<S2SV_blank>translate\\n"" , - bounds . x1 , - bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:mono"" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( ""ps:cmyk"" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( ""ps:alpha"" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( """" ) ; options = AcquireString ( """" ) ; ( void ) FormatLocaleString ( density , MagickPathExtent , ""%gx%g"" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MagickPathExtent , ""-g%.20gx%.20g<S2SV_blank>"" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pages , MagickPathExtent , ""-dFirstPage=%.20g<S2SV_blank>"" ""-dLastPage=%.20g<S2SV_blank>"" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MagickPathExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , ""eps:use-cropbox"" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , ""-dEPSCrop<S2SV_blank>"" , MagickPathExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , ""-dEPSFitPage<S2SV_blank>"" , MagickPathExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MagickPathExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , ""%d"" , MagickPathExtent ) ; ( void ) FormatLocaleString ( command , MagickPathExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename , exception ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , ""<S2SV_blank>-c<S2SV_blank>showpage"" , MagickPathExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , ""PostscriptDelegateFailed"" , ""`%s\'"" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , ""BMP"" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MagickPathExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * q ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile ""<S2SV_blank>%lu"" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { q = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * q ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , ""8bim"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { p = command ; profile = StringToStringInfo ( command ) ; for ( i = ( ssize_t ) GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( ""\\n\\r%"" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , ""xmp"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MagickPathExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MagickPathExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
","<S2SV_ModStart> ""`%s\'"" , option ) ; page_geometry = DestroyString ( page_geometry
",ImageMagick@ImageMagick/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34,CVE-2019-13137,https://github.com/ImageMagick/ImageMagick/commit/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34,2019-07-01T20:15Z,336,,0
859,CWE-264,"CWE-264 static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen , unsigned int flags ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; int len ; int val ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; switch ( optname ) { case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; val = sk -> sk_family ; break ; case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ; if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ; if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ; lock_sock ( sk ) ; err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IPV6_2292PKTOPTIONS : { struct msghdr msg ; struct sk_buff * skb ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = flags ; lock_sock ( sk ) ; skb = np -> pktoptions ; if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ; release_sock ( sk ) ; if ( ! skb ) { if ( np -> rxopt . bits . rxinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxhlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxtclass ) { int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ; put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ; } if ( np -> rxopt . bits . rxoinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxohlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxflow ) { __be32 flowinfo = np -> rcv_flowinfo ; put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ; } } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IPV6_MTU : { struct dst_entry * dst ; val = 0 ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! val ) return - ENOTCONN ; break ; } case IPV6_V6ONLY : val = sk -> sk_ipv6only ; break ; case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ; break ; case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ; break ; case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ; break ; case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ; break ; case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ; break ; case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> optname , optval , len ) ; release_sock ( sk ) ; if ( len < 0 ) return len ; return put_user ( len , optlen ) ; } case IPV6_RECVHOPOPTS : val = np -> rxopt . bits . hopopts ; break ; case IPV6_2292HOPOPTS : val = np -> rxopt . bits . ohopopts ; break ; case IPV6_RECVDSTOPTS : val = np -> rxopt . bits . dstopts ; break ; case IPV6_2292DSTOPTS : val = np -> rxopt . bits . odstopts ; break ; case IPV6_TCLASS : val = np -> tclass ; break ; case IPV6_RECVTCLASS : val = np -> rxopt . bits . rxtclass ; break ; case IPV6_FLOWINFO : val = np -> rxopt . bits . rxflow ; break ; case IPV6_RECVPATHMTU : val = np -> rxopt . bits . rxpmtu ; break ; case IPV6_PATHMTU : { struct dst_entry * dst ; struct ip6_mtuinfo mtuinfo ; if ( len < sizeof ( mtuinfo ) ) return - EINVAL ; len = sizeof ( mtuinfo ) ; memset ( & mtuinfo , 0 , sizeof ( mtuinfo ) ) ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) mtuinfo . ip6m_mtu = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! mtuinfo . ip6m_mtu ) return - ENOTCONN ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & mtuinfo , len ) ) return - EFAULT ; return 0 ; } case IPV6_TRANSPARENT : val = inet_sk ( sk ) -> transparent ; break ; case IPV6_RECVORIGDSTADDR : val = np -> rxopt . bits . rxorigdstaddr ; break ; case IPV6_UNICAST_HOPS : case IPV6_MULTICAST_HOPS : { struct dst_entry * dst ; if ( optname == IPV6_UNICAST_HOPS ) val = np -> hop_limit ; else val = np -> mcast_hops ; if ( val < 0 ) { rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = ip6_dst_hoplimit ( dst ) ; rcu_read_unlock ( ) ; } if ( val < 0 ) val = sock_net ( sk ) -> ipv6 . devconf_all -> hop_limit ; break ; } case IPV6_MULTICAST_LOOP : val = np -> mc_loop ; break ; case IPV6_MULTICAST_IF : val = np -> mcast_oif ; break ; case IPV6_UNICAST_IF : val = ( __force int ) htonl ( ( __u32 ) np -> ucast_oif ) ; break ; case IPV6_MTU_DISCOVER : val = np -> pmtudisc ; break ; case IPV6_RECVERR : val = np -> recverr ; break ; case IPV6_FLOWINFO_SEND : val = np -> sndflow ; break ; case IPV6_FLOWLABEL_MGR : { struct in6_flowlabel_req freq ; int flags ; if ( len < sizeof ( freq ) ) return - EINVAL ; if ( copy_from_user ( & freq , optval , sizeof ( freq ) ) ) return - EFAULT ; if ( freq . flr_action != IPV6_FL_A_GET ) return - EINVAL ; len = sizeof ( freq ) ; flags = freq . flr_flags ; memset ( & freq , 0 , sizeof ( freq ) ) ; val = ipv6_flowlabel_opt_get ( sk , & freq , flags ) ; if ( val < 0 ) return val ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & freq , len ) ) return - EFAULT ; return 0 ; } case IPV6_ADDR_PREFERENCES : val = 0 ; if ( np -> srcprefs & IPV6_PREFER_SRC_TMP ) val |= IPV6_PREFER_SRC_TMP ; else if ( np -> srcprefs & IPV6_PREFER_SRC_PUBLIC ) val |= IPV6_PREFER_SRC_PUBLIC ; else { val |= IPV6_PREFER_SRC_PUBTMP_DEFAULT ; } if ( np -> srcprefs & IPV6_PREFER_SRC_COA ) val |= IPV6_PREFER_SRC_COA ; else val |= IPV6_PREFER_SRC_HOME ; break ; case IPV6_MINHOPCOUNT : val = np -> min_hopcount ; break ; case IPV6_DONTFRAG : val = np -> dontfrag ; break ; case IPV6_AUTOFLOWLABEL : val = np -> autoflowlabel ; break ; default : return - ENOPROTOOPT ; } len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; <S2SV_ModStart> sk ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,337,<S2SV_ModStart> ; if ( opt <S2SV_ModEnd> opt. opt,0
860,CWE-189,"CWE-189 static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; <S2SV_StartBug> currkvno = key_data [ i ] . key_data_kvno ; <S2SV_EndBug> } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) { for ( i = 0 ; i <= num_versions ; i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }
","<S2SV_ModStart> + 1 ; if ( i < n_key_data - 1 ) <S2SV_ModStart> key_data [ i + 1
",krb5@krb5/dc7ed55c689d57de7f7408b34631bf06fec9dab1,CVE-2014-4345,https://github.com/krb5/krb5/commit/dc7ed55c689d57de7f7408b34631bf06fec9dab1,2014-08-14T05:01Z,338,<S2SV_ModStart> ; ret = k2SV_null> <S2SV_null>,0
863,CWE-787,"CWE-787 static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d<S2SV_blank>PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; <S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
","<S2SV_ModStart> 0x02 ) ; if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;
",OpenSC@OpenSC/9d294de90d1cc66956389856e60b6944b27b4817,CVE-2020-26572,https://github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817,2020-10-06T02:15Z,339,<S2SV_ModStart> ; if ( len > 0 ||,0
864,CWE-787,"CWE-787 static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , ""mcs_recv_connect_response(),<S2SV_blank>result=%d"" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
","<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,340,"<S2SV_ModStart> int length ; struct stream packet = * s ; <S2SV_ModStart> length ) ; struct stream packet = * s ; <S2SV_ModStart> length ) ; if (! s_check_rem ( s, length ) )",0
867,CWE-401,"CWE-401 static int i40e_setup_macvlans ( struct i40e_vsi * vsi , u16 macvlan_cnt , u16 qcnt , struct net_device * vdev ) { struct i40e_pf * pf = vsi -> back ; struct i40e_hw * hw = & pf -> hw ; struct i40e_vsi_context ctxt ; u16 sections , qmap , num_qps ; struct i40e_channel * ch ; int i , pow , ret = 0 ; u8 offset = 0 ; if ( vsi -> type != I40E_VSI_MAIN || ! macvlan_cnt ) return - EINVAL ; num_qps = vsi -> num_queue_pairs - ( macvlan_cnt * qcnt ) ; pow = fls ( roundup_pow_of_two ( num_qps ) - 1 ) ; qmap = ( offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT ) | ( pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT ) ; sections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID ; sections |= I40E_AQ_VSI_PROP_SCHED_VALID ; memset ( & ctxt , 0 , sizeof ( ctxt ) ) ; ctxt . seid = vsi -> seid ; ctxt . pf_num = vsi -> back -> hw . pf_id ; ctxt . vf_num = 0 ; ctxt . uplink_seid = vsi -> uplink_seid ; ctxt . info = vsi -> info ; ctxt . info . tc_mapping [ 0 ] = cpu_to_le16 ( qmap ) ; ctxt . info . mapping_flags |= cpu_to_le16 ( I40E_AQ_VSI_QUE_MAP_CONTIG ) ; ctxt . info . queue_mapping [ 0 ] = cpu_to_le16 ( vsi -> base_queue ) ; ctxt . info . valid_sections |= cpu_to_le16 ( sections ) ; vsi -> rss_size = max_t ( u16 , num_qps , qcnt ) ; ret = i40e_vsi_config_rss ( vsi ) ; if ( ret ) { dev_info ( & pf -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>reconfig<S2SV_blank>RSS<S2SV_blank>for<S2SV_blank>num_queues<S2SV_blank>(%u)\\n"" , vsi -> rss_size ) ; return ret ; } vsi -> reconfig_rss = true ; dev_dbg ( & vsi -> back -> pdev -> dev , ""Reconfigured<S2SV_blank>RSS<S2SV_blank>with<S2SV_blank>num_queues<S2SV_blank>(%u)\\n"" , vsi -> rss_size ) ; vsi -> next_base_queue = num_qps ; vsi -> cnt_q_avail = vsi -> num_queue_pairs - num_qps ; ret = i40e_aq_update_vsi_params ( hw , & ctxt , NULL ) ; if ( ret ) { dev_info ( & pf -> pdev -> dev , ""Update<S2SV_blank>vsi<S2SV_blank>tc<S2SV_blank>config<S2SV_blank>failed,<S2SV_blank>err<S2SV_blank>%s<S2SV_blank>aq_err<S2SV_blank>%s\\n"" , i40e_stat_str ( hw , ret ) , i40e_aq_str ( hw , hw -> aq . asq_last_status ) ) ; return ret ; } i40e_vsi_update_queue_map ( vsi , & ctxt ) ; vsi -> info . valid_sections = 0 ; INIT_LIST_HEAD ( & vsi -> macvlan_list ) ; for ( i = 0 ; i < macvlan_cnt ; i ++ ) { ch = kzalloc ( sizeof ( * ch ) , GFP_KERNEL ) ; if ( ! ch ) { ret = - ENOMEM ; goto err_free ; } INIT_LIST_HEAD ( & ch -> list ) ; ch -> num_queue_pairs = qcnt ; if ( ! i40e_setup_channel ( pf , vsi , ch ) ) { ret = - EINVAL ; <S2SV_StartBug> goto err_free ; <S2SV_EndBug> } ch -> parent_vsi = vsi ; vsi -> cnt_q_avail -= ch -> num_queue_pairs ; vsi -> macvlan_cnt ++ ; list_add_tail ( & ch -> list , & vsi -> macvlan_list ) ; } return ret ; err_free : dev_info ( & pf -> pdev -> dev , ""Failed<S2SV_blank>to<S2SV_blank>setup<S2SV_blank>macvlans\\n"" ) ; i40e_free_macvlan_channels ( vsi ) ; return ret ; }
","<S2SV_ModStart> - EINVAL ; kfree ( ch ) ;
",torvalds@linux/27d461333459d282ffa4a2bdb6b215a59d493a8f,CVE-2019-19043,https://github.com/torvalds/linux/commit/27d461333459d282ffa4a2bdb6b215a59d493a8f,2019-11-18T06:15Z,341,<S2SV_ModStart>,0
869,CWE-20,"CWE-20 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
",torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z,342,<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out,0
870,CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; } } return - 1 ;
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,343,,0
872,CWE-190,"CWE-190 jpc_streamlist_t * jpc_ppmstabtostreams ( jpc_ppxstab_t * tab ) { jpc_streamlist_t * streams ; <S2SV_StartBug> uchar * dataptr ; <S2SV_EndBug> uint_fast32_t datacnt ; uint_fast32_t tpcnt ; jpc_ppxstabent_t * ent ; int entno ; jas_stream_t * stream ; int n ; if ( ! ( streams = jpc_streamlist_create ( ) ) ) { goto error ; } if ( ! tab -> numents ) { return streams ; } entno = 0 ; ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; for ( ; ; ) { if ( datacnt < 4 ) { goto error ; } if ( ! ( stream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jpc_streamlist_insert ( streams , jpc_streamlist_numstreams ( streams ) , stream ) ) { goto error ; } tpcnt = ( dataptr [ 0 ] << 24 ) | ( dataptr [ 1 ] << 16 ) | ( dataptr [ 2 ] << 8 ) | dataptr [ 3 ] ; datacnt -= 4 ; dataptr += 4 ; while ( tpcnt ) { if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { goto error ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } n = JAS_MIN ( tpcnt , datacnt ) ; if ( jas_stream_write ( stream , dataptr , n ) != n ) { goto error ; } tpcnt -= n ; dataptr += n ; datacnt -= n ; } jas_stream_rewind ( stream ) ; if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { break ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } } return streams ; error : if ( streams ) { jpc_streamlist_destroy ( streams ) ; } return 0 ; }
","<S2SV_ModStart> * streams ; jas_uchar <S2SV_ModEnd> * dataptr ;
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,344,,0
873,CWE-119,"CWE-119 static void decode_mb_rows ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; MODE_INFO * lf_mic = xd -> mode_info_context ; int ibc = 0 ; int num_part = 1 << pc -> multi_token_partition ; int recon_yoffset , recon_uvoffset ; int mb_row , mb_col ; int mb_idx = 0 ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; int recon_y_stride = yv12_fb_new -> y_stride ; int recon_uv_stride = yv12_fb_new -> uv_stride ; unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; unsigned char * dst_buffer [ 3 ] ; unsigned char * lf_dst [ 3 ] ; unsigned char * eb_dst [ 3 ] ; int i ; int ref_fb_corrupted [ MAX_REF_FRAMES ] ; ref_fb_corrupted [ INTRA_FRAME ] = 0 ; for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) { YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; ref_fb_corrupted [ i ] = this_fb -> corrupted ; } eb_dst [ 0 ] = lf_dst [ 0 ] = dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; eb_dst [ 1 ] = lf_dst [ 1 ] = dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; eb_dst [ 2 ] = lf_dst [ 2 ] = dst_buffer [ 2 ] = yv12_fb_new -> v_buffer ; xd -> up_available = 0 ; if ( pc -> filter_level ) vp8_loop_filter_frame_init ( pc , xd , pc -> filter_level ) ; vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; for ( mb_row = 0 ; mb_row < pc -> mb_rows ; mb_row ++ ) { if ( num_part > 1 ) { xd -> current_bc = & pbi -> mbc [ ibc ] ; ibc ++ ; if ( ibc == num_part ) ibc = 0 ; } recon_yoffset = mb_row * recon_y_stride * 16 ; recon_uvoffset = mb_row * recon_uv_stride * 8 ; xd -> above_context = pc -> above_context ; <S2SV_StartBug> vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> xd -> left_available = 0 ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; xd -> mb_to_bottom_edge = ( ( pc -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; xd -> recon_above [ 0 ] = dst_buffer [ 0 ] + recon_yoffset ; xd -> recon_above [ 1 ] = dst_buffer [ 1 ] + recon_uvoffset ; xd -> recon_above [ 2 ] = dst_buffer [ 2 ] + recon_uvoffset ; xd -> recon_left [ 0 ] = xd -> recon_above [ 0 ] - 1 ; xd -> recon_left [ 1 ] = xd -> recon_above [ 1 ] - 1 ; xd -> recon_left [ 2 ] = xd -> recon_above [ 2 ] - 1 ; xd -> recon_above [ 0 ] -= xd -> dst . y_stride ; xd -> recon_above [ 1 ] -= xd -> dst . uv_stride ; xd -> recon_above [ 2 ] -= xd -> dst . uv_stride ; xd -> recon_left_stride [ 0 ] = xd -> dst . y_stride ; xd -> recon_left_stride [ 1 ] = xd -> dst . uv_stride ; setup_intra_recon_left ( xd -> recon_left [ 0 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> dst . y_stride , xd -> dst . uv_stride ) ; for ( mb_col = 0 ; mb_col < pc -> mb_cols ; mb_col ++ ) { xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( pc -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; # if CONFIG_ERROR_CONCEALMENT { int corrupt_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) || vp8dx_bool_error ( xd -> current_bc ) ; if ( pbi -> ec_active && xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME && corrupt_residual ) { vp8_interpolate_motion ( xd , mb_row , mb_col , pc -> mb_rows , pc -> mb_cols , pc -> mode_info_stride ) ; } } # endif xd -> dst . y_buffer = dst_buffer [ 0 ] + recon_yoffset ; xd -> dst . u_buffer = dst_buffer [ 1 ] + recon_uvoffset ; xd -> dst . v_buffer = dst_buffer [ 2 ] + recon_uvoffset ; <S2SV_StartBug> xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; <S2SV_EndBug> xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ; decode_macroblock ( pbi , xd , mb_idx ) ; mb_idx ++ ; xd -> left_available = 1 ; xd -> corrupted |= vp8dx_bool_error ( xd -> current_bc ) ; xd -> recon_above [ 0 ] += 16 ; xd -> recon_above [ 1 ] += 8 ; xd -> recon_above [ 2 ] += 8 ; xd -> recon_left [ 0 ] += 16 ; xd -> recon_left [ 1 ] += 8 ; xd -> recon_left [ 2 ] += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; ++ xd -> mode_info_context ; xd -> above_context ++ ; } vp8_extend_mb_row ( yv12_fb_new , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; ++ xd -> mode_info_context ; xd -> up_available = 1 ; if ( pc -> filter_level ) { if ( mb_row > 0 ) { if ( pc -> filter_type == NORMAL_LOOPFILTER ) vp8_loop_filter_row_normal ( pc , lf_mic , mb_row - 1 , recon_y_stride , recon_uv_stride , lf_dst [ 0 ] , lf_dst [ 1 ] , lf_dst [ 2 ] ) ; else vp8_loop_filter_row_simple ( pc , lf_mic , mb_row - 1 , recon_y_stride , recon_uv_stride , lf_dst [ 0 ] , lf_dst [ 1 ] , lf_dst [ 2 ] ) ; if ( mb_row > 1 ) { yv12_extend_frame_left_right_c ( yv12_fb_new , eb_dst [ 0 ] , eb_dst [ 1 ] , eb_dst [ 2 ] ) ; eb_dst [ 0 ] += recon_y_stride * 16 ; eb_dst [ 1 ] += recon_uv_stride * 8 ; eb_dst [ 2 ] += recon_uv_stride * 8 ; } lf_dst [ 0 ] += recon_y_stride * 16 ; lf_dst [ 1 ] += recon_uv_stride * 8 ; lf_dst [ 2 ] += recon_uv_stride * 8 ; lf_mic += pc -> mb_cols ; lf_mic ++ ; } } else { if ( mb_row > 0 ) { yv12_extend_frame_left_right_c ( yv12_fb_new , eb_dst [ 0 ] , eb_dst [ 1 ] , eb_dst [ 2 ] ) ; eb_dst [ 0 ] += recon_y_stride * 16 ; eb_dst [ 1 ] += recon_uv_stride * 8 ; eb_dst [ 2 ] += recon_uv_stride * 8 ; } } } if ( pc -> filter_level ) { if ( pc -> filter_type == NORMAL_LOOPFILTER ) vp8_loop_filter_row_normal ( pc , lf_mic , mb_row - 1 , recon_y_stride , recon_uv_stride , lf_dst [ 0 ] , lf_dst [ 1 ] , lf_dst [ 2 ] ) ; else vp8_loop_filter_row_simple ( pc , lf_mic , mb_row - 1 , recon_y_stride , recon_uv_stride , lf_dst [ 0 ] , lf_dst [ 1 ] , lf_dst [ 2 ] ) ; yv12_extend_frame_left_right_c ( yv12_fb_new , eb_dst [ 0 ] , eb_dst [ 1 ] , eb_dst [ 2 ] ) ; eb_dst [ 0 ] += recon_y_stride * 16 ; eb_dst [ 1 ] += recon_uv_stride * 8 ; eb_dst [ 2 ] += recon_uv_stride * 8 ; } yv12_extend_frame_left_right_c ( yv12_fb_new , eb_dst [ 0 ] , eb_dst [ 1 ] , eb_dst [ 2 ] ) ; yv12_extend_frame_top_c ( yv12_fb_new ) ; yv12_extend_frame_bottom_c ( yv12_fb_new ) ; }
","<S2SV_ModStart> -> above_context ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> + recon_uvoffset ; if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) { const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ; <S2SV_ModStart> = ref_buffer [ ref <S2SV_ModEnd> ] [ 0 <S2SV_ModStart> = ref_buffer [ ref <S2SV_ModEnd> ] [ 1 <S2SV_ModStart> = ref_buffer [ ref <S2SV_ModEnd> ] [ 2 <S2SV_ModStart> + recon_uvoffset ; } else { xd -> pre . y_buffer = 0 ; xd -> pre . u_buffer = 0 ; xd -> pre . v_buffer = 0 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,345,<S2SV_ModStart> ; memset <S2SV_ModEnd> ( pbi ->,0
876,CWE-772,"CWE-772 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; <S2SV_StartBug> } <S2SV_EndBug> clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> ) ; } quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
",ImageMagick@ImageMagick/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,CVE-2017-13146,https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,2017-08-23T06:29Z,346,<S2SV_ModStart>,0
878,CWE-125,"CWE-125 static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { <S2SV_StartBug> PyObject * u ; <S2SV_EndBug> char * buf ; char * p ; <S2SV_StartBug> const char * end ; <S2SV_EndBug> if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; <S2SV_StartBug> if ( * s & 0x80 ) { <S2SV_EndBug> strcpy ( p , ""u005c"" ) ; <S2SV_StartBug> p += 5 ; <S2SV_EndBug> } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } <S2SV_StartBug> assert ( p - buf <= Py_SIZE ( u ) ) ; <S2SV_EndBug> Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; <S2SV_StartBug> return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { PyObject * v , * <S2SV_ModStart> char * end ; const char * first_invalid_escape <S2SV_ModStart> ; if ( s >= end || <S2SV_ModStart> p += 5 ; if ( s >= end ) break <S2SV_ModStart> - buf <= PyBytes_GET_SIZE <S2SV_ModEnd> ( u ) <S2SV_ModStart> = buf ; v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ; if ( v != NULL && first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_XDECREF ( u ) ; Py_DECREF ( v ) ; return NULL ; } } Py_XDECREF ( u ) ; return v <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,347,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * s <S2SV_ModStart> char * s ; if ( void * s == NULL ) return NULL ; <S2SV_ModStart> * p ; if (! * s == NULL ) { Py_SetString ( p ) ; return NULL ; } if (! char * s ) { Py_SetString ( p ) ; return NULL ; } if (! p ) { Py_SetString ( p ) ; return NULL ; } * s = _PyObject_SetString ( p + 1 ; p ++ ; <S2SV_ModStart> * p ++ ; if (! buf ) { return NULL ; } * s = _PyObject_TypeError, & p ; } if (! p ) { return NULL ; } if (! char * s ) { return NULL ; } if (! char * s == NULL ) { return NULL ; } * s = p ++ ; } * s = p = p ++ ;",0
884,CWE-20,"CWE-20 void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; <S2SV_StartBug> struct stat stb ; <S2SV_EndBug> enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; <S2SV_StartBug> int setimes , targisdir , wrerrno = 0 ; <S2SV_EndBug> char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; if ( src != NULL && ! iamrecursive && ! Tflag ) { if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>expand<S2SV_blank>pattern"" , __func__ ) ; } for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; goto done ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; size = ( off_t ) ull ; if ( * cp == '\\0' || strchr ( cp , '/' ) != NULL || strcmp ( cp , ""."" ) == 0 || strcmp ( cp , "".."" ) == 0 ) { run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( npatterns > 0 ) { for ( n = 0 ; n < npatterns ; n ++ ) { if ( fnmatch ( patterns [ n ] , cp , 0 ) == 0 ) break ; } if ( n >= npatterns ) SCREWUP ( ""filename<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>request"" ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) == - 1 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect , src ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) == - 1 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) == - 1 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; <S2SV_StartBug> wrerr = NO ; <S2SV_EndBug> statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( ""%s"" , j != EPIPE ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { <S2SV_StartBug> if ( wrerr == NO ) { <S2SV_EndBug> if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; <S2SV_StartBug> if ( count != 0 && wrerr == NO && <S2SV_EndBug> atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && <S2SV_StartBug> ftruncate ( ofd , size ) != 0 ) { <S2SV_EndBug> run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> wrerr = DISPLAYED ; } } <S2SV_StartBug> if ( close ( ofd ) == - 1 ) { <S2SV_EndBug> wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; <S2SV_StartBug> if ( setimes && wrerr == NO ) { <S2SV_EndBug> setimes = 0 ; if ( utimes ( np , tv ) == - 1 ) { <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_EndBug> np , strerror ( errno ) ) ; <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case DISPLAYED : break ; } } done : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; return ; screwup : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> struct stat stb <S2SV_ModEnd> ; BUF * <S2SV_ModStart> , targisdir , wrerr <S2SV_ModEnd> ; char ch <S2SV_ModStart> ; wrerr = 0 <S2SV_ModEnd> ; statbytes = <S2SV_ModStart> { if ( ! wrerr <S2SV_ModEnd> ) { if <S2SV_ModStart> count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> != 0 && ! wrerr <S2SV_ModEnd> && atomicio ( <S2SV_ModStart> count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr <S2SV_ModEnd> && ( ! <S2SV_ModStart> != 0 ) note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( pflag <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> - 1 ) note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( setimes && ! wrerr <S2SV_ModEnd> ) { setimes <S2SV_ModStart> 1 ) { note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_ModStart> ) ) ; } } if ( note_err ( NULL ) == 0 ) <S2SV_ModEnd> ( void ) <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> } done :
",openssh@openssh-portable/aad87b88fc2536b1ea023213729aaf4eaabe1894,CVE-2020-12062,https://github.com/openssh/openssh-portable/commit/aad87b88fc2536b1ea023213729aaf4eaabe1894,2020-06-01T16:15Z,348,"<S2SV_ModStart> ; char * cp = NULL <S2SV_ModEnd> ; char * <S2SV_ModStart> ; char * cp = <S2SV_ModEnd> ; char * <S2SV_ModStart> ; char * cp = <S2SV_ModEnd> ; if ( strcmp ( cp, <S2SV_ModStart> ( cp, <S2SV_ModEnd> ) == 0 || strcmp ( cp, <S2SV_ModStart> ) == 0 || <S2SV_ModEnd> ( cp,",0
886,CWE-476,"CWE-476 static int ghash_final ( struct shash_desc * desc , u8 * dst ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * buf = dctx -> buffer ; <S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ; return 0 ; }
","<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
",torvalds@linux/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,CVE-2011-4081,https://github.com/torvalds/linux/commit/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,2012-05-24T23:55Z,349,<S2SV_ModStart> -> buffer ; if (! ctx -> buffer ) return - EINVAL,0
889,CWE-119,"CWE-119 <S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> return word >= test ; }
","<S2SV_ModStart> int write_bit_gte ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> test ) { vpx_write_literal <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,350,"<S2SV_ModStart> int w, vpx_write_literal <S2SV_ModEnd> ( w,",0
893,CWE-119,"CWE-119 int vp8_alloc_frame_buffers ( VP8_COMMON * oci , int width , int height ) { int i ; vp8_de_alloc_frame_buffers ( oci ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; for ( i = 0 ; i < NUM_YV12_BUFFERS ; i ++ ) { oci -> fb_idx_ref_cnt [ i ] = 0 ; oci -> yv12_fb [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> yv12_fb [ i ] , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; } oci -> new_fb_idx = 0 ; oci -> lst_fb_idx = 1 ; oci -> gld_fb_idx = 2 ; oci -> alt_fb_idx = 3 ; oci -> fb_idx_ref_cnt [ 0 ] = 1 ; oci -> fb_idx_ref_cnt [ 1 ] = 1 ; oci -> fb_idx_ref_cnt [ 2 ] = 1 ; oci -> fb_idx_ref_cnt [ 3 ] = 1 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> temp_scale_frame , width , 16 , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> mb_rows = height >> 4 ; oci -> mb_cols = width >> 4 ; oci -> MBs = oci -> mb_rows * oci -> mb_cols ; oci -> mode_info_stride = oci -> mb_cols + 1 ; oci -> mip = vpx_calloc ( ( oci -> mb_cols + 1 ) * ( oci -> mb_rows + 1 ) , sizeof ( MODE_INFO ) ) ; if ( ! oci -> mip ) goto allocation_fail ; oci -> mi = oci -> mip + oci -> mode_info_stride + 1 ; oci -> above_context = vpx_calloc ( sizeof ( ENTROPY_CONTEXT_PLANES ) * oci -> mb_cols , 1 ) ; if ( ! oci -> above_context ) goto allocation_fail ; # if CONFIG_POSTPROC if ( vp8_yv12_alloc_frame_buffer ( & oci -> post_proc_buffer , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> post_proc_buffer_int_used = 0 ; <S2SV_StartBug> vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , <S2SV_EndBug> oci -> post_proc_buffer . frame_size ) ; oci -> pp_limits_buffer = vpx_memalign ( 16 , 24 * ( ( oci -> mb_cols + 1 ) & ~ 1 ) ) ; if ( ! oci -> pp_limits_buffer ) goto allocation_fail ; # endif return 0 ; allocation_fail : vp8_de_alloc_frame_buffers ( oci ) ; return 1 ; }
","<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( & oci <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( oci ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,351,<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( ),0
901,CWE-119,"CWE-119 void vp8_optimize_mby ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; if ( ! x -> e_mbd . above_context ) return ; if ( ! x -> e_mbd . left_context ) return ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }
","<S2SV_ModStart> ) return ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,352,<S2SV_ModStart> ) return ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left,1
903,CWE-20,"CWE-20 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;
",external@libavc/d4841f1161bdb5e13cb19e81af42437a634dd6ef,CVE-2016-3755,https://android.googlesource.com/platform/external/libavc/+/d4841f1161bdb5e13cb19e81af42437a634dd6ef,2016-07-11T01:59Z,353,<S2SV_ModStart> ) ; } <S2SV_ModEnd> } else {,0
909,CWE-476,"CWE-476 INTERNAL void vterm_screen_free ( VTermScreen * screen ) { vterm_allocator_free ( screen -> vt , screen -> buffers [ 0 ] ) ; <S2SV_StartBug> if ( screen -> buffers [ 1 ] ) <S2SV_EndBug> vterm_allocator_free ( screen -> vt , screen -> buffers [ 1 ] ) ; vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; vterm_allocator_free ( screen -> vt , screen ) ; }
","<S2SV_ModStart> ] ) ; <S2SV_ModEnd> vterm_allocator_free ( screen
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z,354,,0
913,CWE-284,"CWE-284 void GKI_delay ( UINT32 timeout_ms ) { struct timespec delay ; delay . tv_sec = timeout_ms / 1000 ; delay . tv_nsec = 1000 * 1000 * ( timeout_ms % 1000 ) ; int err ; do { <S2SV_StartBug> err = nanosleep ( & delay , & delay ) ; <S2SV_EndBug> } while ( err == - 1 && errno == EINTR ) ; }
","<S2SV_ModStart> { err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & delay )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,355,<S2SV_ModStart> ; err = TEMP_FAILURE_RETRY (,0
915,CWE-119,"CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , <S2SV_StartBug> offset , <S2SV_EndBug> pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length ) <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length )
",ImageMagick@ImageMagick/139d4323c40d7363bfdd2382c3821a6f76d69430,CVE-2016-10050,https://github.com/ImageMagick/ImageMagick/commit/139d4323c40d7363bfdd2382c3821a6f76d69430,2017-03-23T17:59Z,356,<S2SV_ModStart> image_info -> rows * rows <S2SV_ModEnd> ; number_planes =,0
918,CWE-000,"CWE-000 static int virtualHostDirective ( MaState * state , cchar * key , cchar * value ) { state = maPushState ( state ) ; if ( state -> enabled ) { state -> route = httpCreateInheritedRoute ( httpGetHostDefaultRoute ( state -> host ) ) ; state -> route -> ssl = 0 ; state -> auth = state -> route -> auth ; state -> host = httpCloneHost ( state -> host ) ; httpResetRoutes ( state -> host ) ; httpSetRouteHost ( state -> route , state -> host ) ; httpSetHostDefaultRoute ( state -> host , state -> route ) ; if ( value ) { <S2SV_StartBug> httpSetHostName ( state -> host , stok ( sclone ( value ) , ""<S2SV_blank>\\t,"" , NULL ) ) ; <S2SV_EndBug> httpSetRouteName ( state -> route , sfmt ( ""default-%s"" , state -> host -> name ) ) ; state -> endpoints = sclone ( value ) ; } } return 0 ; }
","<S2SV_ModStart> -> host , ssplit <S2SV_ModEnd> ( sclone (
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,357,,0
919,CWE-476,"CWE-476 struct key * request_key_and_link ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * key ; key_ref_t key_ref ; int ret ; kenter ( ""%s,%s,%p,%zu,%p,%p,%lx"" , ctx . index_key . type -> name , ctx . index_key . description , callout_info , callout_len , aux , dest_keyring , flags ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } key_ref = search_process_keyrings ( & ctx ) ; if ( ! IS_ERR ( key_ref ) ) { key = key_ref_to_ptr ( key_ref ) ; if ( dest_keyring ) { construct_get_dest_keyring ( & dest_keyring ) ; ret = key_link ( dest_keyring , key ) ; key_put ( dest_keyring ) ; if ( ret < 0 ) { key_put ( key ) ; key = ERR_PTR ( ret ) ; goto error_free ; } } } else if ( PTR_ERR ( key_ref ) != - EAGAIN ) { key = ERR_CAST ( key_ref ) ; } else { key = ERR_PTR ( - ENOKEY ) ; if ( ! callout_info ) goto error_free ; key = construct_key_and_link ( & ctx , callout_info , callout_len , aux , dest_keyring , flags ) ; } error_free : if ( type -> match_free ) type -> match_free ( & ctx . match_data ) ; error : kleave ( ""<S2SV_blank>=<S2SV_blank>%p"" , key ) ; return key ; }
","<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
",torvalds@linux/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,CVE-2017-2647,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,2017-03-31T04:59Z,358,,0
921,CWE-119,"CWE-119 static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; <S2SV_StartBug> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <S2SV_EndBug> <S2SV_StartBug> if ( job_id ) <S2SV_EndBug> free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ; snprintf ( pool -> prev_hash , 65 , ""%s"" , prev_hash ) ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; snprintf ( pool -> bbversion , 9 , ""%s"" , bbversion ) ; snprintf ( pool -> nbit , 9 , ""%s"" , nbit ) ; snprintf ( pool -> ntime , 9 , ""%s"" , ntime ) ; pool -> swork . clean = clean ; alloc_len = pool -> coinbase_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; pool -> nonce2_offset = cb1_len + pool -> n1_len ; for ( i = 0 ; i < pool -> merkles ; i ++ ) free ( pool -> swork . merkle_bin [ i ] ) ; if ( merkles ) { pool -> swork . merkle_bin = realloc ( pool -> swork . merkle_bin , sizeof ( char * ) * merkles + 1 ) ; for ( i = 0 ; i < merkles ; i ++ ) { char * merkle = json_array_string ( arr , i ) ; pool -> swork . merkle_bin [ i ] = malloc ( 32 ) ; if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>malloc<S2SV_blank>pool<S2SV_blank>swork<S2SV_blank>merkle_bin"" ) ; if ( opt_protocol ) applog ( LOG_DEBUG , ""merkle<S2SV_blank>%d:<S2SV_blank>%s"" , i , merkle ) ; ret = hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; free ( merkle ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>merkle<S2SV_blank>to<S2SV_blank>merkle_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } } } pool -> merkles = merkles ; if ( clean ) pool -> nonce2 = 0 ; # if 0 header_len = strlen ( pool -> bbversion ) + strlen ( pool -> prev_hash ) ; 32 + strlen ( pool -> ntime ) + strlen ( pool -> nbit ) + 8 + 96 ; # endif snprintf ( header , 225 , ""%s%s%s%s%s%s%s"" , pool -> bbversion , pool -> prev_hash , blank_merkle , pool -> ntime , pool -> nbit , ""00000000"" , workpadding ) ; ret = hex2bin ( pool -> header_bin , header , 112 ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } cb1 = alloca ( cb1_len ) ; ret = hex2bin ( cb1 , coinbase1 , cb1_len ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>cb1<S2SV_blank>to<S2SV_blank>cb1_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } cb2 = alloca ( cb2_len ) ; ret = hex2bin ( cb2 , coinbase2 , cb2_len ) ; if ( unlikely ( ! ret ) ) { applog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>cb2<S2SV_blank>to<S2SV_blank>cb2_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; goto out_unlock ; } free ( pool -> coinbase ) ; align_len ( & alloc_len ) ; pool -> coinbase = calloc ( alloc_len , 1 ) ; if ( unlikely ( ! pool -> coinbase ) ) quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool<S2SV_blank>coinbase<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; memcpy ( pool -> coinbase , cb1 , cb1_len ) ; memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; if ( opt_debug ) { char * cb = bin2hex ( pool -> coinbase , pool -> coinbase_len ) ; applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>coinbase<S2SV_blank>%s"" , pool -> pool_no , cb ) ; free ( cb ) ; } out_unlock : cg_wunlock ( & pool -> data_lock ) ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""job_id:<S2SV_blank>%s"" , job_id ) ; applog ( LOG_DEBUG , ""prev_hash:<S2SV_blank>%s"" , prev_hash ) ; applog ( LOG_DEBUG , ""coinbase1:<S2SV_blank>%s"" , coinbase1 ) ; applog ( LOG_DEBUG , ""coinbase2:<S2SV_blank>%s"" , coinbase2 ) ; applog ( LOG_DEBUG , ""bbversion:<S2SV_blank>%s"" , bbversion ) ; applog ( LOG_DEBUG , ""nbit:<S2SV_blank>%s"" , nbit ) ; applog ( LOG_DEBUG , ""ntime:<S2SV_blank>%s"" , ntime ) ; applog ( LOG_DEBUG , ""clean:<S2SV_blank>%s"" , clean ? ""yes"" : ""no"" ) ; } free ( coinbase1 ) ; free ( coinbase2 ) ; pool -> getwork_requested ++ ; total_getworks ++ ; if ( pool == current_pool ( ) ) opt_work_update = true ; out : return ret ; }
","<S2SV_ModStart> if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> ( job_id ) <S2SV_ModStart> ( job_id ) ; free ( coinbase1 ) ; <S2SV_ModEnd> free ( coinbase2
",sgminer-dev@sgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4502,https://github.com/sgminer-dev/sgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z,359,<S2SV_ModStart>,0
922,CWE-284,"CWE-284 static uint16_t transmit_data_on ( int fd , uint8_t * data , uint16_t length ) { assert ( data != NULL ) ; assert ( length > 0 ) ; uint16_t transmitted_length = 0 ; while ( length > 0 ) { <S2SV_StartBug> ssize_t ret = write ( fd , data + transmitted_length , length ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : LOG_ERROR ( ""In<S2SV_blank>%s,<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>the<S2SV_blank>serial<S2SV_blank>port<S2SV_blank>with<S2SV_blank>fd<S2SV_blank>%d:<S2SV_blank>%s"" , __func__ , fd , strerror ( errno ) ) ; return transmitted_length ; case 0 : return transmitted_length ; default : transmitted_length += ret ; length -= ret ; break ; } } return transmitted_length ; }
","<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> transmitted_length , length )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,360,<S2SV_ModStart> return - 1,0
924,CWE-400,"CWE-400 void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; <S2SV_StartBug> put_io_context ( ioc ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ioc ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/61cc74fbb87af6aa551a06a370590c9bc07e29d9,CVE-2012-0879,https://github.com/torvalds/linux/commit/61cc74fbb87af6aa551a06a370590c9bc07e29d9,2012-05-17T11:00Z,361,<S2SV_ModStart> ioc ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,1
925,CWE-125,"CWE-125 static PyObject * ast_type_reduce ( PyObject * self , PyObject * unused ) { <S2SV_StartBug> PyObject * res ; <S2SV_EndBug> _Py_IDENTIFIER ( __dict__ ) ; <S2SV_StartBug> PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ ) ; <S2SV_EndBug> if ( dict == NULL ) { if ( PyErr_ExceptionMatches ( PyExc_AttributeError ) ) PyErr_Clear ( ) ; else return NULL ; } if ( dict ) { <S2SV_StartBug> res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ; <S2SV_EndBug> Py_DECREF ( dict ) ; return res ; } return Py_BuildValue ( ""O()"" , Py_TYPE ( self ) ) ; }
","<S2SV_ModStart> unused ) { <S2SV_ModEnd> _Py_IDENTIFIER ( __dict__ <S2SV_ModStart> PyObject * dict ; if ( lookup_attr_id <S2SV_ModEnd> ( self , <S2SV_ModStart> , & PyId___dict__ , & dict ) < 0 ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> dict ) { return Py_BuildValue ( ""O()N"" <S2SV_ModEnd> , Py_TYPE ( <S2SV_ModStart> , dict ) <S2SV_ModEnd> ; } return
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,362,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
926,CWE-400,"CWE-400 static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , <S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , ""Dual-Role<S2SV_blank>OTG<S2SV_blank>device<S2SV_blank>on<S2SV_blank>%sHNP<S2SV_blank>port\\n"" , ( port1 == bus -> otg_port ) ? """" : ""non-"" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , ""can\'t<S2SV_blank>set<S2SV_blank>HNP<S2SV_blank>mode:<S2SV_blank>%d\\n"" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , ""set<S2SV_blank>a_alt_hnp_support<S2SV_blank>failed:<S2SV_blank>%d\\n"" , err ) ; } } # endif return err ; }
","<S2SV_ModStart> ) & desc , sizeof ( * desc )
",torvalds@linux/704620afc70cf47abb9d6a1a57f3825d2bca49cf,CVE-2018-20169,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,2018-12-17T07:29Z,363,<S2SV_ModStart> ) & desc -> bNumEndpoints,0
927,CWE-264,"CWE-264 static long perf_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct perf_event * event = file -> private_data ; <S2SV_StartBug> void ( * func ) ( struct perf_event * ) ; <S2SV_EndBug> u32 flags = arg ; switch ( cmd ) { case PERF_EVENT_IOC_ENABLE : func = perf_event_enable ; break ; case PERF_EVENT_IOC_DISABLE : func = perf_event_disable ; break ; case PERF_EVENT_IOC_RESET : func = perf_event_reset ; break ; case PERF_EVENT_IOC_REFRESH : return perf_event_refresh ( event , arg ) ; <S2SV_StartBug> case PERF_EVENT_IOC_PERIOD : <S2SV_EndBug> <S2SV_StartBug> return perf_event_period ( event , ( u64 __user * ) arg ) ; <S2SV_EndBug> case PERF_EVENT_IOC_ID : { u64 id = primary_event_id ( event ) ; if ( copy_to_user ( ( void __user * ) arg , & id , sizeof ( id ) ) ) return - EFAULT ; return 0 ; } case PERF_EVENT_IOC_SET_OUTPUT : { int ret ; if ( arg != - 1 ) { struct perf_event * output_event ; struct fd output ; ret = perf_fget_light ( arg , & output ) ; if ( ret ) return ret ; output_event = output . file -> private_data ; ret = perf_event_set_output ( event , output_event ) ; fdput ( output ) ; } else { ret = perf_event_set_output ( event , NULL ) ; } return ret ; } <S2SV_StartBug> case PERF_EVENT_IOC_SET_FILTER : <S2SV_EndBug> return perf_event_set_filter ( event , ( void __user * ) arg ) ; default : return - ENOTTY ; } if ( flags & PERF_IOC_FLAG_GROUP ) perf_event_for_each ( event , func ) ; else perf_event_for_each_child ( event , func ) ; return 0 ; }
","<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; long ret ; ctx = perf_event_ctx_lock ( event ) ; ret = _perf_ioctl ( event , cmd <S2SV_ModEnd> , arg ) <S2SV_ModStart> arg ) ; perf_event_ctx_unlock <S2SV_ModEnd> ( event , <S2SV_ModStart> ( event , ctx ) ; <S2SV_ModEnd> return ret ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z,364,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int perf_event_event_event_event_event_event_event_event_event ( <S2SV_ModEnd> ( event, <S2SV_ModStart> event_event_event_event_event_event_event_event_event ( event, <S2SV_ModEnd> ) ) return",0
929,CWE-119,"CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE y_mode ) { <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . uv_mode_prob [ y_mode ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . uv_mode [ y_mode ] [ uv_mode ] ; return uv_mode ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_uv ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> * r , PREDICTION_MODE <S2SV_ModEnd> y_mode ) { <S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> uv_mode = read_intra_mode <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> uv_mode_prob [ y_mode <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> uv_mode [ y_mode
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,365,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_mode_mode ( VP9_MODE <S2SV_ModStart> * r, PREDICTION_mode, PREDICTION_MODE <S2SV_ModEnd> * r, <S2SV_ModStart> * r, vpx_mode_mode_mode_mode_mode_mode_mode, PREDICTION_MODE <S2SV_ModStart> * r, PREDICTION_mode, vpx_mode_mode_mode_mode_mode_mode <S2SV_ModEnd> * r )",0
931,CWE-401,"CWE-401 static noinline_for_stack int ccp_run_sha_cmd ( struct ccp_cmd_queue * cmd_q , struct ccp_cmd * cmd ) { struct ccp_sha_engine * sha = & cmd -> u . sha ; struct ccp_dm_workarea ctx ; struct ccp_data src ; struct ccp_op op ; unsigned int ioffset , ooffset ; unsigned int digest_size ; int sb_count ; const void * init ; u64 block_size ; int ctx_size ; int ret ; switch ( sha -> type ) { case CCP_SHA_TYPE_1 : if ( sha -> ctx_len < SHA1_DIGEST_SIZE ) return - EINVAL ; block_size = SHA1_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_224 : if ( sha -> ctx_len < SHA224_DIGEST_SIZE ) return - EINVAL ; block_size = SHA224_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_256 : if ( sha -> ctx_len < SHA256_DIGEST_SIZE ) return - EINVAL ; block_size = SHA256_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_384 : if ( cmd_q -> ccp -> vdata -> version < CCP_VERSION ( 4 , 0 ) || sha -> ctx_len < SHA384_DIGEST_SIZE ) return - EINVAL ; block_size = SHA384_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_512 : if ( cmd_q -> ccp -> vdata -> version < CCP_VERSION ( 4 , 0 ) || sha -> ctx_len < SHA512_DIGEST_SIZE ) return - EINVAL ; block_size = SHA512_BLOCK_SIZE ; break ; default : return - EINVAL ; } if ( ! sha -> ctx ) return - EINVAL ; if ( ! sha -> final && ( sha -> src_len & ( block_size - 1 ) ) ) return - EINVAL ; if ( cmd_q -> ccp -> vdata -> version == CCP_VERSION ( 3 , 0 ) ) { if ( ! sha -> src_len ) { unsigned int digest_len ; const u8 * sha_zero ; if ( ! sha -> final ) return 0 ; if ( sha -> msg_bits ) return - EINVAL ; switch ( sha -> type ) { case CCP_SHA_TYPE_1 : sha_zero = sha1_zero_message_hash ; digest_len = SHA1_DIGEST_SIZE ; break ; case CCP_SHA_TYPE_224 : sha_zero = sha224_zero_message_hash ; digest_len = SHA224_DIGEST_SIZE ; break ; case CCP_SHA_TYPE_256 : sha_zero = sha256_zero_message_hash ; digest_len = SHA256_DIGEST_SIZE ; break ; default : return - EINVAL ; } scatterwalk_map_and_copy ( ( void * ) sha_zero , sha -> ctx , 0 , digest_len , 1 ) ; return 0 ; } } switch ( sha -> type ) { case CCP_SHA_TYPE_1 : digest_size = SHA1_DIGEST_SIZE ; init = ( void * ) ccp_sha1_init ; ctx_size = SHA1_DIGEST_SIZE ; sb_count = 1 ; if ( cmd_q -> ccp -> vdata -> version != CCP_VERSION ( 3 , 0 ) ) ooffset = ioffset = CCP_SB_BYTES - SHA1_DIGEST_SIZE ; else ooffset = ioffset = 0 ; break ; case CCP_SHA_TYPE_224 : digest_size = SHA224_DIGEST_SIZE ; init = ( void * ) ccp_sha224_init ; ctx_size = SHA256_DIGEST_SIZE ; sb_count = 1 ; ioffset = 0 ; if ( cmd_q -> ccp -> vdata -> version != CCP_VERSION ( 3 , 0 ) ) ooffset = CCP_SB_BYTES - SHA224_DIGEST_SIZE ; else ooffset = 0 ; break ; case CCP_SHA_TYPE_256 : digest_size = SHA256_DIGEST_SIZE ; init = ( void * ) ccp_sha256_init ; ctx_size = SHA256_DIGEST_SIZE ; sb_count = 1 ; ooffset = ioffset = 0 ; break ; case CCP_SHA_TYPE_384 : digest_size = SHA384_DIGEST_SIZE ; init = ( void * ) ccp_sha384_init ; ctx_size = SHA512_DIGEST_SIZE ; sb_count = 2 ; ioffset = 0 ; ooffset = 2 * CCP_SB_BYTES - SHA384_DIGEST_SIZE ; break ; case CCP_SHA_TYPE_512 : digest_size = SHA512_DIGEST_SIZE ; init = ( void * ) ccp_sha512_init ; ctx_size = SHA512_DIGEST_SIZE ; sb_count = 2 ; ooffset = ioffset = 0 ; break ; default : ret = - EINVAL ; goto e_data ; } if ( sha -> src_len && ! sha -> src ) return - EINVAL ; memset ( & op , 0 , sizeof ( op ) ) ; op . cmd_q = cmd_q ; op . jobid = CCP_NEW_JOBID ( cmd_q -> ccp ) ; op . sb_ctx = cmd_q -> sb_ctx ; op . u . sha . type = sha -> type ; op . u . sha . msg_bits = sha -> msg_bits ; ret = ccp_init_dm_workarea ( & ctx , cmd_q , sb_count * CCP_SB_BYTES , DMA_BIDIRECTIONAL ) ; if ( ret ) return ret ; if ( sha -> first ) { switch ( sha -> type ) { case CCP_SHA_TYPE_1 : case CCP_SHA_TYPE_224 : case CCP_SHA_TYPE_256 : memcpy ( ctx . address + ioffset , init , ctx_size ) ; break ; case CCP_SHA_TYPE_384 : case CCP_SHA_TYPE_512 : memcpy ( ctx . address + ctx_size / 2 , init , ctx_size / 2 ) ; memcpy ( ctx . address , init + ctx_size / 2 , ctx_size / 2 ) ; break ; default : ret = - EINVAL ; goto e_ctx ; } } else { ret = ccp_set_dm_area ( & ctx , 0 , sha -> ctx , 0 , sb_count * CCP_SB_BYTES ) ; if ( ret ) goto e_ctx ; } ret = ccp_copy_to_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_ctx ; } if ( sha -> src ) { ret = ccp_init_data ( & src , cmd_q , sha -> src , sha -> src_len , block_size , DMA_TO_DEVICE ) ; if ( ret ) goto e_ctx ; while ( src . sg_wa . bytes_left ) { ccp_prepare_data ( & src , NULL , & op , block_size , false ) ; if ( sha -> final && ! src . sg_wa . bytes_left ) op . eom = 1 ; ret = cmd_q -> ccp -> vdata -> perform -> sha ( & op ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_data ; } ccp_process_data ( & src , NULL , & op ) ; } } else { op . eom = 1 ; ret = cmd_q -> ccp -> vdata -> perform -> sha ( & op ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_data ; } } ret = ccp_copy_from_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ; if ( ret ) { cmd -> engine_error = cmd_q -> cmd_error ; goto e_data ; } if ( sha -> final ) { switch ( sha -> type ) { case CCP_SHA_TYPE_1 : case CCP_SHA_TYPE_224 : case CCP_SHA_TYPE_256 : ccp_get_dm_area ( & ctx , ooffset , sha -> ctx , 0 , digest_size ) ; break ; case CCP_SHA_TYPE_384 : case CCP_SHA_TYPE_512 : ccp_get_dm_area ( & ctx , 0 , sha -> ctx , LSB_ITEM_SIZE - ooffset , LSB_ITEM_SIZE ) ; ccp_get_dm_area ( & ctx , LSB_ITEM_SIZE + ooffset , sha -> ctx , 0 , LSB_ITEM_SIZE - ooffset ) ; break ; default : ret = - EINVAL ; goto e_ctx ; } } else { ccp_get_dm_area ( & ctx , 0 , sha -> ctx , 0 , sb_count * CCP_SB_BYTES ) ; } if ( sha -> final && sha -> opad ) { struct ccp_cmd hmac_cmd ; struct scatterlist sg ; u8 * hmac_buf ; if ( sha -> opad_len != block_size ) { ret = - EINVAL ; goto e_data ; } hmac_buf = kmalloc ( block_size + digest_size , GFP_KERNEL ) ; if ( ! hmac_buf ) { ret = - ENOMEM ; goto e_data ; } sg_init_one ( & sg , hmac_buf , block_size + digest_size ) ; scatterwalk_map_and_copy ( hmac_buf , sha -> opad , 0 , block_size , 0 ) ; switch ( sha -> type ) { case CCP_SHA_TYPE_1 : case CCP_SHA_TYPE_224 : case CCP_SHA_TYPE_256 : memcpy ( hmac_buf + block_size , ctx . address + ooffset , digest_size ) ; break ; case CCP_SHA_TYPE_384 : case CCP_SHA_TYPE_512 : memcpy ( hmac_buf + block_size , ctx . address + LSB_ITEM_SIZE + ooffset , LSB_ITEM_SIZE ) ; memcpy ( hmac_buf + block_size + ( LSB_ITEM_SIZE - ooffset ) , ctx . address , LSB_ITEM_SIZE ) ; break ; default : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto e_ctx ; <S2SV_EndBug> } memset ( & hmac_cmd , 0 , sizeof ( hmac_cmd ) ) ; hmac_cmd . engine = CCP_ENGINE_SHA ; hmac_cmd . u . sha . type = sha -> type ; hmac_cmd . u . sha . ctx = sha -> ctx ; hmac_cmd . u . sha . ctx_len = sha -> ctx_len ; hmac_cmd . u . sha . src = & sg ; hmac_cmd . u . sha . src_len = block_size + digest_size ; hmac_cmd . u . sha . opad = NULL ; hmac_cmd . u . sha . opad_len = 0 ; hmac_cmd . u . sha . first = 1 ; hmac_cmd . u . sha . final = 1 ; hmac_cmd . u . sha . msg_bits = ( block_size + digest_size ) << 3 ; ret = ccp_run_sha_cmd ( cmd_q , & hmac_cmd ) ; if ( ret ) cmd -> engine_error = hmac_cmd . engine_error ; kfree ( hmac_buf ) ; } e_data : if ( sha -> src ) ccp_free_data ( & src , cmd_q ) ; e_ctx : ccp_dm_free ( & ctx ) ; return ret ; }
","<S2SV_ModStart> ; default : kfree ( hmac_buf ) ; <S2SV_ModStart> EINVAL ; goto e_data <S2SV_ModEnd> ; } memset
",torvalds@linux/128c66429247add5128c03dc1e144ca56f05a4e2,CVE-2019-18808,https://github.com/torvalds/linux/commit/128c66429247add5128c03dc1e144ca56f05a4e2,2019-11-07T16:15Z,366,<S2SV_ModStart> return - 1 <S2SV_ModEnd> ; } if (,0
933,CWE-326,"CWE-326 static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , ""13"" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , ""salt<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>8-octet<S2SV_blank>string"" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; <S2SV_StartBug> return Qnil ; <S2SV_EndBug> }
","<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z,367,<S2SV_ModStart> NULL ) ; if ( key_len == NULL ) ocipher = 0 ;,0
935,CWE-119,"CWE-119 static int stellaris_enet_init ( SysBusDevice * sbd ) { DeviceState * dev = DEVICE ( sbd ) ; stellaris_enet_state * s = STELLARIS_ENET ( dev ) ; memory_region_init_io ( & s -> mmio , OBJECT ( s ) , & stellaris_enet_ops , s , ""stellaris_enet"" , 0x1000 ) ; sysbus_init_mmio ( sbd , & s -> mmio ) ; sysbus_init_irq ( sbd , & s -> irq ) ; qemu_macaddr_default_if_unset ( & s -> conf . macaddr ) ; s -> nic = qemu_new_nic ( & net_stellaris_enet_info , & s -> conf , object_get_typename ( OBJECT ( dev ) ) , dev -> id , s ) ; qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ; stellaris_enet_reset ( s ) ; <S2SV_StartBug> register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , <S2SV_EndBug> stellaris_enet_save , stellaris_enet_load , s ) ; return 0 ; }
","<S2SV_ModStart> s ) ; <S2SV_ModEnd> return 0 ;
",qemu@qemu/2e1198672759eda6e122ff38fcf6df06f27e0fe2,CVE-2013-4532,https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2,2020-01-02T16:15Z,368,<S2SV_ModStart>,0
942,CWE-400,"CWE-400 ssize_t nghttp2_session_mem_recv ( nghttp2_session * session , const uint8_t * in , size_t inlen ) { const uint8_t * first = in , * last = in + inlen ; nghttp2_inbound_frame * iframe = & session -> iframe ; size_t readlen ; ssize_t padlen ; int rv ; int busy = 0 ; nghttp2_frame_hd cont_hd ; nghttp2_stream * stream ; size_t pri_fieldlen ; nghttp2_mem * mem ; DEBUGF ( ""recv:<S2SV_blank>connection<S2SV_blank>recv_window_size=%d,<S2SV_blank>local_window=%d\\n"" , session -> recv_window_size , session -> local_window_size ) ; mem = & session -> mem ; rv = nghttp2_session_adjust_idle_stream ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( ! nghttp2_session_want_read ( session ) ) { return ( ssize_t ) inlen ; } for ( ; ; ) { switch ( iframe -> state ) { case NGHTTP2_IB_READ_CLIENT_MAGIC : readlen = nghttp2_min ( inlen , iframe -> payloadleft ) ; if ( memcmp ( & NGHTTP2_CLIENT_MAGIC [ NGHTTP2_CLIENT_MAGIC_LEN - iframe -> payloadleft ] , in , readlen ) != 0 ) { return NGHTTP2_ERR_BAD_CLIENT_MAGIC ; } iframe -> payloadleft -= readlen ; in += readlen ; if ( iframe -> payloadleft == 0 ) { session_inbound_frame_reset ( session ) ; iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } break ; case NGHTTP2_IB_READ_FIRST_SETTINGS : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_FIRST_SETTINGS]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } if ( iframe -> sbuf . pos [ 3 ] != NGHTTP2_SETTINGS || ( iframe -> sbuf . pos [ 4 ] & NGHTTP2_FLAG_ACK ) ) { rv = session_call_error_callback ( session , NGHTTP2_ERR_SETTINGS_EXPECTED , ""Remote<S2SV_blank>peer<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>data<S2SV_blank>while<S2SV_blank>we<S2SV_blank>expected<S2SV_blank>"" ""SETTINGS<S2SV_blank>frame.<S2SV_blank><S2SV_blank>Perhaps,<S2SV_blank>peer<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>HTTP/2<S2SV_blank>"" ""properly."" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""SETTINGS<S2SV_blank>expected"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> state = NGHTTP2_IB_READ_HEAD ; case NGHTTP2_IB_READ_HEAD : { int on_begin_frame_called = 0 ; DEBUGF ( ""recv:<S2SV_blank>[IB_READ_HEAD]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } nghttp2_frame_unpack_frame_hd ( & iframe -> frame . hd , iframe -> sbuf . pos ) ; iframe -> payloadleft = iframe -> frame . hd . length ; DEBUGF ( ""recv:<S2SV_blank>payloadlen=%zu,<S2SV_blank>type=%u,<S2SV_blank>flags=0x%02x,<S2SV_blank>stream_id=%d\\n"" , iframe -> frame . hd . length , iframe -> frame . hd . type , iframe -> frame . hd . flags , iframe -> frame . hd . stream_id ) ; if ( iframe -> frame . hd . length > session -> local_settings . max_frame_size ) { DEBUGF ( ""recv:<S2SV_blank>length<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%u\\n"" , iframe -> frame . hd . length , session -> local_settings . max_frame_size ) ; rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_FRAME_SIZE_ERROR , ""too<S2SV_blank>large<S2SV_blank>frame<S2SV_blank>size"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } switch ( iframe -> frame . hd . type ) { case NGHTTP2_DATA : { DEBUGF ( ""recv:<S2SV_blank>DATA\\n"" ) ; iframe -> frame . hd . flags &= ( NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_PADDED ) ; busy = 1 ; rv = session_on_data_received_fail_fast ( session ) ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_IGN_PAYLOAD ) { DEBUGF ( ""recv:<S2SV_blank>DATA<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>stream_id=%d\\n"" , iframe -> frame . hd . stream_id ) ; iframe -> state = NGHTTP2_IB_IGN_DATA ; break ; } if ( nghttp2_is_fatal ( rv ) ) { return rv ; } rv = inbound_frame_handle_pad ( iframe , & iframe -> frame . hd ) ; if ( rv < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""DATA:<S2SV_blank>insufficient<S2SV_blank>padding<S2SV_blank>space"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } if ( rv == 1 ) { iframe -> state = NGHTTP2_IB_READ_PAD_DATA ; break ; } iframe -> state = NGHTTP2_IB_READ_DATA ; break ; } case NGHTTP2_HEADERS : DEBUGF ( ""recv:<S2SV_blank>HEADERS\\n"" ) ; iframe -> frame . hd . flags &= ( NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED | NGHTTP2_FLAG_PRIORITY ) ; rv = inbound_frame_handle_pad ( iframe , & iframe -> frame . hd ) ; if ( rv < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""HEADERS:<S2SV_blank>insufficient<S2SV_blank>padding<S2SV_blank>space"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } if ( rv == 1 ) { iframe -> state = NGHTTP2_IB_READ_NBYTE ; break ; } pri_fieldlen = nghttp2_frame_priority_len ( iframe -> frame . hd . flags ) ; if ( pri_fieldlen > 0 ) { if ( iframe -> payloadleft < pri_fieldlen ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , pri_fieldlen ) ; break ; } rv = session_call_on_begin_frame ( session , & iframe -> frame . hd ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } on_begin_frame_called = 1 ; rv = session_process_headers_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } if ( rv == NGHTTP2_ERR_IGN_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; break ; case NGHTTP2_PRIORITY : DEBUGF ( ""recv:<S2SV_blank>PRIORITY\\n"" ) ; iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft != NGHTTP2_PRIORITY_SPECLEN ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , NGHTTP2_PRIORITY_SPECLEN ) ; break ; case NGHTTP2_RST_STREAM : case NGHTTP2_WINDOW_UPDATE : # ifdef DEBUGBUILD switch ( iframe -> frame . hd . type ) { case NGHTTP2_RST_STREAM : DEBUGF ( ""recv:<S2SV_blank>RST_STREAM\\n"" ) ; break ; case NGHTTP2_WINDOW_UPDATE : DEBUGF ( ""recv:<S2SV_blank>WINDOW_UPDATE\\n"" ) ; break ; } # endif iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft != 4 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 4 ) ; break ; case NGHTTP2_SETTINGS : DEBUGF ( ""recv:<S2SV_blank>SETTINGS\\n"" ) ; iframe -> frame . hd . flags &= NGHTTP2_FLAG_ACK ; if ( ( iframe -> frame . hd . length % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) || ( ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) && iframe -> payloadleft > 0 ) ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } <S2SV_StartBug> iframe -> state = NGHTTP2_IB_READ_SETTINGS ; <S2SV_EndBug> if ( iframe -> payloadleft ) { nghttp2_settings_entry * min_header_table_size_entry ; iframe -> max_niv = iframe -> frame . hd . length / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH + 1 ; if ( iframe -> max_niv - 1 > session -> max_settings ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , ""SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) * iframe -> max_niv ) ; if ( ! iframe -> iv ) { return NGHTTP2_ERR_NOMEM ; } min_header_table_size_entry = & iframe -> iv [ iframe -> max_niv - 1 ] ; min_header_table_size_entry -> settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE ; min_header_table_size_entry -> value = UINT32_MAX ; inbound_frame_set_mark ( iframe , NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) ; break ; } busy = 1 ; inbound_frame_set_mark ( iframe , 0 ) ; break ; case NGHTTP2_PUSH_PROMISE : DEBUGF ( ""recv:<S2SV_blank>PUSH_PROMISE\\n"" ) ; iframe -> frame . hd . flags &= ( NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED ) ; rv = inbound_frame_handle_pad ( iframe , & iframe -> frame . hd ) ; if ( rv < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""PUSH_PROMISE:<S2SV_blank>insufficient<S2SV_blank>padding<S2SV_blank>space"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } if ( rv == 1 ) { iframe -> state = NGHTTP2_IB_READ_NBYTE ; break ; } if ( iframe -> payloadleft < 4 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 4 ) ; break ; case NGHTTP2_PING : DEBUGF ( ""recv:<S2SV_blank>PING\\n"" ) ; iframe -> frame . hd . flags &= NGHTTP2_FLAG_ACK ; if ( iframe -> payloadleft != 8 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 8 ) ; break ; case NGHTTP2_GOAWAY : DEBUGF ( ""recv:<S2SV_blank>GOAWAY\\n"" ) ; iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft < 8 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 8 ) ; break ; case NGHTTP2_CONTINUATION : DEBUGF ( ""recv:<S2SV_blank>unexpected<S2SV_blank>CONTINUATION\\n"" ) ; rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""CONTINUATION:<S2SV_blank>unexpected"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; default : DEBUGF ( ""recv:<S2SV_blank>extension<S2SV_blank>frame\\n"" ) ; if ( check_ext_type_set ( session -> user_recv_ext_types , iframe -> frame . hd . type ) ) { if ( ! session -> callbacks . unpack_extension_callback ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_EXTENSION_PAYLOAD ; break ; } else { switch ( iframe -> frame . hd . type ) { case NGHTTP2_ALTSVC : if ( ( session -> builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC ) == 0 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } DEBUGF ( ""recv:<S2SV_blank>ALTSVC\\n"" ) ; iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; iframe -> frame . ext . payload = & iframe -> ext_frame_payload . altsvc ; if ( session -> server ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } if ( iframe -> payloadleft < 2 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 2 ) ; break ; case NGHTTP2_ORIGIN : if ( ! ( session -> builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN ) ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } DEBUGF ( ""recv:<S2SV_blank>ORIGIN\\n"" ) ; iframe -> frame . ext . payload = & iframe -> ext_frame_payload . origin ; if ( session -> server || iframe -> frame . hd . stream_id || ( iframe -> frame . hd . flags & 0xf0 ) ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft ) { iframe -> raw_lbuf = nghttp2_mem_malloc ( mem , iframe -> payloadleft ) ; if ( iframe -> raw_lbuf == NULL ) { return NGHTTP2_ERR_NOMEM ; } nghttp2_buf_wrap_init ( & iframe -> lbuf , iframe -> raw_lbuf , iframe -> payloadleft ) ; } else { busy = 1 ; } iframe -> state = NGHTTP2_IB_READ_ORIGIN_PAYLOAD ; break ; default : busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } } } if ( ! on_begin_frame_called ) { switch ( iframe -> state ) { case NGHTTP2_IB_IGN_HEADER_BLOCK : case NGHTTP2_IB_IGN_PAYLOAD : case NGHTTP2_IB_FRAME_SIZE_ERROR : case NGHTTP2_IB_IGN_DATA : case NGHTTP2_IB_IGN_ALL : break ; default : rv = session_call_on_begin_frame ( session , & iframe -> frame . hd ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } } break ; } case NGHTTP2_IB_READ_NBYTE : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_NBYTE]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; iframe -> payloadleft -= readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu,<S2SV_blank>left=%zd\\n"" , readlen , iframe -> payloadleft , nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } switch ( iframe -> frame . hd . type ) { case NGHTTP2_HEADERS : if ( iframe -> padlen == 0 && ( iframe -> frame . hd . flags & NGHTTP2_FLAG_PADDED ) ) { pri_fieldlen = nghttp2_frame_priority_len ( iframe -> frame . hd . flags ) ; padlen = inbound_frame_compute_pad ( iframe ) ; if ( padlen < 0 || ( size_t ) padlen + pri_fieldlen > 1 + iframe -> payloadleft ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""HEADERS:<S2SV_blank>invalid<S2SV_blank>padding"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . headers . padlen = ( size_t ) padlen ; if ( pri_fieldlen > 0 ) { if ( iframe -> payloadleft < pri_fieldlen ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , pri_fieldlen ) ; break ; } else { inbound_frame_set_mark ( iframe , 0 ) ; } } rv = session_process_headers_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } if ( rv == NGHTTP2_ERR_IGN_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; break ; case NGHTTP2_PRIORITY : rv = session_process_priority_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_RST_STREAM : rv = session_process_rst_stream_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_PUSH_PROMISE : if ( iframe -> padlen == 0 && ( iframe -> frame . hd . flags & NGHTTP2_FLAG_PADDED ) ) { padlen = inbound_frame_compute_pad ( iframe ) ; if ( padlen < 0 || ( size_t ) padlen + 4 > 1 + iframe -> payloadleft ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""PUSH_PROMISE:<S2SV_blank>invalid<S2SV_blank>padding"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . push_promise . padlen = ( size_t ) padlen ; if ( iframe -> payloadleft < 4 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 4 ) ; break ; } rv = session_process_push_promise_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . push_promise . promised_stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } if ( rv == NGHTTP2_ERR_IGN_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; break ; case NGHTTP2_PING : rv = session_process_ping_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_GOAWAY : { size_t debuglen ; debuglen = iframe -> frame . hd . length - 8 ; if ( debuglen > 0 ) { iframe -> raw_lbuf = nghttp2_mem_malloc ( mem , debuglen ) ; if ( iframe -> raw_lbuf == NULL ) { return NGHTTP2_ERR_NOMEM ; } nghttp2_buf_wrap_init ( & iframe -> lbuf , iframe -> raw_lbuf , debuglen ) ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_GOAWAY_DEBUG ; break ; } case NGHTTP2_WINDOW_UPDATE : rv = session_process_window_update_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_ALTSVC : { size_t origin_len ; origin_len = nghttp2_get_uint16 ( iframe -> sbuf . pos ) ; DEBUGF ( ""recv:<S2SV_blank>origin_len=%zu\\n"" , origin_len ) ; if ( origin_len > iframe -> payloadleft ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } if ( iframe -> frame . hd . length > 2 ) { iframe -> raw_lbuf = nghttp2_mem_malloc ( mem , iframe -> frame . hd . length - 2 ) ; if ( iframe -> raw_lbuf == NULL ) { return NGHTTP2_ERR_NOMEM ; } nghttp2_buf_wrap_init ( & iframe -> lbuf , iframe -> raw_lbuf , iframe -> frame . hd . length ) ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_ALTSVC_PAYLOAD ; break ; } default : session_inbound_frame_reset ( session ) ; break ; } break ; case NGHTTP2_IB_READ_HEADER_BLOCK : case NGHTTP2_IB_IGN_HEADER_BLOCK : { ssize_t data_readlen ; size_t trail_padlen ; int final ; # ifdef DEBUGBUILD if ( iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) { DEBUGF ( ""recv:<S2SV_blank>[IB_READ_HEADER_BLOCK]\\n"" ) ; } else { DEBUGF ( ""recv:<S2SV_blank>[IB_IGN_HEADER_BLOCK]\\n"" ) ; } # endif readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft - readlen ) ; data_readlen = inbound_frame_effective_readlen ( iframe , iframe -> payloadleft - readlen , readlen ) ; if ( data_readlen == - 1 ) { data_readlen = 0 ; } trail_padlen = nghttp2_frame_trail_padlen ( & iframe -> frame , iframe -> padlen ) ; final = ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_HEADERS ) && iframe -> payloadleft - ( size_t ) data_readlen == trail_padlen ; if ( data_readlen > 0 || ( data_readlen == 0 && final ) ) { size_t hd_proclen = 0 ; DEBUGF ( ""recv:<S2SV_blank>block<S2SV_blank>final=%d\\n"" , final ) ; rv = inflate_header_block ( session , & iframe -> frame , & hd_proclen , ( uint8_t * ) in , ( size_t ) data_readlen , final , iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_PAUSE ) { in += hd_proclen ; iframe -> payloadleft -= hd_proclen ; return in - first ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { in += hd_proclen ; iframe -> payloadleft -= hd_proclen ; rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . type == NGHTTP2_PUSH_PROMISE ? iframe -> frame . push_promise . promised_stream_id : iframe -> frame . hd . stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } in += readlen ; iframe -> payloadleft -= readlen ; if ( rv == NGHTTP2_ERR_HEADER_COMP ) { if ( iframe -> payloadleft == 0 ) { session_inbound_frame_reset ( session ) ; } else { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; } break ; } } else { in += readlen ; iframe -> payloadleft -= readlen ; } if ( iframe -> payloadleft ) { break ; } if ( ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_HEADERS ) == 0 ) { inbound_frame_set_mark ( iframe , NGHTTP2_FRAME_HDLEN ) ; iframe -> padlen = 0 ; if ( iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_EXPECT_CONTINUATION ; } else { iframe -> state = NGHTTP2_IB_IGN_CONTINUATION ; } } else { if ( iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) { rv = session_after_header_block_received ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } session_inbound_frame_reset ( session ) ; } break ; } case NGHTTP2_IB_IGN_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_IGN_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { break ; } switch ( iframe -> frame . hd . type ) { case NGHTTP2_HEADERS : case NGHTTP2_PUSH_PROMISE : case NGHTTP2_CONTINUATION : session -> hd_inflater . ctx . bad = 1 ; break ; default : break ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_FRAME_SIZE_ERROR : DEBUGF ( ""recv:<S2SV_blank>[IB_FRAME_SIZE_ERROR]\\n"" ) ; rv = session_handle_frame_size_error ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } assert ( iframe -> state == NGHTTP2_IB_IGN_ALL ) ; return ( ssize_t ) inlen ; case NGHTTP2_IB_READ_SETTINGS : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_SETTINGS]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { break ; } if ( readlen > 0 ) { inbound_frame_set_settings_entry ( iframe ) ; } if ( iframe -> payloadleft ) { inbound_frame_set_mark ( iframe , NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) ; break ; } rv = session_process_settings_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_READ_GOAWAY_DEBUG : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_GOAWAY_DEBUG]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; if ( readlen > 0 ) { iframe -> lbuf . last = nghttp2_cpymem ( iframe -> lbuf . last , in , readlen ) ; iframe -> payloadleft -= readlen ; in += readlen ; } DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { assert ( nghttp2_buf_avail ( & iframe -> lbuf ) > 0 ) ; break ; } rv = session_process_goaway_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_EXPECT_CONTINUATION : case NGHTTP2_IB_IGN_CONTINUATION : # ifdef DEBUGBUILD if ( iframe -> state == NGHTTP2_IB_EXPECT_CONTINUATION ) { fprintf ( stderr , ""recv:<S2SV_blank>[IB_EXPECT_CONTINUATION]\\n"" ) ; } else { fprintf ( stderr , ""recv:<S2SV_blank>[IB_IGN_CONTINUATION]\\n"" ) ; } # endif readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } nghttp2_frame_unpack_frame_hd ( & cont_hd , iframe -> sbuf . pos ) ; iframe -> payloadleft = cont_hd . length ; DEBUGF ( ""recv:<S2SV_blank>payloadlen=%zu,<S2SV_blank>type=%u,<S2SV_blank>flags=0x%02x,<S2SV_blank>stream_id=%d\\n"" , cont_hd . length , cont_hd . type , cont_hd . flags , cont_hd . stream_id ) ; if ( cont_hd . type != NGHTTP2_CONTINUATION || cont_hd . stream_id != iframe -> frame . hd . stream_id ) { DEBUGF ( ""recv:<S2SV_blank>expected<S2SV_blank>stream_id=%d,<S2SV_blank>type=%d,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>stream_id=%d,<S2SV_blank>"" ""type=%u\\n"" , iframe -> frame . hd . stream_id , NGHTTP2_CONTINUATION , cont_hd . stream_id , cont_hd . type ) ; rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""unexpected<S2SV_blank>non-CONTINUATION<S2SV_blank>frame<S2SV_blank>or<S2SV_blank>stream_id<S2SV_blank>is<S2SV_blank>invalid"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . hd . flags = ( uint8_t ) ( iframe -> frame . hd . flags | ( cont_hd . flags & NGHTTP2_FLAG_END_HEADERS ) ) ; iframe -> frame . hd . length += cont_hd . length ; busy = 1 ; if ( iframe -> state == NGHTTP2_IB_EXPECT_CONTINUATION ) { iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; rv = session_call_on_begin_frame ( session , & cont_hd ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } else { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; } break ; case NGHTTP2_IB_READ_PAD_DATA : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_PAD_DATA]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; iframe -> payloadleft -= readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu,<S2SV_blank>left=%zu\\n"" , readlen , iframe -> payloadleft , nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } rv = nghttp2_session_update_recv_connection_window_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } rv = nghttp2_session_consume ( session , iframe -> frame . hd . stream_id , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } stream = nghttp2_session_get_stream ( session , iframe -> frame . hd . stream_id ) ; if ( stream ) { rv = nghttp2_session_update_recv_stream_window_size ( session , stream , readlen , iframe -> payloadleft || ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_STREAM ) == 0 ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } busy = 1 ; padlen = inbound_frame_compute_pad ( iframe ) ; if ( padlen < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""DATA:<S2SV_blank>invalid<S2SV_blank>padding"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . data . padlen = ( size_t ) padlen ; iframe -> state = NGHTTP2_IB_READ_DATA ; break ; case NGHTTP2_IB_READ_DATA : stream = nghttp2_session_get_stream ( session , iframe -> frame . hd . stream_id ) ; if ( ! stream ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_DATA ; break ; } DEBUGF ( ""recv:<S2SV_blank>[IB_READ_DATA]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( readlen > 0 ) { ssize_t data_readlen ; rv = nghttp2_session_update_recv_connection_window_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } rv = nghttp2_session_update_recv_stream_window_size ( session , stream , readlen , iframe -> payloadleft || ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_STREAM ) == 0 ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } data_readlen = inbound_frame_effective_readlen ( iframe , iframe -> payloadleft , readlen ) ; if ( data_readlen == - 1 ) { data_readlen = 0 ; } padlen = ( ssize_t ) readlen - data_readlen ; if ( padlen > 0 ) { rv = nghttp2_session_consume ( session , iframe -> frame . hd . stream_id , ( size_t ) padlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } } DEBUGF ( ""recv:<S2SV_blank>data_readlen=%zd\\n"" , data_readlen ) ; if ( data_readlen > 0 ) { if ( session_enforce_http_messaging ( session ) ) { if ( nghttp2_http_on_data_chunk ( stream , ( size_t ) data_readlen ) != 0 ) { if ( session -> opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ) { rv = session_update_connection_consumed_size ( session , ( size_t ) data_readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_DATA ) { return ( ssize_t ) inlen ; } } rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . stream_id , NGHTTP2_PROTOCOL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_DATA ; break ; } } if ( session -> callbacks . on_data_chunk_recv_callback ) { rv = session -> callbacks . on_data_chunk_recv_callback ( session , iframe -> frame . hd . flags , iframe -> frame . hd . stream_id , in - readlen , ( size_t ) data_readlen , session -> user_data ) ; if ( rv == NGHTTP2_ERR_PAUSE ) { return in - first ; } if ( nghttp2_is_fatal ( rv ) ) { return NGHTTP2_ERR_CALLBACK_FAILURE ; } } } } if ( iframe -> payloadleft ) { break ; } rv = session_process_data_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_IGN_DATA : DEBUGF ( ""recv:<S2SV_blank>[IB_IGN_DATA]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( readlen > 0 ) { rv = nghttp2_session_update_recv_connection_window_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( session -> opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ) { rv = session_update_connection_consumed_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } } } if ( iframe -> payloadleft ) { break ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_IGN_ALL : return ( ssize_t ) inlen ; case NGHTTP2_IB_READ_EXTENSION_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_EXTENSION_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( readlen > 0 ) { rv = session_call_on_extension_chunk_recv_callback ( session , in - readlen , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( rv != 0 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } } if ( iframe -> payloadleft > 0 ) { break ; } rv = session_process_extension_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_READ_ALTSVC_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_ALTSVC_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; if ( readlen > 0 ) { iframe -> lbuf . last = nghttp2_cpymem ( iframe -> lbuf . last , in , readlen ) ; iframe -> payloadleft -= readlen ; in += readlen ; } DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { assert ( nghttp2_buf_avail ( & iframe -> lbuf ) > 0 ) ; break ; } rv = session_process_altsvc_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_READ_ORIGIN_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_ORIGIN_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; if ( readlen > 0 ) { iframe -> lbuf . last = nghttp2_cpymem ( iframe -> lbuf . last , in , readlen ) ; iframe -> payloadleft -= readlen ; in += readlen ; } DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { assert ( nghttp2_buf_avail ( & iframe -> lbuf ) > 0 ) ; break ; } rv = session_process_origin_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; } if ( ! busy && in == last ) { break ; } busy = 0 ; } assert ( in == last ) ; return in - first ; }
","<S2SV_ModStart> break ; } if ( session -> obq_flood_counter_ >= session -> max_outbound_ack && ! ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) ) { return NGHTTP2_ERR_FLOODED ; }
",nghttp2@nghttp2/f8da73bd042f810f34d19f9eae02b46d870af394,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/f8da73bd042f810f34d19f9eae02b46d870af394,2020-06-03T23:15Z,369,,0
944,CWE-416,"CWE-416 struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; <S2SV_StartBug> } <S2SV_EndBug> return opt2 ; }
","<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,370,"<S2SV_ModStart> ( opt2, sizeof ( opt2 )",0
945,CWE-20,"CWE-20 __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_arch_events_quirk ) ; switch ( boot_cpu_data . x86_model ) { case 14 : pr_cont ( ""Core<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 15 : x86_add_quirk ( intel_clovertown_quirk ) ; case 22 : case 23 : case 29 : memcpy ( hw_cache_event_ids , core2_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_core ( ) ; x86_pmu . event_constraints = intel_core2_event_constraints ; x86_pmu . pebs_constraints = intel_core2_pebs_event_constraints ; pr_cont ( ""Core2<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 26 : case 30 : case 46 : memcpy ( hw_cache_event_ids , nehalem_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_nehalem_event_constraints ; x86_pmu . pebs_constraints = intel_nehalem_pebs_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . extra_regs = intel_nehalem_extra_regs ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; x86_add_quirk ( intel_nehalem_quirk ) ; pr_cont ( ""Nehalem<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 28 : case 38 : case 39 : case 53 : case 54 : memcpy ( hw_cache_event_ids , atom_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_atom ( ) ; x86_pmu . event_constraints = intel_gen_event_constraints ; x86_pmu . pebs_constraints = intel_atom_pebs_event_constraints ; pr_cont ( ""Atom<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 37 : case 44 : case 47 : memcpy ( hw_cache_event_ids , westmere_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_westmere_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . pebs_constraints = intel_westmere_pebs_event_constraints ; x86_pmu . extra_regs = intel_westmere_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""Westmere<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 42 : case 45 : x86_add_quirk ( intel_sandybridge_quirk ) ; memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_snb_event_constraints ; x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""SandyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 58 : case 62 : memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_ivb_event_constraints ; x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ; <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> x86_pmu . extra_regs = intel_snb_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""IvyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; default : switch ( x86_pmu . version ) { case 1 : x86_pmu . event_constraints = intel_v1_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon<S2SV_blank>v1,<S2SV_blank>"" ) ; break ; default : x86_pmu . event_constraints = intel_gen_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon,<S2SV_blank>"" ) ; break ; } } if ( x86_pmu . num_counters > INTEL_PMC_MAX_GENERIC ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters , INTEL_PMC_MAX_GENERIC ) ; x86_pmu . num_counters = INTEL_PMC_MAX_GENERIC ; } x86_pmu . intel_ctrl = ( 1 << x86_pmu . num_counters ) - 1 ; if ( x86_pmu . num_counters_fixed > INTEL_PMC_MAX_FIXED ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>fixed<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters_fixed , INTEL_PMC_MAX_FIXED ) ; x86_pmu . num_counters_fixed = INTEL_PMC_MAX_FIXED ; } x86_pmu . intel_ctrl |= ( ( 1LL << x86_pmu . num_counters_fixed ) - 1 ) << INTEL_PMC_IDX_FIXED ; if ( x86_pmu . event_constraints ) { for_each_event_constraint ( c , x86_pmu . event_constraints ) { if ( c -> cmask != X86_RAW_EVENT_MASK || c -> idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES ) { continue ; } c -> idxmsk64 |= ( 1ULL << x86_pmu . num_counters ) - 1 ; c -> weight += x86_pmu . num_counters ; } } return 0 ; }
","<S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
",torvalds@linux/f1923820c447e986a9da0fc6bf60c1dccdf0408e,CVE-2013-2146,https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e,2013-06-07T14:03Z,371,<S2SV_ModStart> ; if ( unsigned long ) return - EINVAL,0
949,CWE-119,"CWE-119 <S2SV_StartBug> static void pack_mb_tokens ( vp9_writer * w , <S2SV_EndBug> <S2SV_StartBug> TOKENEXTRA * * tp , const TOKENEXTRA * stop ) { <S2SV_EndBug> TOKENEXTRA * p = * tp ; while ( p < stop && p -> token != EOSB_TOKEN ) { const int t = p -> token ; const struct vp9_token * const a = & vp9_coef_encodings [ t ] ; <S2SV_StartBug> const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; <S2SV_EndBug> <S2SV_StartBug> int i = 0 ; <S2SV_EndBug> int v = a -> value ; int n = a -> len ; if ( p -> skip_eob_node ) { n -= p -> skip_eob_node ; i = 2 * p -> skip_eob_node ; } if ( t >= TWO_TOKEN && t < EOB_TOKEN ) { int len = UNCONSTRAINED_NODES - p -> skip_eob_node ; int bits = v >> ( n - len ) ; vp9_write_tree ( w , vp9_coef_tree , p -> context_tree , bits , len , i ) ; vp9_write_tree ( w , vp9_coef_con_tree , vp9_pareto8_full [ p -> context_tree [ PIVOT_NODE ] - 1 ] , v , n - len , 0 ) ; } else { vp9_write_tree ( w , vp9_coef_tree , p -> context_tree , v , n , i ) ; } if ( b -> base_val ) { const int e = p -> extra , l = b -> len ; if ( l ) { const unsigned char * pb = b -> prob ; int v = e >> 1 ; int n = l ; int i = 0 ; do { const int bb = ( v >> -- n ) & 1 ; <S2SV_StartBug> vp9_write ( w , bb , pb [ i >> 1 ] ) ; <S2SV_EndBug> i = b -> tree [ i + bb ] ; } while ( n ) ; } <S2SV_StartBug> vp9_write_bit ( w , e & 1 ) ; <S2SV_EndBug> } ++ p ; } * tp = p + ( p -> token == EOSB_TOKEN ) ; }
","<S2SV_ModStart> void pack_mb_tokens ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> const TOKENEXTRA * const stop , vpx_bit_depth_t bit_depth <S2SV_ModEnd> ) { TOKENEXTRA <S2SV_ModStart> t ] ; int i = 0 ; int v = a -> value ; int n = a -> len ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> const vp9_extra_bit * b ; if ( bit_depth == VPX_BITS_12 ) b = & vp9_extra_bits_high12 [ t ] ; else if ( bit_depth == VPX_BITS_10 ) b = & vp9_extra_bits_high10 [ t ] ; else <S2SV_ModEnd> b = & <S2SV_ModStart> t ] ; # else const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; ( void ) bit_depth ; # endif <S2SV_ModEnd> if ( p <S2SV_ModStart> & 1 ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> ) ; } vpx_write_bit <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,372,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
950,CWE-119,"CWE-119 void vp9_pack_bitstream ( VP9_COMP * cpi , uint8_t * dest , size_t * size ) { uint8_t * data = dest ; size_t first_part_size , uncompressed_hdr_size ; <S2SV_StartBug> struct vp9_write_bit_buffer wb = { data , 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer saved_wb ; <S2SV_EndBug> write_uncompressed_header ( cpi , & wb ) ; saved_wb = wb ; <S2SV_StartBug> vp9_wb_write_literal ( & wb , 0 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> uncompressed_hdr_size = vp9_rb_bytes_written ( & wb ) ; <S2SV_EndBug> data += uncompressed_hdr_size ; <S2SV_StartBug> vp9_compute_update_table ( ) ; <S2SV_EndBug> vp9_clear_system_state ( ) ; first_part_size = write_compressed_header ( cpi , data ) ; data += first_part_size ; <S2SV_StartBug> vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ; <S2SV_EndBug> data += encode_tiles ( cpi , data ) ; * size = data - dest ; }
","<S2SV_ModStart> uncompressed_hdr_size ; struct vpx_write_bit_buffer <S2SV_ModEnd> wb = { <S2SV_ModStart> } ; struct vpx_write_bit_buffer <S2SV_ModEnd> saved_wb ; write_uncompressed_header <S2SV_ModStart> = wb ; vpx_wb_write_literal <S2SV_ModEnd> ( & wb <S2SV_ModStart> ; uncompressed_hdr_size = vpx_wb_bytes_written <S2SV_ModEnd> ( & wb <S2SV_ModStart> += uncompressed_hdr_size ; vpx_clear_system_state <S2SV_ModEnd> ( ) ; <S2SV_ModStart> += first_part_size ; vpx_wb_write_literal <S2SV_ModEnd> ( & saved_wb
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,373,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>,0
951,CWE-476,"CWE-476 <S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> struct net_device * dev , const char * name ) { BUG_ON ( ! net ) ; if ( ! dev_valid_name ( name ) ) return - EINVAL ; if ( strchr ( name , '%' ) ) return dev_alloc_name_ns ( net , dev , name ) ; else if ( __dev_get_by_name ( net , name ) ) return - EEXIST ; else if ( dev -> name != name ) strlcpy ( dev -> name , name , IFNAMSIZ ) ; return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int dev_get_valid_name (
",torvalds@linux/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,CVE-2018-7191,https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,2019-05-17T05:29Z,374,"<S2SV_ModStart> * name, <S2SV_ModEnd> const char *",0
953,CWE-125,"CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z,375,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
956,CWE-416,"CWE-416 static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } <S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
","<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
",mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z,376,<S2SV_ModStart> if ( cmpt = 0,0
957,CWE-401,"CWE-401 static int ath10k_usb_hif_tx_sg ( struct ath10k * ar , u8 pipe_id , struct ath10k_hif_sg_item * items , int n_items ) { struct ath10k_usb * ar_usb = ath10k_usb_priv ( ar ) ; struct ath10k_usb_pipe * pipe = & ar_usb -> pipes [ pipe_id ] ; struct ath10k_urb_context * urb_context ; struct sk_buff * skb ; struct urb * urb ; int ret , i ; for ( i = 0 ; i < n_items ; i ++ ) { urb_context = ath10k_usb_alloc_urb_from_pipe ( pipe ) ; if ( ! urb_context ) { ret = - ENOMEM ; goto err ; } skb = items [ i ] . transfer_context ; urb_context -> skb = skb ; urb = usb_alloc_urb ( 0 , GFP_ATOMIC ) ; if ( ! urb ) { ret = - ENOMEM ; goto err_free_urb_to_pipe ; } usb_fill_bulk_urb ( urb , ar_usb -> udev , pipe -> usb_pipe_handle , skb -> data , skb -> len , ath10k_usb_transmit_complete , urb_context ) ; if ( ! ( skb -> len % pipe -> max_packet_size ) ) { urb -> transfer_flags |= URB_ZERO_PACKET ; } usb_anchor_urb ( urb , & pipe -> urb_submitted ) ; ret = usb_submit_urb ( urb , GFP_ATOMIC ) ; if ( ret ) { ath10k_dbg ( ar , ATH10K_DBG_USB_BULK , ""usb<S2SV_blank>bulk<S2SV_blank>transmit<S2SV_blank>failed:<S2SV_blank>%d\\n"" , ret ) ; usb_unanchor_urb ( urb ) ; <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> goto err_free_urb_to_pipe ; } usb_free_urb ( urb ) ; } return 0 ; err_free_urb_to_pipe : ath10k_usb_free_urb_to_pipe ( urb_context -> pipe , urb_context ) ; err : return ret ; }
","<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
",torvalds@linux/b8d17e7d93d2beb89e4f34c59996376b8b544792,CVE-2019-19078,https://github.com/torvalds/linux/commit/b8d17e7d93d2beb89e4f34c59996376b8b544792,2019-11-18T06:15Z,377,<S2SV_ModStart> err ) ; usb_free ( urb ) ;,0
958,CWE-787,"CWE-787 VOID ixheaacd_esbr_radix4bfly ( const WORD32 * w , WORD32 * x , WORD32 index1 , WORD32 index ) { int i ; WORD32 l1 , l2 , h2 , fft_jmp ; <S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; WORD32 x_h2_0 , x_h2_1 ; WORD32 si10 , si20 , si30 , co10 , co20 , co30 ; WORD64 mul_1 , mul_2 , mul_3 , mul_4 , mul_5 , mul_6 ; WORD64 mul_7 , mul_8 , mul_9 , mul_10 , mul_11 , mul_12 ; WORD32 * x_l1 ; WORD32 * x_l2 ; WORD32 * x_h2 ; const WORD32 * w_ptr = w ; WORD32 i1 ; h2 = index << 1 ; l1 = index << 2 ; l2 = ( index << 2 ) + ( index << 1 ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; fft_jmp = 6 * ( index ) ; for ( i1 = 0 ; i1 < index1 ; i1 ++ ) { for ( i = 0 ; i < index ; i ++ ) { si10 = ( * w_ptr ++ ) ; co10 = ( * w_ptr ++ ) ; si20 = ( * w_ptr ++ ) ; co20 = ( * w_ptr ++ ) ; si30 = ( * w_ptr ++ ) ; co30 = ( * w_ptr ++ ) ; x_0 = x [ 0 ] ; x_h2_0 = x [ h2 ] ; x_l1_0 = x [ l1 ] ; x_l2_0 = x [ l2 ] ; <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> x_1 = x [ 1 ] ; x_h2_1 = x [ h2 + 1 ] ; x_l1_1 = x [ l1 + 1 ] ; x_l2_1 = x [ l2 + 1 ] ; <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ; mul_3 = ixheaacd_mult64 ( yt2_0 , si30 ) ; x [ l2 ] = ( WORD32 ) ( ( mul_3 + mul_11 ) >> 32 ) << RADIXSHIFT ; mul_5 = ixheaacd_mult64 ( xt2_0 , si30 ) ; mul_9 = ixheaacd_mult64 ( yt2_0 , co30 ) ; x [ l2 + 1 ] = ( WORD32 ) ( ( mul_9 - mul_5 ) >> 32 ) << RADIXSHIFT ; mul_12 = ixheaacd_mult64 ( xt0_0 , co20 ) ; mul_2 = ixheaacd_mult64 ( yt0_0 , si20 ) ; x [ l1 ] = ( WORD32 ) ( ( mul_2 + mul_12 ) >> 32 ) << RADIXSHIFT ; mul_6 = ixheaacd_mult64 ( xt0_0 , si20 ) ; mul_8 = ixheaacd_mult64 ( yt0_0 , co20 ) ; x [ l1 + 1 ] = ( WORD32 ) ( ( mul_8 - mul_6 ) >> 32 ) << RADIXSHIFT ; mul_4 = ixheaacd_mult64 ( xt1_0 , co10 ) ; mul_1 = ixheaacd_mult64 ( yt1_0 , si10 ) ; x [ h2 ] = ( WORD32 ) ( ( mul_1 + mul_4 ) >> 32 ) << RADIXSHIFT ; mul_10 = ixheaacd_mult64 ( xt1_0 , si10 ) ; mul_7 = ixheaacd_mult64 ( yt1_0 , co10 ) ; x [ h2 + 1 ] = ( WORD32 ) ( ( mul_7 - mul_10 ) >> 32 ) << RADIXSHIFT ; x += 2 ; } x += fft_jmp ; w_ptr = w_ptr - fft_jmp ; } }
","<S2SV_ModStart> , fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , yt0_0 <S2SV_ModStart> , yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , xh1_0 <S2SV_ModStart> ; xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xl0_0 <S2SV_ModStart> ; xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xh20_0 <S2SV_ModStart> ; xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; xl20_0 <S2SV_ModStart> ; xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; x <S2SV_ModStart> 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> ; xt0_0 = <S2SV_ModStart> ; xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> xh20_0 ; x_1 <S2SV_ModStart> ; xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xl1_0 <S2SV_ModStart> ; xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xh21_0 <S2SV_ModStart> ; xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; xl21_0 <S2SV_ModStart> ; xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; x <S2SV_ModStart> 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> ; yt0_0 = <S2SV_ModStart> ; yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> xh21_0 ; xt1_0 <S2SV_ModStart> ; xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> xl21_0 ; xt2_0 <S2SV_ModStart> ; xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> xl21_0 ; yt2_0 <S2SV_ModStart> ; yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> xl20_0 ; yt1_0 <S2SV_ModStart> ; yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> xl20_0 ; mul_11
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,378,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
961,CWE-59,"CWE-59 static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> }
","<S2SV_ModStart> mntent -> mnt_dir , NULL
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z,379,<S2SV_ModStart> mntS2SV_null> <S2SV_null> <S2SV_null>,0
964,CWE-119,"CWE-119 static void write_display_size ( const VP9_COMMON * cm , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> const int scaling_active = cm -> width != cm -> display_width || cm -> height != cm -> display_height ; <S2SV_StartBug> vp9_wb_write_bit ( wb , scaling_active ) ; <S2SV_EndBug> if ( scaling_active ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> -> display_height ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> scaling_active ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 16 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,380,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static vpx_write_buffer <S2SV_ModEnd> ( wb, <S2SV_ModStart> wb_literal <S2SV_ModEnd> ( wb,",0
966,CWE-444,"CWE-444 VALUE request_env ( agooReq req , VALUE self ) { if ( Qnil == ( VALUE ) req -> env ) { volatile VALUE env = rb_hash_new ( ) ; rb_hash_aset ( env , request_method_val , req_method ( req ) ) ; rb_hash_aset ( env , script_name_val , req_script_name ( req ) ) ; rb_hash_aset ( env , path_info_val , req_path_info ( req ) ) ; rb_hash_aset ( env , query_string_val , req_query_string ( req ) ) ; <S2SV_StartBug> rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; <S2SV_EndBug> rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; fill_headers ( req , env ) ; rb_hash_aset ( env , rack_version_val , rack_version_val_val ) ; rb_hash_aset ( env , rack_url_scheme_val , req_rack_url_scheme ( req ) ) ; rb_hash_aset ( env , rack_input_val , req_rack_input ( req ) ) ; rb_hash_aset ( env , rack_errors_val , req_rack_errors ( req ) ) ; rb_hash_aset ( env , rack_multithread_val , req_rack_multithread ( req ) ) ; rb_hash_aset ( env , rack_multiprocess_val , Qfalse ) ; rb_hash_aset ( env , rack_run_once_val , Qfalse ) ; rb_hash_aset ( env , rack_logger_val , req_rack_logger ( req ) ) ; rb_hash_aset ( env , rack_upgrade_val , req_rack_upgrade ( req ) ) ; rb_hash_aset ( env , rack_hijackq_val , Qtrue ) ; rb_hash_aset ( env , rack_hijack_val , self ) ; rb_hash_aset ( env , rack_hijack_io_val , Qnil ) ; if ( agoo_server . rack_early_hints ) { volatile VALUE eh = agoo_early_hints_new ( req ) ; rb_hash_aset ( env , early_hints_val , eh ) ; } req -> env = ( void * ) env ; } return ( VALUE ) req -> env ; }
","<S2SV_ModStart> ( env , remote_addr_val , req_remote_addr ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; rb_hash_aset ( env , <S2SV_ModStart> server_name_val , req_server_name <S2SV_ModEnd> ( req )
",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z,381,"<S2SV_ModStart> ) ; } rb_literal <S2SV_ModEnd> ( req,",0
969,CWE-125,"CWE-125 int dbd_st_prepare ( SV * sth , imp_sth_t * imp_sth , char * statement , SV * attribs ) { int i ; SV * * svp ; dTHX ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION char * str_ptr , * str_last_ptr ; # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION int limit_flag = 0 ; # endif # endif <S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> MYSQL_BIND * bind , * bind_end ; imp_sth_phb_t * fbind ; # endif D_imp_xxh ( sth ) ; D_imp_dbh_from_sth ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_prepare<S2SV_blank>MYSQL_VERSION_ID<S2SV_blank>%d,<S2SV_blank>SQL<S2SV_blank>statement:<S2SV_blank>%s\\n"" , MYSQL_VERSION_ID , statement ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_sth -> use_server_side_prepare = imp_dbh -> use_server_side_prepare ; if ( attribs ) { svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_server_prepare"" , 20 ) ; imp_sth -> use_server_side_prepare = ( svp ) ? SvTRUE ( * svp ) : imp_dbh -> use_server_side_prepare ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""async"" , 5 ) ; if ( svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth , 2000 , ""Async<S2SV_blank>support<S2SV_blank>was<S2SV_blank>not<S2SV_blank>built<S2SV_blank>into<S2SV_blank>this<S2SV_blank>version<S2SV_blank>of<S2SV_blank>DBD::mysql"" , ""HY000"" ) ; return 0 ; # endif } } imp_sth -> fetch_done = 0 ; # endif imp_sth -> done_desc = 0 ; imp_sth -> result = NULL ; imp_sth -> currow = 0 ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_use_result"" , 16 ) ; imp_sth -> use_mysql_use_result = svp ? SvTRUE ( * svp ) : imp_dbh -> use_mysql_use_result ; for ( i = 0 ; i < AV_ATTRIB_LAST ; i ++ ) imp_sth -> av_attr [ i ] = Nullav ; mysql_st_free_result_sets ( sth , imp_sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set,<S2SV_blank>check<S2SV_blank>restrictions\\n"" ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>LIMIT<S2SV_blank>&<S2SV_blank>CALL\\n"" ) ; # else ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>restrictions\\n"" ) ; # endif str_last_ptr = statement + strlen ( statement ) ; for ( str_ptr = statement ; str_ptr < str_last_ptr ; str_ptr ++ ) { # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION if ( limit_flag ) { if ( * str_ptr == '?' ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tLIMIT<S2SV_blank>and<S2SV_blank>?<S2SV_blank>found,<S2SV_blank>set<S2SV_blank>to<S2SV_blank>use_server_side_prepare=0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } else if ( str_ptr < str_last_ptr - 6 && isspace ( * ( str_ptr + 0 ) ) && tolower ( * ( str_ptr + 1 ) ) == 'l' && tolower ( * ( str_ptr + 2 ) ) == 'i' && tolower ( * ( str_ptr + 3 ) ) == 'm' && tolower ( * ( str_ptr + 4 ) ) == 'i' && tolower ( * ( str_ptr + 5 ) ) == 't' && isspace ( * ( str_ptr + 6 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""LIMIT<S2SV_blank>set<S2SV_blank>limit<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>1\\n"" ) ; limit_flag = 1 ; } # endif if ( str_ptr < str_last_ptr - 4 && tolower ( * ( str_ptr + 0 ) ) == 'c' && tolower ( * ( str_ptr + 1 ) ) == 'a' && tolower ( * ( str_ptr + 2 ) ) == 'l' && tolower ( * ( str_ptr + 3 ) ) == 'l' && isspace ( * ( str_ptr + 4 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""Disable<S2SV_blank>PS<S2SV_blank>mode<S2SV_blank>for<S2SV_blank>CALL()\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set\\n"" ) ; if ( imp_sth -> stmt ) fprintf ( stderr , <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ; if ( ! imp_sth -> stmt ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) ) ; } prepare_retval = mysql_stmt_prepare ( imp_sth -> stmt , statement , strlen ( statement ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>returned<S2SV_blank>%d\\n"" , prepare_retval ) ; if ( prepare_retval ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>%d<S2SV_blank>%s\\n"" , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) ) ; if ( mysql_stmt_errno ( imp_sth -> stmt ) == ER_UNSUPPORTED_PS ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tSETTING<S2SV_blank>imp_sth->use_server_side_prepare<S2SV_blank>to<S2SV_blank>0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; } else { do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; mysql_stmt_close ( imp_sth -> stmt ) ; imp_sth -> stmt = NULL ; return FALSE ; } } else { DBIc_NUM_PARAMS ( imp_sth ) = mysql_stmt_param_count ( imp_sth -> stmt ) ; if ( DBIc_NUM_PARAMS ( imp_sth ) > 0 ) { <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> imp_sth -> bind = alloc_bind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> fbind = alloc_fbind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> has_been_bound = 0 ; for ( i = 0 , bind = imp_sth -> bind , fbind = imp_sth -> fbind , bind_end = bind + DBIc_NUM_PARAMS ( imp_sth ) ; bind < bind_end ; bind ++ , fbind ++ , i ++ ) { <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug> imp_sth -> stmt -> fields [ i ] . type : MYSQL_TYPE_STRING ) ; bind -> buffer_type = mysql_to_perl_type ( col_type ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_to_perl_type<S2SV_blank>returned<S2SV_blank>%d\\n"" , col_type ) ; bind -> buffer = NULL ; bind -> length = & ( fbind -> length ) ; bind -> is_null = ( char * ) & ( fbind -> is_null ) ; fbind -> is_null = 1 ; fbind -> length = 0 ; } } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare == 0 ) DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # else DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # endif imp_sth -> params = alloc_param ( DBIc_NUM_PARAMS ( imp_sth ) ) ; DBIc_IMPSET_on ( imp_sth ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_prepare\\n"" ) ; return 1 ; }
","<S2SV_ModStart> # endif int <S2SV_ModEnd> prepare_retval ; MYSQL_BIND <S2SV_ModStart> ( stderr , ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> ) ; imp_sth <S2SV_ModStart> imp_xxh ) , ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> , mysql_errno ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> imp_sth -> bind <S2SV_ModStart> ++ ) { bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ; bind ->
",perl5-dbi@DBD-mysql/793b72b1a0baa5070adacaac0e12fd995a6fbabe,CVE-2016-1249,https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe,2017-02-17T02:59Z,382,<S2SV_ModStart> char * str <S2SV_ModEnd> ; char *,0
972,CWE-000,"CWE-000 static void SaltTextAway ( XtermWidget xw , int which , CELL * cellc , CELL * cell ) { TScreen * screen = TScreenOf ( xw ) ; SelectedCells * scp ; int i ; int eol ; <S2SV_StartBug> int need = 0 ; <S2SV_EndBug> Char * line ; Char * lp ; CELL first = * cellc ; CELL last = * cell ; if ( which < 0 || which >= MAX_SELECTIONS ) { TRACE ( ( ""SaltTextAway<S2SV_blank>-<S2SV_blank>which<S2SV_blank>selection?\\n"" ) ) ; return ; } scp = & ( screen -> selected_cells [ which ] ) ; TRACE ( ( ""SaltTextAway<S2SV_blank>which=%d,<S2SV_blank>first=%d,%d,<S2SV_blank>last=%d,%d\\n"" , which , first . row , first . col , last . row , last . col ) ) ; if ( isSameRow ( & first , & last ) && first . col > last . col ) { int tmp ; EXCHANGE ( first . col , last . col , tmp ) ; } -- last . col ; if ( isSameRow ( & last , & first ) ) { need = Length ( screen , first . row , first . col , last . col ) ; } else { need += Length ( screen , first . row , first . col , screen -> max_col ) + 1 ; for ( i = first . row + 1 ; i < last . row ; i ++ ) need += Length ( screen , i , 0 , screen -> max_col ) + 1 ; if ( last . col >= 0 ) need += Length ( screen , last . row , 0 , last . col ) ; } if_OPT_WIDE_CHARS ( screen , { <S2SV_StartBug> need *= 4 ; <S2SV_EndBug> } ) ; if ( need < 0 ) return ; if ( scp -> data_limit <= ( unsigned ) need ) { if ( ( line = ( Char * ) malloc ( ( size_t ) need + 1 ) ) == 0 ) SysError ( ERROR_BMALLOC2 ) ; free ( scp -> data_buffer ) ; scp -> data_buffer = line ; scp -> data_limit = ( size_t ) ( need + 1 ) ; } else { line = scp -> data_buffer ; } if ( line == 0 ) return ; line [ need ] = '\\0' ; lp = line ; if ( isSameRow ( & last , & first ) ) { lp = SaveText ( screen , last . row , first . col , last . col , lp , & eol ) ; } else { lp = SaveText ( screen , first . row , first . col , screen -> max_col , lp , & eol ) ; if ( eol ) * lp ++ = '\\n' ; for ( i = first . row + 1 ; i < last . row ; i ++ ) { lp = SaveText ( screen , i , 0 , screen -> max_col , lp , & eol ) ; if ( eol ) * lp ++ = '\\n' ; } if ( last . col >= 0 ) lp = SaveText ( screen , last . row , 0 , last . col , lp , & eol ) ; } * lp = '\\0' ; <S2SV_StartBug> TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\n"" , ( unsigned ) ( lp - line ) , <S2SV_EndBug> <S2SV_StartBug> visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> scp -> data_length = ( size_t ) ( lp - line ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; int need = 0 ; size_t have <S2SV_ModStart> screen , { if ( need > 0 ) { if ( screen -> max_combining > 0 ) need += screen -> max_combining ; need *= 6 ; } <S2SV_ModEnd> } ) ; <S2SV_ModStart> = '\\0' ; have = ( size_t ) ( lp - line ) ; if ( ( have * 2 ) < ( size_t ) need ) { scp -> data_limit = have + 1 ; line = realloc ( line , scp -> data_limit ) ; } <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> , visibleChars ( <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> data_length = have <S2SV_ModEnd> ; } <S2SV_null>
",ThomasDickey@xterm-snapshots/82ba55b8f994ab30ff561a347b82ea340ba7075c,CVE-2021-27135,https://github.com/ThomasDickey/xterm-snapshots/commit/82ba55b8f994ab30ff561a347b82ea340ba7075c,2021-02-10T16:15Z,383,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
974,CWE-119,"CWE-119 <S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> const JsVarFloat stopAtError = 0.0000001 ; <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> else if ( ! isfinite ( val ) ) { <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; fractionalDigits -- ; } } # endif * ( str ++ ) = 0 ; } }
","<S2SV_ModStart> fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> val ) ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""NaN"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> < 0 ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""-Infinity"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> ) ; else strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""Infinity"" <S2SV_ModEnd> ) ; }
",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z,384,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> char * len ; if ( len > len - 1 ) { <S2SV_ModEnd> char * <S2SV_ModStart> ( str, ""%s"", ""%s"", str <S2SV_ModEnd> ) ; return",0
976,CWE-787,"CWE-787 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; <S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
",coreutils@gnulib/278b4175c9d7dd47c1a3071554aac02add3b3c35,CVE-2018-17942,https://github.com/coreutils/gnulib/commit/278b4175c9d7dd47c1a3071554aac02add3b3c35,2018-10-03T08:29Z,385,<S2SV_ModStart> ) ; } size_t size ; size_t length = sizeof ( size_t ) ; if ( size_t )!= sizeof ( size_t ) - 1 ; <S2SV_ModStart> ) ; if ( size < sizeof ( size_t )!= 0 ) { ASSERT ( buf + 1 ) ; ASSERT ( result!= 0 ) ; ASSERT ( result!= 0 ) ; ASSERT ( result = 0 ; ASSERT ( result!= NULL ) ; ASSERT ( result!= 0 ) ; ASSERT ( result!= 0 )!= 0 ) ; ASSERT ( result = 0 ; ASSERT ( result!= 0 ; ASSERT ( buf + 1 )!= 0 ; ASSERT ( result!= 0 ; ASSERT ( buf + 1 )!= 0 ; ASSERT ( result!= 0 )!= 0 ) ; ASSERT ( result!= 0 ; ASSERT ( result!= 0 )!= 0 ) ; ASSERT ( buf + 1 ) ; ASSERT ( buf + 1 ) ; ASSERT ( result!= 0 ; ASSERT ( result!= 0 ; ASSERT ( buf + 1 ) ; ASSERT ( buf + 1 )!= 0 ; ASSERT ( buf + 1 ) ; ASSERT ( buf + 1 )!= 0 ; ASSERT ( buf + 1 ) ; ASSERT ( buf + 1 )!= 0 ; ASSERT ( buf + 1 ; ASSERT ( buf ) ; ASSERT (,0
977,CWE-200,"CWE-200 void add_interrupt_randomness ( int irq , int irq_flags ) { struct entropy_store * r ; struct fast_pool * fast_pool = this_cpu_ptr ( & irq_randomness ) ; struct pt_regs * regs = get_irq_regs ( ) ; unsigned long now = jiffies ; cycles_t cycles = random_get_entropy ( ) ; __u32 c_high , j_high ; __u64 ip ; unsigned long seed ; int credit = 0 ; if ( cycles == 0 ) cycles = get_reg ( fast_pool , regs ) ; c_high = ( sizeof ( cycles ) > 4 ) ? cycles >> 32 : 0 ; j_high = ( sizeof ( now ) > 4 ) ? now >> 32 : 0 ; fast_pool -> pool [ 0 ] ^= cycles ^ j_high ^ irq ; fast_pool -> pool [ 1 ] ^= now ^ c_high ; ip = regs ? instruction_pointer ( regs ) : _RET_IP_ ; fast_pool -> pool [ 2 ] ^= ip ; fast_pool -> pool [ 3 ] ^= ( sizeof ( ip ) > 4 ) ? ip >> 32 : get_reg ( fast_pool , regs ) ; fast_mix ( fast_pool ) ; add_interrupt_bench ( cycles ) ; <S2SV_StartBug> if ( unlikely ( crng_init == 0 ) ) { <S2SV_EndBug> if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) { fast_pool -> count = 0 ; fast_pool -> last = now ; } return ; } if ( ( fast_pool -> count < 64 ) && ! time_after ( now , fast_pool -> last + HZ ) ) return ; r = & input_pool ; if ( ! spin_trylock ( & r -> lock ) ) return ; fast_pool -> last = now ; __mix_pool_bytes ( r , & fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ; if ( arch_get_random_seed_long ( & seed ) ) { __mix_pool_bytes ( r , & seed , sizeof ( seed ) ) ; credit = 1 ; } spin_unlock ( & r -> lock ) ; fast_pool -> count = 0 ; credit_entropy_bits ( r , credit + 1 ) ; }
","<S2SV_ModStart> cycles ) ; this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ;
",torvalds@linux/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,CVE-2020-16166,https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,2020-07-30T21:15Z,386,<S2SV_ModStart> ) ) return false,0
978,CWE-119,"CWE-119 void jslGetTokenString ( char * str , size_t len ) { if ( lex -> tk == LEX_ID ) { <S2SV_StartBug> strncpy ( str , ""ID:"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> } else if ( lex -> tk == LEX_STR ) { <S2SV_StartBug> strncpy ( str , ""String:\'"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> strncat ( str , ""\'"" , len ) ; } else jslTokenAsString ( lex -> tk , str , len ) ; }
","<S2SV_ModStart> LEX_ID ) { espruino_snprintf <S2SV_ModEnd> ( str , <S2SV_ModStart> ( str , len , ""ID:%s"" <S2SV_ModEnd> , jslGetTokenValueAsString ( <S2SV_ModStart> jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> LEX_STR ) { espruino_snprintf <S2SV_ModEnd> ( str , <S2SV_ModStart> ( str , len , ""String:\'%s\'"" <S2SV_ModEnd> , jslGetTokenValueAsString ( <S2SV_ModStart> jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; }
",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z,387,"<S2SV_ModStart> ( str, ""%s"", len <S2SV_ModEnd> ( str, <S2SV_ModStart> len ) ) ; if",0
980,CWE-119,"CWE-119 void cJSON_DeleteItemFromArray ( cJSON * array , int which ) { cJSON_Delete ( cJSON_DetachItemFromArray ( array , which ) ) ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,388,,1
981,CWE-252,"CWE-252 static MagickBooleanType ConcatenateImages ( int argc , char * * argv , ExceptionInfo * exception ) { FILE * input , * output ; <S2SV_StartBug> int <S2SV_EndBug> c ; register ssize_t i ; if ( ExpandFilenames ( & argc , & argv ) == MagickFalse ) ThrowFileException ( exception , ResourceLimitError , ""MemoryAllocationFailed"" , GetExceptionMessage ( errno ) ) ; output = fopen_utf8 ( argv [ argc - 1 ] , ""wb"" ) ; if ( output == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ argc - 1 ] ) ; return ( MagickFalse ) ; } <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> # if 0 fprintf ( stderr , ""DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\""%s\\""\\n"" , argv [ i ] ) ; # endif input = fopen_utf8 ( argv [ i ] , ""rb"" ) ; if ( input == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ i ] ) ; continue ; } for ( c = fgetc ( input ) ; c != EOF ; c = fgetc ( input ) ) <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * output ; MagickBooleanType status ; <S2SV_ModStart> ) ; } status = MagickTrue ; <S2SV_ModStart> i ++ ) { <S2SV_ModEnd> input = fopen_utf8 <S2SV_ModStart> input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> ( void ) fclose ( input <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> output ) ; <S2SV_ModStart> ; return ( status <S2SV_ModEnd> ) ; }
",ImageMagick@ImageMagick/933e96f01a8c889c7bf5ffd30020e86a02a046e7,CVE-2016-10060,https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7,2017-03-02T21:59Z,389,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static MagickFalse <S2SV_ModStart> output ) { <S2SV_ModEnd> input = MagickFalse ; <S2SV_ModStart> * output = MagickFalse ; } <S2SV_ModStart> output ) { <S2SV_ModEnd> input = MagickFalse ; <S2SV_ModStart> ( void ) output = MagickFalse ; } <S2SV_ModEnd> output = MagickFalse ;,0
982,CWE-119,"CWE-119 vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) { <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || options == NULL || si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } strncpy ( si -> options , options , sizeof ( si -> options ) ) ; si -> options [ sizeof ( si -> options ) - 1 ] = '\\0' ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> options ) { SvcInternal_t <S2SV_ModEnd> * const si
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,390,,0
984,CWE-264,"CWE-264 <S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> { FILE * fp = NULL , * pwf = NULL ; int save_errno ; int found ; int namelen ; int buflen = 256 ; int contlen , rc ; char * linebuf = NULL ; char * tmpname = NULL ; <S2SV_StartBug> char * atomic_dir = ""/etc"" ; <S2SV_EndBug> pw_init ( ) ; <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> return - 1 ; if ( fchown ( fileno ( fp ) , ( uid_t ) 0 , ( gid_t ) 0 ) < 0 ) goto fail ; if ( lckpwdf ( ) < 0 ) goto fail ; pwf = fopen ( PASSWD_FILE , ""r"" ) ; if ( ! pwf ) goto fail ; namelen = strlen ( pwd -> pw_name ) ; linebuf = malloc ( buflen ) ; if ( ! linebuf ) goto fail ; found = false ; while ( fgets ( linebuf , buflen , pwf ) != NULL ) { contlen = strlen ( linebuf ) ; while ( linebuf [ contlen - 1 ] != '\\n' && ! feof ( pwf ) ) { char * tmp ; buflen *= 2 ; tmp = realloc ( linebuf , buflen ) ; if ( tmp == NULL ) goto fail ; linebuf = tmp ; if ( fgets ( & linebuf [ contlen ] , buflen / 2 , pwf ) == NULL ) break ; contlen = strlen ( linebuf ) ; } if ( ! found && linebuf [ namelen ] == ':' && ! strncmp ( linebuf , pwd -> pw_name , namelen ) ) { if ( putpwent ( pwd , fp ) < 0 ) goto fail ; found = true ; continue ; } fputs ( linebuf , fp ) ; } if ( fchmod ( fileno ( fp ) , 0644 ) < 0 ) goto fail ; rc = close_stream ( fp ) ; fp = NULL ; if ( rc != 0 ) goto fail ; fclose ( pwf ) ; pwf = NULL ; if ( ! found ) { errno = ENOENT ; goto fail ; } unlink ( PASSWD_FILE "".OLD"" ) ; ignore_result ( link ( PASSWD_FILE , PASSWD_FILE "".OLD"" ) ) ; if ( rename ( tmpname , PASSWD_FILE ) < 0 ) goto fail ; ulckpwdf ( ) ; return 0 ; fail : save_errno = errno ; ulckpwdf ( ) ; if ( fp != NULL ) fclose ( fp ) ; if ( tmpname != NULL ) unlink ( tmpname ) ; free ( tmpname ) ; if ( pwf != NULL ) fclose ( pwf ) ; free ( linebuf ) ; errno = save_errno ; return - 1 ; }
","<S2SV_ModStart> passwd * pwd , const char * prefix <S2SV_ModStart> = NULL ; <S2SV_ModEnd> pw_init ( ) <S2SV_ModStart> & tmpname , ""/etc"" , prefix <S2SV_ModEnd> ) ) ==
",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z,391,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * <S2SV_ModStart> char * tmpname = NULL <S2SV_ModStart> char * tmpname ; <S2SV_ModEnd> char * tmpname <S2SV_ModStart> char * tmpname = NULL <S2SV_ModStart> ; if (! tmpname ) { err = NULL ; } <S2SV_ModEnd> if (!,0
985,CWE-119,"CWE-119 <S2SV_StartBug> static unsigned int convert_distribution ( unsigned int i , vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { unsigned int left , right ; if ( tree [ i ] <= 0 ) left = num_events [ - tree [ i ] ] ; else left = convert_distribution ( tree [ i ] , tree , branch_ct , num_events ) ; if ( tree [ i + 1 ] <= 0 ) right = num_events [ - tree [ i + 1 ] ] ; else right = convert_distribution ( tree [ i + 1 ] , tree , branch_ct , num_events ) ; branch_ct [ i >> 1 ] [ 0 ] = left ; branch_ct [ i >> 1 ] [ 1 ] = right ; return left + right ; }
","<S2SV_ModStart> int i , vpx_tree <S2SV_ModEnd> tree , unsigned
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,392,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
986,CWE-125,"CWE-125 int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }
","<S2SV_ModStart> s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> , s2 , len + 1 <S2SV_ModEnd> ) ; }
",jedisct1@pure-ftpd/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,CVE-2020-9365,https://github.com/jedisct1/pure-ftpd/commit/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,2020-02-24T16:15Z,393,<S2SV_ModStart> s2 ) { size_t s2 = 0 ; if (,0
987,CWE-346,"CWE-346 static gboolean _handle_carbons ( xmpp_stanza_t * const stanza ) { xmpp_stanza_t * carbons = xmpp_stanza_get_child_by_ns ( stanza , STANZA_NS_CARBONS ) ; if ( ! carbons ) { return FALSE ; } const char * name = xmpp_stanza_get_name ( carbons ) ; if ( ! name ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>stanza<S2SV_blank>name<S2SV_blank>for<S2SV_blank>Carbon"" ) ; return TRUE ; } if ( g_strcmp0 ( name , ""private"" ) == 0 ) { log_info ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>private<S2SV_blank>element."" ) ; return FALSE ; } if ( ( g_strcmp0 ( name , ""received"" ) != 0 ) && ( g_strcmp0 ( name , ""sent"" ) != 0 ) ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>unrecognised<S2SV_blank>stanza<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; return TRUE ; } xmpp_stanza_t * forwarded = xmpp_stanza_get_child_by_ns ( carbons , STANZA_NS_FORWARD ) ; if ( ! forwarded ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>forwarded<S2SV_blank>element"" ) ; return TRUE ; } xmpp_stanza_t * message = xmpp_stanza_get_child_by_name ( forwarded , STANZA_NAME_MESSAGE ) ; if ( ! message ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message<S2SV_blank>element"" ) ; return TRUE ; } char * message_txt = xmpp_message_get_body ( message ) ; if ( ! message_txt ) { log_warning ( ""Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message."" ) ; return TRUE ; } <S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> const gchar * from = xmpp_stanza_get_from ( message ) ; if ( ! to ) to = from ; Jid * jid_from = jid_create ( from ) ; <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; char * enc_message = NULL ; xmpp_stanza_t * x = xmpp_stanza_get_child_by_ns ( message , STANZA_NS_ENCRYPTED ) ; if ( x ) { enc_message = xmpp_stanza_get_text ( x ) ; } if ( g_strcmp0 ( my_jid -> barejid , jid_to -> barejid ) == 0 ) { sv_ev_incoming_carbon ( jid_from -> barejid , jid_from -> resourcepart , message_txt , enc_message ) ; } else { sv_ev_outgoing_carbon ( jid_to -> barejid , message_txt , enc_message ) ; } xmpp_ctx_t * ctx = connection_get_ctx ( ) ; xmpp_free ( ctx , message_txt ) ; xmpp_free ( ctx , enc_message ) ; jid_destroy ( jid_from ) ; jid_destroy ( jid_to ) ; jid_destroy ( my_jid ) ; return TRUE ; }
","<S2SV_ModStart> TRUE ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> jid_create ( to <S2SV_ModEnd> ) ; char
",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z,394,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S_null>,0
990,CWE-295,"CWE-295 int options_cmdline ( char * arg1 , char * arg2 ) { char * name ; CONF_TYPE type ; # ifdef USE_WIN32 ( void ) arg2 ; # endif if ( ! arg1 ) { name = # ifdef CONFDIR CONFDIR # ifdef USE_WIN32 ""\\\\"" # else ""/"" # endif # endif ""stunnel.conf"" ; type = CONF_FILE ; } else if ( ! strcasecmp ( arg1 , ""-help"" ) ) { <S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> parse_service_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-version"" ) ) { <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> parse_service_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-sockets"" ) ) { socket_options_print ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-options"" ) ) { print_ssl_options ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else # ifndef USE_WIN32 if ( ! strcasecmp ( arg1 , ""-fd"" ) ) { if ( ! arg2 ) { s_log ( LOG_ERR , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>specified"" ) ; print_syntax ( ) ; return 1 ; } name = arg2 ; type = CONF_FD ; } else # endif { name = arg1 ; type = CONF_FILE ; } if ( type == CONF_FILE ) { # ifdef HAVE_REALPATH char * real_path = NULL ; # ifdef MAXPATHLEN real_path = malloc ( MAXPATHLEN ) ; # endif real_path = realpath ( name , real_path ) ; if ( ! real_path ) { s_log ( LOG_ERR , ""Invalid<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>name<S2SV_blank>\\""%s\\"""" , name ) ; ioerror ( ""realpath"" ) ; return 1 ; } configuration_file = str_dup ( real_path ) ; free ( real_path ) ; # else configuration_file = str_dup ( name ) ; # endif # ifndef USE_WIN32 } else if ( type == CONF_FD ) { configuration_file = str_dup ( name ) ; # endif } return options_parse ( type ) ; }
","<S2SV_ModStart> NULL , NULL , NULL <S2SV_ModStart> parse_global_option ( CMD_PRINT_DEFAULTS , NULL
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,395,<S2SV_ModStart> TRUE ; } if ( arg2 == NULL ) return NULL,0
992,CWE-125,"CWE-125 PyObject * ast2obj_excepthandler ( void * _o ) { excepthandler_ty o = ( excepthandler_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case ExceptHandler_kind : result = PyType_GenericNew ( ExceptHandler_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . ExceptHandler . type ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> v . ExceptHandler . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ExceptHandler . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,396,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,1
993,CWE-125,"CWE-125 void process_packet_tail ( struct msg_digest * md ) { struct state * st = md -> st ; enum state_kind from_state = md -> v1_from_state ; const struct state_v1_microcode * smc = md -> smc ; bool new_iv_set = md -> new_iv_set ; bool self_delete = FALSE ; if ( md -> hdr . isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION ) { endpoint_buf b ; dbg ( ""received<S2SV_blank>encrypted<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>%s"" , str_endpoint ( & md -> sender , & b ) ) ; if ( st == NULL ) { libreswan_log ( ""discarding<S2SV_blank>encrypted<S2SV_blank>message<S2SV_blank>for<S2SV_blank>an<S2SV_blank>unknown<S2SV_blank>ISAKMP<S2SV_blank>SA"" ) ; return ; } if ( st -> st_skeyid_e_nss == NULL ) { loglog ( RC_LOG_SERIOUS , ""discarding<S2SV_blank>encrypted<S2SV_blank>message<S2SV_blank>because<S2SV_blank>we<S2SV_blank>haven\'t<S2SV_blank>yet<S2SV_blank>negotiated<S2SV_blank>keying<S2SV_blank>material"" ) ; return ; } md -> encrypted = TRUE ; const struct encrypt_desc * e = st -> st_oakley . ta_encrypt ; if ( pbs_left ( & md -> message_pbs ) % e -> enc_blocksize != 0 ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>message:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>encryption<S2SV_blank>blocksize"" ) ; return ; } md -> raw_packet = clone_bytes_as_chunk ( md -> packet_pbs . start , pbs_room ( & md -> packet_pbs ) , ""raw<S2SV_blank>packet"" ) ; if ( ! new_iv_set ) { if ( st -> st_v1_iv . len == 0 ) { init_phase2_iv ( st , & md -> hdr . isa_msgid ) ; } else { restore_new_iv ( st , st -> st_v1_iv ) ; } } passert ( st -> st_v1_new_iv . len >= e -> enc_blocksize ) ; st -> st_v1_new_iv . len = e -> enc_blocksize ; if ( DBGP ( DBG_CRYPT ) ) { DBG_log ( ""decrypting<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>using<S2SV_blank>algorithm<S2SV_blank>%s"" , ( unsigned ) pbs_left ( & md -> message_pbs ) , st -> st_oakley . ta_encrypt -> common . fqn ) ; DBG_dump_hunk ( ""IV<S2SV_blank>before:"" , st -> st_v1_new_iv ) ; } e -> encrypt_ops -> do_crypt ( e , md -> message_pbs . cur , pbs_left ( & md -> message_pbs ) , st -> st_enc_key_nss , st -> st_v1_new_iv . ptr , FALSE ) ; if ( DBGP ( DBG_CRYPT ) ) { DBG_dump_hunk ( ""IV<S2SV_blank>after:"" , st -> st_v1_new_iv ) ; DBG_log ( ""decrypted<S2SV_blank>payload<S2SV_blank>(starts<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%td):"" , md -> message_pbs . cur - md -> message_pbs . roof ) ; DBG_dump ( NULL , md -> message_pbs . start , md -> message_pbs . roof - md -> message_pbs . start ) ; } } else { if ( smc -> flags & SMF_INPUT_ENCRYPTED ) { loglog ( RC_LOG_SERIOUS , ""packet<S2SV_blank>rejected:<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>encrypted"" ) ; SEND_NOTIFICATION ( INVALID_FLAGS ) ; return ; } } { enum next_payload_types_ikev1 np = md -> hdr . isa_np ; lset_t needed = smc -> req_payloads ; const char * excuse = LIN ( SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT , smc -> flags ) ? ""probable<S2SV_blank>authentication<S2SV_blank>failure<S2SV_blank>(mismatch<S2SV_blank>of<S2SV_blank>preshared<S2SV_blank>secrets?):<S2SV_blank>"" : """" ; while ( np != ISAKMP_NEXT_NONE ) { struct_desc * sd = v1_payload_desc ( np ) ; if ( md -> digest_roof >= elemsof ( md -> digest ) ) { loglog ( RC_LOG_SERIOUS , ""more<S2SV_blank>than<S2SV_blank>%zu<S2SV_blank>payloads<S2SV_blank>in<S2SV_blank>message;<S2SV_blank>ignored"" , elemsof ( md -> digest ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } struct payload_digest * const pd = md -> digest + md -> digest_roof ; if ( st != NULL && st -> st_connection != NULL && ( st -> st_connection -> policy & POLICY_AGGRESSIVE ) == LEMPTY ) { switch ( np ) { case ISAKMP_NEXT_NATD_RFC : case ISAKMP_NEXT_NATOA_RFC : if ( ( st -> hidden_variables . st_nat_traversal & NAT_T_WITH_RFC_VALUES ) == LEMPTY ) { DBG ( DBG_NATT , DBG_log ( ""st_nat_traversal<S2SV_blank>was:<S2SV_blank>%s"" , bitnamesof ( natt_bit_names , st -> hidden_variables . st_nat_traversal ) ) ) ; sd = NULL ; } break ; default : break ; } } if ( sd == NULL ) { switch ( np ) { case ISAKMP_NEXT_ID : sd = ( IS_PHASE1 ( from_state ) || IS_PHASE15 ( from_state ) ) ? & isakmp_identification_desc : & isakmp_ipsec_identification_desc ; break ; case ISAKMP_NEXT_NATD_DRAFTS : np = ISAKMP_NEXT_NATD_RFC ; sd = & isakmp_nat_d_drafts ; break ; case ISAKMP_NEXT_NATOA_DRAFTS : np = ISAKMP_NEXT_NATOA_RFC ; sd = & isakmp_nat_oa_drafts ; break ; case ISAKMP_NEXT_SAK : loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>with<S2SV_blank>unsupported<S2SV_blank>payload<S2SV_blank>ISAKMP_NEXT_SAK<S2SV_blank>(or<S2SV_blank>ISAKMP_NEXT_NATD_BADDRAFTS)<S2SV_blank>ignored"" , excuse ) ; if ( ! in_struct ( & pd -> payload , & isakmp_ignore_desc , & md -> message_pbs , & pd -> pbs ) ) { loglog ( RC_LOG_SERIOUS , ""%smalformed<S2SV_blank>payload<S2SV_blank>in<S2SV_blank>packet"" , excuse ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } np = pd -> payload . generic . isag_np ; continue ; default : loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unknown<S2SV_blank>or<S2SV_blank>unexpected<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>at<S2SV_blank>the<S2SV_blank>outermost<S2SV_blank>level"" , excuse , enum_show ( & ikev1_payload_names , np ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( INVALID_PAYLOAD_TYPE ) ; } return ; } passert ( sd != NULL ) ; } passert ( np < LELEM_ROOF ) ; { lset_t s = LELEM ( np ) ; if ( LDISJOINT ( s , needed | smc -> opt_payloads | LELEM ( ISAKMP_NEXT_VID ) | LELEM ( ISAKMP_NEXT_N ) | LELEM ( ISAKMP_NEXT_D ) | LELEM ( ISAKMP_NEXT_CR ) | LELEM ( ISAKMP_NEXT_CERT ) ) ) { loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>unexpected<S2SV_blank>by<S2SV_blank>state<S2SV_blank>%s"" , excuse , enum_show ( & ikev1_payload_names , np ) , <S2SV_StartBug> st -> st_state -> name ) ; <S2SV_EndBug> if ( ! md -> encrypted ) { SEND_NOTIFICATION ( INVALID_PAYLOAD_TYPE ) ; } return ; } DBG ( DBG_PARSING , DBG_log ( ""got<S2SV_blank>payload<S2SV_blank>0x%"" PRIxLSET ""<S2SV_blank><S2SV_blank>(%s)<S2SV_blank>needed:<S2SV_blank>0x%"" PRIxLSET ""<S2SV_blank>opt:<S2SV_blank>0x%"" PRIxLSET , s , enum_show ( & ikev1_payload_names , np ) , needed , smc -> opt_payloads ) ) ; needed &= ~ s ; } pd -> payload_type = np ; if ( ! in_struct ( & pd -> payload , sd , & md -> message_pbs , & pd -> pbs ) ) { loglog ( RC_LOG_SERIOUS , ""%smalformed<S2SV_blank>payload<S2SV_blank>in<S2SV_blank>packet"" , excuse ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } switch ( np ) { case ISAKMP_NEXT_ID : case ISAKMP_NEXT_NATOA_RFC : DBG ( DBG_PARSING , DBG_dump ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>obj:<S2SV_blank>"" , pd -> pbs . cur , pbs_left ( & pd -> pbs ) ) ) ; break ; default : break ; } { passert ( np < elemsof ( md -> chain ) ) ; struct payload_digest * * p = & md -> chain [ np ] ; while ( * p != NULL ) p = & ( * p ) -> next ; * p = pd ; pd -> next = NULL ; } np = pd -> payload . generic . isag_np ; md -> digest_roof ++ ; excuse = """" ; } DBG ( DBG_PARSING , { if ( pbs_left ( & md -> message_pbs ) != 0 ) DBG_log ( ""removing<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>padding"" , ( int ) pbs_left ( & md -> message_pbs ) ) ; } ) ; md -> message_pbs . roof = md -> message_pbs . cur ; if ( needed != 0 ) { loglog ( RC_LOG_SERIOUS , ""message<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>missing<S2SV_blank>payloads<S2SV_blank>%s"" , finite_states [ from_state ] -> name , bitnamesof ( payload_name_ikev1 , needed ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } } if ( ! check_v1_HASH ( smc -> hash_type , smc -> message , st , md ) ) { return ; } if ( IS_PHASE1 ( from_state ) || IS_PHASE15 ( from_state ) ) { if ( md -> chain [ ISAKMP_NEXT_SA ] != NULL && md -> hdr . isa_np != ISAKMP_NEXT_SA ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Phase<S2SV_blank>1<S2SV_blank>message:<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>an<S2SV_blank>SA<S2SV_blank>payload"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } } else if ( IS_QUICK ( from_state ) ) { if ( md -> hdr . isa_np != ISAKMP_NEXT_HASH ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>HASH<S2SV_blank>payload"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } { struct payload_digest * p ; int i ; p = md -> chain [ ISAKMP_NEXT_SA ] ; i = 1 ; while ( p != NULL ) { if ( p != & md -> digest [ i ] ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>SA<S2SV_blank>payload<S2SV_blank>is<S2SV_blank>in<S2SV_blank>wrong<S2SV_blank>position"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } p = p -> next ; i ++ ; } } { struct payload_digest * id = md -> chain [ ISAKMP_NEXT_ID ] ; if ( id != NULL ) { if ( id -> next == NULL || id -> next -> next != NULL ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>if<S2SV_blank>any<S2SV_blank>ID<S2SV_blank>payload<S2SV_blank>is<S2SV_blank>present,<S2SV_blank>there<S2SV_blank>must<S2SV_blank>be<S2SV_blank>exactly<S2SV_blank>two"" ) ; SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; return ; } if ( id + 1 != id -> next ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>the<S2SV_blank>ID<S2SV_blank>payloads<S2SV_blank>are<S2SV_blank>not<S2SV_blank>adjacent"" ) ; SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; return ; } } } } { struct payload_digest * p = md -> chain [ ISAKMP_NEXT_N ] ; while ( p != NULL ) { switch ( p -> payload . notification . isan_type ) { case R_U_THERE : case R_U_THERE_ACK : case ISAKMP_N_CISCO_LOAD_BALANCE : case PAYLOAD_MALFORMED : case INVALID_MESSAGE_ID : case IPSEC_RESPONDER_LIFETIME : if ( md -> hdr . isa_xchg == ISAKMP_XCHG_INFO ) { break ; } default : if ( st == NULL ) { DBG ( DBG_CONTROL , DBG_log ( ""ignoring<S2SV_blank>informational<S2SV_blank>payload<S2SV_blank>%s,<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>state"" , enum_show ( & ikev1_notify_names , p -> payload . notification . isan_type ) ) ) ; } else { loglog ( RC_LOG_SERIOUS , ""ignoring<S2SV_blank>informational<S2SV_blank>payload<S2SV_blank>%s,<S2SV_blank>msgid=%08"" PRIx32 "",<S2SV_blank>length=%d"" , enum_show ( & ikev1_notify_names , p -> payload . notification . isan_type ) , st -> st_v1_msgid . id , p -> payload . notification . isan_length ) ; DBG_dump_pbs ( & p -> pbs ) ; } } if ( DBGP ( DBG_BASE ) ) { DBG_dump ( ""info:"" , p -> pbs . cur , pbs_left ( & p -> pbs ) ) ; } p = p -> next ; } p = md -> chain [ ISAKMP_NEXT_D ] ; while ( p != NULL ) { self_delete |= accept_delete ( md , p ) ; if ( DBGP ( DBG_BASE ) ) { DBG_dump ( ""del:"" , p -> pbs . cur , pbs_left ( & p -> pbs ) ) ; } if ( md -> st != st ) { pexpect ( md -> st == NULL ) ; dbg ( ""zapping<S2SV_blank>ST<S2SV_blank>as<S2SV_blank>accept_delete()<S2SV_blank>zapped<S2SV_blank>MD.ST"" ) ; st = md -> st ; } p = p -> next ; } p = md -> chain [ ISAKMP_NEXT_VID ] ; while ( p != NULL ) { handle_vendorid ( md , ( char * ) p -> pbs . cur , pbs_left ( & p -> pbs ) , FALSE ) ; p = p -> next ; } } if ( self_delete ) { accept_self_delete ( md ) ; st = md -> st ; } pexpect ( st == md -> st ) ; statetime_t start = statetime_start ( md -> st ) ; complete_v1_state_transition ( md , smc -> processor ( st , md ) ) ; statetime_stop ( & start , ""%s()"" , __func__ ) ; }
","<S2SV_ModStart> np ) , finite_states [ smc -> state ] <S2SV_ModEnd> -> name )
",libreswan@libreswan/471a3e41a449d7c753bc4edbba4239501bb62ba8,CVE-2020-1763,https://github.com/libreswan/libreswan/commit/471a3e41a449d7c753bc4edbba4239501bb62ba8,2020-05-12T14:15Z,397,<S2SV_ModStart> ; if ( s_len < 1 &&,0
994,CWE-787,"CWE-787 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; <S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> } }
","<S2SV_ModStart> = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
",external@libmpeg2/bef16671c891e16f25a7b174bc528eea109357be,CVE-2018-9497,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be,2018-10-02T19:29Z,398,,0
997,CWE-119,"CWE-119 <S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> { <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cJSON * item , printbuffer * p <S2SV_ModStart> item -> valuestring , p
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,399,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
998,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_encode ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx || ( img && ! duration ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { unsigned int num_enc = ctx -> priv -> enc . total_encoders ; FLOATING_POINT_INIT ( ) ; if ( num_enc == 1 ) <S2SV_StartBug> res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> duration , flags , deadline ) ; else { int i ; ctx += num_enc - 1 ; if ( img ) img += num_enc - 1 ; for ( i = num_enc - 1 ; i >= 0 ; i -- ) { <S2SV_StartBug> if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> duration , flags , deadline ) ) ) break ; ctx -- ; if ( img ) img -- ; } ctx ++ ; } FLOATING_POINT_RESTORE ( ) ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> . encode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , img , <S2SV_ModStart> . encode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , img ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,400,,0
999,CWE-119,"CWE-119 int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = ""<S2SV_blank>"" ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = ""xtractprotos"" ; if ( argc == 1 ) { fprintf ( stderr , ""xtractprotos<S2SV_blank>[-prestring=<string>]<S2SV_blank>[-protos=<where>]<S2SV_blank>"" ""[list<S2SV_blank>of<S2SV_blank>C<S2SV_blank>files]\\n"" ""where<S2SV_blank>the<S2SV_blank>prestring<S2SV_blank>is<S2SV_blank>prepended<S2SV_blank>to<S2SV_blank>each<S2SV_blank>prototype,<S2SV_blank>and<S2SV_blank>\\n"" ""protos<S2SV_blank>can<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'inline\'<S2SV_blank>or<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>an<S2SV_blank>output<S2SV_blank>"" ""prototype<S2SV_blank>file\\n"" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , ""-prestring"" , 10 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , ""parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>prestring\\n"" ) ; return 1 ; } <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> L_WARNING ( ""prestring<S2SV_blank>too<S2SV_blank>large;<S2SV_blank>omitting!\\n"" , mainName ) ; } else { buf [ len ] = '<S2SV_blank>' ; buf [ len + 1 ] = '\\0' ; prestring = stringNew ( buf ) ; } } else if ( ! strncmp ( argv [ i ] , ""-protos"" , 7 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , ""parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>protos\\n"" ) ; return 1 ; } outprotos = stringNew ( buf ) ; if ( ! strncmp ( outprotos , ""inline"" , 7 ) ) in_line = TRUE ; } } } if ( argc - nflags < 2 ) { fprintf ( stderr , ""no<S2SV_blank>files<S2SV_blank>specified!\\n"" ) ; return 1 ; } ba = l_byteaCreate ( 500 ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) ""/*"" , L_COPY ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , version ) ; sarrayAddString ( sa , buf , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""<S2SV_blank>*/"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""#ifdef<S2SV_blank>__cplusplus"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""extern<S2SV_blank>\\""C\\""<S2SV_blank>{"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/\\n"" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; firstfile = 1 + nflags ; protos_added = FALSE ; if ( ( tempfile = l_makeTempFilename ( ) ) == NULL ) { fprintf ( stderr , ""failure<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>writeable<S2SV_blank>temp<S2SV_blank>file\\n"" ) ; return 1 ; } for ( i = firstfile ; i < argc ; i ++ ) { filein = argv [ i ] ; len = strlen ( filein ) ; if ( filein [ len - 1 ] == 'h' ) continue ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , <S2SV_EndBug> filein , tempfile ) ; ret = system ( buf ) ; if ( ret ) { fprintf ( stderr , ""cpp<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n"" , filein ) ; continue ; } if ( ( str = parseForProtos ( tempfile , prestring ) ) == NULL ) { fprintf ( stderr , ""parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n"" , filein ) ; continue ; } if ( strlen ( str ) > 1 ) { l_byteaAppendString ( ba , str ) ; protos_added = TRUE ; } lept_free ( str ) ; } lept_rmfile ( tempfile ) ; lept_free ( tempfile ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) ""\\n#ifdef<S2SV_blank>__cplusplus"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""}"" , L_COPY ) ; sarrayAddString ( sa , ( char * ) ""#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/"" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; protostr = ( char * ) l_byteaCopyData ( ba , & nbytes ) ; l_byteaDestroy ( & ba ) ; if ( ! outprotos ) { fprintf ( stderr , ""%s\\n"" , protostr ) ; lept_free ( protostr ) ; return 0 ; } if ( ! protos_added ) { fprintf ( stderr , ""No<S2SV_blank>protos<S2SV_blank>found\\n"" ) ; lept_free ( protostr ) ; return 1 ; } ba = l_byteaInitFromFile ( ""allheaders_top.txt"" ) ; if ( ! in_line ) { snprintf ( buf , sizeof ( buf ) , ""#include<S2SV_blank>\\""%s\\""\\n"" , outprotos ) ; l_byteaAppendString ( ba , buf ) ; l_binaryWrite ( outprotos , ""w"" , protostr , nbytes ) ; } else { l_byteaAppendString ( ba , protostr ) ; } ba2 = l_byteaInitFromFile ( ""allheaders_bot.txt"" ) ; l_byteaJoin ( ba , & ba2 ) ; l_byteaWrite ( ""allheaders.h"" , ba , 0 , 0 ) ; l_byteaDestroy ( & ba ) ; lept_free ( protostr ) ; return 0 ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_uint8 <S2SV_ModStart> + 1 , ""prestring=%490s"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ) ) > L_BUFSIZE <S2SV_ModEnd> - 3 ) <S2SV_ModStart> + 1 , ""protos=%490s"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" ,
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z,401,"<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( buf, L_BUFSIZE <S2SV_ModEnd>, ""%s"",",0
1002,CWE-000,"CWE-000 static void do_winop ( void ) { int arg1 = term . csi_argv [ 1 ] , arg2 = term . csi_argv [ 2 ] ; if ( * cfg . suppress_win && contains ( cfg . suppress_win , term . csi_argv [ 0 ] ) ) return ; switch ( term . csi_argv [ 0 ] ) { when 1 : win_set_iconic ( false ) ; when 2 : win_set_iconic ( true ) ; when 3 : win_set_pos ( arg1 , arg2 ) ; when 4 : win_set_pixels ( arg1 , arg2 ) ; when 5 : if ( term . csi_argc != 1 ) return ; win_set_zorder ( true ) ; when 6 : if ( term . csi_argc != 1 ) return ; win_set_zorder ( false ) ; when 7 : win_invalidate_all ( false ) ; when 8 : { int def1 = term . csi_argv_defined [ 1 ] , def2 = term . csi_argv_defined [ 2 ] ; int rows , cols ; win_get_screen_chars ( & rows , & cols ) ; win_set_chars ( arg1 ? : def1 ? rows : term . rows , arg2 ? : def2 ? cols : term . cols ) ; } when 9 : { if ( term . csi_argc != 2 ) return ; int rows0 = term . rows0 , cols0 = term . cols0 ; if ( arg1 == 2 ) { win_set_geom ( 0 , - 1 , 0 , - 1 ) ; term . rows0 = rows0 ; term . cols0 = cols0 ; } else if ( arg1 == 3 ) { win_set_geom ( - 1 , 0 , - 1 , 0 ) ; term . rows0 = rows0 ; term . cols0 = cols0 ; } else if ( arg1 == 1 ) { win_maximise ( 1 ) ; term . rows0 = rows0 ; term . cols0 = cols0 ; } else if ( arg1 == 0 ) { win_maximise ( 0 ) ; win_set_chars ( rows0 , cols0 ) ; } <S2SV_StartBug> } <S2SV_EndBug> when 10 : if ( term . csi_argc != 2 ) return ; if ( arg1 == 2 ) win_maximise ( - 2 ) ; else if ( arg1 == 1 || arg1 == 0 ) <S2SV_StartBug> win_maximise ( arg1 ? 2 : 0 ) ; <S2SV_EndBug> when 11 : child_write ( win_is_iconic ( ) ? ""\\e[2t"" : ""\\e[1t"" , 4 ) ; when 13 : { int x , y ; win_get_scrpos ( & x , & y , arg1 == 2 ) ; child_printf ( ""\\e[3;%u;%ut"" , ( ushort ) x , ( ushort ) y ) ; } when 14 : { int height , width ; win_get_pixels ( & height , & width , arg1 == 2 ) ; child_printf ( ""\\e[4;%d;%dt"" , height , width ) ; } when 15 : { int w , h ; search_monitors ( & w , & h , 0 , false , 0 ) ; child_printf ( ""\\e[5;%d;%dt"" , h , w ) ; } when 16 : child_printf ( ""\\e[6;%d;%dt"" , cell_height , cell_width ) ; when 18 : child_printf ( ""\\e[8;%d;%dt"" , term . rows , term . cols ) ; when 19 : { # ifdef size_of_monitor_only # warning not what xterm reports int rows , cols ; win_get_screen_chars ( & rows , & cols ) ; child_printf ( ""\\e[9;%d;%dt"" , rows , cols ) ; # else int w , h ; search_monitors ( & w , & h , 0 , false , 0 ) ; child_printf ( ""\\e[9;%d;%dt"" , h / cell_height , w / cell_width ) ; # endif } when 22 : if ( arg1 == 0 || arg1 == 2 ) win_save_title ( ) ; when 23 : if ( arg1 == 0 || arg1 == 2 ) win_restore_title ( ) ; } }
","<S2SV_ModStart> ) ; } usleep ( 1000 ) ; <S2SV_ModStart> 2 : 0 ) ; usleep ( 1000
",mintty@mintty/bd52109993440b6996760aaccb66e68e782762b9,CVE-2021-28848,https://github.com/mintty/mintty/commit/bd52109993440b6996760aaccb66e68e782762b9,2021-06-03T12:15Z,402,<S2SV_ModStart> 1 ) ; if (,0
1005,CWE-119,"CWE-119 void vp8_mbpost_proc_across_ip_c ( unsigned char * src , int pitch , int rows , int cols , int flimit ) { int r , c , i ; unsigned char * s = src ; unsigned char d [ 16 ] ; for ( r = 0 ; r < rows ; r ++ ) { int sumsq = 0 ; int sum = 0 ; for ( i = - 8 ; i < 0 ; i ++ ) s [ i ] = s [ 0 ] ; <S2SV_StartBug> for ( i = cols ; i < cols + 17 ; i ++ ) <S2SV_EndBug> s [ i ] = s [ cols - 1 ] ; for ( i = - 8 ; i <= 6 ; i ++ ) { sumsq += s [ i ] * s [ i ] ; sum += s [ i ] ; d [ i + 8 ] = 0 ; } for ( c = 0 ; c < cols + 8 ; c ++ ) { int x = s [ c + 7 ] - s [ c - 8 ] ; int y = s [ c + 7 ] + s [ c - 8 ] ; sum += x ; sumsq += x * y ; d [ c & 15 ] = s [ c ] ; if ( sumsq * 15 - sum * sum < flimit ) { d [ c & 15 ] = ( 8 + sum + s [ c ] ) >> 4 ; } s [ c - 8 ] = d [ ( c - 8 ) & 15 ] ; } s += pitch ; } }
","<S2SV_ModStart> ( i = 0 ; i < 17 ; i ++ ) s [ i + cols <S2SV_ModEnd> ] = s
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,403,,0
1007,CWE-119,"CWE-119 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; <S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
","<S2SV_ModStart> = act_code ; if ( npix > 0 ) <S2SV_ModStart> = casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - stackp <S2SV_ModStart> - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= (
",miniupnp@ngiflib/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,CVE-2018-10717,https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,2018-05-03T17:29Z,404,,0
1012,CWE-119,"CWE-119 <S2SV_StartBug> static void encode_term_subexp ( vp9_writer * w , int word ) { <S2SV_EndBug> if ( ! write_bit_gte ( w , word , 16 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word , 4 ) ; <S2SV_EndBug> } else if ( ! write_bit_gte ( w , word , 32 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word - 16 , 4 ) ; <S2SV_EndBug> } else if ( ! write_bit_gte ( w , word , 64 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word - 32 , 5 ) ; <S2SV_EndBug> } else { encode_uniform ( w , word - 64 ) ; } }
","<S2SV_ModStart> void encode_term_subexp ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> ) ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> ) ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> ) ) { vpx_write_literal <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,405,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static vpx_write_literal <S2SV_ModEnd> ( w, <S2SV_ModStart> 8 ) { vpx_write_literal <S2SV_ModEnd> ( w, <S2SV_ModStart> 0 ) { vpx_literal <S2SV_ModEnd> ( w, <S2SV_ModStart> 0 ) ; vpx_write_literal <S2SV_ModEnd> ( w,",0
1017,CWE-000,"CWE-000 static krb5_error_code krb5_ldap_get_password_policy_from_dn ( krb5_context context , char * pol_name , char * pol_dn , osa_policy_ent_t * policy ) { krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; krb5_clear_error_message ( context ) ; if ( pol_dn == NULL ) return EINVAL ; * policy = NULL ; SETUP_CONTEXT ( ) ; GET_HANDLE ( ) ; * ( policy ) = ( osa_policy_ent_t ) malloc ( sizeof ( osa_policy_ent_rec ) ) ; if ( * policy == NULL ) { st = ENOMEM ; goto cleanup ; } memset ( * policy , 0 , sizeof ( osa_policy_ent_rec ) ) ; LDAP_SEARCH ( pol_dn , LDAP_SCOPE_BASE , ""(objectclass=krbPwdPolicy)"" , password_policy_attributes ) ; ent = ldap_first_entry ( ld , result ) ; <S2SV_StartBug> if ( ent != NULL ) { <S2SV_EndBug> if ( ( st = populate_policy ( context , ld , ent , pol_name , * policy ) ) != 0 ) goto cleanup ; } <S2SV_StartBug> cleanup : <S2SV_EndBug> ldap_msgfree ( result ) ; if ( st != 0 ) { if ( * policy != NULL ) { krb5_ldap_free_password_policy ( context , * policy ) ; * policy = NULL ; } } krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return st ; }
","<S2SV_ModStart> if ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> goto cleanup ; <S2SV_ModStart> cleanup ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ;
",krb5@krb5/d1f707024f1d0af6e54a18885322d70fa15ec4d3,CVE-2014-5353,https://github.com/krb5/krb5/commit/d1f707024f1d0af6e54a18885322d70fa15ec4d3,2014-12-16T23:59Z,406,<S2SV_ModStart> goto cleanup ; <S2SV_ModEnd> goto cleanup ;,0
1018,CWE-119,"CWE-119 IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ; BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { <S2SV_StartBug> UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; <S2SV_EndBug> ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || <S2SV_StartBug> ( ps_pps -> i1_num_tile_columns > ps_sps -> i2_pic_wd_in_ctb ) || <S2SV_EndBug> ( ps_pps -> i1_num_tile_rows < 1 ) || <S2SV_StartBug> ( ps_pps -> i1_num_tile_rows > ps_sps -> i2_pic_ht_in_ctb ) ) <S2SV_EndBug> return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; ps_codec -> i4_pps_done = 1 ; return ret ; }
","<S2SV_ModStart> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> -> i1_num_tile_columns > max_tile_cols <S2SV_ModEnd> ) || ( <S2SV_ModStart> -> i1_num_tile_rows > max_tile_rows <S2SV_ModEnd> ) ) return
",external@libhevc/ebaa71da6362c497310377df509651974401d258,CVE-2017-0637,https://android.googlesource.com/platform/external/libhevc/+/ebaa71da6362c497310377df509651974401d258,2017-06-14T13:29Z,407,,0
1020,CWE-119,"CWE-119 int psf_binheader_writef ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; sf_count_t countdata ; unsigned long longdata ; unsigned int data ; float floatdata ; double doubledata ; void * bindata ; size_t size ; char c , * strptr ; int count = 0 , trunc_8to4 ; trunc_8to4 = SF_FALSE ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> { case '<S2SV_blank>' : break ; case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 't' : trunc_8to4 = SF_TRUE ; break ; case 'T' : trunc_8to4 = SF_FALSE ; break ; case 'm' : data = va_arg ( argptr , unsigned int ) ; header_put_marker ( psf , data ) ; count += 4 ; break ; case '1' : data = va_arg ( argptr , unsigned int ) ; header_put_byte ( psf , data ) ; count += 1 ; break ; case '2' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_short ( psf , data ) ; } else { header_put_le_short ( psf , data ) ; } ; count += 2 ; break ; case '3' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_3byte ( psf , data ) ; } else { header_put_le_3byte ( psf , data ) ; } ; count += 3 ; break ; case '4' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_int ( psf , data ) ; } else { header_put_le_int ( psf , data ) ; } ; count += 4 ; break ; case '8' : countdata = va_arg ( argptr , sf_count_t ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE ) { header_put_be_8byte ( psf , countdata ) ; count += 8 ; } else if ( psf -> rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE ) { header_put_le_8byte ( psf , countdata ) ; count += 8 ; } else if ( psf -> rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE ) { longdata = countdata & 0xFFFFFFFF ; header_put_be_int ( psf , longdata ) ; count += 4 ; } else if ( psf -> rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE ) { longdata = countdata & 0xFFFFFFFF ; header_put_le_int ( psf , longdata ) ; count += 4 ; } break ; case 'f' : floatdata = ( float ) va_arg ( argptr , double ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_StartBug> float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> else <S2SV_StartBug> float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> psf -> headindex += 4 ; count += 4 ; break ; case 'd' : doubledata = va_arg ( argptr , double ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_StartBug> double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> else <S2SV_StartBug> double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> psf -> headindex += 8 ; count += 8 ; break ; case 's' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) + 1 ; <S2SV_StartBug> size += ( size & 1 ) ; <S2SV_EndBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) header_put_be_int ( psf , size ) ; else header_put_le_int ( psf , size ) ; <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex - 1 ] = 0 ; <S2SV_EndBug> count += 4 + size ; break ; case 'S' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) ; <S2SV_StartBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_EndBug> header_put_be_int ( psf , size ) ; else header_put_le_int ( psf , size ) ; <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; <S2SV_EndBug> size += ( size & 1 ) ; <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ] = 0 ; <S2SV_EndBug> count += 4 + size ; break ; case 'p' : strptr = va_arg ( argptr , char * ) ; size = strlen ( strptr ) ; size = ( size & 1 ) ? size : size + 1 ; size = ( size > 254 ) ? 254 : size ; <S2SV_StartBug> header_put_byte ( psf , size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> count += 1 + size ; break ; case 'b' : bindata = va_arg ( argptr , void * ) ; size = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( psf -> headindex + size < sizeof ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; <S2SV_EndBug> psf -> headindex += size ; count += size ; } ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; count += size ; while ( size ) { psf -> header [ psf -> headindex ] = 0 ; <S2SV_StartBug> psf -> headindex ++ ; <S2SV_EndBug> size -- ; } ; break ; case 'h' : bindata = va_arg ( argptr , void * ) ; <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += 16 ; <S2SV_EndBug> count += 16 ; break ; case 'j' : size = va_arg ( argptr , size_t ) ; <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> count += size ; break ; case 'o' : size = va_arg ( argptr , size_t ) ; <S2SV_StartBug> if ( size < sizeof ( psf -> header ) ) <S2SV_EndBug> { psf -> headindex = size ; count = 0 ; } ; break ; default : psf_log_printf ( psf , ""***<S2SV_blank>Invalid<S2SV_blank>format<S2SV_blank>specifier<S2SV_blank>`%c\'\\n"" , c ) ; psf -> error = SFE_INTERNAL ; break ; } ; } ; va_end ( argptr ) ; return count ; }
","<S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 4 ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 8 ; <S2SV_ModStart> & 1 ) ; if ( psf -> header . indx + ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> - 1 ] <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; if ( psf -> <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] = 0 <S2SV_ModStart> : size ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; memcpy ( & ( psf -> header . ptr [ psf -> header . indx ] ) , bindata , size ) ; psf -> header . indx += size ; count += size ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; count += size ; while ( size ) { psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx ] <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> ++ ; size <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += 16 ; <S2SV_ModStart> size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ; if ( ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx = size <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,408,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1021,CWE-125,"CWE-125 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO ""0x%02x"" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO "",<S2SV_blank>"" ) ; } printk ( "")<S2SV_blank>toneburst=%d\\n"" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( ""%s<S2SV_blank>burst=%d\\n"" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }
","<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i
",torvalds@linux/1fa2337a315a2448c5434f41e00d56b01a22283c,CVE-2015-9289,https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c,2019-07-27T22:15Z,409,<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i,1
1023,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
",ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z,410,,0
1024,CWE-269,"CWE-269 static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { fprintf ( stderr , ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; return 0 ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0600 ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> 0600 ) ; <S2SV_ModEnd> fs_logger2 ( ""clone"" <S2SV_ModStart> ""clone"" , dest <S2SV_ModEnd> ) ; return
",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z,411,"<S2SV_ModStart> ( src, NULL <S2SV_ModEnd> ) ; }",0
1032,CWE-119,"CWE-119 <S2SV_StartBug> static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) { <S2SV_EndBug> switch ( bsize ) { case BLOCK_8X8 : <S2SV_StartBug> return vp9_mse8x8 ; <S2SV_EndBug> case BLOCK_16X8 : <S2SV_StartBug> return vp9_mse16x8 ; <S2SV_EndBug> case BLOCK_8X16 : <S2SV_StartBug> return vp9_mse8x16 ; <S2SV_EndBug> default : <S2SV_StartBug> return vp9_mse16x16 ; <S2SV_EndBug> } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_variance_fn_t <S2SV_ModEnd> get_block_variance_fn ( BLOCK_SIZE <S2SV_ModStart> BLOCK_8X8 : return vpx_mse8x8 <S2SV_ModEnd> ; case BLOCK_16X8 <S2SV_ModStart> BLOCK_16X8 : return vpx_mse16x8 <S2SV_ModEnd> ; case BLOCK_8X16 <S2SV_ModStart> BLOCK_8X16 : return vpx_mse8x16 <S2SV_ModEnd> ; default : <S2SV_ModStart> default : return vpx_mse16x16 <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,412,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1033,CWE-000,"CWE-000 static void _isdn_setup ( struct net_device * dev ) { isdn_net_local * lp = netdev_priv ( dev ) ; ether_setup ( dev ) ; dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; <S2SV_StartBug> dev -> header_ops = NULL ; <S2SV_EndBug> dev -> netdev_ops = & isdn_netdev_ops ; dev -> tx_queue_len = 30 ; lp -> p_encap = ISDN_NET_ENCAP_RAWIP ; lp -> magic = ISDN_NET_MAGIC ; lp -> last = lp ; lp -> next = lp ; lp -> isdn_device = - 1 ; lp -> isdn_channel = - 1 ; lp -> pre_device = - 1 ; lp -> pre_channel = - 1 ; lp -> exclusive = - 1 ; lp -> ppp_slot = - 1 ; lp -> pppbind = - 1 ; skb_queue_head_init ( & lp -> super_tx_queue ) ; lp -> l2_proto = ISDN_PROTO_L2_X75I ; lp -> l3_proto = ISDN_PROTO_L3_TRANS ; lp -> triggercps = 6000 ; lp -> slavedelay = 10 * HZ ; lp -> hupflags = ISDN_INHUP ; lp -> onhtime = 10 ; lp -> dialmax = 1 ; lp -> flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL ; lp -> cbdelay = 25 ; lp -> dialtimeout = - 1 ; lp -> dialwait = 5 * HZ ; lp -> dialstarted = 0 ; lp -> dialwait_timer = 0 ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,413,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->,1
1036,CWE-000,"CWE-000 static krb5_error_code pkinit_server_return_padata ( krb5_context context , krb5_pa_data * padata , krb5_data * req_pkt , krb5_kdc_req * request , krb5_kdc_rep * reply , krb5_keyblock * encrypting_key , krb5_pa_data * * send_pa , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_modreq modreq ) { krb5_error_code retval = 0 ; krb5_data scratch = { 0 , 0 , NULL } ; krb5_pa_pk_as_req * reqp = NULL ; krb5_pa_pk_as_req_draft9 * reqp9 = NULL ; int i = 0 ; unsigned char * subjectPublicKey = NULL ; unsigned char * dh_pubkey = NULL , * server_key = NULL ; unsigned int subjectPublicKey_len = 0 ; unsigned int server_key_len = 0 , dh_pubkey_len = 0 ; krb5_kdc_dh_key_info dhkey_info ; krb5_data * encoded_dhkey_info = NULL ; krb5_pa_pk_as_rep * rep = NULL ; krb5_pa_pk_as_rep_draft9 * rep9 = NULL ; krb5_data * out_data = NULL ; krb5_octet_data secret ; krb5_enctype enctype = - 1 ; krb5_reply_key_pack * key_pack = NULL ; krb5_reply_key_pack_draft9 * key_pack9 = NULL ; krb5_data * encoded_key_pack = NULL ; pkinit_kdc_context plgctx ; pkinit_kdc_req_context reqctx ; int fixed_keypack = 0 ; * send_pa = NULL ; if ( padata -> pa_type == KRB5_PADATA_PKINIT_KX ) { return return_pkinit_kx ( context , request , reply , encrypting_key , send_pa ) ; } if ( padata -> length <= 0 || padata -> contents == NULL ) return 0 ; if ( modreq == NULL ) { pkiDebug ( ""missing<S2SV_blank>request<S2SV_blank>context<S2SV_blank>\\n"" ) ; return EINVAL ; } plgctx = pkinit_find_realm_context ( context , moddata , request -> server ) ; if ( plgctx == NULL ) { pkiDebug ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>correct<S2SV_blank>realm<S2SV_blank>context\\n"" ) ; return ENOENT ; } pkiDebug ( ""pkinit_return_padata:<S2SV_blank>entered!\\n"" ) ; reqctx = ( pkinit_kdc_req_context ) modreq ; if ( encrypting_key -> contents ) { free ( encrypting_key -> contents ) ; encrypting_key -> length = 0 ; encrypting_key -> contents = NULL ; } for ( i = 0 ; i < request -> nktypes ; i ++ ) { enctype = request -> ktype [ i ] ; if ( ! krb5_c_valid_enctype ( enctype ) ) continue ; else { pkiDebug ( ""KDC<S2SV_blank>picked<S2SV_blank>etype<S2SV_blank>=<S2SV_blank>%d\\n"" , enctype ) ; break ; } } if ( i == request -> nktypes ) { retval = KRB5KDC_ERR_ETYPE_NOSUPP ; goto cleanup ; } switch ( ( int ) reqctx -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : init_krb5_pa_pk_as_rep ( & rep ) ; if ( rep == NULL ) { retval = ENOMEM ; goto cleanup ; } rep -> choice = choice_pa_pk_as_rep_encKeyPack ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : init_krb5_pa_pk_as_rep_draft9 ( & rep9 ) ; if ( rep9 == NULL ) { retval = ENOMEM ; goto cleanup ; } rep9 -> choice = choice_pa_pk_as_rep_draft9_encKeyPack ; break ; default : retval = KRB5KDC_ERR_PREAUTH_FAILED ; goto cleanup ; } if ( reqctx -> rcv_auth_pack != NULL && reqctx -> rcv_auth_pack -> clientPublicValue != NULL ) { subjectPublicKey = reqctx -> rcv_auth_pack -> clientPublicValue -> subjectPublicKey . data ; subjectPublicKey_len = reqctx -> rcv_auth_pack -> clientPublicValue -> subjectPublicKey . length ; rep -> choice = choice_pa_pk_as_rep_dhInfo ; } else if ( reqctx -> rcv_auth_pack9 != NULL && reqctx -> rcv_auth_pack9 -> clientPublicValue != NULL ) { subjectPublicKey = reqctx -> rcv_auth_pack9 -> clientPublicValue -> subjectPublicKey . data ; subjectPublicKey_len = reqctx -> rcv_auth_pack9 -> clientPublicValue -> subjectPublicKey . length ; rep9 -> choice = choice_pa_pk_as_rep_draft9_dhSignedData ; } if ( rep != NULL && ( rep -> choice == choice_pa_pk_as_rep_dhInfo || rep -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) ) { pkiDebug ( ""received<S2SV_blank>DH<S2SV_blank>key<S2SV_blank>delivery<S2SV_blank>AS<S2SV_blank>REQ\\n"" ) ; retval = server_process_dh ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , subjectPublicKey , subjectPublicKey_len , & dh_pubkey , & dh_pubkey_len , & server_key , & server_key_len ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>process/create<S2SV_blank>dh<S2SV_blank>paramters\\n"" ) ; goto cleanup ; } } if ( ( rep9 != NULL && rep9 -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) || ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) ) { dhkey_info . subjectPublicKey . length = dh_pubkey_len ; dhkey_info . subjectPublicKey . data = dh_pubkey ; dhkey_info . nonce = request -> nonce ; dhkey_info . dhKeyExpiration = 0 ; retval = k5int_encode_krb5_kdc_dh_key_info ( & dhkey_info , & encoded_dhkey_info ) ; if ( retval ) { pkiDebug ( ""encode_krb5_kdc_dh_key_info<S2SV_blank>failed\\n"" ) ; goto cleanup ; } # ifdef DEBUG_ASN1 print_buffer_bin ( ( unsigned char * ) encoded_dhkey_info -> data , encoded_dhkey_info -> length , ""/tmp/kdc_dh_key_info"" ) ; # endif switch ( ( int ) padata -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : retval = cms_signeddata_create ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_SERVER , 1 , ( unsigned char * ) encoded_dhkey_info -> data , encoded_dhkey_info -> length , & rep -> u . dh_Info . dhSignedData . data , & rep -> u . dh_Info . dhSignedData . length ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>pkcs7<S2SV_blank>signed<S2SV_blank>data\\n"" ) ; goto cleanup ; } break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : retval = cms_signeddata_create ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_DRAFT9 , 1 , ( unsigned char * ) encoded_dhkey_info -> data , encoded_dhkey_info -> length , & rep9 -> u . dhSignedData . data , & rep9 -> u . dhSignedData . length ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>pkcs7<S2SV_blank>signed<S2SV_blank>data\\n"" ) ; goto cleanup ; } break ; } } else { pkiDebug ( ""received<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>delivery<S2SV_blank>AS<S2SV_blank>REQ\\n"" ) ; retval = krb5_c_make_random_key ( context , enctype , encrypting_key ) ; if ( retval ) { pkiDebug ( ""unable<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>session<S2SV_blank>key\\n"" ) ; goto cleanup ; } for ( i = 0 ; request -> padata [ i ] != NULL ; i ++ ) { pkiDebug ( ""%s:<S2SV_blank>Checking<S2SV_blank>pa_type<S2SV_blank>0x%08x\\n"" , __FUNCTION__ , request -> padata [ i ] -> pa_type ) ; if ( request -> padata [ i ] -> pa_type == 132 ) fixed_keypack = 1 ; } pkiDebug ( ""%s:<S2SV_blank>return<S2SV_blank>checksum<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>nonce<S2SV_blank>=<S2SV_blank>%d\\n"" , __FUNCTION__ , fixed_keypack ) ; if ( ( int ) padata -> pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack ) { init_krb5_reply_key_pack ( & key_pack ) ; if ( key_pack == NULL ) { retval = ENOMEM ; goto cleanup ; } retval = krb5_c_make_checksum ( context , 0 , encrypting_key , KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM , req_pkt , & key_pack -> asChecksum ) ; if ( retval ) { pkiDebug ( ""unable<S2SV_blank>to<S2SV_blank>calculate<S2SV_blank>AS<S2SV_blank>REQ<S2SV_blank>checksum\\n"" ) ; goto cleanup ; } # ifdef DEBUG_CKSUM pkiDebug ( ""calculating<S2SV_blank>checksum<S2SV_blank>on<S2SV_blank>buf<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d\\n"" , req_pkt -> length ) ; print_buffer ( req_pkt -> data , req_pkt -> length ) ; pkiDebug ( ""checksum<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d\\n"" , key_pack -> asChecksum . length ) ; print_buffer ( key_pack -> asChecksum . contents , key_pack -> asChecksum . length ) ; pkiDebug ( ""encrypting<S2SV_blank>key<S2SV_blank>(%d)\\n"" , encrypting_key -> length ) ; print_buffer ( encrypting_key -> contents , encrypting_key -> length ) ; # endif krb5_copy_keyblock_contents ( context , encrypting_key , & key_pack -> replyKey ) ; retval = k5int_encode_krb5_reply_key_pack ( key_pack , & encoded_key_pack ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>reply_key_pack\\n"" ) ; goto cleanup ; } } switch ( ( int ) padata -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : rep -> choice = choice_pa_pk_as_rep_encKeyPack ; retval = cms_envelopeddata_create ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , padata -> pa_type , 1 , ( unsigned char * ) encoded_key_pack -> data , encoded_key_pack -> length , & rep -> u . encKeyPack . data , & rep -> u . encKeyPack . length ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : if ( ! fixed_keypack ) { init_krb5_reply_key_pack_draft9 ( & key_pack9 ) ; if ( key_pack9 == NULL ) { retval = ENOMEM ; goto cleanup ; } key_pack9 -> nonce = reqctx -> rcv_auth_pack9 -> pkAuthenticator . nonce ; krb5_copy_keyblock_contents ( context , encrypting_key , & key_pack9 -> replyKey ) ; retval = k5int_encode_krb5_reply_key_pack_draft9 ( key_pack9 , & encoded_key_pack ) ; if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>reply_key_pack\\n"" ) ; goto cleanup ; } } rep9 -> choice = choice_pa_pk_as_rep_draft9_encKeyPack ; retval = cms_envelopeddata_create ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , plgctx -> idctx , padata -> pa_type , 1 , ( unsigned char * ) encoded_key_pack -> data , encoded_key_pack -> length , & rep9 -> u . encKeyPack . data , & rep9 -> u . encKeyPack . length ) ; break ; } if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>pkcs7<S2SV_blank>enveloped<S2SV_blank>data:<S2SV_blank>%s\\n"" , error_message ( retval ) ) ; goto cleanup ; } # ifdef DEBUG_ASN1 print_buffer_bin ( ( unsigned char * ) encoded_key_pack -> data , encoded_key_pack -> length , ""/tmp/kdc_key_pack"" ) ; switch ( ( int ) padata -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : print_buffer_bin ( rep -> u . encKeyPack . data , rep -> u . encKeyPack . length , ""/tmp/kdc_enc_key_pack"" ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : print_buffer_bin ( rep9 -> u . encKeyPack . data , rep9 -> u . encKeyPack . length , ""/tmp/kdc_enc_key_pack"" ) ; break ; } # endif } if ( ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) && ( ( reqctx -> rcv_auth_pack != NULL && reqctx -> rcv_auth_pack -> supportedKDFs != NULL ) ) ) { if ( reqctx -> rcv_auth_pack != NULL && reqctx -> rcv_auth_pack -> supportedKDFs != NULL ) { retval = pkinit_pick_kdf_alg ( context , reqctx -> rcv_auth_pack -> supportedKDFs , & ( rep -> u . dh_Info . kdfID ) ) ; if ( retval ) { pkiDebug ( ""pkinit_pick_kdf_alg<S2SV_blank>failed:<S2SV_blank>%s\\n"" , error_message ( retval ) ) ; goto cleanup ; } } } switch ( ( int ) padata -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : retval = k5int_encode_krb5_pa_pk_as_rep ( rep , & out_data ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : retval = k5int_encode_krb5_pa_pk_as_rep_draft9 ( rep9 , & out_data ) ; break ; } if ( retval ) { pkiDebug ( ""failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>AS_REP\\n"" ) ; goto cleanup ; } # ifdef DEBUG_ASN1 if ( out_data != NULL ) print_buffer_bin ( ( unsigned char * ) out_data -> data , out_data -> length , ""/tmp/kdc_as_rep"" ) ; # endif if ( ( rep9 != NULL && rep9 -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) || ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) ) { <S2SV_StartBug> if ( rep -> u . dh_Info . kdfID ) { <S2SV_EndBug> <S2SV_StartBug> secret . data = server_key ; <S2SV_EndBug> secret . length = server_key_len ; retval = pkinit_alg_agility_kdf ( context , & secret , rep -> u . dh_Info . kdfID , request -> client , request -> server , enctype , ( krb5_octet_data * ) req_pkt , ( krb5_octet_data * ) out_data , encrypting_key ) ; if ( retval ) { pkiDebug ( ""pkinit_alg_agility_kdf<S2SV_blank>failed:<S2SV_blank>%s\\n"" , error_message ( retval ) ) ; goto cleanup ; } } else { retval = pkinit_octetstring2key ( context , enctype , server_key , server_key_len , encrypting_key ) ; if ( retval ) { pkiDebug ( ""pkinit_octetstring2key<S2SV_blank>failed:<S2SV_blank>%s\\n"" , error_message ( retval ) ) ; goto cleanup ; } } } * send_pa = malloc ( sizeof ( krb5_pa_data ) ) ; if ( * send_pa == NULL ) { retval = ENOMEM ; free ( out_data -> data ) ; free ( out_data ) ; out_data = NULL ; goto cleanup ; } ( * send_pa ) -> magic = KV5M_PA_DATA ; switch ( ( int ) padata -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : ( * send_pa ) -> pa_type = KRB5_PADATA_PK_AS_REP ; break ; case KRB5_PADATA_PK_AS_REQ_OLD : case KRB5_PADATA_PK_AS_REP_OLD : ( * send_pa ) -> pa_type = KRB5_PADATA_PK_AS_REP_OLD ; break ; } ( * send_pa ) -> length = out_data -> length ; ( * send_pa ) -> contents = ( krb5_octet * ) out_data -> data ; cleanup : pkinit_fini_kdc_req_context ( context , reqctx ) ; free ( scratch . data ) ; free ( out_data ) ; if ( encoded_dhkey_info != NULL ) krb5_free_data ( context , encoded_dhkey_info ) ; if ( encoded_key_pack != NULL ) krb5_free_data ( context , encoded_key_pack ) ; free ( dh_pubkey ) ; free ( server_key ) ; switch ( ( int ) padata -> pa_type ) { case KRB5_PADATA_PK_AS_REQ : free_krb5_pa_pk_as_req ( & reqp ) ; free_krb5_pa_pk_as_rep ( & rep ) ; free_krb5_reply_key_pack ( & key_pack ) ; break ; case KRB5_PADATA_PK_AS_REP_OLD : case KRB5_PADATA_PK_AS_REQ_OLD : free_krb5_pa_pk_as_req_draft9 ( & reqp9 ) ; free_krb5_pa_pk_as_rep_draft9 ( & rep9 ) ; if ( ! fixed_keypack ) free_krb5_reply_key_pack_draft9 ( & key_pack9 ) ; else free_krb5_reply_key_pack ( & key_pack ) ; break ; } if ( retval ) pkiDebug ( ""pkinit_verify_padata<S2SV_blank>failure"" ) ; return retval ; }
","<S2SV_ModStart> if ( rep != NULL && rep <S2SV_ModStart> . data = ( char * )
",krb5@krb5/db64ca25d661a47b996b4e2645998b5d7f0eb52c,CVE-2012-1016,https://github.com/krb5/krb5/commit/db64ca25d661a47b996b4e2645998b5d7f0eb52c,2013-03-05T04:54Z,414,<S2SV_ModStart> ) return EINVAL <S2SV_ModEnd> ; if (,0
1037,CWE-120,"CWE-120 MagickExport void * AcquireQuantumMemory ( const size_t count , const size_t quantum ) { size_t extent ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; extent = count * quantum ; return ( AcquireMagickMemory ( extent ) ) ; }
","<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
",ImageMagick@ImageMagick/e45e48b881038487d0bc94d92a16c1537616cc0a,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/e45e48b881038487d0bc94d92a16c1537616cc0a,2017-03-03T17:59Z,415,"<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count,",1
1043,CWE-476,"CWE-476 static void tw5864_handle_frame ( struct tw5864_h264_frame * frame ) { # define SKIP_VLCBUF_BYTES 3 struct tw5864_input * input = frame -> input ; struct tw5864_dev * dev = input -> root ; struct tw5864_buf * vb ; struct vb2_v4l2_buffer * v4l2_buf ; int frame_len = frame -> vlc_len - SKIP_VLCBUF_BYTES ; u8 * dst = input -> buf_cur_ptr ; u8 tail_mask , vlc_mask = 0 ; int i ; u8 vlc_first_byte = ( ( u8 * ) ( frame -> vlc . addr + SKIP_VLCBUF_BYTES ) ) [ 0 ] ; unsigned long flags ; int zero_run ; u8 * src ; u8 * src_end ; # ifdef DEBUG if ( frame -> checksum != tw5864_vlc_checksum ( ( u32 * ) frame -> vlc . addr , frame_len ) ) dev_err ( & dev -> pci -> dev , ""Checksum<S2SV_blank>of<S2SV_blank>encoded<S2SV_blank>frame<S2SV_blank>doesn\'t<S2SV_blank>match!\\n"" ) ; # endif spin_lock_irqsave ( & input -> slock , flags ) ; vb = input -> vb ; input -> vb = NULL ; spin_unlock_irqrestore ( & input -> slock , flags ) ; <S2SV_StartBug> v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vb ) { <S2SV_EndBug> dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } if ( input -> buf_cur_space_left < frame_len * 5 / 4 ) { dev_err_once ( & dev -> pci -> dev , ""Left<S2SV_blank>space<S2SV_blank>in<S2SV_blank>vb2<S2SV_blank>buffer,<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>is<S2SV_blank>less<S2SV_blank>than<S2SV_blank>considered<S2SV_blank>safely<S2SV_blank>enough<S2SV_blank>to<S2SV_blank>put<S2SV_blank>frame<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d.<S2SV_blank>Dropping<S2SV_blank>this<S2SV_blank>frame.\\n"" , input -> buf_cur_space_left , frame_len ) ; return ; } for ( i = 0 ; i < 8 - input -> tail_nb_bits ; i ++ ) vlc_mask |= 1 << i ; tail_mask = ( ~ vlc_mask ) & 0xff ; dst [ 0 ] = ( input -> tail & tail_mask ) | ( vlc_first_byte & vlc_mask ) ; frame_len -- ; dst ++ ; src = frame -> vlc . addr + SKIP_VLCBUF_BYTES + 1 ; src_end = src + frame_len ; zero_run = 0 ; for ( ; src < src_end ; src ++ ) { if ( zero_run < 2 ) { if ( * src == 0 ) ++ zero_run ; else zero_run = 0 ; } else { if ( ( * src & ~ 0x03 ) == 0 ) * dst ++ = 0x03 ; zero_run = * src == 0 ; } * dst ++ = * src ; } vb2_set_plane_payload ( & vb -> vb . vb2_buf , 0 , dst - ( u8 * ) vb2_plane_vaddr ( & vb -> vb . vb2_buf , 0 ) ) ; vb -> vb . vb2_buf . timestamp = frame -> timestamp ; v4l2_buf -> field = V4L2_FIELD_INTERLACED ; v4l2_buf -> sequence = frame -> seqno ; if ( frame -> gop_seqno && tw5864_is_motion_triggered ( frame ) ) { struct v4l2_event ev = { . type = V4L2_EVENT_MOTION_DET , . u . motion_det = { . flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ , . frame_sequence = v4l2_buf -> sequence , } , } ; v4l2_event_queue ( & input -> vdev , & ev ) ; } vb2_buffer_done ( & vb -> vb . vb2_buf , VB2_BUF_STATE_DONE ) ; }
","<S2SV_ModStart> flags ) ; if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } <S2SV_ModStart> vb2_buf ) ; <S2SV_ModEnd> if ( input
",torvalds@linux/2e7682ebfc750177a4944eeb56e97a3f05734528,CVE-2019-20806,https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528,2020-05-27T12:15Z,416,<S2SV_ModStart> = NULL ; },0
1044,CWE-190,"CWE-190 <S2SV_StartBug> void * zcalloc ( size_t size ) { <S2SV_EndBug> void * ptr = calloc ( 1 , size + PREFIX_SIZE ) ; if ( ! ptr ) zmalloc_oom_handler ( size ) ; # ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc ( zmalloc_size ( ptr ) ) ; return ptr ; # else * ( ( size_t * ) ptr ) = size ; update_zmalloc_stat_alloc ( size + PREFIX_SIZE ) ; return ( char * ) ptr + PREFIX_SIZE ; # endif }
","<S2SV_ModStart> size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ;
",redis@redis/c992857618db99776917f10bf4f2345a5fdc78b0,CVE-2021-21309,https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0,2021-02-26T22:15Z,417,"<S2SV_ModStart> size ) { memset <S2SV_ModEnd> ( size,",0
1045,CWE-189,"CWE-189 sf_count_t psf_fwrite ( const void * ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE * psf ) { sf_count_t total = 0 ; <S2SV_StartBug> ssize_t count ; <S2SV_EndBug> if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ; items *= bytes ; if ( items <= 0 ) return 0 ; while ( items > 0 ) { count = ( items > SENSIBLE_SIZE ) ? SENSIBLE_SIZE : items ; count = write ( psf -> file . filedes , ( ( const char * ) ptr ) + total , count ) ; if ( count == - 1 ) { if ( errno == EINTR ) continue ; psf_log_syserr ( psf , errno ) ; break ; } ; if ( count == 0 ) break ; total += count ; items -= count ; } ; if ( psf -> is_pipe ) psf -> pipeoffset += total ; return total / bytes ; }
","<S2SV_ModStart> ; ssize_t count ; if ( bytes == 0 || items == 0 ) return 0
",erikd@libsndfile/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6,CVE-2014-9756,https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6,2015-11-19T20:59Z,418,<S2SV_ModStart> ; bytes = 0,0
1046,CWE-125,"CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
","<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
",the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94,CVE-2018-14466,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,2019-10-03T16:15Z,419,,0
1048,CWE-120,"CWE-120 int mwifiex_cmd_802_11_ad_hoc_start ( struct mwifiex_private * priv , struct host_cmd_ds_command * cmd , struct cfg80211_ssid * req_ssid ) { int rsn_ie_len = 0 ; struct mwifiex_adapter * adapter = priv -> adapter ; struct host_cmd_ds_802_11_ad_hoc_start * adhoc_start = & cmd -> params . adhoc_start ; struct mwifiex_bssdescriptor * bss_desc ; u32 cmd_append_size = 0 ; u32 i ; u16 tmp_cap ; struct mwifiex_ie_types_chan_list_param_set * chan_tlv ; u8 radio_type ; struct mwifiex_ie_types_htcap * ht_cap ; struct mwifiex_ie_types_htinfo * ht_info ; u8 * pos = ( u8 * ) adhoc_start + sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) ; if ( ! adapter ) return - 1 ; cmd -> command = cpu_to_le16 ( HostCmd_CMD_802_11_AD_HOC_START ) ; bss_desc = & priv -> curr_bss_params . bss_descriptor ; priv -> attempted_bss_desc = bss_desc ; <S2SV_StartBug> memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; <S2SV_EndBug> memcpy ( adhoc_start -> ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>SSID<S2SV_blank>=<S2SV_blank>%s\\n"" , adhoc_start -> ssid ) ; memset ( bss_desc -> ssid . ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; memcpy ( bss_desc -> ssid . ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; bss_desc -> ssid . ssid_len = req_ssid -> ssid_len ; adhoc_start -> bss_mode = HostCmd_BSS_MODE_IBSS ; bss_desc -> bss_mode = NL80211_IFTYPE_ADHOC ; adhoc_start -> beacon_period = cpu_to_le16 ( priv -> beacon_period ) ; bss_desc -> beacon_period = priv -> beacon_period ; # define DS_PARA_IE_ID 3 # define DS_PARA_IE_LEN 1 adhoc_start -> phy_param_set . ds_param_set . element_id = DS_PARA_IE_ID ; adhoc_start -> phy_param_set . ds_param_set . len = DS_PARA_IE_LEN ; if ( ! mwifiex_get_cfp ( priv , adapter -> adhoc_start_band , ( u16 ) priv -> adhoc_channel , 0 ) ) { struct mwifiex_chan_freq_power * cfp ; cfp = mwifiex_get_cfp ( priv , adapter -> adhoc_start_band , FIRST_VALID_CHANNEL , 0 ) ; if ( cfp ) priv -> adhoc_channel = ( u8 ) cfp -> channel ; } if ( ! priv -> adhoc_channel ) { mwifiex_dbg ( adapter , ERROR , ""ADHOC_S_CMD:<S2SV_blank>adhoc_channel<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>0\\n"" ) ; return - 1 ; } mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>creating<S2SV_blank>ADHOC<S2SV_blank>on<S2SV_blank>channel<S2SV_blank>%d\\n"" , priv -> adhoc_channel ) ; priv -> curr_bss_params . bss_descriptor . channel = priv -> adhoc_channel ; priv -> curr_bss_params . band = adapter -> adhoc_start_band ; bss_desc -> channel = priv -> adhoc_channel ; adhoc_start -> phy_param_set . ds_param_set . current_chan = priv -> adhoc_channel ; memcpy ( & bss_desc -> phy_param_set , & adhoc_start -> phy_param_set , sizeof ( union ieee_types_phy_param_set ) ) ; # define IBSS_PARA_IE_ID 6 # define IBSS_PARA_IE_LEN 2 adhoc_start -> ss_param_set . ibss_param_set . element_id = IBSS_PARA_IE_ID ; adhoc_start -> ss_param_set . ibss_param_set . len = IBSS_PARA_IE_LEN ; adhoc_start -> ss_param_set . ibss_param_set . atim_window = cpu_to_le16 ( priv -> atim_window ) ; memcpy ( & bss_desc -> ss_param_set , & adhoc_start -> ss_param_set , sizeof ( union ieee_types_ss_param_set ) ) ; bss_desc -> cap_info_bitmap |= WLAN_CAPABILITY_IBSS ; tmp_cap = WLAN_CAPABILITY_IBSS ; if ( priv -> sec_info . encryption_mode ) { mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>wep_status<S2SV_blank>set<S2SV_blank>privacy<S2SV_blank>to<S2SV_blank>WEP\\n"" ) ; bss_desc -> privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP ; tmp_cap |= WLAN_CAPABILITY_PRIVACY ; } else { mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>wep_status<S2SV_blank>NOT<S2SV_blank>set,\\t"" ""setting<S2SV_blank>privacy<S2SV_blank>to<S2SV_blank>ACCEPT<S2SV_blank>ALL\\n"" ) ; bss_desc -> privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL ; } memset ( adhoc_start -> data_rate , 0 , sizeof ( adhoc_start -> data_rate ) ) ; mwifiex_get_active_data_rates ( priv , adhoc_start -> data_rate ) ; if ( ( adapter -> adhoc_start_band & BAND_G ) && ( priv -> curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON ) ) { if ( mwifiex_send_cmd ( priv , HostCmd_CMD_MAC_CONTROL , HostCmd_ACT_GEN_SET , 0 , & priv -> curr_pkt_filter , false ) ) { mwifiex_dbg ( adapter , ERROR , ""ADHOC_S_CMD:<S2SV_blank>G<S2SV_blank>Protection<S2SV_blank>config<S2SV_blank>failed\\n"" ) ; return - 1 ; } } for ( i = 0 ; i < sizeof ( adhoc_start -> data_rate ) ; i ++ ) if ( ! adhoc_start -> data_rate [ i ] ) break ; priv -> curr_bss_params . num_of_rates = i ; memcpy ( & priv -> curr_bss_params . data_rates , & adhoc_start -> data_rate , priv -> curr_bss_params . num_of_rates ) ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>rates=%4ph\\n"" , adhoc_start -> data_rate ) ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>AD-HOC<S2SV_blank>Start<S2SV_blank>command<S2SV_blank>is<S2SV_blank>ready\\n"" ) ; if ( IS_SUPPORT_MULTI_BANDS ( adapter ) ) { chan_tlv = ( struct mwifiex_ie_types_chan_list_param_set * ) pos ; chan_tlv -> header . type = cpu_to_le16 ( TLV_TYPE_CHANLIST ) ; chan_tlv -> header . len = cpu_to_le16 ( sizeof ( struct mwifiex_chan_scan_param_set ) ) ; memset ( chan_tlv -> chan_scan_param , 0x00 , sizeof ( struct mwifiex_chan_scan_param_set ) ) ; chan_tlv -> chan_scan_param [ 0 ] . chan_number = ( u8 ) priv -> curr_bss_params . bss_descriptor . channel ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>TLV<S2SV_blank>Chan<S2SV_blank>=<S2SV_blank>%d\\n"" , chan_tlv -> chan_scan_param [ 0 ] . chan_number ) ; chan_tlv -> chan_scan_param [ 0 ] . radio_type = mwifiex_band_to_radio_type ( priv -> curr_bss_params . band ) ; if ( adapter -> adhoc_start_band & BAND_GN || adapter -> adhoc_start_band & BAND_AN ) { if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_ABOVE ) chan_tlv -> chan_scan_param [ 0 ] . radio_type |= ( IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4 ) ; else if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_BELOW ) chan_tlv -> chan_scan_param [ 0 ] . radio_type |= ( IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4 ) ; } mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>TLV<S2SV_blank>Band<S2SV_blank>=<S2SV_blank>%d\\n"" , chan_tlv -> chan_scan_param [ 0 ] . radio_type ) ; pos += sizeof ( chan_tlv -> header ) + sizeof ( struct mwifiex_chan_scan_param_set ) ; cmd_append_size += sizeof ( chan_tlv -> header ) + sizeof ( struct mwifiex_chan_scan_param_set ) ; } cmd_append_size += mwifiex_cmd_append_vsie_tlv ( priv , MWIFIEX_VSIE_MASK_ADHOC , & pos ) ; if ( priv -> sec_info . wpa_enabled ) { rsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2 ( priv , & pos ) ; if ( rsn_ie_len == - 1 ) return - 1 ; cmd_append_size += rsn_ie_len ; } if ( adapter -> adhoc_11n_enabled ) { ht_cap = ( struct mwifiex_ie_types_htcap * ) pos ; memset ( ht_cap , 0 , sizeof ( struct mwifiex_ie_types_htcap ) ) ; ht_cap -> header . type = cpu_to_le16 ( WLAN_EID_HT_CAPABILITY ) ; ht_cap -> header . len = cpu_to_le16 ( sizeof ( struct ieee80211_ht_cap ) ) ; radio_type = mwifiex_band_to_radio_type ( priv -> adapter -> config_bands ) ; mwifiex_fill_cap_info ( priv , radio_type , & ht_cap -> ht_cap ) ; if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_NONE ) { u16 tmp_ht_cap ; tmp_ht_cap = le16_to_cpu ( ht_cap -> ht_cap . cap_info ) ; tmp_ht_cap &= ~ IEEE80211_HT_CAP_SUP_WIDTH_20_40 ; tmp_ht_cap &= ~ IEEE80211_HT_CAP_SGI_40 ; ht_cap -> ht_cap . cap_info = cpu_to_le16 ( tmp_ht_cap ) ; } pos += sizeof ( struct mwifiex_ie_types_htcap ) ; cmd_append_size += sizeof ( struct mwifiex_ie_types_htcap ) ; ht_info = ( struct mwifiex_ie_types_htinfo * ) pos ; memset ( ht_info , 0 , sizeof ( struct mwifiex_ie_types_htinfo ) ) ; ht_info -> header . type = cpu_to_le16 ( WLAN_EID_HT_OPERATION ) ; ht_info -> header . len = cpu_to_le16 ( sizeof ( struct ieee80211_ht_operation ) ) ; ht_info -> ht_oper . primary_chan = ( u8 ) priv -> curr_bss_params . bss_descriptor . channel ; if ( adapter -> sec_chan_offset ) { ht_info -> ht_oper . ht_param = adapter -> sec_chan_offset ; ht_info -> ht_oper . ht_param |= IEEE80211_HT_PARAM_CHAN_WIDTH_ANY ; } ht_info -> ht_oper . operation_mode = cpu_to_le16 ( IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT ) ; ht_info -> ht_oper . basic_set [ 0 ] = 0xff ; pos += sizeof ( struct mwifiex_ie_types_htinfo ) ; cmd_append_size += sizeof ( struct mwifiex_ie_types_htinfo ) ; } cmd -> size = cpu_to_le16 ( ( u16 ) ( sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) + S_DS_GEN + cmd_append_size ) ) ; if ( adapter -> adhoc_start_band == BAND_B ) tmp_cap &= ~ WLAN_CAPABILITY_SHORT_SLOT_TIME ; else tmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME ; adhoc_start -> cap_info_bitmap = cpu_to_le16 ( tmp_cap ) ; return 0 ; }
","<S2SV_ModStart> , IEEE80211_MAX_SSID_LEN ) ; if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN
",torvalds@linux/5c455c5ab332773464d02ba17015acdca198f03d,CVE-2020-36158,https://github.com/torvalds/linux/commit/5c455c5ab332773464d02ba17015acdca198f03d,2021-01-05T05:15Z,420,<S2SV_ModStart> - EINVAL ; if (! assoc_len ) return - EINVAL ;,0
1049,CWE-400,"CWE-400 int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { if ( unlikely ( ( ( char * ) sfe < ( char * ) sf ) || ( ( char * ) sfe >= ( ( char * ) sf + dp -> i_afp -> if_bytes ) ) ) ) { XFS_CORRUPTION_ERROR ( ""xfs_attr_shortform_list"" , XFS_ERRLEVEL_LOW , context -> dp -> i_mount , sfe ) ; kmem_free ( sbuf ) ; return - EFSCORRUPTED ; } sbp -> entno = i ; sbp -> hash = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; sbp -> name = sfe -> nameval ; sbp -> namelen = sfe -> namelen ; sbp -> valuelen = sfe -> valuelen ; sbp -> flags = sfe -> flags ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; sbp ++ ; nsbuf ++ ; } xfs_sort ( sbuf , nsbuf , sizeof ( * sbuf ) , xfs_attr_shortform_compare ) ; count = 0 ; cursor -> initted = 1 ; cursor -> blkno = 0 ; for ( sbp = sbuf , i = 0 ; i < nsbuf ; i ++ , sbp ++ ) { if ( sbp -> hash == cursor -> hashval ) { if ( cursor -> offset == count ) { break ; } count ++ ; } else if ( sbp -> hash > cursor -> hashval ) { break ; } } if ( i == nsbuf ) { kmem_free ( sbuf ) ; return 0 ; } for ( ; i < nsbuf ; i ++ , sbp ++ ) { if ( cursor -> hashval != sbp -> hash ) { cursor -> hashval = sbp -> hash ; cursor -> offset = 0 ; } error = context -> put_listent ( context , sbp -> flags , sbp -> name , sbp -> namelen , sbp -> valuelen , & sbp -> name [ sbp -> namelen ] ) ; <S2SV_StartBug> if ( error ) <S2SV_EndBug> return error ; <S2SV_StartBug> if ( context -> seen_enough ) <S2SV_EndBug> break ; cursor -> offset ++ ; } kmem_free ( sbuf ) ; return 0 ; }
","<S2SV_ModStart> ( error ) { kmem_free ( sbuf ) ; <S2SV_ModStart> return error ; }
",torvalds@linux/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,CVE-2016-9685,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2016-12-28T07:59Z,421,,0
1053,CWE-787,"CWE-787 static int l2cap_build_conf_req ( struct sock * sk , void * data ) { struct l2cap_pinfo * pi = l2cap_pi ( sk ) ; struct l2cap_conf_req * req = data ; <S2SV_StartBug> struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; <S2SV_EndBug> void * ptr = req -> data ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; <S2SV_StartBug> switch ( pi -> mode ) { <S2SV_EndBug> case L2CAP_MODE_BASIC : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ; break ; case L2CAP_MODE_ERTM : rfc . mode = L2CAP_MODE_ERTM ; <S2SV_StartBug> rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; <S2SV_EndBug> rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ; <S2SV_StartBug> rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; <S2SV_EndBug> <S2SV_StartBug> rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; <S2SV_EndBug> rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; } req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> flags = cpu_to_le16 ( 0 ) ; return ptr - data ; }
","<S2SV_ModStart> . mode = L2CAP_MODE_ERTM <S2SV_ModEnd> } ; void <S2SV_ModStart> sk ) ; if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> . txwin_size = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . retrans_timeout = 0 <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . monitor_timeout = 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ; rfc .
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,422,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct l2CAP_conf_conf_mode <S2SV_ModEnd> ; struct l2CAP_conf_mode <S2SV_ModStart> ) { struct l2CAP_REQ ) { struct l2CAP_REQ_REQ_MODE_REQ ; l2cap_mode = l2cap_mode ( l2cap_req ( l2cap_req ( struct l2cap_req ), L2CAP_REQ, L2CAP_REQ ) ; if ( pi -> mode == L2CAP_REQ ) { struct l2CAP_conf_mode = L2CAP_ERR ( l2CAP_ERR ( l2CAP_REQ, L2CAP_REQ, L2CAP_REQ, L2CAP_REQ, L2CAP_REQ, sizeof ( struct l2CAP_REQ_REQ, L2CAP_REQ ), L2CAP_MODE_REQ_REQ ) ; if ( pi -> mode == L2CAP_CONF_REQ_REQ_REQ_REQ_REQ_REQ_REQ_REQ_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MIN_MAX_MAX_MAX_",0
1054,CWE-284,"CWE-284 int sock_recv_all ( int sock_fd , uint8_t * buf , int len ) { int r = len ; int ret = - 1 ; while ( r ) { <S2SV_StartBug> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <S2SV_EndBug> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>fd:%d<S2SV_blank>recv<S2SV_blank>errno:%d,<S2SV_blank>ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; r -= ret ; } return len ; }
","<S2SV_ModStart> do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> r , MSG_WAITALL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,423,"<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ret, 0 )",0
1056,CWE-200,"CWE-200 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( ""\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\'s<S2SV_blank>try\\n"" ) ; } u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ps_dec -> u1_pic_decode_done != 1 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; } ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( ""Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\n"" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; <S2SV_StartBug> if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && <S2SV_EndBug> ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( ""\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\n"" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( ""\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\n"" , u1_nal_unit_type ) ; break ; } } } return i_status ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> i_status != OK
",external@libavc/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,CVE-2017-0555,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,2017-04-07T22:59Z,424,,0
1057,CWE-000,"CWE-000 static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , ""&"" , & tok ) ; <S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug> mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , ""&"" , & tok ) ; } }
","<S2SV_ModStart> while ( pair <S2SV_ModEnd> ) { mprAddItem
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,425,,0
1059,CWE-416,"CWE-416 static struct ucounts * get_ucounts ( struct user_namespace * ns , kuid_t uid ) { struct hlist_head * hashent = ucounts_hashentry ( ns , uid ) ; struct ucounts * ucounts , * new ; spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ! ucounts ) { spin_unlock_irq ( & ucounts_lock ) ; new = kzalloc ( sizeof ( * new ) , GFP_KERNEL ) ; if ( ! new ) return NULL ; new -> ns = ns ; new -> uid = uid ; <S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ucounts ) { kfree ( new ) ; } else { hlist_add_head ( & new -> node , hashent ) ; ucounts = new ; } } <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ucounts = NULL ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts ; }
","<S2SV_ModStart> = uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (
",torvalds@linux/040757f738e13caaa9c5078bca79aa97e11dde88,CVE-2017-6874,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,2017-03-14T09:59Z,426,<S2SV_ModStart> newcounts = NULL <S2SV_ModEnd> ; if (,0
1064,CWE-000,"CWE-000 <S2SV_StartBug> static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , int open_flags ) <S2SV_EndBug> { struct nfs_inode * nfsi = NFS_I ( state -> inode ) ; struct nfs_delegation * deleg_cur ; int ret = 0 ; <S2SV_StartBug> open_flags &= ( FMODE_READ | FMODE_WRITE ) ; <S2SV_EndBug> rcu_read_lock ( ) ; deleg_cur = rcu_dereference ( nfsi -> delegation ) ; if ( deleg_cur == NULL ) goto no_delegation ; spin_lock ( & deleg_cur -> lock ) ; if ( nfsi -> delegation != deleg_cur || <S2SV_StartBug> ( deleg_cur -> type & open_flags ) != open_flags ) <S2SV_EndBug> goto no_delegation_unlock ; if ( delegation == NULL ) delegation = & deleg_cur -> stateid ; else if ( memcmp ( deleg_cur -> stateid . data , delegation -> data , NFS4_STATEID_SIZE ) != 0 ) goto no_delegation_unlock ; nfs_mark_delegation_referenced ( deleg_cur ) ; <S2SV_StartBug> __update_open_stateid ( state , open_stateid , & deleg_cur -> stateid , open_flags ) ; <S2SV_EndBug> ret = 1 ; no_delegation_unlock : spin_unlock ( & deleg_cur -> lock ) ; no_delegation : rcu_read_unlock ( ) ; if ( ! ret && open_stateid != NULL ) { <S2SV_StartBug> __update_open_stateid ( state , open_stateid , NULL , open_flags ) ; <S2SV_EndBug> ret = 1 ; } return ret ; }
","<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> = 0 ; fmode <S2SV_ModEnd> &= ( FMODE_READ <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) goto no_delegation_unlock <S2SV_ModStart> -> stateid , fmode <S2SV_ModEnd> ) ; ret <S2SV_ModStart> , NULL , fmode <S2SV_ModEnd> ) ; ret
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z,427,"<S2SV_ModStart> * stateid, fmode_t fmode <S2SV_ModStart> = fmode ; fmode_t fmode = fmode_t fmode ; fmode = fmode_t fmode ; if ( fmode & fmode & fmode ) goto out ;",0
1066,CWE-284,"CWE-284 static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( ""btif_hl_select_close_connected"" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,428,"<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart>, 0 ) )",1
1068,CWE-119,"CWE-119 static void model_rd_for_sb ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , <S2SV_StartBug> int * out_rate_sum , int64_t * out_dist_sum ) { <S2SV_EndBug> int i ; int64_t rate_sum = 0 ; int64_t dist_sum = 0 ; const int ref = xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] ; unsigned int sse ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_EndBug> struct macroblock_plane * const p = & x -> plane [ i ] ; struct macroblockd_plane * const pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; <S2SV_StartBug> ( void ) cpi -> fn_ptr [ bs ] . vf ( p -> src . buf , p -> src . stride , <S2SV_EndBug> <S2SV_StartBug> pd -> dst . buf , pd -> dst . stride , & sse ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i == 0 ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_sse [ ref ] = sse ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed > 4 ) { <S2SV_EndBug> int64_t rate ; <S2SV_StartBug> int64_t dist ; <S2SV_EndBug> <S2SV_StartBug> int64_t square_error = sse ; <S2SV_EndBug> <S2SV_StartBug> int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ; <S2SV_EndBug> if ( quantizer < 120 ) rate = ( square_error * ( 280 - quantizer ) ) >> 8 ; else rate = 0 ; dist = ( square_error * quantizer ) >> 8 ; rate_sum += rate ; dist_sum += dist ; } else { <S2SV_StartBug> int rate ; <S2SV_EndBug> int64_t dist ; vp9_model_rd_from_var_lapndz ( sse , 1 << num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ; rate_sum += rate ; dist_sum += dist ; } } <S2SV_StartBug> * out_rate_sum = ( int ) rate_sum ; <S2SV_EndBug> * out_dist_sum = dist_sum << 4 ; }
","<S2SV_ModStart> int64_t * out_dist_sum , int * skip_txfm_sb , int64_t * skip_sse_sb <S2SV_ModStart> int sse ; unsigned int var = 0 ; unsigned int sum_sse = 0 ; int64_t total_sse = 0 ; int skip_flag = 1 ; const int shift = 6 ; int rate ; int64_t dist ; const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ; x -> pred_sse [ ref ] = 0 ; <S2SV_ModStart> pd ) ; const TX_SIZE max_tx_size = max_txsize_lookup <S2SV_ModEnd> [ bs ] <S2SV_ModStart> [ bs ] ; const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> shift ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> shift ; const int64_t low_dc_thr = MIN ( 50 , dc_thr >> 2 ) ; const int64_t low_ac_thr = MIN ( 80 , ac_thr >> 2 ) ; int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int idx , idy ; int lw = b_width_log2_lookup [ unit_size ] + 2 ; int lh = b_height_log2_lookup [ unit_size ] + 2 ; sum_sse = 0 ; for ( idy = 0 ; idy < bh ; ++ idy ) { for ( idx = 0 ; idx < bw ; ++ idx ) { uint8_t * src = <S2SV_ModEnd> p -> src <S2SV_ModStart> src . buf + ( idy * <S2SV_ModEnd> p -> src <S2SV_ModStart> src . stride << lh ) + ( idx << lw ) ; uint8_t * dst = <S2SV_ModEnd> pd -> dst <S2SV_ModStart> dst . buf + ( idy * <S2SV_ModEnd> pd -> dst <S2SV_ModStart> dst . stride << lh ) + ( idx << lh ) ; int block_idx = ( idy << 1 ) + idx ; int low_err_skip = 0 ; var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride <S2SV_ModStart> sse ) ; x -> bsse [ ( i << 2 ) + block_idx ] = sse ; sum_sse += sse ; x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ; if ( ! x -> select_tx_size ) { if ( var < ac_thr || var <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ; if ( sse - var < dc_thr || sse == var ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ; if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ; } } } if ( skip_flag && ! low_err_skip ) skip_flag = 0 ; if ( i == 0 ) x -> <S2SV_ModEnd> pred_sse [ ref <S2SV_ModStart> [ ref ] += sse ; } } total_sse += sum_sse ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> ( cpi -> sf . simple_model_rd_from_var <S2SV_ModEnd> ) { int64_t <S2SV_ModStart> int64_t rate ; const <S2SV_ModEnd> int64_t square_error = <S2SV_ModStart> int64_t square_error = sum_sse <S2SV_ModEnd> ; int quantizer <S2SV_ModStart> 1 ] >> dequant_shift <S2SV_ModEnd> ) ; if <S2SV_ModStart> } else { vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> dequant_shift , <S2SV_ModEnd> & rate , <S2SV_ModStart> } } * skip_txfm_sb = skip_flag ; * skip_sse_sb = total_sse << 4 ; *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,429,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static int64_t <S2SV_ModEnd> q, int64_t rate, int64_t rate, int64_t rate, int64_t rate, int64_t rate, int64_t rate_t rate, int64_t rate, int64_t dist, int64_t rate, int64_t dist, int64_t dist, int64_t dist, int64_t dist, int64_t dist, int64_t rate_t dist, int64_t rate, int64_t rate, int64_t dist, int64_t dist, int64_t dist, int64_t dist, int64_t dist, int64_t dist, int64_t rate, int64_t rate_t rate_t rate, rate, rate_t dist, int64_t dist, unsigned int64_t rate_t dist, int64_t * rate_t dist, int64_t dist, int64_t rate_t <S2SV_ModEnd> ; int64_t <S2SV_ModStart> 0 ] = ( int64_t *",0
1069,CWE-264,"CWE-264 static void mincore_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , unsigned char * vec ) { unsigned long next ; pmd_t * pmd ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( mincore_huge_pmd ( vma , pmd , addr , next , vec ) ) { vec += ( next - addr ) >> PAGE_SHIFT ; continue ; } } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> mincore_unmapped_range ( vma , addr , next , vec ) ; else mincore_pte_range ( vma , pmd , addr , next , vec ) ; vec += ( next - addr ) >> PAGE_SHIFT ; } while ( pmd ++ , addr = next , addr != end ) ; }
","<S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,430,<S2SV_ModStart> ( pmd ) <S2SV_ModEnd> if ( pmd,0
1071,CWE-120,"CWE-120 static int parse_user_name ( char * user_input , char * * ret_username ) { register char * ptr ; register int index = 0 ; char username [ PAM_MAX_RESP_SIZE ] ; * ret_username = NULL ; bzero ( ( void * ) username , PAM_MAX_RESP_SIZE ) ; ptr = user_input ; while ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\t' ) ) ptr ++ ; if ( * ptr == '\\0' ) { return ( PAM_BUF_ERR ) ; } while ( * ptr != '\\0' ) { <S2SV_StartBug> if ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\t' ) ) <S2SV_EndBug> break ; else { username [ index ] = * ptr ; index ++ ; ptr ++ ; } } <S2SV_StartBug> if ( ( * ret_username = malloc ( index + 1 ) ) == NULL ) <S2SV_EndBug> return ( PAM_BUF_ERR ) ; <S2SV_StartBug> ( void ) strcpy ( * ret_username , username ) ; <S2SV_EndBug> return ( PAM_SUCCESS ) ; }
","<S2SV_ModStart> == '\\t' ) || ( index >= PAM_MAX_RESP_SIZE ) ) { break ; } <S2SV_ModEnd> else { username <S2SV_ModStart> } if ( index >= PAM_MAX_RESP_SIZE || <S2SV_ModStart> * ret_username = strdup ( username <S2SV_ModEnd> ) ) == <S2SV_ModStart> PAM_BUF_ERR ) ; <S2SV_ModEnd> return ( PAM_SUCCESS
",illumos@illumos-gate/1d276e0b382cf066dae93640746d8b4c54d15452,CVE-2020-27678,https://github.com/illumos/illumos-gate/commit/1d276e0b382cf066dae93640746d8b4c54d15452,2020-10-26T12:17Z,431,<S2SV_ModStart> ; if ( ( <S2SV_ModEnd> == '\\0' ),0
1072,CWE-119,"CWE-119 <S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int read_segment_id ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ) { return vpx_read_tree <S2SV_ModEnd> ( r ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,432,"<S2SV_ModStart> * r, vpx_reader <S2SV_ModEnd> * r,",0
1075,CWE-119,"CWE-119 static void extend_plane ( uint8_t * const src , int src_stride , int width , int height , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i ; const int linesize = extend_left + extend_right + width ; uint8_t * src_ptr1 = src ; uint8_t * src_ptr2 = src + width - 1 ; uint8_t * dst_ptr1 = src - extend_left ; uint8_t * dst_ptr2 = src + width ; for ( i = 0 ; i < height ; ++ i ) { <S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <S2SV_EndBug> src_ptr1 += src_stride ; src_ptr2 += src_stride ; dst_ptr1 += src_stride ; dst_ptr2 += src_stride ; } src_ptr1 = src - extend_left ; src_ptr2 = src + src_stride * ( height - 1 ) - extend_left ; dst_ptr1 = src + src_stride * - extend_top - extend_left ; dst_ptr2 = src + src_stride * height - extend_left ; for ( i = 0 ; i < extend_top ; ++ i ) { <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dst_ptr1 += src_stride ; } for ( i = 0 ; i < extend_bottom ; ++ i ) { <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dst_ptr2 += src_stride ; } }
","<S2SV_ModStart> i ) { memset <S2SV_ModEnd> ( dst_ptr1 , <S2SV_ModStart> extend_left ) ; memset <S2SV_ModEnd> ( dst_ptr2 , <S2SV_ModStart> i ) { memcpy <S2SV_ModEnd> ( dst_ptr1 , <S2SV_ModStart> i ) { memcpy <S2SV_ModEnd> ( dst_ptr2 ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,433,"<S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( dst_ptr1, <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( dst_ptr1, <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr2, <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr2, <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr2, <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr2, <S2SV_ModStart> ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr2,",0
1077,CWE-400,"CWE-400 <S2SV_StartBug> static void kgdb_hw_overflow_handler ( struct perf_event * event , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct task_struct * tsk = current ; int i ; for ( i = 0 ; i < 4 ; i ++ ) if ( breakinfo [ i ] . enabled ) tsk -> thread . debugreg6 |= ( DR_TRAP0 << i ) ; }
","<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,434,"<S2SV_ModStart> perf_event * event <S2SV_ModEnd>, struct perf_sample_data",1
1078,CWE-674,"CWE-674 const u_char * smb_fdata ( netdissect_options * ndo , const u_char * buf , const char * fmt , const u_char * maxbuf , int unicodestr ) { static int depth = 0 ; char s [ 128 ] ; char * p ; while ( * fmt ) { switch ( * fmt ) { case '*' : fmt ++ ; while ( buf < maxbuf ) { const u_char * buf2 ; depth ++ ; <S2SV_StartBug> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <S2SV_EndBug> depth -- ; if ( buf2 == NULL ) return ( NULL ) ; if ( buf2 == buf ) return ( buf ) ; buf = buf2 ; } return ( buf ) ; case '|' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; break ; case '%' : fmt ++ ; buf = maxbuf ; break ; case '#' : fmt ++ ; return ( buf ) ; break ; case '[' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; memset ( s , 0 , sizeof ( s ) ) ; p = strchr ( fmt , ']' ) ; if ( ( size_t ) ( p - fmt + 1 ) > sizeof ( s ) ) { return ( buf ) ; } strncpy ( s , fmt , p - fmt ) ; s [ p - fmt ] = '\\0' ; fmt = p + 1 ; buf = smb_fdata1 ( ndo , buf , s , maxbuf , unicodestr ) ; if ( buf == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""%c"" , * fmt ) ) ; fmt ++ ; break ; } } if ( ! depth && buf < maxbuf ) { size_t len = PTR_DIFF ( maxbuf , buf ) ; ND_PRINT ( ( ndo , ""Data:<S2SV_blank>(%lu<S2SV_blank>bytes)\\n"" , ( unsigned long ) len ) ) ; smb_print_data ( ndo , buf , len ) ; return ( buf + len ) ; } return ( buf ) ; }
","<S2SV_ModStart> depth ++ ; if ( depth == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else
",the-tcpdump-group@tcpdump/24182d959f661327525a20d9a94c98a8ec016778,CVE-2018-16452,https://github.com/the-tcpdump-group/tcpdump/commit/24182d959f661327525a20d9a94c98a8ec016778,2019-10-03T16:15Z,435,,0
1081,CWE-20,"CWE-20 error_t ksz8851SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t n ; size_t length ; Ksz8851TxHeader header ; Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; length = netBufferGetLength ( buffer ) - offset ; if ( length > ETH_MAX_FRAME_SIZE ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n < ( length + 8 ) ) { return ERROR_FAILURE ; } netBufferRead ( context -> txBuffer , buffer , offset , length ) ; <S2SV_StartBug> header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; <S2SV_EndBug> header . byteCount = htole16 ( length ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851WriteFifo ( interface , ( uint8_t * ) & header , sizeof ( Ksz8851TxHeader ) ) ; ksz8851WriteFifo ( interface , context -> txBuffer , length ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { osSetEvent ( & interface -> nicTxEvent ) ; } return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> = htole16 ( KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> | ( context <S2SV_ModStart> frameId ++ & KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851WriteFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,436,"<S2SV_ModStart> ( interface, KSZ8851_ISR ) ; if ( ( ( length > KSZ8851_FRAME ) ) { <S2SV_ModStart> ( interface, KSZ8851_MASK ) ; }",0
1082,CWE-310,"CWE-310 static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes"" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; <S2SV_StartBug> return key ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z,437,,0
1084,CWE-20,"CWE-20 static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings . logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE ; settings . logger_buf_size = LOGGER_BUF_SIZE ; settings . drop_privileges = true ; # ifdef MEMCACHED_DEBUG settings . relaxed_privileges = false ; # endif }
","<S2SV_ModStart> . udpport = 0 <S2SV_ModEnd> ; settings .
",memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z,438,<S2SV_ModStart>. udpport = 0 <S2SV_ModEnd> ; settings.,1
1085,CWE-399,"CWE-399 static guint32 finalizer_thread ( gpointer unused ) { while ( ! finished ) { g_assert ( mono_domain_get ( ) == mono_get_root_domain ( ) ) ; # ifdef MONO_HAS_SEMAPHORES MONO_SEM_WAIT ( & finalizer_sem ) ; # else WaitForSingleObjectEx ( finalizer_event , INFINITE , FALSE ) ; # endif mono_console_handle_async_ops ( ) ; # ifndef DISABLE_ATTACH mono_attach_maybe_start ( ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( domains_to_finalize ) { mono_finalizer_lock ( ) ; if ( domains_to_finalize ) { DomainFinalizationReq * req = domains_to_finalize -> data ; domains_to_finalize = g_slist_remove ( domains_to_finalize , req ) ; mono_finalizer_unlock ( ) ; finalize_domain_objects ( req ) ; } else { mono_finalizer_unlock ( ) ; } } mono_gc_invoke_finalizers ( ) ; SetEvent ( pending_done_event ) ; } SetEvent ( shutdown_event ) ; return 0 ; }
","<S2SV_ModStart> ; # endif reference_queue_proccess_all ( ) ;
",mono@mono/8eb1189099e02372fd45ca1c67230eccf1edddc0,CVE-2011-0991,https://github.com/mono/mono/commit/8eb1189099e02372fd45ca1c67230eccf1edddc0,2011-04-13T21:55Z,439,,0
1086,CWE-787,"CWE-787 VOID ixheaacd_esbr_postradixcompute2 ( WORD32 * ptr_y , WORD32 * ptr_x , const WORD32 * pdig_rev_tbl , WORD32 npoints ) { WORD32 i , k ; WORD32 h2 ; WORD32 x_0 , x_1 , x_2 , x_3 ; WORD32 x_4 , x_5 , x_6 , x_7 ; <S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ; WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ; WORD32 n0 , j0 ; WORD32 * x2 , * x0 ; WORD32 * y0 , * y1 , * y2 , * y3 ; y0 = ptr_y ; y2 = ptr_y + ( WORD32 ) npoints ; x0 = ptr_x ; x2 = ptr_x + ( WORD32 ) ( npoints >> 1 ) ; y1 = y0 + ( WORD32 ) ( npoints >> 2 ) ; y3 = y2 + ( WORD32 ) ( npoints >> 2 ) ; j0 = 8 ; n0 = npoints >> 1 ; for ( k = 0 ; k < 2 ; k ++ ) { for ( i = 0 ; i < npoints >> 1 ; i += 8 ) { h2 = * pdig_rev_tbl ++ >> 2 ; x_0 = * x0 ++ ; x_1 = * x0 ++ ; x_2 = * x0 ++ ; x_3 = * x0 ++ ; x_4 = * x0 ++ ; x_5 = * x0 ++ ; x_6 = * x0 ++ ; x_7 = * x0 ++ ; <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> n01 = x_1 + x_3 ; n20 = x_0 - x_2 ; n21 = x_1 - x_3 ; n10 = x_4 + x_6 ; n11 = x_5 + x_7 ; n30 = x_4 - x_6 ; n31 = x_5 - x_7 ; y0 [ h2 ] = n00 ; y0 [ h2 + 1 ] = n01 ; <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> y2 [ h2 ] = n20 ; y2 [ h2 + 1 ] = n21 ; <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; n02 = x_8 + x_a ; n03 = x_9 + x_b ; n22 = x_8 - x_a ; n23 = x_9 - x_b ; n12 = x_c + x_e ; n13 = x_d + x_f ; n32 = x_c - x_e ; n33 = x_d - x_f ; y0 [ h2 + 2 ] = n02 ; y0 [ h2 + 3 ] = n03 ; y1 [ h2 + 2 ] = n12 ; y1 [ h2 + 3 ] = n13 ; y2 [ h2 + 2 ] = n22 ; y2 [ h2 + 3 ] = n23 ; y3 [ h2 + 2 ] = n32 ; y3 [ h2 + 3 ] = n33 ; } x0 += ( WORD32 ) npoints >> 1 ; x2 += ( WORD32 ) npoints >> 1 ; } }
","<S2SV_ModStart> x_e , x_f <S2SV_ModEnd> ; WORD32 n0 <S2SV_ModStart> x0 ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; } x0
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,440,"<S2SV_ModStart> x1, x1, x = x2 <S2SV_ModEnd> x2 <S2SV_ModStart> x2 ) ; x = x = x2 <S2SV_ModEnd> x2 <S2SV_ModStart> x2 ) ; x = x = x2 <S2SV_ModEnd>",0
1087,CWE-189,"CWE-189 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( ""invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n"" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }
","<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
",torvalds@linux/a5cd335165e31db9dbab636fd29895d41da55dd2,CVE-2012-0044,https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2,2012-05-17T11:00Z,441,,0
1088,CWE-264,"CWE-264 static inline int unuse_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , swp_entry_t entry , struct page * page ) { pmd_t * pmd ; unsigned long next ; int ret ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; <S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug> continue ; if ( pmd_none_or_clear_bad ( pmd ) ) continue ; ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; if ( ret ) return ret ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }
","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,442,<S2SV_ModStart> ( pmd ) <S2SV_ModEnd> if ( pmd,0
1089,CWE-399,"CWE-399 static int misaligned_fpu_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } switch ( width_shift ) { case 2 : buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; break ; case 3 : if ( do_paired_load ) { buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # else buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # endif } break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } * ( __u32 * ) & buffer = buflo ; * ( 1 + ( __u32 * ) & buffer ) = bufhi ; if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } return 0 ; } else { die ( ""Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel"" , regs , 0 ) ; return - 1 ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,443,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",1
1091,CWE-119,"CWE-119 int main ( int argc , char * argv [ ] ) { char * fin , * fout ; FILE * fpin , * fpout ; uint8_t * inbuf , * outbuf ; uint8_t * inbuf_u , * outbuf_u ; uint8_t * inbuf_v , * outbuf_v ; int f , frames ; <S2SV_StartBug> int width , height , target_width , target_height ; <S2SV_EndBug> if ( argc < 5 ) { printf ( ""Incorrect<S2SV_blank>parameters:\\n"" ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } fin = argv [ 1 ] ; fout = argv [ 4 ] ; if ( ! parse_dim ( argv [ 2 ] , & width , & height ) ) { printf ( ""Incorrect<S2SV_blank>parameters:<S2SV_blank>%s\\n"" , argv [ 2 ] ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } if ( ! parse_dim ( argv [ 3 ] , & target_width , & target_height ) ) { printf ( ""Incorrect<S2SV_blank>parameters:<S2SV_blank>%s\\n"" , argv [ 3 ] ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } fpin = fopen ( fin , ""rb"" ) ; if ( fpin == NULL ) { printf ( ""Can\'t<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>read\\n"" , fin ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } fpout = fopen ( fout , ""wb"" ) ; if ( fpout == NULL ) { printf ( ""Can\'t<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>write\\n"" , fout ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } if ( argc >= 6 ) frames = atoi ( argv [ 5 ] ) ; else frames = INT_MAX ; printf ( ""Input<S2SV_blank>size:<S2SV_blank><S2SV_blank>%dx%d\\n"" , width , height ) ; printf ( ""Target<S2SV_blank>size:<S2SV_blank>%dx%d,<S2SV_blank>Frames:<S2SV_blank>"" , target_width , target_height ) ; if ( frames == INT_MAX ) printf ( ""All\\n"" ) ; else printf ( ""%d\\n"" , frames ) ; inbuf = ( uint8_t * ) malloc ( width * height * 3 / 2 ) ; outbuf = ( uint8_t * ) malloc ( target_width * target_height * 3 / 2 ) ; inbuf_u = inbuf + width * height ; inbuf_v = inbuf_u + width * height / 4 ; outbuf_u = outbuf + target_width * target_height ; outbuf_v = outbuf_u + target_width * target_height / 4 ; f = 0 ; while ( f < frames ) { if ( fread ( inbuf , width * height * 3 / 2 , 1 , fpin ) != 1 ) break ; vp9_resize_frame420 ( inbuf , width , inbuf_u , inbuf_v , width / 2 , height , width , outbuf , target_width , outbuf_u , outbuf_v , target_width / 2 , target_height , target_width ) ; fwrite ( outbuf , target_width * target_height * 3 / 2 , 1 , fpout ) ; f ++ ; } printf ( ""%d<S2SV_blank>frames<S2SV_blank>processed\\n"" , f ) ; fclose ( fpin ) ; fclose ( fpout ) ; free ( inbuf ) ; free ( outbuf ) ; return 0 ; }
","<S2SV_ModStart> target_width , target_height ; exec_name = argv [ 0 ] <S2SV_ModStart> ; usage ( <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; usage ( <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; usage ( <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; usage ( <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; usage ( <S2SV_ModEnd> ) ; return
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,444,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>,0
1097,CWE-125,"CWE-125 static int add_attributes ( PyTypeObject * type , char * * attrs , int num_fields ) { <S2SV_StartBug> int i , result ; <S2SV_EndBug> _Py_IDENTIFIER ( _attributes ) ; PyObject * s , * l = PyTuple_New ( num_fields ) ; if ( ! l ) return 0 ; for ( i = 0 ; i < num_fields ; i ++ ) { s = PyUnicode_FromString ( attrs [ i ] ) ; if ( ! s ) { Py_DECREF ( l ) ; return 0 ; } PyTuple_SET_ITEM ( l , i , s ) ; } result = _PyObject_SetAttrId ( ( PyObject * ) type , & PyId__attributes , l ) >= 0 ; Py_DECREF ( l ) ; return result ; }
","<S2SV_ModStart> i , result <S2SV_ModEnd> ; PyObject *
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,445,,0
1099,CWE-119,"CWE-119 static vpx_codec_err_t vp8e_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * mr_cfg ) { vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_StartBug> struct vpx_codec_alg_priv * priv ; <S2SV_EndBug> vpx_codec_enc_cfg_t * cfg ; unsigned int i ; struct VP8_COMP * optr ; vp8_rtcd ( ) ; if ( ! ctx -> priv ) { <S2SV_StartBug> priv = calloc ( 1 , sizeof ( struct vpx_codec_alg_priv ) ) ; <S2SV_EndBug> if ( ! priv ) { return VPX_CODEC_MEM_ERROR ; } <S2SV_StartBug> ctx -> priv = & priv -> base ; <S2SV_EndBug> ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = priv ; ctx -> priv -> init_flags = ctx -> init_flags ; if ( ctx -> config . enc ) { <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . enc ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . enc = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> } cfg = & ctx -> priv -> alg_priv -> cfg ; for ( i = 0 ; extracfg_map [ i ] . usage && extracfg_map [ i ] . usage != cfg -> g_usage ; i ++ ) ; <S2SV_StartBug> priv -> vp8_cfg = extracfg_map [ i ] . cfg ; <S2SV_EndBug> priv -> vp8_cfg . pkt_list = & priv -> pkt_list . head ; priv -> cx_data_sz = priv -> cfg . g_w * priv -> cfg . g_h * 3 / 2 * 2 ; if ( priv -> cx_data_sz < 32768 ) priv -> cx_data_sz = 32768 ; priv -> cx_data = malloc ( priv -> cx_data_sz ) ; if ( ! priv -> cx_data ) { return VPX_CODEC_MEM_ERROR ; } if ( mr_cfg ) ctx -> priv -> enc . total_encoders = mr_cfg -> mr_total_resolutions ; else ctx -> priv -> enc . total_encoders = 1 ; res = validate_config ( priv , & priv -> cfg , & priv -> vp8_cfg , 0 ) ; if ( ! res ) { <S2SV_StartBug> set_vp8e_config ( & ctx -> priv -> alg_priv -> oxcf , <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg , <S2SV_EndBug> ctx -> priv -> alg_priv -> vp8_cfg , mr_cfg ) ; <S2SV_StartBug> optr = vp8_create_compressor ( & ctx -> priv -> alg_priv -> oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! optr ) <S2SV_EndBug> res = VPX_CODEC_MEM_ERROR ; <S2SV_StartBug> else <S2SV_EndBug> ctx -> priv -> alg_priv -> cpi = optr ; } } return res ; }
","<S2SV_ModStart> = VPX_CODEC_OK ; vp8_rtcd ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; if ( ! ctx -> priv ) { <S2SV_ModStart> vpx_codec_alg_priv * priv = <S2SV_ModEnd> ( struct vpx_codec_alg_priv <S2SV_ModStart> ( struct vpx_codec_alg_priv * ) vpx_calloc ( 1 , sizeof ( * priv <S2SV_ModStart> -> priv = ( vpx_codec_priv_t * ) <S2SV_ModEnd> priv ; ctx <S2SV_ModStart> enc ) { priv <S2SV_ModEnd> -> cfg = <S2SV_ModStart> enc = & priv -> cfg ; } <S2SV_ModEnd> priv -> vp8_cfg <S2SV_ModStart> -> vp8_cfg = default_extracfg <S2SV_ModEnd> ; priv -> <S2SV_ModStart> set_vp8e_config ( & priv <S2SV_ModEnd> -> oxcf , <S2SV_ModStart> -> oxcf , priv -> cfg , priv <S2SV_ModEnd> -> vp8_cfg , <S2SV_ModStart> mr_cfg ) ; priv -> cpi <S2SV_ModEnd> = vp8_create_compressor ( <S2SV_ModStart> vp8_create_compressor ( & priv <S2SV_ModEnd> -> oxcf ) <S2SV_ModStart> if ( ! priv -> cpi <S2SV_ModEnd> ) res = <S2SV_ModStart> = VPX_CODEC_MEM_ERROR ; <S2SV_ModEnd> } } return
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,446,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> vpx_codec_alg_alg_alg_alg_alg_priv ( vpx_alg_alg_t * ) <S2SV_ModEnd> ; vpx_codec_alg_alg_alg_alg_priv ( <S2SV_ModStart> priv_t * ) ; priv = get_alg_alg_alg_alg_alg_alg_alg_alg_alg_alg_alg_alg_priv ( ) <S2SV_ModEnd> ) ;,0
1101,CWE-119,"CWE-119 static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; } <S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }
","<S2SV_ModStart> } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
",FFmpeg@FFmpeg/2171dfae8c065878a2e130390eb78cf2947a5b69,CVE-2017-9995,https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69,2017-06-28T06:29Z,447,,0
1104,CWE-119,"CWE-119 static int update_fragments ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , vpx_codec_err_t * res ) { * res = VPX_CODEC_OK ; if ( ctx -> fragments . count == 0 ) { <S2SV_StartBug> vpx_memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ; <S2SV_EndBug> } if ( ctx -> fragments . enabled && ! ( data == NULL && data_sz == 0 ) ) { ctx -> fragments . ptrs [ ctx -> fragments . count ] = data ; ctx -> fragments . sizes [ ctx -> fragments . count ] = data_sz ; ctx -> fragments . count ++ ; if ( ctx -> fragments . count > ( 1 << EIGHT_PARTITION ) + 1 ) { ctx -> fragments . count = 0 ; * res = VPX_CODEC_INVALID_PARAM ; return - 1 ; } return 0 ; } <S2SV_StartBug> if ( ! ctx -> fragments . enabled ) <S2SV_EndBug> { ctx -> fragments . ptrs [ 0 ] = data ; ctx -> fragments . sizes [ 0 ] = data_sz ; ctx -> fragments . count = 1 ; } return 1 ; }
","<S2SV_ModStart> 0 ) { memset <S2SV_ModEnd> ( ( void <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( ! ctx -> fragments . enabled
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,448,<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( ctx ->,0
1105,CWE-476,"CWE-476 static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; <S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> if ( priv -> task ) put_task_struct ( priv -> task ) ; }
","<S2SV_ModStart> = v ; if ( ! IS_ERR ( vma ) )
",torvalds@linux/76597cd31470fa130784c78fadb4dab2e624a723,CVE-2011-3637,https://github.com/torvalds/linux/commit/76597cd31470fa130784c78fadb4dab2e624a723,2012-05-17T11:00Z,449,<S2SV_ModStart> = v ; <S2SV_ModEnd> return v ;,0
1108,CWE-119,"CWE-119 static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,<S2SV_blank>partition=%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; return - EIO ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; goto out ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; if ( ie -> indirectICB . extLength ) { brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; goto out ; } brelse ( bh ) ; goto reread ; } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; goto out ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return 0 ; } ret = - EIO ; read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) { if ( ! hidden_inode ) { ret = - ESTALE ; goto out ; } link_count = 1 ; } set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } inode -> i_generation = iinfo -> i_unique ; <S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; goto out ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else goto out ; } ret = 0 ; out : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
",torvalds@linux/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,CVE-2014-9728,https://github.com/torvalds/linux/commit/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,2015-08-31T10:59Z,450,<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if (,0
1109,CWE-20,"CWE-20 void enc28j60WritePhyReg ( NetInterface * interface , uint16_t address , uint16_t data ) { <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> { } }
","<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MIWRL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_MIWRH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,451,"<S2SV_ModStart> ( interface, ENC28J60_MISTAT )!= 0 <S2SV_ModEnd> ) { interface <S2SV_ModStart> ( interface, ENC28J60_MISTAT <S2SV_ModEnd>, sizeof ( <S2SV_ModStart> ( interface, ENC28J60_MISTAT ) <S2SV_ModStart> ( interface, ENC28J60_MISTAT <S2SV_ModEnd> ) ; }",0
1110,CWE-134,"CWE-134 <S2SV_StartBug> static int bad_format_imginfo ( <S2SV_EndBug> char * fmt ) { <S2SV_StartBug> char * ptr ; <S2SV_EndBug> int n = 0 ; ptr = fmt ; while ( * ptr != '\\0' ) if ( * ptr ++ == '%' ) { if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 'S' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '<S2SV_blank>' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int bad_format_imginfo ( <S2SV_ModStart> fmt ) { return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> ) ; }
",oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z,452,<S2SV_ModStart> char * str <S2SV_ModEnd> ) { return,0
1115,CWE-358,"CWE-358 void DefragRegisterTests ( void ) { # ifdef UNITTESTS UtRegisterTest ( ""DefragInOrderSimpleTest"" , DefragInOrderSimpleTest ) ; UtRegisterTest ( ""DefragReverseSimpleTest"" , DefragReverseSimpleTest ) ; UtRegisterTest ( ""DefragSturgesNovakBsdTest"" , DefragSturgesNovakBsdTest ) ; UtRegisterTest ( ""DefragSturgesNovakLinuxTest"" , DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( ""DefragSturgesNovakWindowsTest"" , DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( ""DefragSturgesNovakSolarisTest"" , DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( ""DefragSturgesNovakFirstTest"" , DefragSturgesNovakFirstTest ) ; UtRegisterTest ( ""DefragSturgesNovakLastTest"" , DefragSturgesNovakLastTest ) ; UtRegisterTest ( ""DefragIPv4NoDataTest"" , DefragIPv4NoDataTest ) ; UtRegisterTest ( ""DefragIPv4TooLargeTest"" , DefragIPv4TooLargeTest ) ; UtRegisterTest ( ""IPV6DefragInOrderSimpleTest"" , IPV6DefragInOrderSimpleTest ) ; UtRegisterTest ( ""IPV6DefragReverseSimpleTest"" , IPV6DefragReverseSimpleTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakBsdTest"" , IPV6DefragSturgesNovakBsdTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakLinuxTest"" , IPV6DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakWindowsTest"" , IPV6DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakSolarisTest"" , IPV6DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakFirstTest"" , IPV6DefragSturgesNovakFirstTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakLastTest"" , IPV6DefragSturgesNovakLastTest ) ; UtRegisterTest ( ""DefragVlanTest"" , DefragVlanTest ) ; UtRegisterTest ( ""DefragVlanQinQTest"" , DefragVlanQinQTest ) ; UtRegisterTest ( ""DefragTrackerReuseTest"" , DefragTrackerReuseTest ) ; UtRegisterTest ( ""DefragTimeoutTest"" , DefragTimeoutTest ) ; UtRegisterTest ( ""DefragMfIpv4Test"" , DefragMfIpv4Test ) ; UtRegisterTest ( ""DefragMfIpv6Test"" , DefragMfIpv6Test ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> DefragMfIpv6Test ) ; UtRegisterTest ( ""DefragTestBadProto"" , DefragTestBadProto ) ;
",inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z,453,<S2SV_ModStart> ; },0
1116,CWE-415,"CWE-415 static int coolkey_add_object ( coolkey_private_data_t * priv , unsigned long object_id , const u8 * object_data , size_t object_length , int add_v1_record ) { sc_cardctl_coolkey_object_t new_object ; int r ; memset ( & new_object , 0 , sizeof ( new_object ) ) ; new_object . path = coolkey_template_path ; new_object . path . len = 4 ; ulong2bebytes ( new_object . path . value , object_id ) ; new_object . id = object_id ; new_object . length = object_length ; <S2SV_StartBug> if ( object_data ) { <S2SV_EndBug> new_object . data = malloc ( object_length + add_v1_record ) ; if ( new_object . data == NULL ) { return SC_ERROR_OUT_OF_MEMORY ; } if ( add_v1_record ) { new_object . data [ 0 ] = COOLKEY_V1_OBJECT ; new_object . length ++ ; } memcpy ( & new_object . data [ add_v1_record ] , object_data , object_length ) ; } r = coolkey_add_object_to_list ( & priv -> objects_list , & new_object ) ; if ( r != SC_SUCCESS ) { free ( new_object . data ) ; new_object . data = NULL ; } return r ; }
","<S2SV_ModStart> ; if ( coolkey_find_object_by_id ( & priv -> objects_list , object_id ) != NULL ) { return SC_ERROR_INTERNAL ; } if (
",OpenSC@OpenSC/c246f6f69a749d4f68626b40795a4f69168008f4,CVE-2019-20792,https://github.com/OpenSC/OpenSC/commit/c246f6f69a749d4f68626b40795a4f69168008f4,2020-04-29T04:15Z,454,<S2SV_ModStart>,0
1118,CWE-20,"CWE-20 error_t webSocketParseAuthenticateField ( WebSocket * webSocket , char_t * value ) { # if ( WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) size_t n ; char_t * p ; char_t * token ; char_t * separator ; char_t * name ; WebSocketAuthContext * authContext ; authContext = & webSocket -> authContext ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcasecmp ( token , ""Basic"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_BASIC ; } else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_DIGEST ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""realm"" ) ) { strSafeCopy ( authContext -> realm , value , WEB_SOCKET_REALM_MAX_LEN ) ; } # if ( WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { strSafeCopy ( authContext -> nonce , value , WEB_SOCKET_NONCE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { strSafeCopy ( authContext -> opaque , value , WEB_SOCKET_OPAQUE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""stale"" ) ) { if ( ! osStrcasecmp ( value , ""true"" ) ) authContext -> stale = TRUE ; else authContext -> stale = FALSE ; } # endif token = osStrtok_r ( NULL , "","" , & p ) ; } } # endif return NO_ERROR ; }
","<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,455,"<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token,",1
1123,CWE-20,"CWE-20 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,456,<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),1
1126,CWE-120,"CWE-120 static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) { encoder_sys_t * p_sys = p_enc -> p_sys ; block_t * p_block , * p_output_chain = NULL ; SchroFrame * p_frame ; bool b_go = true ; if ( ! p_pic ) { if ( ! p_sys -> started || p_sys -> b_eos_pulled ) return NULL ; if ( ! p_sys -> b_eos_signalled ) { p_sys -> b_eos_signalled = 1 ; schro_encoder_end_of_stream ( p_sys -> p_schro ) ; } } else { p_sys -> p_format -> interlaced = ! p_pic -> b_progressive ; p_sys -> p_format -> top_field_first = p_pic -> b_top_field_first ; if ( p_sys -> b_auto_field_coding ) schro_encoder_setting_set_double ( p_sys -> p_schro , ""interlaced_coding"" , ! p_pic -> b_progressive ) ; } if ( ! p_sys -> started ) { date_t date ; if ( p_pic -> format . i_chroma != p_enc -> fmt_in . i_codec ) { char chroma_in [ 5 ] , chroma_out [ 5 ] ; vlc_fourcc_to_char ( p_pic -> format . i_chroma , chroma_in ) ; chroma_in [ 4 ] = '\\0' ; chroma_out [ 4 ] = '\\0' ; vlc_fourcc_to_char ( p_enc -> fmt_in . i_codec , chroma_out ) ; msg_Warn ( p_enc , ""Resetting<S2SV_blank>chroma<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s"" , chroma_out , chroma_in ) ; if ( ! SetEncChromaFormat ( p_enc , p_pic -> format . i_chroma ) ) { msg_Err ( p_enc , ""Could<S2SV_blank>not<S2SV_blank>reset<S2SV_blank>chroma<S2SV_blank>format<S2SV_blank>to<S2SV_blank>%s"" , chroma_in ) ; return NULL ; } } date_Init ( & date , p_enc -> fmt_in . video . i_frame_rate , p_enc -> fmt_in . video . i_frame_rate_base ) ; date_Increment ( & date , 1 ) ; p_sys -> i_pts_offset = date_Get ( & date ) ; if ( schro_encoder_setting_get_double ( p_sys -> p_schro , ""interlaced_coding"" ) > 0.0 ) { date_Set ( & date , 0 ) ; date_Increment ( & date , 1 ) ; p_sys -> i_field_time = date_Get ( & date ) / 2 ; } schro_video_format_set_std_signal_range ( p_sys -> p_format , SCHRO_SIGNAL_RANGE_8BIT_VIDEO ) ; schro_encoder_set_video_format ( p_sys -> p_schro , p_sys -> p_format ) ; schro_encoder_start ( p_sys -> p_schro ) ; p_sys -> started = 1 ; } if ( ! p_sys -> b_eos_signalled ) { picture_Hold ( p_pic ) ; p_frame = CreateSchroFrameFromInputPic ( p_enc , p_pic ) ; if ( ! p_frame ) return NULL ; schro_encoder_push_frame ( p_sys -> p_schro , p_frame ) ; StorePicturePTS ( p_enc , p_sys -> i_input_picnum , p_pic -> date ) ; p_sys -> i_input_picnum ++ ; p_block = block_Alloc ( 1 ) ; if ( ! p_block ) return NULL ; p_block -> i_dts = p_pic -> date - p_sys -> i_pts_offset ; block_FifoPut ( p_sys -> p_dts_fifo , p_block ) ; p_block = NULL ; if ( schro_encoder_setting_get_double ( p_sys -> p_schro , ""interlaced_coding"" ) > 0.0 ) { StorePicturePTS ( p_enc , p_sys -> i_input_picnum , p_pic -> date + p_sys -> i_field_time ) ; p_sys -> i_input_picnum ++ ; p_block = block_Alloc ( 1 ) ; if ( ! p_block ) return NULL ; p_block -> i_dts = p_pic -> date - p_sys -> i_pts_offset + p_sys -> i_field_time ; block_FifoPut ( p_sys -> p_dts_fifo , p_block ) ; p_block = NULL ; } } do { SchroStateEnum state ; state = schro_encoder_wait ( p_sys -> p_schro ) ; switch ( state ) { case SCHRO_STATE_NEED_FRAME : b_go = false ; break ; case SCHRO_STATE_AGAIN : break ; case SCHRO_STATE_END_OF_STREAM : p_sys -> b_eos_pulled = 1 ; b_go = false ; break ; case SCHRO_STATE_HAVE_BUFFER : { SchroBuffer * p_enc_buf ; uint32_t u_pic_num ; int i_presentation_frame ; p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ; p_block = block_Alloc ( p_enc_buf -> length ) ; if ( ! p_block ) return NULL ; memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ; schro_buffer_unref ( p_enc_buf ) ; if ( 0 == p_block -> p_buffer [ 4 ] ) { p_block -> i_flags |= BLOCK_FLAG_TYPE_I ; if ( ! p_enc -> fmt_out . p_extra ) { const uint8_t eos [ ] = { 'B' , 'B' , 'C' , 'D' , 0x10 , 0 , 0 , 0 , 13 , 0 , 0 , 0 , 0 } ; uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ; <S2SV_StartBug> p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ; <S2SV_EndBug> if ( ! p_enc -> fmt_out . p_extra ) return NULL ; memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ; memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ; SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ; p_enc -> fmt_out . i_extra = len + sizeof ( eos ) ; } } if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) { block_t * p_dts_block = block_FifoGet ( p_sys -> p_dts_fifo ) ; p_block -> i_dts = p_dts_block -> i_dts ; p_block -> i_pts = GetPicturePTS ( p_enc , u_pic_num ) ; block_Release ( p_dts_block ) ; block_ChainAppend ( & p_output_chain , p_block ) ; } else { block_ChainAppend ( & p_output_chain , p_block ) ; } break ; } default : break ; } } while ( b_go ) ; return p_output_chain ; }
","<S2SV_ModStart> 5 ) ; if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ;
",videolan@vlc/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5,CVE-2014-9629,https://github.com/videolan/vlc/commit/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5,2020-01-24T22:15Z,457,,0
1127,CWE-134,"CWE-134 static mf_t * open_mf_pattern ( void * talloc_ctx , struct demuxer * d , char * filename ) { struct mp_log * log = d -> log ; int error_count = 0 ; int count = 0 ; mf_t * mf = talloc_zero ( talloc_ctx , mf_t ) ; mf -> log = log ; if ( filename [ 0 ] == '@' ) { struct stream * s = stream_create ( filename + 1 , d -> stream_origin | STREAM_READ , d -> cancel , d -> global ) ; if ( s ) { while ( 1 ) { char buf [ 512 ] ; int len = stream_read_peek ( s , buf , sizeof ( buf ) ) ; if ( ! len ) break ; bstr data = ( bstr ) { buf , len } ; int pos = bstrchr ( data , '\\n' ) ; data = bstr_splice ( data , 0 , pos < 0 ? data . len : pos + 1 ) ; bstr fname = bstr_strip ( data ) ; if ( fname . len ) { if ( bstrchr ( fname , '\\0' ) >= 0 ) { mp_err ( log , ""invalid<S2SV_blank>filename\\n"" ) ; break ; } char * entry = bstrto0 ( mf , fname ) ; if ( ! mp_path_exists ( entry ) ) { mp_verbose ( log , ""file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\'%s\'\\n"" , entry ) ; } else { MP_TARRAY_APPEND ( mf , mf -> names , mf -> nr_of_files , entry ) ; } } stream_seek_skip ( s , stream_tell ( s ) + data . len ) ; } free_stream ( s ) ; mp_info ( log , ""number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\n"" , mf -> nr_of_files ) ; goto exit_mf ; } mp_info ( log , ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>indirect<S2SV_blank>filelist\\n"" , filename + 1 ) ; } if ( strchr ( filename , ',' ) ) { mp_info ( log , ""filelist:<S2SV_blank>%s\\n"" , filename ) ; bstr bfilename = bstr0 ( filename ) ; while ( bfilename . len ) { bstr bfname ; bstr_split_tok ( bfilename , "","" , & bfname , & bfilename ) ; char * fname2 = bstrdup0 ( mf , bfname ) ; if ( ! mp_path_exists ( fname2 ) ) mp_verbose ( log , ""file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\'%s\'\\n"" , fname2 ) ; else { mf_add ( mf , fname2 ) ; } talloc_free ( fname2 ) ; } mp_info ( log , ""number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\n"" , mf -> nr_of_files ) ; goto exit_mf ; } <S2SV_StartBug> char * fname = talloc_size ( mf , strlen ( filename ) + 32 ) ; <S2SV_EndBug> # if HAVE_GLOB if ( ! strchr ( filename , '%' ) ) { strcpy ( fname , filename ) ; if ( ! strchr ( filename , '*' ) ) strcat ( fname , ""*"" ) ; mp_info ( log , ""search<S2SV_blank>expr:<S2SV_blank>%s\\n"" , fname ) ; glob_t gg ; if ( glob ( fname , 0 , NULL , & gg ) ) { talloc_free ( mf ) ; return NULL ; } for ( int i = 0 ; i < gg . gl_pathc ; i ++ ) { if ( mp_path_isdir ( gg . gl_pathv [ i ] ) ) continue ; mf_add ( mf , gg . gl_pathv [ i ] ) ; } mp_info ( log , ""number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\n"" , mf -> nr_of_files ) ; globfree ( & gg ) ; goto exit_mf ; } # endif <S2SV_StartBug> mp_info ( log , ""search<S2SV_blank>expr:<S2SV_blank>%s\\n"" , filename ) ; <S2SV_EndBug> while ( error_count < 5 ) { <S2SV_StartBug> sprintf ( fname , filename , count ++ ) ; <S2SV_EndBug> if ( ! mp_path_exists ( fname ) ) { error_count ++ ; mp_verbose ( log , ""file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\'%s\'\\n"" , fname ) ; } else { mf_add ( mf , fname ) ; } } mp_info ( log , ""number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\n"" , mf -> nr_of_files ) ; exit_mf : return mf ; }
","<S2SV_ModStart> exit_mf ; } size_t fname_avail = <S2SV_ModEnd> strlen ( filename <S2SV_ModStart> ) + 32 ; char * fname = talloc_size ( mf , fname_avail <S2SV_ModStart> } # endif const char * f = filename ; int MAXDIGS = 3 , nspec = 0 , bad_spec = 0 , c ; while ( nspec < 2 && ( c = * f ++ ) ) { if ( c != '%' ) continue ; if ( * f != '%' ) { nspec ++ ; if ( * f == '.' ) f ++ ; for ( int ndig = 0 ; mp_isdigit ( * f ) && ndig < MAXDIGS ; ndig ++ , f ++ ) ; if ( * f != 'd' ) { bad_spec ++ ; break ; } } f ++ ; } if ( bad_spec || nspec != 1 ) { mp_err ( log , ""unsupported<S2SV_blank>expr<S2SV_blank>format:<S2SV_blank>\'%s\'\\n"" , filename ) ; goto exit_mf ; } <S2SV_ModStart> 5 ) { if ( snprintf ( fname , fname_avail <S2SV_ModEnd> , filename , <S2SV_ModStart> count ++ ) >= fname_avail ) { mp_err ( log , ""format<S2SV_blank>result<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\'%s\'\\n"" , filename ) ; goto exit_mf ; } <S2SV_ModEnd> if ( !
",mpv-player@mpv/d0c530919d8cd4d7a774e38ab064e0fabdae34e6,CVE-2021-30145,https://github.com/mpv-player/mpv/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6,2021-05-18T14:15Z,458,,0
1129,CWE-125,"CWE-125 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z,459,,0
1130,CWE-000,"CWE-000 static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,<S2SV_blank>partition=%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; return - EIO ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; goto out ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; if ( ie -> indirectICB . extLength ) { brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; goto out ; } brelse ( bh ) ; goto reread ; } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; goto out ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return 0 ; } ret = - EIO ; read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) { if ( ! hidden_inode ) { ret = - ESTALE ; goto out ; } link_count = 1 ; } set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } inode -> i_generation = iinfo -> i_unique ; <S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; goto out ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else goto out ; } ret = 0 ; out : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
",torvalds@linux/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,CVE-2014-9729,https://github.com/torvalds/linux/commit/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,2015-08-31T10:59Z,460,<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if (,0
1131,CWE-667,"CWE-667 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; if ( ! vma -> vm_userfaultfd_ctx . ctx ) goto skip ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }
","<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;
",torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z,461,<S2SV_ModStart> mmap_sem ) ; if (! mmget_still_valid ( mm ) ) goto out_unlock ;,1
1132,CWE-119,"CWE-119 static unsigned int tt_activity_measure ( VP8_COMP * cpi , MACROBLOCK * x ) { unsigned int act ; unsigned int sse ; <S2SV_StartBug> act = vp8_variance16x16 ( x -> src . y_buffer , <S2SV_EndBug> x -> src . y_stride , VP8_VAR_OFFS , 0 , & sse ) ; act = act << 4 ; if ( act < 8 << 12 ) act = act < 5 << 12 ? act : 5 << 12 ; return act ; }
","<S2SV_ModStart> int sse ; ( void ) cpi ; act = vpx_variance16x16 <S2SV_ModEnd> ( x ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,462,,0
1134,CWE-119,"CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vp9_ref_frame_t * data = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_StartBug> if ( data ) { <S2SV_EndBug> YV12_BUFFER_CONFIG * fb ; <S2SV_StartBug> vp9_get_reference_dec ( ctx -> pbi , data -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & data -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> * fb ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; fb = get_ref_frame ( & frame_worker_data -> pbi -> common <S2SV_ModEnd> , data -> <S2SV_ModStart> data -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,463,"<S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args ) <S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args )",0
1136,CWE-787,"CWE-787 static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>"" ""beginning<S2SV_blank>of<S2SV_blank>image.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>SOI<S2SV_blank>marker<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>first<S2SV_blank>"" ""marker<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>SOI.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>image<S2SV_blank>content<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } length = AV_RB16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker<S2SV_blank>segment.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == JPEG_MARKER_SOS ) { length = AV_RB16 ( frag -> data + start ) ; <S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! data ) return AVERROR ( ENOMEM ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) return err ; if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }
","<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z,464,,0
1137,CWE-125,"CWE-125 static stmt_ty ast_for_expr_stmt ( struct compiling * c , const node * n ) { REQ ( n , expr_stmt ) ; <S2SV_StartBug> if ( NCH ( n ) == 1 ) { <S2SV_EndBug> expr_ty e = ast_for_testlist ( c , CHILD ( n , 0 ) ) ; if ( ! e ) return NULL ; return Expr ( e , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == augassign ) { expr_ty expr1 , expr2 ; operator_ty newoperator ; node * ch = CHILD ( n , 0 ) ; expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) return NULL ; if ( ! set_context ( c , expr1 , Store , ch ) ) return NULL ; switch ( expr1 -> kind ) { case Name_kind : case Attribute_kind : case Subscript_kind : break ; default : ast_error ( c , ch , ""illegal<S2SV_blank>expression<S2SV_blank>for<S2SV_blank>augmented<S2SV_blank>assignment"" ) ; return NULL ; } ch = CHILD ( n , 2 ) ; if ( TYPE ( ch ) == testlist ) expr2 = ast_for_testlist ( c , ch ) ; else expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) return NULL ; newoperator = ast_for_augassign ( c , CHILD ( n , 1 ) ) ; if ( ! newoperator ) return NULL ; return AugAssign ( expr1 , newoperator , expr2 , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == annassign ) { expr_ty expr1 , expr2 , expr3 ; node * ch = CHILD ( n , 0 ) ; node * deep , * ann = CHILD ( n , 1 ) ; int simple = 1 ; deep = ch ; while ( NCH ( deep ) == 1 ) { deep = CHILD ( deep , 0 ) ; } if ( NCH ( deep ) > 0 && TYPE ( CHILD ( deep , 0 ) ) == LPAR ) { simple = 0 ; } expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) { return NULL ; } switch ( expr1 -> kind ) { case Name_kind : if ( forbidden_name ( c , expr1 -> v . Name . id , n , 0 ) ) { return NULL ; } expr1 -> v . Name . ctx = Store ; break ; case Attribute_kind : if ( forbidden_name ( c , expr1 -> v . Attribute . attr , n , 1 ) ) { return NULL ; } expr1 -> v . Attribute . ctx = Store ; break ; case Subscript_kind : expr1 -> v . Subscript . ctx = Store ; break ; case List_kind : ast_error ( c , ch , ""only<S2SV_blank>single<S2SV_blank>target<S2SV_blank>(not<S2SV_blank>list)<S2SV_blank>can<S2SV_blank>be<S2SV_blank>annotated"" ) ; return NULL ; case Tuple_kind : ast_error ( c , ch , ""only<S2SV_blank>single<S2SV_blank>target<S2SV_blank>(not<S2SV_blank>tuple)<S2SV_blank>can<S2SV_blank>be<S2SV_blank>annotated"" ) ; return NULL ; default : ast_error ( c , ch , ""illegal<S2SV_blank>target<S2SV_blank>for<S2SV_blank>annotation"" ) ; return NULL ; } if ( expr1 -> kind != Name_kind ) { simple = 0 ; } ch = CHILD ( ann , 1 ) ; expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) { return NULL ; } if ( NCH ( ann ) == 2 ) { return AnnAssign ( expr1 , expr2 , NULL , simple , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else { ch = CHILD ( ann , 3 ) ; if ( TYPE ( ch ) == testlist ) { expr3 = ast_for_testlist ( c , ch ) ; } else { expr3 = ast_for_expr ( c , ch ) ; } if ( ! expr3 ) { return NULL ; } return AnnAssign ( expr1 , expr2 , expr3 , simple , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } } else { <S2SV_StartBug> int i ; <S2SV_EndBug> asdl_seq * targets ; node * value ; expr_ty expression ; <S2SV_StartBug> REQ ( CHILD ( n , 1 ) , EQUAL ) ; <S2SV_EndBug> <S2SV_StartBug> targets = _Py_asdl_seq_new ( NCH ( n ) / 2 , c -> c_arena ) ; <S2SV_EndBug> if ( ! targets ) return NULL ; <S2SV_StartBug> for ( i = 0 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> expr_ty e ; node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == yield_expr ) { ast_error ( c , ch , ""assignment<S2SV_blank>to<S2SV_blank>yield<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>possible"" ) ; return NULL ; } e = ast_for_testlist ( c , ch ) ; if ( ! e ) return NULL ; if ( ! set_context ( c , e , Store , CHILD ( n , i ) ) ) return NULL ; asdl_seq_SET ( targets , i / 2 , e ) ; } <S2SV_StartBug> value = CHILD ( n , NCH ( n ) - 1 ) ; <S2SV_EndBug> if ( TYPE ( value ) == testlist_star_expr ) expression = ast_for_testlist ( c , value ) ; else expression = ast_for_expr ( c , value ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> return Assign ( targets , expression , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } }
","<S2SV_ModStart> expr_stmt ) ; int num = <S2SV_ModEnd> NCH ( n <S2SV_ModStart> ( n ) ; if ( num <S2SV_ModStart> { int i , nch_minus_type , has_type_comment <S2SV_ModStart> expr_ty expression ; string type_comment ; <S2SV_ModStart> EQUAL ) ; has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ; nch_minus_type = num - has_type_comment ; <S2SV_ModStart> = _Py_asdl_seq_new ( nch_minus_type <S2SV_ModEnd> / 2 , <S2SV_ModStart> ; i < nch_minus_type <S2SV_ModEnd> - 2 ; <S2SV_ModStart> ( n , nch_minus_type <S2SV_ModEnd> - 1 ) <S2SV_ModStart> return NULL ; if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; <S2SV_ModStart> , expression , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,465,,0
1138,CWE-119,"CWE-119 <S2SV_StartBug> int vp8_denoiser_filter_c ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) { unsigned char * sig = signal -> thismb ; int sig_stride = 16 ; <S2SV_StartBug> unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; <S2SV_EndBug> int mc_avg_y_stride = mc_running_avg -> y_stride ; <S2SV_StartBug> unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; <S2SV_EndBug> int avg_y_stride = running_avg -> y_stride ; <S2SV_StartBug> int r , c , i ; <S2SV_EndBug> int sum_diff = 0 ; <S2SV_StartBug> int adj_val [ 3 ] = { 3 , 4 , 6 } ; <S2SV_EndBug> if ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) { <S2SV_StartBug> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_EndBug> adj_val [ i ] += 1 ; } for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = 0 ; int adjustment = 0 ; int absdiff = 0 ; diff = mc_running_avg_y [ c ] - sig [ c ] ; absdiff = abs ( diff ) ; <S2SV_StartBug> if ( absdiff <= 3 ) <S2SV_EndBug> { running_avg_y [ c ] = mc_running_avg_y [ c ] ; <S2SV_StartBug> sum_diff += diff ; <S2SV_EndBug> } else { <S2SV_StartBug> if ( absdiff >= 4 && absdiff <= 7 ) <S2SV_EndBug> adjustment = adj_val [ 0 ] ; else if ( absdiff >= 8 && absdiff <= 15 ) adjustment = adj_val [ 1 ] ; else adjustment = adj_val [ 2 ] ; if ( diff > 0 ) { if ( ( sig [ c ] + adjustment ) > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = sig [ c ] + adjustment ; <S2SV_StartBug> sum_diff += adjustment ; <S2SV_EndBug> } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ; else <S2SV_StartBug> running_avg_y [ c ] = sig [ c ] - adjustment ; <S2SV_EndBug> sum_diff -= adjustment ; } } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> return COPY_BLOCK ; <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> return FILTER_BLOCK ; }
","<S2SV_ModStart> int vp8_denoiser_filter_c ( <S2SV_ModEnd> unsigned char * <S2SV_ModStart> char * mc_running_avg_y , int mc_avg_y_stride , <S2SV_ModEnd> unsigned char * <S2SV_ModStart> char * running_avg_y , int avg_y_stride , unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; int sum_diff_thresh <S2SV_ModEnd> ; int r <S2SV_ModStart> r , c <S2SV_ModEnd> ; int sum_diff <S2SV_ModStart> 4 , 6 } ; int shift_inc1 = 0 ; int shift_inc2 = 1 ; int col_sum [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <S2SV_ModStart> MOTION_MAGNITUDE_THRESHOLD ) { if ( increase_denoising ) { shift_inc1 = 1 ; shift_inc2 = 2 ; } adj_val [ 0 ] += shift_inc2 ; adj_val [ 1 ] += shift_inc2 ; adj_val [ 2 ] += shift_inc2 <S2SV_ModEnd> ; } for <S2SV_ModStart> absdiff <= 3 + shift_inc1 <S2SV_ModStart> c ] ; col_sum [ c ] <S2SV_ModEnd> += diff ; <S2SV_ModStart> absdiff >= 4 + shift_inc1 <S2SV_ModStart> + adjustment ; col_sum [ c ] += adjustment ; } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = sig [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] ; } sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs ( sum_diff ) > sum_diff_thresh ) { int delta = ( ( abs ( sum_diff ) - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = mc_running_avg_y <S2SV_ModEnd> [ c ] <S2SV_ModStart> c ] - sig [ c ] ; int adjustment = abs ( diff ) ; if ( adjustment > delta ) adjustment = delta ; if ( diff > 0 ) { if ( running_avg_y [ c ] - adjustment < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = running_avg_y [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } else if ( diff < 0 ) { if ( running_avg_y [ c ] + adjustment > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = running_avg_y [ c ] + adjustment ; col_sum [ c ] += adjustment ; } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } sum_diff = 0 ; for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] <S2SV_ModEnd> ; } if <S2SV_ModStart> sum_diff ) > sum_diff_thresh <S2SV_ModEnd> ) return COPY_BLOCK <S2SV_ModStart> return COPY_BLOCK ; } else { return COPY_BLOCK ; } } vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> , avg_y_stride , <S2SV_ModStart> , avg_y_stride , sig_start <S2SV_ModEnd> , sig_stride )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,466,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1139,CWE-119,"CWE-119 static SockState SockParse ( Sock * sockPtr ) { const Tcl_DString * bufPtr ; const Driver * drvPtr ; Request * reqPtr ; char save ; SockState result ; NS_NONNULL_ASSERT ( sockPtr != NULL ) ; drvPtr = sockPtr -> drvPtr ; NsUpdateProgress ( ( Ns_Sock * ) sockPtr ) ; reqPtr = sockPtr -> reqPtr ; bufPtr = & reqPtr -> buffer ; while ( reqPtr -> coff == 0u ) { char * s , * e ; size_t cnt ; s = bufPtr -> string + reqPtr -> roff ; e = memchr ( s , INTCHAR ( '\\n' ) , reqPtr -> avail ) ; if ( unlikely ( e == NULL ) ) { return SOCK_MORE ; } if ( unlikely ( ( e - s ) > drvPtr -> maxline ) ) { sockPtr -> keep = NS_FALSE ; if ( reqPtr -> request . line == NULL ) { Ns_Log ( DriverDebug , ""SockParse:<S2SV_blank>maxline<S2SV_blank>reached<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , drvPtr -> maxline ) ; sockPtr -> flags = NS_CONN_REQUESTURITOOLONG ; Ns_Log ( Warning , ""request<S2SV_blank>line<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%d<S2SV_blank>bytes)"" , ( int ) ( e - s ) ) ; } else { sockPtr -> flags = NS_CONN_LINETOOLONG ; Ns_Log ( Warning , ""request<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%d<S2SV_blank>bytes)"" , ( int ) ( e - s ) ) ; } } cnt = ( size_t ) ( e - s ) + 1u ; reqPtr -> roff += cnt ; reqPtr -> avail -= cnt ; if ( likely ( e > s ) && likely ( * ( e - 1 ) == '\\r' ) ) { -- e ; } if ( unlikely ( e == s ) && ( reqPtr -> coff == 0u ) ) { reqPtr -> coff = EndOfHeader ( sockPtr ) ; if ( ( sockPtr -> flags & NS_CONN_CONTINUE ) != 0u ) { Ns_Log ( Ns_LogRequestDebug , ""honoring<S2SV_blank>100-continue"" ) ; if ( ( sockPtr -> flags & NS_CONN_ENTITYTOOLARGE ) != 0u ) { Ns_Log ( Ns_LogRequestDebug , ""100-continue:<S2SV_blank>entity<S2SV_blank>too<S2SV_blank>large"" ) ; return SOCK_ENTITYTOOLARGE ; } else { struct iovec iov [ 1 ] ; ssize_t sent ; Ns_Log ( Ns_LogRequestDebug , ""100-continue:<S2SV_blank>reply<S2SV_blank>CONTINUE"" ) ; iov [ 0 ] . iov_base = ( char * ) ""HTTP/1.1<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n"" ; iov [ 0 ] . iov_len = strlen ( iov [ 0 ] . iov_base ) ; sent = Ns_SockSendBufs ( ( Ns_Sock * ) sockPtr , iov , 1 , NULL , 0u ) ; if ( sent != ( ssize_t ) iov [ 0 ] . iov_len ) { Ns_Log ( Warning , ""could<S2SV_blank>not<S2SV_blank>deliver<S2SV_blank>response:<S2SV_blank>100<S2SV_blank>Continue"" ) ; } } } } else { save = * e ; * e = '\\0' ; if ( unlikely ( reqPtr -> request . line == NULL ) ) { Ns_Log ( DriverDebug , ""SockParse<S2SV_blank>(%d):<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>line<S2SV_blank><%s>"" , sockPtr -> sock , s ) ; if ( Ns_ParseRequest ( & reqPtr -> request , s ) == NS_ERROR ) { return SOCK_BADREQUEST ; } if ( unlikely ( reqPtr -> request . version < 1.0 ) ) { reqPtr -> coff = reqPtr -> roff ; Ns_Log ( Notice , ""pre-HTTP/1.0<S2SV_blank>request<S2SV_blank><%s>"" , reqPtr -> request . line ) ; } } else if ( Ns_ParseHeader ( reqPtr -> headers , s , Preserve ) != NS_OK ) { return SOCK_BADHEADER ; } else { if ( unlikely ( Ns_SetSize ( reqPtr -> headers ) > ( size_t ) drvPtr -> maxheaders ) ) { Ns_Log ( DriverDebug , ""SockParse<S2SV_blank>(%d):<S2SV_blank>maxheaders<S2SV_blank>reached<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , sockPtr -> sock , drvPtr -> maxheaders ) ; return SOCK_TOOMANYHEADERS ; } } * e = save ; } } if ( unlikely ( reqPtr -> request . line == NULL ) ) { return SOCK_BADREQUEST ; } assert ( reqPtr -> coff > 0u ) ; assert ( reqPtr -> request . line != NULL ) ; <S2SV_StartBug> Ns_Log ( Dev , ""===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%"" PRIuz <S2SV_EndBug> "",<S2SV_blank>avail<S2SV_blank>%"" PRIuz "")<S2SV_blank>tfd<S2SV_blank>%d<S2SV_blank>tfile<S2SV_blank>%p<S2SV_blank>chunkStartOff<S2SV_blank>%"" PRIuz , reqPtr -> length , reqPtr -> avail , sockPtr -> tfd , ( void * ) sockPtr -> tfile , reqPtr -> chunkStartOff ) ; if ( reqPtr -> chunkStartOff != 0u ) { <S2SV_StartBug> bool complete ; <S2SV_EndBug> size_t currentContentLength ; <S2SV_StartBug> complete = ChunkedDecode ( reqPtr , NS_TRUE ) ; <S2SV_EndBug> currentContentLength = reqPtr -> chunkWriteOff - reqPtr -> coff ; <S2SV_StartBug> if ( ( ! complete ) <S2SV_EndBug> || ( reqPtr -> expectedLength != 0u && currentContentLength < reqPtr -> expectedLength ) ) { return SOCK_MORE ; <S2SV_StartBug> } <S2SV_EndBug> reqPtr -> length = ( size_t ) currentContentLength ; } if ( reqPtr -> avail < reqPtr -> length ) { Ns_Log ( DriverDebug , ""SockRead<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>more<S2SV_blank>input"" ) ; return SOCK_MORE ; } Ns_Log ( Dev , ""===<S2SV_blank>all<S2SV_blank>required<S2SV_blank>data<S2SV_blank>is<S2SV_blank>available<S2SV_blank>(avail<S2SV_blank>%"" PRIuz "",<S2SV_blank>length<S2SV_blank>%"" PRIuz "",<S2SV_blank>"" ""readahead<S2SV_blank>%"" TCL_LL_MODIFIER ""d<S2SV_blank>maxupload<S2SV_blank>%"" TCL_LL_MODIFIER ""d)<S2SV_blank>tfd<S2SV_blank>%d"" , reqPtr -> avail , reqPtr -> length , drvPtr -> readahead , drvPtr -> maxupload , sockPtr -> tfd ) ; result = SOCK_READY ; if ( sockPtr -> tfile != NULL ) { reqPtr -> content = NULL ; reqPtr -> next = NULL ; reqPtr -> avail = 0u ; Ns_Log ( DriverDebug , ""content<S2SV_blank>spooled<S2SV_blank>to<S2SV_blank>file:<S2SV_blank>size<S2SV_blank>%"" PRIdz "",<S2SV_blank>file<S2SV_blank>%s"" , reqPtr -> length , sockPtr -> tfile ) ; } else { if ( sockPtr -> tfd > 0 ) { # ifdef _WIN32 assert ( 0 ) ; # else int prot = PROT_READ | PROT_WRITE ; ssize_t rc = ns_write ( sockPtr -> tfd , ""\\0"" , 1 ) ; if ( rc == - 1 ) { Ns_Log ( Error , ""socket:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>append<S2SV_blank>terminating<S2SV_blank>0-byte"" ) ; } sockPtr -> tsize = reqPtr -> length + 1 ; sockPtr -> taddr = mmap ( 0 , sockPtr -> tsize , prot , MAP_PRIVATE , sockPtr -> tfd , 0 ) ; if ( sockPtr -> taddr == MAP_FAILED ) { sockPtr -> taddr = NULL ; result = SOCK_ERROR ; } else { reqPtr -> content = sockPtr -> taddr ; Ns_Log ( Debug , ""content<S2SV_blank>spooled<S2SV_blank>to<S2SV_blank>mmapped<S2SV_blank>file:<S2SV_blank>readahead=%"" TCL_LL_MODIFIER ""d,<S2SV_blank>filesize=%"" PRIdz , drvPtr -> readahead , sockPtr -> tsize ) ; } # endif } else { reqPtr -> content = bufPtr -> string + reqPtr -> coff ; } reqPtr -> next = reqPtr -> content ; if ( reqPtr -> length > 0u ) { Ns_Log ( DriverDebug , ""SockRead<S2SV_blank>adds<S2SV_blank>null<S2SV_blank>terminating<S2SV_blank>character<S2SV_blank>at<S2SV_blank>content[%"" PRIuz ""]"" , reqPtr -> length ) ; reqPtr -> savedChar = reqPtr -> content [ reqPtr -> length ] ; reqPtr -> content [ reqPtr -> length ] = '\\0' ; if ( sockPtr -> taddr == NULL ) { LogBuffer ( DriverDebug , ""UPDATED<S2SV_blank>BUFFER"" , sockPtr -> reqPtr -> buffer . string , ( size_t ) reqPtr -> buffer . length ) ; } } } return result ; }
","<S2SV_ModStart> ; Ns_Log ( Debug <S2SV_ModEnd> , ""===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%"" PRIuz <S2SV_ModStart> 0u ) { SockState chunkState <S2SV_ModEnd> ; size_t currentContentLength <S2SV_ModStart> size_t currentContentLength ; chunkState <S2SV_ModEnd> = ChunkedDecode ( <S2SV_ModStart> if ( ( chunkState == SOCK_MORE <S2SV_ModEnd> ) || ( <S2SV_ModStart> SOCK_MORE ; } else if ( chunkState != SOCK_READY ) { return chunkState ; }
",naviserver@naviserver/a5c3079f1d8996d5f34c9384a440acf3519ca3bb,CVE-2020-13111,https://bitbucket.org/naviserver/naviserver/commit/a5c3079f1d8996d5f34c9384a440acf3519ca3bb,2020-05-16T15:15Z,467,,0
1140,CWE-20,"CWE-20 int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z,468,,0
1141,CWE-20,"CWE-20 error_t rawSocketReceiveIpPacket ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } rawSocketUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }
","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,469,<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->,1
1142,CWE-22,"CWE-22 static void xcopy_pt_undepend_remotedev ( struct xcopy_op * xop ) { <S2SV_StartBug> struct se_device * remote_dev ; <S2SV_EndBug> if ( xop -> op_origin == XCOL_SOURCE_RECV_OP ) <S2SV_StartBug> remote_dev = xop -> dst_dev ; <S2SV_EndBug> else <S2SV_StartBug> remote_dev = xop -> src_dev ; <S2SV_EndBug> pr_debug ( ""Calling<S2SV_blank>configfs_undepend_item<S2SV_blank>for"" ""<S2SV_blank>remote_dev:<S2SV_blank>%p<S2SV_blank>remote_dev->dev_group:<S2SV_blank>%p\\n"" , remote_dev , & remote_dev -> dev_group . cg_item ) ; target_undepend_item ( & remote_dev -> dev_group . cg_item ) ; }
","<S2SV_ModStart> xop ) { <S2SV_ModEnd> if ( xop <S2SV_ModStart> == XCOL_SOURCE_RECV_OP ) pr_debug ( ""putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> dst_dev <S2SV_ModStart> xop -> dst_dev ) ; else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> src_dev <S2SV_ModStart> xop -> src_dev ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> ) ; }
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z,470,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
1144,CWE-19,"CWE-19 static int ext2_xattr_set2 ( struct inode * inode , struct buffer_head * old_bh , struct ext2_xattr_header * header ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; int error ; <S2SV_StartBug> if ( header ) { <S2SV_EndBug> new_bh = ext2_xattr_cache_find ( inode , header ) ; if ( new_bh ) { if ( new_bh == old_bh ) { ea_bdebug ( new_bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; } else { ea_bdebug ( new_bh , ""reusing<S2SV_blank>block"" ) ; error = dquot_alloc_block ( inode , 1 ) ; if ( error ) { unlock_buffer ( new_bh ) ; goto cleanup ; } le32_add_cpu ( & HDR ( new_bh ) -> h_refcount , 1 ) ; ea_bdebug ( new_bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( new_bh ) -> h_refcount ) ) ; } unlock_buffer ( new_bh ) ; } else if ( old_bh && header == HDR ( old_bh ) ) { new_bh = old_bh ; get_bh ( new_bh ) ; <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> } else { ext2_fsblk_t goal = ext2_group_first_block_no ( sb , EXT2_I ( inode ) -> i_block_group ) ; int block = ext2_new_block ( inode , goal , & error ) ; if ( error ) goto cleanup ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%d"" , block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { ext2_free_blocks ( inode , block , 1 ) ; mark_inode_dirty ( inode ) ; error = - ENOMEM ; goto cleanup ; } lock_buffer ( new_bh ) ; memcpy ( new_bh -> b_data , header , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> ext2_xattr_update_super_block ( sb ) ; } mark_buffer_dirty ( new_bh ) ; if ( IS_SYNC ( inode ) ) { sync_dirty_buffer ( new_bh ) ; error = - EIO ; if ( buffer_req ( new_bh ) && ! buffer_uptodate ( new_bh ) ) goto cleanup ; } } EXT2_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; inode -> i_ctime = CURRENT_TIME_SEC ; if ( IS_SYNC ( inode ) ) { error = sync_inode_metadata ( inode , 1 ) ; if ( error && error != - ENOSPC ) { if ( new_bh && new_bh != old_bh ) { dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; } goto cleanup ; } } else mark_inode_dirty ( inode ) ; error = 0 ; if ( old_bh && old_bh != new_bh ) { <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> ce = mb_cache_entry_get ( ext2_xattr_cache , old_bh -> b_bdev , old_bh -> b_blocknr ) ; lock_buffer ( old_bh ) ; if ( HDR ( old_bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ea_bdebug ( old_bh , ""freeing"" ) ; ext2_free_blocks ( inode , old_bh -> b_blocknr , 1 ) ; mark_inode_dirty ( inode ) ; get_bh ( old_bh ) ; bforget ( old_bh ) ; } else { le32_add_cpu ( & HDR ( old_bh ) -> h_refcount , - 1 ) ; <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_release ( ce ) ; dquot_free_block_nodirty ( inode , 1 ) ; mark_inode_dirty ( inode ) ; mark_buffer_dirty ( old_bh ) ; ea_bdebug ( old_bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( old_bh ) -> h_refcount ) ) ; } unlock_buffer ( old_bh ) ; } cleanup : brelse ( new_bh ) ; return error ; }
","<S2SV_ModStart> int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ; <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> new_bh ) { <S2SV_ModEnd> lock_buffer ( old_bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( old_bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext2_mb_cache , hash , old_bh -> b_blocknr <S2SV_ModEnd> ) ; ea_bdebug <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> dquot_free_block_nodirty ( inode
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z,471,<S2SV_ModStart> ; int error ; struct mb2_cache * new_bh = NULL ; struct mb2_bh = EXT2_SB ( new_bh ) -> b_bh <S2SV_ModStart> ; if (! new_bh ) -> h_bh -> h_bh -> h_bh -> h_bh_bh -> h_bh_bh_bh ) { ext2_cache = NULL ; goto out ; } sb2_cache = NULL ; <S2SV_ModEnd> if (!,0
1146,CWE-119,"CWE-119 static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_active_map_t * const map = va_arg ( args , vpx_active_map_t * ) ; if ( map ) { <S2SV_StartBug> if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) <S2SV_EndBug> return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> -> active_map , ( int ) <S2SV_ModStart> -> rows , ( int )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,472,"<S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args )",0
1148,CWE-476,"CWE-476 static Image * ReadXCFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char magick [ 14 ] ; Image * image ; int foundPropEnd = 0 ; MagickBooleanType status ; MagickOffsetType offset ; register ssize_t i ; size_t image_type , length ; ssize_t count ; XCFDocInfo doc_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 14 , ( unsigned char * ) magick ) ; if ( ( count != 14 ) || ( LocaleNCompare ( ( char * ) magick , ""gimp<S2SV_blank>xcf"" , 8 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ResetMagickMemory ( & doc_info , 0 , sizeof ( XCFDocInfo ) ) ; doc_info . exception = exception ; doc_info . width = ReadBlobMSBLong ( image ) ; doc_info . height = ReadBlobMSBLong ( image ) ; if ( ( doc_info . width > 262144 ) || ( doc_info . height > 262144 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; doc_info . image_type = ReadBlobMSBLong ( image ) ; image -> columns = doc_info . width ; image -> rows = doc_info . height ; image_type = doc_info . image_type ; doc_info . file_size = GetBlobSize ( image ) ; image -> compression = NoCompression ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image_type == GIMP_RGB ) ; else if ( image_type == GIMP_GRAY ) image -> colorspace = GRAYColorspace ; else if ( image_type == GIMP_INDEXED ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; ( void ) SetImageOpacity ( image , OpaqueOpacity ) ; ( void ) SetImageBackgroundColor ( image ) ; while ( ( foundPropEnd == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) { PropType prop_type = ( PropType ) ReadBlobMSBLong ( image ) ; size_t prop_size = ReadBlobMSBLong ( image ) ; switch ( prop_type ) { case PROP_END : foundPropEnd = 1 ; break ; case PROP_COLORMAP : { size_t num_colours = ReadBlobMSBLong ( image ) ; if ( DiscardBlobBytes ( image , 3 * num_colours ) == MagickFalse ) ThrowFileException ( & image -> exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } case PROP_COMPRESSION : { doc_info . compression = ReadBlobByte ( image ) ; if ( ( doc_info . compression != COMPRESS_NONE ) && ( doc_info . compression != COMPRESS_RLE ) && ( doc_info . compression != COMPRESS_ZLIB ) && ( doc_info . compression != COMPRESS_FRACTAL ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } break ; case PROP_GUIDES : { if ( DiscardBlobBytes ( image , prop_size ) == MagickFalse ) ThrowFileException ( & image -> exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } break ; case PROP_RESOLUTION : { ( void ) ReadBlobMSBLong ( image ) ; ( void ) ReadBlobMSBLong ( image ) ; } break ; case PROP_TATTOO : { ( void ) ReadBlobMSBLong ( image ) ; } break ; case PROP_PARASITES : { if ( DiscardBlobBytes ( image , prop_size ) == MagickFalse ) ThrowFileException ( & image -> exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } break ; case PROP_UNIT : { ( void ) ReadBlobMSBLong ( image ) ; } break ; case PROP_PATHS : { if ( DiscardBlobBytes ( image , prop_size ) == MagickFalse ) ThrowFileException ( & image -> exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } break ; case PROP_USER_UNIT : { char unit_string [ 1000 ] ; ( void ) ReadBlobMSBLong ( image ) ; ( void ) ReadBlobMSBLong ( image ) ; for ( i = 0 ; i < 5 ; i ++ ) ( void ) ReadBlobStringWithLongSize ( image , unit_string , sizeof ( unit_string ) ) ; } break ; default : { int buf [ 16 ] ; ssize_t amount ; while ( ( prop_size > 0 ) && ( EOFBlob ( image ) == MagickFalse ) ) { amount = ( ssize_t ) MagickMin ( 16 , prop_size ) ; amount = ( ssize_t ) ReadBlob ( image , ( size_t ) amount , ( unsigned char * ) & buf ) ; if ( ! amount ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; prop_size -= ( size_t ) MagickMin ( 16 , ( size_t ) amount ) ; } } break ; } } if ( foundPropEnd == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) { ; } else { int current_layer = 0 , foundAllLayers = MagickFalse , number_layers = 0 ; MagickOffsetType oldPos = TellBlob ( image ) ; XCFLayerInfo * layer_info ; do { ssize_t offset = ReadBlobMSBSignedLong ( image ) ; if ( offset == 0 ) foundAllLayers = MagickTrue ; else number_layers ++ ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } while ( foundAllLayers == MagickFalse ) ; doc_info . number_layers = number_layers ; offset = SeekBlob ( image , oldPos , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; length = ( size_t ) number_layers ; layer_info = ( XCFLayerInfo * ) AcquireQuantumMemory ( length , sizeof ( * layer_info ) ) ; if ( layer_info == ( XCFLayerInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( layer_info , 0 , number_layers * sizeof ( XCFLayerInfo ) ) ; for ( ; ; ) { MagickBooleanType layer_ok ; MagickOffsetType offset , saved_pos ; offset = ( MagickOffsetType ) ReadBlobMSBLong ( image ) ; if ( offset == 0 ) break ; saved_pos = TellBlob ( image ) ; if ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ThrowReaderException ( ResourceLimitError , ""NotEnoughPixelData"" ) ; layer_ok = ReadOneLayer ( image_info , image , & doc_info , & layer_info [ current_layer ] , current_layer ) ; if ( layer_ok == MagickFalse ) { int j ; for ( j = 0 ; j < current_layer ; j ++ ) layer_info [ j ] . image = DestroyImage ( layer_info [ j ] . image ) ; layer_info = ( XCFLayerInfo * ) RelinquishMagickMemory ( layer_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } offset = SeekBlob ( image , saved_pos , SEEK_SET ) ; current_layer ++ ; } # if 0 { signed int j ; for ( j = number_layers - 1 ; j >= 0 ; j -- ) { if ( layer_info [ j ] . visible ) { CompositeImage ( image , OverCompositeOp , layer_info [ j ] . image , layer_info [ j ] . offset_x , layer_info [ j ] . offset_y ) ; layer_info [ j ] . image = DestroyImage ( layer_info [ j ] . image ) ; if ( image_type == GIMP_GRAY ) { QuantizeInfo qi ; GetQuantizeInfo ( & qi ) ; qi . colorspace = GRAYColorspace ; QuantizeImage ( & qi , layer_info [ j ] . image ) ; } } } } # else { ssize_t j ; for ( j = ( long ) number_layers - 1 ; j >= 0 ; j -- ) AppendImageToList ( & image , layer_info [ j ] . image ) ; } # endif layer_info = ( XCFLayerInfo * ) RelinquishMagickMemory ( layer_info ) ; # if 0 while ( MagickTrue ) { info -> cp += xcf_read_int32 ( info -> fp , & offset , 1 ) ; if ( offset == 0 ) break ; saved_pos = info -> cp ; xcf_seek_pos ( info , offset ) ; channel = xcf_load_channel ( info , gimage ) ; if ( channel == 0 ) goto error ; num_successful_elements ++ ; if ( channel != gimage -> selection_mask ) gimp_image_add_channel ( gimage , channel , - 1 ) ; xcf_seek_pos ( info , saved_pos ) ; } # endif } ( void ) CloseBlob ( image ) ; <S2SV_StartBug> DestroyImage ( RemoveFirstImageFromList ( & image ) ) ; <S2SV_EndBug> if ( image_type == GIMP_GRAY ) image -> type = GrayscaleType ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> image ) ; if ( GetNextImageInList ( image ) != ( Image * ) NULL )
",ImageMagick@ImageMagick/d31fec57e9dfb0516deead2053a856e3c71e9751,CVE-2017-6501,https://github.com/ImageMagick/ImageMagick/commit/d31fec57e9dfb0516deead2053a856e3c71e9751,2017-03-06T02:59Z,473,,0
1149,CWE-400,"CWE-400 static void perf_event_task_output ( struct perf_event * event , struct perf_task_event * task_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; struct task_struct * task = task_event -> task ; int ret , size = task_event -> event_id . header . size ; perf_event_header__init_id ( & task_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <S2SV_StartBug> task_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> if ( ret ) goto out ; task_event -> event_id . pid = perf_event_pid ( event , task ) ; task_event -> event_id . ppid = perf_event_pid ( event , current ) ; task_event -> event_id . tid = perf_event_tid ( event , task ) ; task_event -> event_id . ptid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , task_event -> event_id ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : task_event -> event_id . header . size = size ; }
","<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,474,"<S2SV_ModStart> size, 0 <S2SV_ModEnd> ) ; if",1
1153,CWE-119,"CWE-119 MagickBooleanType sixel_decode ( unsigned char * p , unsigned char * * pixels , size_t * pwidth , size_t * pheight , unsigned char * * palette , size_t * ncolors ) { int n , i , r , g , b , sixel_vertical_mask , c ; int posision_x , posision_y ; int max_x , max_y ; int attributed_pan , attributed_pad ; int attributed_ph , attributed_pv ; int repeat_count , color_index , max_color_index = 2 , background_color_index ; int param [ 10 ] ; int sixel_palet [ SIXEL_PALETTE_MAX ] ; unsigned char * imbuf , * dmbuf ; int imsx , imsy ; int dmsx , dmsy ; int y ; posision_x = posision_y = 0 ; max_x = max_y = 0 ; attributed_pan = 2 ; attributed_pad = 1 ; attributed_ph = attributed_pv = 0 ; repeat_count = 1 ; color_index = 0 ; background_color_index = 0 ; imsx = 2048 ; imsy = 2048 ; <S2SV_StartBug> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <S2SV_EndBug> if ( imbuf == NULL ) { return ( MagickFalse ) ; } for ( n = 0 ; n < 16 ; n ++ ) { sixel_palet [ n ] = sixel_default_color_table [ n ] ; } for ( r = 0 ; r < 6 ; r ++ ) { for ( g = 0 ; g < 6 ; g ++ ) { for ( b = 0 ; b < 6 ; b ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( r * 51 , g * 51 , b * 51 ) ; } } } for ( i = 0 ; i < 24 ; i ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( i * 11 , i * 11 , i * 11 ) ; } for ( ; n < SIXEL_PALETTE_MAX ; n ++ ) { sixel_palet [ n ] = SIXEL_RGB ( 255 , 255 , 255 ) ; } <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <S2SV_EndBug> while ( * p != '\\0' ) { if ( ( p [ 0 ] == '\\033' && p [ 1 ] == 'P' ) || * p == 0x90 ) { if ( * p == '\\033' ) { p ++ ; } p = get_params ( ++ p , param , & n ) ; if ( * p == 'q' ) { p ++ ; if ( n > 0 ) { switch ( param [ 0 ] ) { case 0 : case 1 : attributed_pad = 2 ; break ; case 2 : attributed_pad = 5 ; break ; case 3 : attributed_pad = 4 ; break ; case 4 : attributed_pad = 4 ; break ; case 5 : attributed_pad = 3 ; break ; case 6 : attributed_pad = 3 ; break ; case 7 : attributed_pad = 2 ; break ; case 8 : attributed_pad = 2 ; break ; case 9 : attributed_pad = 1 ; break ; } } if ( n > 2 ) { if ( param [ 2 ] == 0 ) { param [ 2 ] = 10 ; } attributed_pan = attributed_pan * param [ 2 ] / 10 ; attributed_pad = attributed_pad * param [ 2 ] / 10 ; if ( attributed_pan <= 0 ) attributed_pan = 1 ; if ( attributed_pad <= 0 ) attributed_pad = 1 ; } } } else if ( ( p [ 0 ] == '\\033' && p [ 1 ] == '\\\\' ) || * p == 0x9C ) { break ; } else if ( * p == \'""\' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) attributed_pad = param [ 0 ] ; if ( n > 1 ) attributed_pan = param [ 1 ] ; if ( n > 2 && param [ 2 ] > 0 ) attributed_ph = param [ 2 ] ; if ( n > 3 && param [ 3 ] > 0 ) attributed_pv = param [ 3 ] ; if ( attributed_pan <= 0 ) attributed_pan = 1 ; if ( attributed_pad <= 0 ) attributed_pad = 1 ; if ( imsx < attributed_ph || imsy < attributed_pv ) { dmsx = imsx > attributed_ph ? imsx : attributed_ph ; dmsy = imsy > attributed_pv ? imsy : attributed_pv ; <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> if ( dmbuf == ( unsigned char * ) NULL ) { imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> for ( y = 0 ; y < imsy ; ++ y ) { <S2SV_StartBug> ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; <S2SV_EndBug> } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } } else if ( * p == '!' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) { repeat_count = param [ 0 ] ; } } else if ( * p == '#' ) { p = get_params ( ++ p , param , & n ) ; if ( n > 0 ) { if ( ( color_index = param [ 0 ] ) < 0 ) { color_index = 0 ; } else if ( color_index >= SIXEL_PALETTE_MAX ) { color_index = SIXEL_PALETTE_MAX - 1 ; } } if ( n > 4 ) { if ( param [ 1 ] == 1 ) { if ( param [ 2 ] > 360 ) param [ 2 ] = 360 ; if ( param [ 3 ] > 100 ) param [ 3 ] = 100 ; if ( param [ 4 ] > 100 ) param [ 4 ] = 100 ; sixel_palet [ color_index ] = hls_to_rgb ( param [ 2 ] * 100 / 360 , param [ 3 ] , param [ 4 ] ) ; } else if ( param [ 1 ] == 2 ) { if ( param [ 2 ] > 100 ) param [ 2 ] = 100 ; if ( param [ 3 ] > 100 ) param [ 3 ] = 100 ; if ( param [ 4 ] > 100 ) param [ 4 ] = 100 ; sixel_palet [ color_index ] = SIXEL_XRGB ( param [ 2 ] , param [ 3 ] , param [ 4 ] ) ; } } } else if ( * p == '$' ) { p ++ ; posision_x = 0 ; repeat_count = 1 ; } else if ( * p == '-' ) { p ++ ; posision_x = 0 ; posision_y += 6 ; repeat_count = 1 ; } else if ( * p >= '?' && * p <= '\\177' ) { if ( imsx < ( posision_x + repeat_count ) || imsy < ( posision_y + 6 ) ) { int nx = imsx * 2 ; int ny = imsy * 2 ; while ( nx < ( posision_x + repeat_count ) || ny < ( posision_y + 6 ) ) { nx *= 2 ; ny *= 2 ; } dmsx = nx ; dmsy = ny ; <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> if ( dmbuf == ( unsigned char * ) NULL ) { imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> for ( y = 0 ; y < imsy ; ++ y ) { <S2SV_StartBug> ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; <S2SV_EndBug> } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } if ( color_index > max_color_index ) { max_color_index = color_index ; } if ( ( b = * ( p ++ ) - '?' ) == 0 ) { posision_x += repeat_count ; } else { sixel_vertical_mask = 0x01 ; if ( repeat_count <= 1 ) { for ( i = 0 ; i < 6 ; i ++ ) { if ( ( b & sixel_vertical_mask ) != 0 ) { imbuf [ imsx * ( posision_y + i ) + posision_x ] = color_index ; if ( max_x < posision_x ) { max_x = posision_x ; } if ( max_y < ( posision_y + i ) ) { max_y = posision_y + i ; } } sixel_vertical_mask <<= 1 ; } posision_x += 1 ; } else { for ( i = 0 ; i < 6 ; i ++ ) { if ( ( b & sixel_vertical_mask ) != 0 ) { c = sixel_vertical_mask << 1 ; for ( n = 1 ; ( i + n ) < 6 ; n ++ ) { if ( ( b & c ) == 0 ) { break ; } c <<= 1 ; } for ( y = posision_y + i ; y < posision_y + i + n ; ++ y ) { <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <S2SV_EndBug> } if ( max_x < ( posision_x + repeat_count - 1 ) ) { max_x = posision_x + repeat_count - 1 ; } if ( max_y < ( posision_y + i + n - 1 ) ) { max_y = posision_y + i + n - 1 ; } i += ( n - 1 ) ; sixel_vertical_mask <<= ( n - 1 ) ; } sixel_vertical_mask <<= 1 ; } posision_x += repeat_count ; } } repeat_count = 1 ; } else { p ++ ; } } if ( ++ max_x < attributed_ph ) { max_x = attributed_ph ; } if ( ++ max_y < attributed_pv ) { max_y = attributed_pv ; } if ( imsx > max_x || imsy > max_y ) { dmsx = max_x ; dmsy = max_y ; <S2SV_StartBug> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <S2SV_EndBug> imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; return ( MagickFalse ) ; } for ( y = 0 ; y < dmsy ; ++ y ) { ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , dmsx ) ; } imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ; imsx = dmsx ; imsy = dmsy ; imbuf = dmbuf ; } * pixels = imbuf ; * pwidth = imsx ; * pheight = imsy ; * ncolors = max_color_index + 1 ; * palette = ( unsigned char * ) AcquireQuantumMemory ( * ncolors , 4 ) ; for ( n = 0 ; n < ( ssize_t ) * ncolors ; ++ n ) { ( * palette ) [ n * 4 + 0 ] = sixel_palet [ n ] >> 16 & 0xff ; ( * palette ) [ n * 4 + 1 ] = sixel_palet [ n ] >> 8 & 0xff ; ( * palette ) [ n * 4 + 2 ] = sixel_palet [ n ] & 0xff ; ( * palette ) [ n * 4 + 3 ] = 0xff ; } return ( MagickTrue ) ; }
","<S2SV_ModStart> AcquireQuantumMemory ( imsx , imsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> , imbuf + ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> , imbuf + ( size_t ) <S2SV_ModStart> ( imbuf + ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ) ==
",ImageMagick@ImageMagick/10b3823a7619ed22d42764733eb052c4159bc8c1,CVE-2016-10057,https://github.com/ImageMagick/ImageMagick/commit/10b3823a7619ed22d42764733eb052c4159bc8c1,2017-03-23T17:59Z,475,<S2SV_ModStart> NULL ; } if ( size_t ),0
1155,CWE-119,"CWE-119 static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_copy_reference_dec ( ctx -> pbi , <S2SV_EndBug> ( VP9_REFFRAME ) frame -> frame_type , & sd ) ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> YV12_BUFFER_CONFIG sd ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> return vp9_copy_reference_dec ( frame_worker_data <S2SV_ModEnd> -> pbi ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,476,"<S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args ) <S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args )",0
1159,CWE-20,"CWE-20 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { <S2SV_StartBug> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; <S2SV_EndBug> ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> -> ps_cur_slice -> <S2SV_ModEnd> u1_slice_type = P_SLICE
",external@libavc/cc676ebd95247646e67907ccab150fb77a847335,CVE-2016-3741,https://android.googlesource.com/platform/external/libavc/+/cc676ebd95247646e67907ccab150fb77a847335,2016-07-11T01:59Z,477,<S2SV_ModStart> ) { return ret <S2SV_ModEnd> ; } ps_dec ->,0
1160,CWE-119,"CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice ( dec_state_t * ps_dec ) { WORD16 * pi2_vld_out ; UWORD32 i ; yuv_buf_t * ps_cur_frm_buf = & ps_dec -> s_cur_frm_buf ; UWORD32 u4_frm_offset = 0 ; const dec_mb_params_t * ps_dec_mb_params ; IMPEG2D_ERROR_CODES_T e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; pi2_vld_out = ps_dec -> ai2_vld_buf ; memset ( ps_dec -> ai2_pred_mv , 0 , sizeof ( ps_dec -> ai2_pred_mv ) ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_first_mb = 1 ; ps_dec -> u2_picture_width = ps_dec -> u2_frame_width ; if ( ps_dec -> u2_picture_structure != FRAME_PICTURE ) { ps_dec -> u2_picture_width <<= 1 ; if ( ps_dec -> u2_picture_structure == BOTTOM_FIELD ) { u4_frm_offset = ps_dec -> u2_frame_width ; } } do { UWORD32 u4_x_offset , u4_y_offset ; <S2SV_StartBug> UWORD32 u4_x_dst_offset = 0 ; <S2SV_EndBug> UWORD32 u4_y_dst_offset = 0 ; UWORD8 * pu1_out_p ; UWORD8 * pu1_pred ; WORD32 u4_pred_strd ; IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; if ( ps_dec -> e_pic_type == B_PIC ) <S2SV_StartBug> impeg2d_dec_pnb_mb_params ( ps_dec ) ; <S2SV_EndBug> else <S2SV_StartBug> impeg2d_dec_p_mb_params ( ps_dec ) ; <S2SV_EndBug> IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; u4_x_dst_offset = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; u4_y_dst_offset = ( ps_dec -> u2_mb_y << 4 ) * ps_dec -> u2_picture_width ; pu1_out_p = ps_cur_frm_buf -> pu1_y + u4_x_dst_offset + u4_y_dst_offset ; if ( ps_dec -> u2_prev_intra_mb == 0 ) { UWORD32 offset_x , offset_y , stride ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; if ( ps_dec -> e_mb_pred == BIDIRECT ) { ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ index ] ; } else { ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; } stride = ps_dec -> u2_picture_width ; offset_x = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; offset_y = ( ps_dec -> u2_mb_y << 4 ) ; ps_dec -> s_dest_buf . pu1_y = ps_cur_frm_buf -> pu1_y + offset_y * stride + offset_x ; stride = stride >> 1 ; ps_dec -> s_dest_buf . pu1_u = ps_cur_frm_buf -> pu1_u + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; ps_dec -> s_dest_buf . pu1_v = ps_cur_frm_buf -> pu1_v + ( offset_y >> 1 ) * stride + ( offset_x >> 1 ) ; PROFILE_DISABLE_MC_IF0 ps_dec_mb_params -> pf_mc ( ps_dec ) ; } for ( i = 0 ; i < NUM_LUMA_BLKS ; ++ i ) { if ( ( ps_dec -> u2_cbp & ( 1 << ( BLOCKS_IN_MB - 1 - i ) ) ) != 0 ) { e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , Y_LUMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } u4_x_offset = gai2_impeg2_blk_x_off [ i ] ; if ( ps_dec -> u2_field_dct == 0 ) u4_y_offset = gai2_impeg2_blk_y_off_frm [ i ] ; else u4_y_offset = gai2_impeg2_blk_y_off_fld [ i ] ; IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset ; u4_pred_strd = ps_dec -> u2_picture_width << ps_dec -> u2_field_dct ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p + u4_y_offset * ps_dec -> u2_picture_width + u4_x_offset , 8 , u4_pred_strd , ps_dec -> u2_picture_width << ps_dec -> u2_field_dct , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } } u4_x_dst_offset >>= 1 ; u4_y_dst_offset >>= 2 ; if ( ( ps_dec -> u2_cbp & 0x02 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_u + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , U_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } if ( ( ps_dec -> u2_cbp & 0x01 ) != 0 ) { pu1_out_p = ps_cur_frm_buf -> pu1_v + u4_x_dst_offset + u4_y_dst_offset ; e_error = ps_dec -> pf_vld_inv_quant ( ps_dec , pi2_vld_out , ps_dec -> pu1_inv_scan_matrix , ps_dec -> u2_prev_intra_mb , V_CHROMA , 0 ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } IMPEG2D_IDCT_INP_STATISTICS ( pi2_vld_out , ps_dec -> u4_non_zero_cols , ps_dec -> u4_non_zero_rows ) ; PROFILE_DISABLE_IDCT_IF0 { WORD32 idx ; if ( 1 == ( ps_dec -> u4_non_zero_cols | ps_dec -> u4_non_zero_rows ) ) idx = 0 ; else idx = 1 ; if ( 0 == ps_dec -> u2_prev_intra_mb ) { pu1_pred = pu1_out_p ; u4_pred_strd = ps_dec -> u2_picture_width >> 1 ; } else { pu1_pred = ( UWORD8 * ) gau1_impeg2_zerobuf ; u4_pred_strd = 8 ; } ps_dec -> pf_idct_recon [ idx * 2 + ps_dec -> i4_last_value_one ] ( pi2_vld_out , ps_dec -> ai2_idct_stg1 , pu1_pred , pu1_out_p , 8 , u4_pred_strd , ps_dec -> u2_picture_width >> 1 , ~ ps_dec -> u4_non_zero_cols , ~ ps_dec -> u4_non_zero_rows ) ; } } ps_dec -> u2_num_mbs_left -- ; ps_dec -> u2_first_mb = 0 ; ps_dec -> u2_mb_x ++ ; if ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } else if ( ps_dec -> u2_mb_x == ps_dec -> u2_num_horiz_mb ) { ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y ++ ; } } while ( ps_dec -> u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , 23 ) != 0x0 ) ; return e_error ; }
","<S2SV_ModStart> , u4_y_offset ; WORD32 ret ; <S2SV_ModStart> == B_PIC ) ret = <S2SV_ModStart> ) ; else ret = <S2SV_ModStart> ( ps_dec ) ; if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR
",external@libmpeg2/58a6822d7140137ce957c6d2fc20bae1374186c1,CVE-2016-0835,https://android.googlesource.com/platform/external/libmpeg2/+/58a6822d7140137ce957c6d2fc20bae1374186c1,2016-04-18T00:59Z,478,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> 0 <S2SV_ModStart> = ps_dec -> u4_num_size ; ps_dec -> u2d_size = ps_dec -> u2_size ; ps_dec -> u2_num_mbs_size = ps_dec -> u2_frame_size ; ps_size = ps_size = ps_dec -> u2_frame_size ; ps_size = ps_dec -> u2_frame_size = ps_size ; ps_dec -> u2_size = ps_dec -> u2_mbs_size = ps_size ; ps_dec -> u2_size = ps_dec -> u2_mbs_size = ps_size ; ps_size = ps_dec -> u2_dec -> u2_mbs_size = ps_size ; ps_size = ps_dec -> u2_dec -> u2_size = ps_dec -> u2_size ; ps_dec -> u2_dec -> u2_frame_size = ps_size = ps_dec -> u2_size ; if ( ps_dec -> u2_,0
1161,CWE-119,"CWE-119 vpx_codec_err_t vp9_copy_reference_dec ( VP9Decoder * pbi , VP9_REFFRAME ref_frame_flag , YV12_BUFFER_CONFIG * sd ) { VP9_COMMON * cm = & pbi -> common ; if ( ref_frame_flag == VP9_LAST_FLAG ) { <S2SV_StartBug> const YV12_BUFFER_CONFIG * const cfg = <S2SV_EndBug> <S2SV_StartBug> & cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] . buf ; <S2SV_EndBug> if ( ! equal_dimensions ( cfg , sd ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions"" ) ; else vp8_yv12_copy_frame ( cfg , sd ) ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Invalid<S2SV_blank>reference<S2SV_blank>frame"" ) ; } return cm -> error . error_code ; }
","<S2SV_ModStart> const cfg = get_ref_frame ( cm , 0 ) ; if ( cfg == NULL ) { vpx_internal_error ( <S2SV_ModStart> & cm -> error , VPX_CODEC_ERROR , ""No<S2SV_blank>\'last\'<S2SV_blank>reference<S2SV_blank>frame"" ) ; return VPX_CODEC_ERROR ; } <S2SV_ModEnd> if ( !
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,479,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1162,CWE-190,"CWE-190 void jas_matrix_asr ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; assert ( n >= 0 ) ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = jas_seqent_asr ( * data , n ) ; } } } }
","<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,480,<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t,1
1163,CWE-119,"CWE-119 void vp9_foreach_transformed_block_in_plane ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , int plane , foreach_transformed_block_visitor visit , void * arg ) { const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; const MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) <S2SV_EndBug> : mbmi -> tx_size ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , pd ) ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ; const int step = 1 << ( tx_size << 1 ) ; <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) { <S2SV_EndBug> int r , c ; int max_blocks_wide = num_4x4_w ; int max_blocks_high = num_4x4_h ; if ( xd -> mb_to_right_edge < 0 ) max_blocks_wide += ( xd -> mb_to_right_edge >> ( 5 + pd -> subsampling_x ) ) ; <S2SV_StartBug> if ( xd -> mb_to_bottom_edge < 0 ) <S2SV_EndBug> max_blocks_high += ( xd -> mb_to_bottom_edge >> ( 5 + pd -> subsampling_y ) ) ; <S2SV_StartBug> i = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( r = 0 ; r < num_4x4_h ; r += ( 1 << tx_size ) ) { <S2SV_EndBug> for ( c = 0 ; c < num_4x4_w ; c += ( 1 << tx_size ) ) { <S2SV_StartBug> if ( r < max_blocks_high && c < max_blocks_wide ) <S2SV_EndBug> visit ( plane , i , plane_bsize , tx_size , arg ) ; i += step ; } <S2SV_StartBug> } <S2SV_EndBug> } else { for ( i = 0 ; i < num_4x4_w * num_4x4_h ; i += step ) visit ( plane , i , plane_bsize , tx_size , arg ) ; } }
","<S2SV_ModStart> get_uv_tx_size ( mbmi , pd <S2SV_ModStart> ; int i = 0 , r , c ; const int max_blocks_wide = num_4x4_w + <S2SV_ModEnd> ( xd -> <S2SV_ModStart> xd -> mb_to_right_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_right_edge <S2SV_ModStart> ) ) ; const int max_blocks_high = num_4x4_h + <S2SV_ModEnd> ( xd -> <S2SV_ModStart> xd -> mb_to_bottom_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_bottom_edge <S2SV_ModStart> ) ) ; const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> r < max_blocks_high <S2SV_ModStart> r < max_blocks_high ; r += ( 1 << tx_size ) ) { for ( c = 0 ; <S2SV_ModEnd> c < max_blocks_wide <S2SV_ModStart> c < max_blocks_wide ; c += ( 1 << tx_size ) ) { <S2SV_ModEnd> visit ( plane <S2SV_ModStart> step ; } i += extra_step <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,481,<S2SV_ModStart>,0
1165,CWE-119,"CWE-119 void vp8_copy_mem8x4_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 4 ; r ++ ) { <S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; # endif src += src_stride ; dst += dst_stride ; } }
","<S2SV_ModStart> ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,482,"<S2SV_ModStart> ++ ) { memcpy ( dst, src, 8 ) ; <S2SV_ModEnd> src += src_stride",1
1167,CWE-787,"CWE-787 static int gtStripSeparate ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileSeparateRoutine put = img -> put . separate ; unsigned char * buf = NULL ; unsigned char * p0 = NULL , * p1 = NULL , * p2 = NULL , * pa = NULL ; uint32 row , y , nrow , rowstoread ; tmsize_t pos ; tmsize_t scanline ; uint32 rowsperstrip , offset_row ; uint32 imagewidth = img -> width ; tmsize_t stripsize ; tmsize_t bufsize ; int32 fromskew , toskew ; int alpha = img -> alpha ; int ret = 1 , flip ; uint16 colorchannels ; stripsize = TIFFStripSize ( tif ) ; bufsize = _TIFFMultiplySSize ( tif , alpha ? 4 : 3 , stripsize , ""gtStripSeparate"" ) ; if ( bufsize == 0 ) { return ( 0 ) ; } flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } switch ( img -> photometric ) { case PHOTOMETRIC_MINISWHITE : case PHOTOMETRIC_MINISBLACK : case PHOTOMETRIC_PALETTE : colorchannels = 1 ; break ; default : colorchannels = 3 ; break ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) { <S2SV_StartBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; <S2SV_EndBug> nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; offset_row = row + img -> row_offset ; <S2SV_StartBug> if ( buf == NULL ) <S2SV_EndBug> { if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , ( void * * ) & buf , bufsize , <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && ( buf == NULL || img -> stoponerr ) ) { ret = 0 ; break ; } p0 = buf ; if ( colorchannels == 1 ) { p2 = p1 = p0 ; pa = ( alpha ? ( p0 + 3 * stripsize ) : NULL ) ; } else { p1 = p0 + stripsize ; p2 = p1 + stripsize ; pa = ( alpha ? ( p2 + stripsize ) : NULL ) ; } } else if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , <S2SV_StartBug> p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 1 ) , <S2SV_StartBug> p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 2 ) , <S2SV_StartBug> p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( alpha ) { if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , <S2SV_StartBug> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } } pos = ( ( row + img -> row_offset ) % rowsperstrip ) * scanline + ( ( tmsize_t ) img -> col_offset * img -> samplesperpixel ) ; ( * put ) ( img , raster + y * w , 0 , y , w , nrow , fromskew , toskew , p0 + pos , p1 + pos , p2 + pos , ( alpha ? ( pa + pos ) : NULL ) ) ; y += ( ( flip & FLIP_VERTICALLY ) ? - ( int32 ) nrow : ( int32 ) nrow ) ; } if ( flip & FLIP_HORIZONTALLY ) { uint32 line ; for ( line = 0 ; line < h ; line ++ ) { uint32 * left = raster + ( line * w ) ; uint32 * right = left + w - 1 ; while ( left < right ) { uint32 temp = * left ; * left = * right ; * right = temp ; left ++ ; right -- ; } } } _TIFFfree ( buf ) ; return ( ret ) ; }
","<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ; return 0 ; } <S2SV_ModStart> , bufsize , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p0 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p1 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p2 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , pa , temp <S2SV_ModEnd> * scanline )
",OSGeo@gdal/21674033ee246f698887604c7af7ba1962a40ddf,CVE-2019-17546,https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf,2019-10-14T02:15Z,483,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( y,0
1168,CWE-125,"CWE-125 static int num_stmts ( const node * n ) { int i , l ; node * ch ; switch ( TYPE ( n ) ) { case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) return 0 ; else return num_stmts ( CHILD ( n , 0 ) ) ; case file_input : l = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == stmt ) l += num_stmts ( ch ) ; } return l ; case stmt : return num_stmts ( CHILD ( n , 0 ) ) ; case compound_stmt : return 1 ; case simple_stmt : return NCH ( n ) / 2 ; case suite : if ( NCH ( n ) == 1 ) return num_stmts ( CHILD ( n , 0 ) ) ; else { i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 1 ) ; i ++ ) l += num_stmts ( CHILD ( n , i ) ) ; return l ; } default : { char buf [ 128 ] ; sprintf ( buf , ""Non-statement<S2SV_blank>found:<S2SV_blank>%d<S2SV_blank>%d"" , TYPE ( n ) , NCH ( n ) ) ; Py_FatalError ( buf ) ; } } <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ; } } abort ( ) <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,484,,0
1169,CWE-119,"CWE-119 static inline void header_put_be_short ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,485,<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr,0
1172,CWE-190,"CWE-190 int SWFInput_readSBits ( SWFInput input , int number ) { int num = SWFInput_readBits ( input , number ) ; <S2SV_StartBug> if ( num & ( 1 << ( number - 1 ) ) ) <S2SV_EndBug> return num - ( 1 << number ) ; else return num ; }
","<S2SV_ModStart> ; if ( number &&
",libming@libming/a009a38dce1d9316cad1ab522b813b1d5ba4c62a,CVE-2019-12980,https://github.com/libming/libming/commit/a009a38dce1d9316cad1ab522b813b1d5ba4c62a,2019-06-26T18:15Z,486,<S2SV_ModStart> ( num < 0 ) { if (,0
1173,CWE-119,"CWE-119 int vpx_img_read ( vpx_image_t * img , FILE * file ) { int plane ; for ( plane = 0 ; plane < 3 ; ++ plane ) { unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; <S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> const int h = vpx_img_plane_height ( img , plane ) ; int y ; for ( y = 0 ; y < h ; ++ y ) { <S2SV_StartBug> if ( fread ( buf , 1 , w , file ) != w ) <S2SV_EndBug> return 0 ; buf += stride ; } } return 1 ; }
","<S2SV_ModStart> , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) <S2SV_ModStart> file ) != ( size_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,487,<S2SV_ModStart> ( buf ) <S2SV_ModEnd> ; if (,0
1174,CWE-119,"CWE-119 static int decode_avp ( struct l2tp_avp_t * avp , const struct l2tp_attr_t * RV , const char * secret , size_t secret_len ) { MD5_CTX md5_ctx ; uint8_t md5 [ MD5_DIGEST_LENGTH ] ; uint8_t p1 [ MD5_DIGEST_LENGTH ] ; uint8_t * prev_block = NULL ; <S2SV_StartBug> uint16_t attr_len ; <S2SV_EndBug> uint16_t orig_attr_len ; uint16_t bytes_left ; uint16_t blocks_left ; uint16_t last_block_len ; <S2SV_StartBug> if ( avp -> length < sizeof ( struct l2tp_avp_t ) + 2 ) { <S2SV_EndBug> log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>hidden<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type<S2SV_blank>%hu):"" ""<S2SV_blank>length<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%hu<S2SV_blank>bytes)\\n"" , <S2SV_StartBug> ntohs ( avp -> type ) , avp -> length ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> attr_len = avp -> length - sizeof ( struct l2tp_avp_t ) ; <S2SV_EndBug> MD5_Init ( & md5_ctx ) ; MD5_Update ( & md5_ctx , & avp -> type , sizeof ( avp -> type ) ) ; MD5_Update ( & md5_ctx , secret , secret_len ) ; MD5_Update ( & md5_ctx , RV -> val . octets , RV -> length ) ; MD5_Final ( p1 , & md5_ctx ) ; if ( attr_len <= MD5_DIGEST_LENGTH ) { memxor ( avp -> val , p1 , attr_len ) ; return 0 ; } memxor ( p1 , avp -> val , MD5_DIGEST_LENGTH ) ; orig_attr_len = ntohs ( * ( uint16_t * ) p1 ) ; if ( orig_attr_len <= MD5_DIGEST_LENGTH - 2 ) { memcpy ( avp -> val , p1 , MD5_DIGEST_LENGTH ) ; return 0 ; } if ( orig_attr_len > attr_len - 2 ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>hidden<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type<S2SV_blank>%hu):"" ""<S2SV_blank>original<S2SV_blank>attribute<S2SV_blank>length<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(ciphered"" ""<S2SV_blank>attribute<S2SV_blank>length:<S2SV_blank>%hu<S2SV_blank>bytes,<S2SV_blank>advertised<S2SV_blank>original"" ""<S2SV_blank>attribute<S2SV_blank>length:<S2SV_blank>%hu<S2SV_blank>bytes)\\n"" , ntohs ( avp -> type ) , attr_len , orig_attr_len ) ; return - 1 ; } bytes_left = orig_attr_len + 2 - MD5_DIGEST_LENGTH ; last_block_len = bytes_left % MD5_DIGEST_LENGTH ; blocks_left = bytes_left / MD5_DIGEST_LENGTH ; if ( last_block_len ) { prev_block = avp -> val + blocks_left * MD5_DIGEST_LENGTH ; MD5_Init ( & md5_ctx ) ; MD5_Update ( & md5_ctx , secret , secret_len ) ; MD5_Update ( & md5_ctx , prev_block , MD5_DIGEST_LENGTH ) ; MD5_Final ( md5 , & md5_ctx ) ; memxor ( prev_block + MD5_DIGEST_LENGTH , md5 , last_block_len ) ; prev_block -= MD5_DIGEST_LENGTH ; } else prev_block = avp -> val + ( blocks_left - 1 ) * MD5_DIGEST_LENGTH ; while ( prev_block >= avp -> val ) { MD5_Init ( & md5_ctx ) ; MD5_Update ( & md5_ctx , secret , secret_len ) ; MD5_Update ( & md5_ctx , prev_block , MD5_DIGEST_LENGTH ) ; MD5_Final ( md5 , & md5_ctx ) ; memxor ( prev_block + MD5_DIGEST_LENGTH , md5 , MD5_DIGEST_LENGTH ) ; prev_block -= MD5_DIGEST_LENGTH ; } memcpy ( avp -> val , p1 , MD5_DIGEST_LENGTH ) ; return 0 ; }
","<S2SV_ModStart> NULL ; uint16_t avp_len ; uint16_t <S2SV_ModStart> uint16_t last_block_len ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len <S2SV_ModEnd> < sizeof ( <S2SV_ModStart> type ) , avp_len <S2SV_ModEnd> ) ; return <S2SV_ModStart> } attr_len = avp_len <S2SV_ModEnd> - sizeof (
",accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,CVE-2020-15173,https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,2020-09-09T23:15Z,488,<S2SV_ModStart> ; uint16_t data_t <S2SV_ModEnd> ; uint16_t,0
1176,CWE-125,"CWE-125 static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) { EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; switch ( type ) { case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( actx == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; return 0 ; } actx -> len . aad = 0 ; actx -> len . text = 0 ; actx -> aad = 0 ; actx -> mac_inited = 0 ; actx -> tag_len = 0 ; actx -> nonce_len = 12 ; actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; return 1 ; case EVP_CTRL_COPY : if ( actx ) { EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( dst -> cipher_data == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; return 0 ; } } return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ; actx -> nonce_len = arg ; return 1 ; case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ; actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ; if ( ptr != NULL ) { memcpy ( actx -> tag , ptr , arg ) ; actx -> tag_len = arg ; } return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ; memcpy ( ptr , actx -> tag , arg ) ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; { unsigned int len ; unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ; len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ; if ( ! ctx -> encrypt ) { <S2SV_StartBug> len -= POLY1305_BLOCK_SIZE ; <S2SV_EndBug> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ; aad = temp ; temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ; temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ; } actx -> tls_payload_length = len ; actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ; actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ; actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ; actx -> mac_inited = 0 ; chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ; return POLY1305_BLOCK_SIZE ; } case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ; default : return - 1 ; } }
","<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
",openssl@openssl/00d965474b22b54e4275232bc71ee0c699c5cd21,CVE-2017-3731,https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21,2017-05-04T19:29Z,489,<S2SV_ModStart> ; if ( (,0
1177,CWE-264,"CWE-264 struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
","<S2SV_ModStart> { request_module ( ""crypto-%s"" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( ""crypto-%s-all"" <S2SV_ModEnd> , name )
",torvalds@linux/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,CVE-2013-7421,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,2015-03-02T11:59Z,490,<S2SV_ModStart> ; if ( <S2SV_ModEnd>  name,0
1178,CWE-400,"CWE-400 static void perf_event_comm_output ( struct perf_event * event , struct perf_comm_event * comm_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = comm_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & comm_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <S2SV_StartBug> comm_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> if ( ret ) goto out ; comm_event -> event_id . pid = perf_event_pid ( event , comm_event -> task ) ; comm_event -> event_id . tid = perf_event_tid ( event , comm_event -> task ) ; perf_output_put ( & handle , comm_event -> event_id ) ; __output_copy ( & handle , comm_event -> comm , comm_event -> comm_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : comm_event -> event_id . header . size = size ; }
","<S2SV_ModStart> header . size <S2SV_ModEnd> , 0 )
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,491,"<S2SV_ModStart>, 0, <S2SV_ModEnd> size ) ;",0
1179,CWE-284,"CWE-284 void fslib_copy_libs ( const char * full_path ) { assert ( full_path ) ; if ( arg_debug || arg_debug_private_lib ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>fslib_copy_libs<S2SV_blank>%s\\n"" , full_path ) ; if ( access ( full_path , R_OK ) ) { if ( arg_debug || arg_debug_private_lib ) printf ( ""cannot<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>private-lib,<S2SV_blank>skipping...\\n"" , full_path ) ; return ; } unlink ( RUN_LIB_FILE ) ; create_empty_file_as_root ( RUN_LIB_FILE , 0644 ) ; if ( chown ( RUN_LIB_FILE , getuid ( ) , getgid ( ) ) ) errExit ( ""chown"" ) ; if ( arg_debug || arg_debug_private_lib ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>running<S2SV_blank>fldd<S2SV_blank>%s\\n"" , full_path ) ; sbox_run ( SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE , 3 , PATH_FLDD , full_path , RUN_LIB_FILE ) ; FILE * fp = fopen ( RUN_LIB_FILE , ""r"" ) ; if ( ! fp ) errExit ( ""fopen"" ) ; char buf [ MAXBUF ] ; while ( fgets ( buf , MAXBUF , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; fslib_duplicate ( buf ) ; } fclose ( fp ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> fp ) ; unlink ( RUN_LIB_FILE ) ;
",netblue30@firejail/eecf35c2f8249489a1d3e512bb07f0d427183134,CVE-2019-12589,https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134,2019-06-03T03:29Z,492,<S2SV_ModStart> fp ) ; unlink ( RUN_LIB_FILE ) ;,1
1181,CWE-200,"CWE-200 static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> sa -> rc_family = AF_BLUETOOTH ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }
","<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z,493,"<S2SV_ModStart>, sa, sizeof ( sa )",0
1182,CWE-119,"CWE-119 static int handle_packet ( unsigned char * data , int data_len ) { struct mt_mactelnet_hdr pkthdr ; if ( data_len < MT_HEADER_LEN ) { return - 1 ; } parse_packet ( data , & pkthdr ) ; if ( pkthdr . seskey != sessionkey ) { return - 1 ; } if ( pkthdr . ptype == MT_PTYPE_DATA ) { struct mt_packet odata ; struct mt_mactelnet_control_hdr cpkt ; int success = 0 ; init_packet ( & odata , MT_PTYPE_ACK , srcmac , dstmac , sessionkey , pkthdr . counter + ( data_len - MT_HEADER_LEN ) ) ; send_udp ( & odata , 0 ) ; if ( pkthdr . counter > incounter || ( incounter - pkthdr . counter ) > 65535 ) { incounter = pkthdr . counter ; } else { return - 1 ; } success = parse_control_packet ( data + MT_HEADER_LEN , data_len - MT_HEADER_LEN , & cpkt ) ; while ( success ) { if ( cpkt . cptype == MT_CPTYPE_PASSSALT ) { <S2SV_StartBug> memcpy ( pass_salt , cpkt . data , cpkt . length ) ; <S2SV_EndBug> send_auth ( username , password ) ; } else if ( cpkt . cptype == MT_CPTYPE_PLAINDATA ) { fwrite ( ( const void * ) cpkt . data , 1 , cpkt . length , stdout ) ; } else if ( cpkt . cptype == MT_CPTYPE_END_AUTH ) { terminal_mode = 1 ; if ( is_a_tty ) { raw_term ( ) ; setvbuf ( stdin , ( char * ) NULL , _IONBF , 0 ) ; signal ( SIGWINCH , sig_winch ) ; } } success = parse_control_packet ( NULL , 0 , & cpkt ) ; } } else if ( pkthdr . ptype == MT_PTYPE_ACK ) { } else if ( pkthdr . ptype == MT_PTYPE_END ) { struct mt_packet odata ; init_packet ( & odata , MT_PTYPE_END , srcmac , dstmac , pkthdr . seskey , 0 ) ; send_udp ( & odata , 0 ) ; if ( ! quiet_mode ) { fprintf ( stderr , _ ( ""Connection<S2SV_blank>closed.\\n"" ) ) ; } running = 0 ; } else { fprintf ( stderr , _ ( ""Unhandeled<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n"" ) , pkthdr . ptype , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; return - 1 ; } return pkthdr . ptype ; }
","<S2SV_ModStart> MT_CPTYPE_PASSSALT ) { if ( cpkt . length != 16 ) { fprintf ( stderr , _ ( ""Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n"" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; } <S2SV_ModStart> . data , 16 <S2SV_ModEnd> ) ; send_auth
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z,494,"<S2SV_ModStart>, cpkt. size <S2SV_ModEnd> ) ; if",0
1184,CWE-522,"CWE-522 int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) { <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } # endif } else if ( mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>PREAUTH"" ) ) { # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> err_close_conn : imap_close_connection ( adata ) ; <S2SV_StartBug> # endif <S2SV_EndBug> bail : FREE ( & adata -> capstr ) ; return - 1 ; }
","<S2SV_ModStart> ) { goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> return 0 ; bail <S2SV_ModEnd> : imap_close_connection ( <S2SV_ModStart> adata ) ; <S2SV_ModEnd> FREE ( &
",neomutt@neomutt/9c36717a3e2af1f2c1b7242035455ec8112b4b06,CVE-2020-28896,https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06,2020-11-23T19:15Z,495,"<S2SV_ModStart>,",0
1185,CWE-200,"CWE-200 static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; <S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z,496,<S2SV_ModStart> crypto_kfree ; strncpy <S2SV_ModEnd> ( skb.,0
1188,CWE-787,"CWE-787 void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = AF_INET ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } FD_ZERO ( & read_fd ) ; FD_SET ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , NULL , NULL , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?WATCH={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } while ( G . do_exit == 0 ) { usleep ( 500000 ) ; memset ( G . gps_loc , 0 , sizeof ( float ) * 5 ) ; if ( is_json ) { if ( pos == sizeof ( line ) ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } <S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug> return ; temp = strstr ( line , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { continue ; } if ( strchr ( temp , '}' ) == NULL ) { pos = strlen ( temp ) ; if ( temp != line ) { memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } temp = strstr ( temp , ""\\""lat\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 0 ] ) ; temp = strstr ( temp , ""\\""lon\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 1 ] ) ; temp = strstr ( temp , ""\\""alt\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 4 ] ) ; temp = strstr ( temp , ""\\""speed\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 2 ] ) ; temp = strstr ( temp , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } else { pos = strlen ( temp ) ; memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } else { memset ( line , 0 , sizeof ( line ) ) ; snprintf ( line , sizeof ( line ) - 1 , ""PVTAD\\r\\n"" ) ; if ( send ( gpsd_sock , line , 7 , 0 ) != 7 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( memcmp ( line , ""GPSD,P="" , 7 ) != 0 ) continue ; if ( line [ 7 ] == '?' ) continue ; ret = sscanf ( line + 7 , ""%f<S2SV_blank>%f"" , & G . gps_loc [ 0 ] , & G . gps_loc [ 1 ] ) ; if ( ( temp = strstr ( line , ""V="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 2 ] ) ; if ( ( temp = strstr ( line , ""T="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 3 ] ) ; if ( ( temp = strstr ( line , ""A="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 4 ] ) ; } if ( G . record_data ) fputs ( line , G . f_gps ) ; G . save_gps = 1 ; if ( G . do_exit == 0 ) { unused = write ( G . gc_pipe [ 1 ] , G . gps_loc , sizeof ( float ) * 5 ) ; kill ( getppid ( ) , SIGUSR2 ) ; } } }
","<S2SV_ModStart> line ) - pos -
",aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z,497,,0
1189,CWE-674,"CWE-674 krb5_error_code k5_asn1_full_decode ( const krb5_data * code , const struct atype_info * a , void * * retrep ) { krb5_error_code ret ; const uint8_t * contents , * remainder ; size_t clen , rlen ; taginfo t ; * retrep = NULL ; ret = get_tag ( ( uint8_t * ) code -> data , code -> length , & t , & contents , <S2SV_StartBug> & clen , & remainder , & rlen ) ; <S2SV_EndBug> if ( ret ) return ret ; if ( ! check_atype_tag ( a , & t ) ) return ASN1_BAD_ID ; return decode_atype_to_ptr ( & t , contents , clen , a , retrep ) ; }
","<S2SV_ModStart> , & rlen , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z,498,"<S2SV_ModStart>, & rlen, 0",1
1190,CWE-119,"CWE-119 static void user_login ( struct mt_connection * curconn , struct mt_mactelnet_hdr * pkthdr ) { struct mt_packet pdata ; unsigned char md5sum [ 17 ] ; char md5data [ 100 ] ; struct mt_credentials * user ; char * slavename ; <S2SV_StartBug> read_userfile ( ) ; <S2SV_EndBug> if ( ( user = find_user ( curconn -> username ) ) != NULL ) { md5_state_t state ; # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5sum ) ) ; if ( user -> password != NULL ) { mlock ( user -> password , strlen ( user -> password ) ) ; } # endif <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , user -> password , 82 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( user -> password ) , curconn -> pass_salt , 16 ) ; <S2SV_EndBug> md5_init ( & state ) ; <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( user -> password ) + 17 ) ; <S2SV_EndBug> md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & pdata , MT_PTYPE_DATA , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; curconn -> outcounter += add_control_packet ( & pdata , MT_CPTYPE_END_AUTH , NULL , 0 ) ; send_udp ( curconn , & pdata ) ; if ( curconn -> state == STATE_ACTIVE ) { return ; } } if ( user == NULL || memcmp ( md5sum , curconn -> trypassword , 17 ) != 0 ) { syslog ( LOG_NOTICE , _ ( ""(%d)<S2SV_blank>Invalid<S2SV_blank>login<S2SV_blank>by<S2SV_blank>%s."" ) , curconn -> seskey , curconn -> username ) ; abort_connection ( curconn , pkthdr , _ ( ""Login<S2SV_blank>failed,<S2SV_blank>incorrect<S2SV_blank>username<S2SV_blank>or<S2SV_blank>password\\r\\n"" ) ) ; return ; } curconn -> state = STATE_ACTIVE ; curconn -> terminal_mode = 1 ; curconn -> ptsfd = posix_openpt ( O_RDWR ) ; if ( curconn -> ptsfd == - 1 || grantpt ( curconn -> ptsfd ) == - 1 || unlockpt ( curconn -> ptsfd ) == - 1 ) { syslog ( LOG_ERR , ""posix_openpt:<S2SV_blank>%s"" , strerror ( errno ) ) ; abort_connection ( curconn , pkthdr , _ ( ""Terminal<S2SV_blank>error\\r\\n"" ) ) ; return ; } slavename = ptsname ( curconn -> ptsfd ) ; if ( slavename != NULL ) { pid_t pid ; struct stat sb ; struct passwd * user = ( struct passwd * ) malloc ( sizeof ( struct passwd ) ) ; struct passwd * tmpuser = user ; char * buffer = malloc ( 1024 ) ; if ( user == NULL || buffer == NULL ) { syslog ( LOG_CRIT , _ ( ""(%d)<S2SV_blank>Error<S2SV_blank>allocating<S2SV_blank>memory."" ) , curconn -> seskey ) ; abort_connection ( curconn , pkthdr , _ ( ""System<S2SV_blank>error,<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\r\\n"" ) ) ; return ; } if ( getpwnam_r ( curconn -> username , user , buffer , 1024 , & tmpuser ) != 0 ) { syslog ( LOG_WARNING , _ ( ""(%d)<S2SV_blank>Login<S2SV_blank>ok,<S2SV_blank>but<S2SV_blank>local<S2SV_blank>user<S2SV_blank>not<S2SV_blank>accessible<S2SV_blank>(%s)."" ) , curconn -> seskey , curconn -> username ) ; abort_connection ( curconn , pkthdr , _ ( ""Local<S2SV_blank>user<S2SV_blank>not<S2SV_blank>accessible\\r\\n"" ) ) ; free ( user ) ; free ( buffer ) ; return ; } chown ( slavename , user -> pw_uid , user -> pw_gid ) ; curconn -> slavefd = open ( slavename , O_RDWR ) ; if ( curconn -> slavefd == - 1 ) { syslog ( LOG_ERR , _ ( ""Error<S2SV_blank>opening<S2SV_blank>%s:<S2SV_blank>%s"" ) , slavename , strerror ( errno ) ) ; abort_connection ( curconn , pkthdr , _ ( ""Error<S2SV_blank>opening<S2SV_blank>terminal\\r\\n"" ) ) ; list_remove_connection ( curconn ) ; return ; } if ( ( pid = fork ( ) ) == 0 ) { struct net_interface * interface ; uwtmp_login ( curconn ) ; syslog ( LOG_INFO , _ ( ""(%d)<S2SV_blank>User<S2SV_blank>%s<S2SV_blank>logged<S2SV_blank>in."" ) , curconn -> seskey , curconn -> username ) ; setenv ( ""USER"" , user -> pw_name , 1 ) ; setenv ( ""HOME"" , user -> pw_dir , 1 ) ; setenv ( ""SHELL"" , user -> pw_shell , 1 ) ; setenv ( ""TERM"" , curconn -> terminal_type , 1 ) ; close ( sockfd ) ; close ( insockfd ) ; DL_FOREACH ( interfaces , interface ) { if ( interface -> socketfd > 0 ) { close ( interface -> socketfd ) ; } } setsid ( ) ; fcntl ( curconn -> slavefd , F_SETFD , FD_CLOEXEC ) ; close ( curconn -> ptsfd ) ; close ( 0 ) ; dup ( curconn -> slavefd ) ; close ( 1 ) ; dup ( curconn -> slavefd ) ; close ( 2 ) ; dup ( curconn -> slavefd ) ; ioctl ( 0 , TIOCSCTTY , 1 ) ; tcsetpgrp ( 0 , getpid ( ) ) ; if ( ( setgid ( user -> pw_gid ) != 0 ) || ( setuid ( user -> pw_uid ) != 0 ) ) { syslog ( LOG_ERR , _ ( ""(%d)<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>log<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d:%d):<S2SV_blank>setuid/setgid:<S2SV_blank>%s"" ) , curconn -> seskey , curconn -> username , user -> pw_uid , user -> pw_gid , strerror ( errno ) ) ; abort_connection ( curconn , pkthdr , _ ( ""Internal<S2SV_blank>error\\r\\n"" ) ) ; exit ( 0 ) ; } if ( stat ( _PATH_NOLOGIN , & sb ) == 0 && getuid ( ) != 0 ) { syslog ( LOG_NOTICE , _ ( ""(%d)<S2SV_blank>User<S2SV_blank>%s<S2SV_blank>disconnected<S2SV_blank>with<S2SV_blank>"" _PATH_NOLOGIN ""<S2SV_blank>message."" ) , curconn -> seskey , curconn -> username ) ; display_nologin ( ) ; curconn -> state = STATE_CLOSED ; init_packet ( & pdata , MT_PTYPE_END , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; send_udp ( curconn , & pdata ) ; exit ( 0 ) ; } display_motd ( ) ; chdir ( user -> pw_dir ) ; execl ( user -> pw_shell , user -> pw_shell , ""-"" , ( char * ) 0 ) ; exit ( 0 ) ; } free ( user ) ; free ( buffer ) ; close ( curconn -> slavefd ) ; curconn -> pid = pid ; set_terminal_size ( curconn -> ptsfd , curconn -> terminal_width , curconn -> terminal_height ) ; } }
","<S2SV_ModStart> * slavename ; int act_pass_len ; <S2SV_ModStart> } # endif act_pass_len = strlen ( user -> password ) ; act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ; <S2SV_ModStart> = 0 ; memcpy <S2SV_ModEnd> ( md5data + <S2SV_ModStart> -> password , act_pass_len <S2SV_ModEnd> ) ; memcpy <S2SV_ModStart> + 1 + act_pass_len <S2SV_ModEnd> , curconn -> <S2SV_ModStart> ) md5data , 1 + act_pass_len + 16 <S2SV_ModEnd> ) ; md5_finish
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z,499,<S2SV_ModStart> ) ) { size_t <S2SV_ModEnd> data ; size <S2SV_ModStart> ) ; size = sizeof ( unsigned <S2SV_ModStart> ) + 2 <S2SV_ModEnd> ) ; if,0
1192,CWE-125,"CWE-125 static int forbidden_name ( struct compiling * c , identifier name , const node * n , int full_checks ) { assert ( PyUnicode_Check ( name ) ) ; <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 ) { <S2SV_EndBug> ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ; return 1 ; } if ( full_checks ) { const char * const * p ; for ( p = FORBIDDEN ; * p ; p ++ ) { <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , * p ) == 0 ) { <S2SV_EndBug> ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ; return 1 ; } } } return 0 ; }
","<S2SV_ModStart> ; if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> , ""__debug__"" ) <S2SV_ModEnd> ) { ast_error <S2SV_ModStart> { if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> * p ) <S2SV_ModEnd> ) { ast_error
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,500,<S2SV_ModStart> ; if ( c == NULL ) return 0 ; if (,0
1197,CWE-125,"CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
","<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
",devnexen@radare2/88a8adf080a9f8ed5a4250a2507752e133ba54dd,CVE-2018-20459,https://github.com/devnexen/radare2/commit/88a8adf080a9f8ed5a4250a2507752e133ba54dd,2018-12-25T19:29Z,501,,0
1198,CWE-190,"CWE-190 int pnm_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ; if ( ( n = jas_stream_read ( in , buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == 'P' && isdigit ( buf [ 1 ] ) ) { return 0 ; } return - 1 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ 2
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,502,<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ 2,1
1201,CWE-476,"CWE-476 BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , ""Authentication<S2SV_blank>failure,<S2SV_blank>check<S2SV_blank>credentials.\\n"" ""If<S2SV_blank>credentials<S2SV_blank>are<S2SV_blank>valid,<S2SV_blank>the<S2SV_blank>NTLMSSP<S2SV_blank>implementation<S2SV_blank>may<S2SV_blank>be<S2SV_blank>to<S2SV_blank>blame.\\n"" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } credssp_free ( transport -> credssp ) ; return TRUE ; }
","<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
",FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z,503,<S2SV_ModStart> credssp ) ; credssp = NULL ;,0
1206,CWE-310,"CWE-310 static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , ""13"" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , ""salt<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>8-octet<S2SV_blank>string"" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; <S2SV_StartBug> return Qnil ; <S2SV_EndBug> }
","<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z,504,<S2SV_ModStart> NULL ) ; if ( key_len == NULL ) return NULL ;,0
1210,CWE-200,"CWE-200 static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ; <S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> struct sshkey * key = NULL ; <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>scheme"" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( ""refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key"" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes"" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( ""%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> } xasprintf ( & userstyle , ""%s%s%s"" , authctxt -> user , authctxt -> style ? "":"" : """" , authctxt -> style ? authctxt -> style : """" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""publickey"" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ; <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( ""%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) <S2SV_StartBug> fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( ""%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing"" , __func__ ) ; authenticated = 0 ; } debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s"" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ; <S2SV_StartBug> return authenticated ; <S2SV_EndBug> }
","<S2SV_ModStart> sshbuf * b = NULL <S2SV_ModStart> char * pkalg = NULL <S2SV_ModStart> u_char * pkblob = NULL <S2SV_ModStart> , * sig = NULL <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> r ) ) ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done <S2SV_ModStart> b ) ; <S2SV_ModEnd> auth2_record_key ( authctxt <S2SV_ModStart> ) ) ; if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } <S2SV_ModStart> ca_s ) ; free ( sig ) ;
",openbsd@src/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,CVE-2018-15473,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,2018-08-17T19:29Z,505,"<S2SV_ModStart> * authctxt ; <S2SV_ModEnd> char * authctxt <S2SV_ModStart> char * authctxt = NULL <S2SV_ModStart> char * authctxt ; if (! authctxt -> user == NULL ) { debug2 ( ""%s: <S2SV_blank> user"", __func__ ) ; goto done",0
1211,CWE-908,"CWE-908 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> ; uint32_t bcount ; CLEAR ( WaveHeader )
",dbry@WavPack/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,CVE-2019-1010319,https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,2019-07-11T20:15Z,506,<S2SV_ModStart> ; uint32_t bcount = 0,0
1215,CWE-416,"CWE-416 static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ;
",libexif@libexif/ec412aa4583ad71ecabb967d3c77162760169d1f,CVE-2020-13113,https://github.com/libexif/libexif/commit/ec412aa4583ad71ecabb967d3c77162760169d1f,2020-05-21T17:15Z,507,,0
1217,CWE-20,"CWE-20 static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
","<S2SV_ModStart> bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,508,<S2SV_ModStart> ( dp_addr ) < 0,0
1223,CWE-189,"CWE-189 Datum txid_snapshot_recv ( PG_FUNCTION_ARGS ) { StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; TxidSnapshot * snap ; txid last = 0 ; int nxip ; int i ; <S2SV_StartBug> int avail ; <S2SV_EndBug> int expect ; txid xmin , xmax ; nxip = pq_getmsgint ( buf , 4 ) ; <S2SV_StartBug> avail = buf -> len - buf -> cursor ; <S2SV_EndBug> expect = 8 + 8 + nxip * 8 ; <S2SV_StartBug> if ( nxip < 0 || nxip > avail || expect > avail ) <S2SV_EndBug> goto bad_format ; xmin = pq_getmsgint64 ( buf ) ; xmax = pq_getmsgint64 ( buf ) ; if ( xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID ) goto bad_format ; snap = palloc ( TXID_SNAPSHOT_SIZE ( nxip ) ) ; snap -> xmin = xmin ; snap -> xmax = xmax ; snap -> nxip = nxip ; SET_VARSIZE ( snap , TXID_SNAPSHOT_SIZE ( nxip ) ) ; for ( i = 0 ; i < nxip ; i ++ ) { txid cur = pq_getmsgint64 ( buf ) ; if ( cur <= last || cur < xmin || cur >= xmax ) goto bad_format ; snap -> xip [ i ] = cur ; last = cur ; } PG_RETURN_POINTER ( snap ) ; bad_format : elog ( ERROR , ""invalid<S2SV_blank>snapshot<S2SV_blank>data"" ) ; return ( Datum ) NULL ; }
","<S2SV_ModStart> int i ; <S2SV_ModEnd> txid xmin , <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> if ( nxip <S2SV_ModStart> || nxip > TXID_SNAPSHOT_MAX_NXIP <S2SV_ModEnd> ) goto bad_format
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z,509,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1224,CWE-119,"CWE-119 static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,510,<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr,0
1225,CWE-399,"CWE-399 static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ) ; <S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ret = - EADDRNOTAVAIL ; rdsdebug ( ""addr<S2SV_blank>%pI4<S2SV_blank>ret<S2SV_blank>%d<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d\\n"" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }
","<S2SV_ModStart> ( ret || ! cm_id -> device ||
",torvalds@linux/c2349758acf1874e4c2b93fe41d072336f1a31d0,CVE-2013-7339,https://github.com/torvalds/linux/commit/c2349758acf1874e4c2b93fe41d072336f1a31d0,2014-03-24T16:40Z,511,<S2SV_ModStart> ; ret = - EINVAL ;,0
1227,CWE-552,"CWE-552 static ssize_t _epoll_write ( oe_fd_t * epoll_ , const void * buf , size_t count ) { ssize_t ret = - 1 ; <S2SV_StartBug> epoll_t * epoll = _cast_epoll ( epoll_ ) ; <S2SV_EndBug> oe_errno = 0 ; <S2SV_StartBug> if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> ; epoll_t * file <S2SV_ModEnd> = _cast_epoll ( <S2SV_ModStart> ; if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( <S2SV_ModStart> & ret , file <S2SV_ModEnd> -> host_fd , <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,512,<S2SV_ModStart> (! ret || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) { ret = - 1 ; },0
1229,CWE-295,"CWE-295 NOEXPORT int init_section ( int eof , SERVICE_OPTIONS * * section_ptr ) { char * errstr ; # ifndef USE_WIN32 ( * section_ptr ) -> option . log_stderr = new_global_options . option . log_stderr ; # endif if ( * section_ptr == & new_service_options ) { <S2SV_StartBug> errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ; <S2SV_EndBug> if ( errstr ) { s_log ( LOG_ERR , ""Global<S2SV_blank>options:<S2SV_blank>%s"" , errstr ) ; return 1 ; } } if ( * section_ptr != & new_service_options || eof ) { <S2SV_StartBug> if ( * section_ptr == & new_service_options ) <S2SV_EndBug> s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , ( * section_ptr ) -> servname ) ; errstr = parse_service_option ( CMD_INITIALIZE , section_ptr , NULL , NULL ) ; if ( errstr ) { if ( * section_ptr == & new_service_options ) s_log ( LOG_ERR , ""Inetd<S2SV_blank>mode:<S2SV_blank>%s"" , errstr ) ; else s_log ( LOG_ERR , ""Service<S2SV_blank>[%s]:<S2SV_blank>%s"" , ( * section_ptr ) -> servname , errstr ) ; return 1 ; } } return 0 ; }
","<S2SV_ModStart> ( CMD_INITIALIZE , & new_global_options , <S2SV_ModStart> eof ) { <S2SV_ModEnd> errstr = parse_service_option
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,513,<S2SV_ModStart> ; if ( * section == NULL || * section == NULL ) if (,0
1232,CWE-787,"CWE-787 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; <S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
","<S2SV_ModStart> = act_code ; if ( npix > 0 ) <S2SV_ModStart> = casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - stackp <S2SV_ModStart> - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= (
",miniupnp@ngiflib/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,CVE-2018-10717,https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,2018-05-03T17:29Z,514,,0
1233,CWE-399,"CWE-399 public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_NAME_MAX : * ( size_t * ) val = ms -> name_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }
","<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ;
",file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4,CVE-2014-9620,https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4,2015-01-21T18:59Z,515,,0
1237,CWE-000,"CWE-000 static void ext4_invalidatepage ( struct page * page , unsigned long offset ) { <S2SV_StartBug> journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; <S2SV_EndBug> if ( offset == 0 ) ClearPageChecked ( page ) ; if ( journal ) jbd2_journal_invalidatepage ( journal , page , offset ) ; else block_invalidatepage ( page , offset ) ; }
","<S2SV_ModStart> mapping -> host ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,516,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1238,CWE-476,"CWE-476 GF_Err SetupWriters ( MovieWriter * mw , GF_List * writers , u8 interleaving ) { u32 i , trackCount ; TrackWriter * writer ; GF_TrackBox * trak ; GF_ISOFile * movie = mw -> movie ; mw -> total_samples = mw -> nb_done = 0 ; if ( ! movie -> moov ) return GF_OK ; trackCount = gf_list_count ( movie -> moov -> trackList ) ; for ( i = 0 ; i < trackCount ; i ++ ) { <S2SV_StartBug> trak = gf_isom_get_track ( movie -> moov , i + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> GF_SAFEALLOC ( writer , TrackWriter ) ; <S2SV_EndBug> if ( ! writer ) goto exit ; writer -> sampleNumber = 1 ; writer -> mdia = trak -> Media ; writer -> stbl = trak -> Media -> information -> sampleTable ; writer -> timeScale = trak -> Media -> mediaHeader -> timeScale ; writer -> all_dref_mode = Media_SelfContainedType ( writer -> mdia ) ; if ( trak -> sample_encryption ) writer -> prevent_dispatch = GF_TRUE ; writer -> isDone = 0 ; writer -> DTSprev = 0 ; writer -> chunkDur = 0 ; writer -> chunkSize = 0 ; writer -> constant_size = writer -> constant_dur = 0 ; if ( writer -> stbl -> SampleSize -> sampleSize ) writer -> constant_size = writer -> stbl -> SampleSize -> sampleSize ; if ( writer -> stbl -> TimeToSample -> nb_entries == 1 ) { writer -> constant_dur = writer -> stbl -> TimeToSample -> entries [ 0 ] . sampleDelta ; if ( writer -> constant_dur > 1 ) writer -> constant_dur = 0 ; } if ( ! writer -> constant_dur || ! writer -> constant_size || ( writer -> constant_size >= 10 ) ) writer -> constant_size = writer -> constant_dur = 0 ; writer -> stsc = ( GF_SampleToChunkBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_STSC ) ; if ( ! writer -> stsc ) return GF_OUT_OF_MEM ; if ( writer -> stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_STCO ) ; } else { writer -> stco = gf_isom_box_new ( GF_ISOM_BOX_TYPE_CO64 ) ; } if ( ! writer -> stco ) return GF_OUT_OF_MEM ; if ( interleaving ) writer -> stbl -> MaxSamplePerChunk = 0 ; if ( Media_IsSelfContained ( writer -> mdia , 1 ) ) mw -> total_samples += writer -> stbl -> SampleSize -> sampleCount ; if ( movie -> storageMode != GF_ISOM_STORE_INTERLEAVED ) { gf_list_add ( writers , writer ) ; } else { if ( writer -> mdia -> information -> InfoHeader && writer -> mdia -> information -> InfoHeader -> type == GF_ISOM_BOX_TYPE_SMHD ) { gf_list_add ( writers , writer ) ; } else { gf_list_insert ( writers , writer , 0 ) ; } } if ( movie -> sample_groups_in_traf && trak -> Media -> information -> sampleTable ) { gf_isom_box_array_del_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; trak -> Media -> information -> sampleTable -> sampleGroupsDescription = NULL ; } } return GF_OK ; exit : CleanWriters ( writers ) ; return GF_OUT_OF_MEM ; }
","<S2SV_ModStart> ++ ) { GF_SampleTableBox * stbl ; <S2SV_ModStart> 1 ) ; stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ; if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) { return GF_ISOM_INVALID_FILE ; }
",gpac@gpac/dae9900580a8888969481cd72035408091edb11b,CVE-2020-35981,https://github.com/gpac/gpac/commit/dae9900580a8888969481cd72035408091edb11b,2021-04-21T16:15Z,517,,0
1240,CWE-119,"CWE-119 static void send_auth ( char * username , char * password ) { struct mt_packet data ; unsigned short width = 0 ; unsigned short height = 0 ; char * terminal = getenv ( ""TERM"" ) ; char md5data [ 100 ] ; unsigned char md5sum [ 17 ] ; <S2SV_StartBug> int plen ; <S2SV_EndBug> md5_state_t state ; # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5data ) ) ; # endif <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , password , 82 ) ; <S2SV_EndBug> md5data [ 83 ] = '\\0' ; <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ; <S2SV_EndBug> md5_init ( & state ) ; <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ; <S2SV_EndBug> md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & data , MT_PTYPE_DATA , srcmac , dstmac , sessionkey , outcounter ) ; plen = add_control_packet ( & data , MT_CPTYPE_PASSWORD , md5sum , 17 ) ; plen += add_control_packet ( & data , MT_CPTYPE_USERNAME , username , strlen ( username ) ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_TYPE , terminal , strlen ( terminal ) ) ; if ( is_a_tty && get_terminal_size ( & width , & height ) != - 1 ) { width = htole16 ( width ) ; height = htole16 ( height ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_WIDTH , & width , 2 ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_HEIGHT , & height , 2 ) ; } outcounter += plen ; send_udp ( & data , 1 ) ; }
","<S2SV_ModStart> ; int plen , act_pass_len <S2SV_ModStart> ; # endif act_pass_len = strnlen ( password , 82 ) ; <S2SV_ModStart> = 0 ; memcpy <S2SV_ModEnd> ( md5data + <S2SV_ModStart> , password , act_pass_len ) <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> + 1 + act_pass_len <S2SV_ModEnd> , pass_salt , <S2SV_ModStart> ) md5data , 1 + act_pass_len + 16 <S2SV_ModEnd> ) ; md5_finish
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z,518,<S2SV_ModStart> ) ) { <S2SV_ModEnd> char * data <S2SV_ModStart> = malloc ( size_t ) <S2SV_ModEnd> ; memset (,0
1242,CWE-59,"CWE-59 void shutdown_mib ( void ) { unload_all_mibs ( ) ; if ( tree_top ) { if ( tree_top -> label ) SNMP_FREE ( tree_top -> label ) ; SNMP_FREE ( tree_top ) ; } tree_head = NULL ; Mib = NULL ; <S2SV_StartBug> if ( _mibindexes ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < _mibindex ; ++ i ) SNMP_FREE ( _mibindexes [ i ] ) ; free ( _mibindexes ) ; _mibindex = 0 ; _mibindex_max = 0 ; _mibindexes = NULL ; } if ( Prefix != NULL && Prefix != & Standard_Prefix [ 0 ] ) SNMP_FREE ( Prefix ) ; if ( Prefix ) Prefix = NULL ; SNMP_FREE ( confmibs ) ; SNMP_FREE ( confmibdir ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> Prefix != NULL
",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z,519,,0
1243,CWE-401,"CWE-401 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) { <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( n ) \\\n{ <S2SV_ModEnd> sum = ( <S2SV_ModStart> ++ ; } \\\n} <S2SV_ModEnd> typedef struct PCDTable <S2SV_ModStart> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
",ImageMagick@ImageMagick/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,CVE-2019-7175,https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,2019-03-07T23:29Z,520,<S2SV_ModStart> ( n ) \\\n{ <S2SV_ModEnd> if ( pcd,0
1244,CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b,CVE-2019-19275,https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b,2019-11-26T15:15Z,521,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1245,CWE-20,"CWE-20 static void test_headers_bad ( Test * test , gconstpointer data ) { GHashTable * headers ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=1;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=2;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; <S2SV_StartBug> g_hash_table_destroy ( headers ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;
",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z,522,<S2SV_ModStart> ) ) ; g_free ( header ) ;,0
1248,CWE-119,"CWE-119 void vpx_yv12_copy_y_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ; <S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } }
","<S2SV_ModStart> -> y_buffer ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ; uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ; <S2SV_ModStart> row ) { memcpy ( dst16 , src16 , src_ybc -> y_width * sizeof ( uint16_t ) ) ; src16 += src_ybc -> y_stride ; dst16 += dst_ybc -> y_stride ; } return ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy <S2SV_ModEnd> ( dst ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,523,"<S2SV_ModStart> dst_ybc ) { memcpy <S2SV_ModEnd> ( dst,",0
1251,CWE-119,"CWE-119 <S2SV_StartBug> static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> mi_col += MI_BLOCK_SIZE ) { <S2SV_StartBug> int dummy_rate ; <S2SV_EndBug> int64_t dummy_dist ; <S2SV_StartBug> BLOCK_SIZE i ; <S2SV_EndBug> MACROBLOCK * x = & cpi -> mb ; if ( sf -> adaptive_pred_interp_filter ) { <S2SV_StartBug> for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { <S2SV_EndBug> const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ; const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ; for ( x -> sb_index = 0 ; x -> sb_index < 4 ; ++ x -> sb_index ) for ( x -> mb_index = 0 ; x -> mb_index < 4 ; ++ x -> mb_index ) for ( x -> b_index = 0 ; x -> b_index < 16 / num_4x4_blk ; ++ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ; } } vp9_zero ( cpi -> mb . pred_mv ) ; <S2SV_StartBug> if ( ( sf -> partition_search_type == SEARCH_PARTITION && <S2SV_EndBug> sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION || <S2SV_StartBug> sf -> partition_search_type == VAR_BASED_PARTITION || <S2SV_EndBug> sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; cpi -> mb . source_variance = UINT_MAX ; if ( sf -> partition_search_type == FIXED_PARTITION ) { <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , sf -> always_this_block_size ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 ) ; <S2SV_EndBug> } else if ( sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else if ( sf -> partition_search_type == VAR_BASED_PARTITION ) { choose_partitioning ( cpi , tile , mi_row , mi_col ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } else { if ( ( cm -> current_video_frame % sf -> last_partitioning_redo_frequency ) == 0 || cm -> prev_mi == 0 || cm -> show_frame == 0 || cm -> frame_type == KEY_FRAME || cpi -> rc . is_src_frame_alt_ref || ( ( sf -> use_lastframe_partitioning == LAST_FRAME_PARTITION_LOW_MOTION ) && sb_has_motion ( cm , prev_mi_8x8 ) ) ) { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ; } rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; } else { if ( sf -> constrain_copy_partition && sb_has_motion ( cm , prev_mi_8x8 ) ) constrain_copy_partitioning ( cpi , tile , mi_8x8 , prev_mi_8x8 , mi_row , mi_col , BLOCK_16X16 ) ; else copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 ) ; } } } else { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile , mi_row , mi_col , & sf -> min_partition_size , & sf -> max_partition_size ) ; } rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; } } }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * const <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> xd -> left_context <S2SV_ModStart> xd -> left_context ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> ( xd -> left_seg_context <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( mi_col = tile_info <S2SV_ModEnd> -> mi_col_start ; <S2SV_ModStart> ; mi_col < tile_info <S2SV_ModEnd> -> mi_col_end ; <S2SV_ModStart> MI_BLOCK_SIZE ) { const struct segmentation * const seg = & cm -> seg ; <S2SV_ModStart> int64_t dummy_dist ; RD_COST dummy_rdc ; int i ; int seg_skip = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < 64 <S2SV_ModEnd> ; ++ i <S2SV_ModStart> ++ i ) td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; for ( i = 0 ; i < 64 ; ++ i ) { td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; } } vp9_zero ( x -> pred_mv ) ; td -> pc_root -> index = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; } x -> source_variance = UINT_MAX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> sf -> partition_search_type <S2SV_ModStart> == FIXED_PARTITION || seg_skip ) { const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( cpi -> partition_search_skippable_frame ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( <S2SV_ModStart> partition_search_type == VAR_BASED_PARTITION && cm -> frame_type != KEY_FRAME ) { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else { if ( sf -> auto_min_max_partition_size <S2SV_ModEnd> ) { set_offsets <S2SV_ModStart> ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ; } rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> BLOCK_64X64 , & dummy_rdc , INT64_MAX , td -> pc_root <S2SV_ModEnd> ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,524,<S2SV_ModStart>,0
1252,CWE-125,"CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_StartBug> int hexdump ; <S2SV_EndBug> u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> ; int hexdump , ret <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
",the-tcpdump-group@tcpdump/d97e94223720684c6aa740ff219e0d19426c2220,CVE-2018-14464,https://github.com/the-tcpdump-group/tcpdump/commit/d97e94223720684c6aa740ff219e0d19426c2220,2019-10-03T16:15Z,525,"<S2SV_ModStart> ; u_int length, tstr <S2SV_ModEnd> ) ) ;",0
1253,CWE-119,"CWE-119 <S2SV_StartBug> static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , <S2SV_EndBug> nmv_context_counts * counts ) { int i ; for ( i = 0 ; i < 1 + has_second_ref ( mbmi ) ; ++ i ) { <S2SV_StartBug> const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ; <S2SV_EndBug> const MV diff = { mvs [ i ] . as_mv . row - ref -> row , mvs [ i ] . as_mv . col - ref -> col } ; vp9_inc_mv ( & diff , counts ) ; } }
","<S2SV_ModStart> * mbmi , const MB_MODE_INFO_EXT * mbmi_ext , <S2SV_ModStart> ref = & mbmi_ext <S2SV_ModEnd> -> ref_mvs [
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,526,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
1254,CWE-119,"CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; int update_frame_num = 0 ; const int fps = 30 ; const int bitrate = 200 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ; encoder = get_vpx_encoder_by_name ( ""vp8"" ) ; if ( ! encoder ) die ( ""Unsupported<S2SV_blank>codec."" ) ; update_frame_num = atoi ( argv [ 5 ] ) ; if ( ! update_frame_num ) die ( ""Couldn\'t<S2SV_blank>parse<S2SV_blank>frame<S2SV_blank>number<S2SV_blank>\'%s\'\\n"" , argv [ 5 ] ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 1 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 2 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image."" ) ; } <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; writer = vpx_video_writer_open ( argv [ 4 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 4 ] ) ; if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 3 ] ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; while ( vpx_img_read ( & raw , infile ) ) { if ( frame_count + 1 == update_frame_num ) { vpx_ref_frame_t ref ; ref . frame_type = VP8_LAST_FRAME ; ref . img = raw ; if ( vpx_codec_control ( & codec , VP8_SET_REFERENCE , & ref ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>reference<S2SV_blank>frame"" ) ; } encode_frame ( & codec , & raw , frame_count ++ , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> printf ( ""\\n"" ) ; fclose ( infile ) ; printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , encoder -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> ) ; } while ( <S2SV_ModStart> , writer ) ) { } <S2SV_ModEnd> printf ( ""\\n""
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,527,"<S2SV_ModStart> ( encoder -> codec_interface <S2SV_ModEnd> ( ), <S2SV_ModStart>, encoder -> codec_interface <S2SV_ModEnd> ( ),",0
1255,CWE-399,"CWE-399 static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ; <S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }
","<S2SV_ModStart> , size - skb_out <S2SV_ModEnd> -> len ,
",torvalds@linux/5b6698b0e4a37053de35cc24ee695b98a7eb712b,CVE-2014-9428,https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b,2015-01-02T21:59Z,528,<S2SV_ModStart> ; if ( <S2SV_ModEnd> skb -> flags,0
1260,CWE-399,"CWE-399 static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( ""ldlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; case 3 : asm ( ""ldlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0"" : ""=r"" ( hi ) : ""r"" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,529,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",1
1261,CWE-59,"CWE-59 void netsnmp_init_mib ( void ) { const char * prefix ; char * env_var , * entry ; PrefixListPtr pp = & mib_prefixes [ 0 ] ; char * st = NULL ; if ( Mib ) return ; netsnmp_init_mib_internals ( ) ; netsnmp_fixup_mib_directory ( ) ; env_var = strdup ( netsnmp_get_mib_directory ( ) ) ; if ( ! env_var ) return ; <S2SV_StartBug> netsnmp_mibindex_load ( ) ; <S2SV_EndBug> DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { add_mibdir ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( * env_var == '+' ) entry = strtok_r ( env_var + 1 , ENV_SEPARATOR , & st ) ; else entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { <S2SV_StartBug> add_mibfile ( entry , NULL , NULL ) ; <S2SV_EndBug> entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } } netsnmp_init_mib_internals ( ) ; env_var = netsnmp_getenv ( ""MIBS"" ) ; if ( env_var == NULL ) { if ( confmibs != NULL ) env_var = strdup ( confmibs ) ; else env_var = strdup ( NETSNMP_DEFAULT_MIBS ) ; } else { env_var = strdup ( env_var ) ; } if ( env_var && ( ( * env_var == '+' ) || ( * env_var == '-' ) ) ) { entry = ( char * ) malloc ( strlen ( NETSNMP_DEFAULT_MIBS ) + strlen ( env_var ) + 2 ) ; if ( ! entry ) { DEBUGMSGTL ( ( ""init_mib"" , ""env<S2SV_blank>mibs<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; SNMP_FREE ( env_var ) ; return ; } else { if ( * env_var == '+' ) sprintf ( entry , ""%s%c%s"" , NETSNMP_DEFAULT_MIBS , ENV_SEPARATOR_CHAR , env_var + 1 ) ; else sprintf ( entry , ""%s%c%s"" , env_var + 1 , ENV_SEPARATOR_CHAR , NETSNMP_DEFAULT_MIBS ) ; } SNMP_FREE ( env_var ) ; env_var = entry ; } DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>files<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { if ( strcasecmp ( entry , DEBUG_ALWAYS_TOKEN ) == 0 ) { read_all_mibs ( ) ; } else if ( strstr ( entry , ""/"" ) != NULL ) { read_mib ( entry ) ; } else { netsnmp_read_module ( entry ) ; } entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } adopt_orphans ( ) ; SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( ( * env_var == '+' ) || ( * env_var == '-' ) ) { # ifdef NETSNMP_DEFAULT_MIBFILES entry = ( char * ) malloc ( strlen ( NETSNMP_DEFAULT_MIBFILES ) + strlen ( env_var ) + 2 ) ; if ( ! entry ) { DEBUGMSGTL ( ( ""init_mib"" , ""env<S2SV_blank>mibfiles<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; } else { if ( * env_var ++ == '+' ) sprintf ( entry , ""%s%c%s"" , NETSNMP_DEFAULT_MIBFILES , ENV_SEPARATOR_CHAR , env_var ) ; else sprintf ( entry , ""%s%c%s"" , env_var , ENV_SEPARATOR_CHAR , NETSNMP_DEFAULT_MIBFILES ) ; } SNMP_FREE ( env_var ) ; env_var = entry ; # else env_var = strdup ( env_var + 1 ) ; # endif } else { env_var = strdup ( env_var ) ; } } else { # ifdef NETSNMP_DEFAULT_MIBFILES env_var = strdup ( NETSNMP_DEFAULT_MIBFILES ) ; # endif } if ( env_var != NULL ) { DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBFILES:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>files<S2SV_blank>...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { read_mib ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; } prefix = netsnmp_getenv ( ""PREFIX"" ) ; if ( ! prefix ) prefix = Standard_Prefix ; Prefix = ( char * ) malloc ( strlen ( prefix ) + 2 ) ; if ( ! Prefix ) DEBUGMSGTL ( ( ""init_mib"" , ""Prefix<S2SV_blank>malloc<S2SV_blank>failed"" ) ) ; else strcpy ( Prefix , prefix ) ; DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>PREFIX:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>prefix<S2SV_blank>...\\n"" , Prefix ) ) ; if ( Prefix ) { env_var = & Prefix [ strlen ( Prefix ) - 1 ] ; if ( * env_var == '.' ) * env_var = '\\0' ; } pp -> str = Prefix ; while ( pp -> str ) { pp -> len = strlen ( pp -> str ) ; pp ++ ; } Mib = tree_head ; tree_top = ( struct tree * ) calloc ( 1 , sizeof ( struct tree ) ) ; if ( tree_top ) { tree_top -> label = strdup ( ""(top)"" ) ; tree_top -> child_list = tree_head ; } }
","<S2SV_ModStart> ) return ; <S2SV_ModEnd> DEBUGMSGTL ( ( <S2SV_ModStart> add_mibfile ( entry <S2SV_ModEnd> , NULL )
",net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z,530,"<S2SV_ModStart> char * env, NULL",0
1263,CWE-284,"CWE-284 int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { <S2SV_StartBug> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <S2SV_EndBug> if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( ""%s<S2SV_blank>ERROR:<S2SV_blank>uinput<S2SV_blank>device<S2SV_blank>open<S2SV_blank>failed"" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ; <S2SV_StartBug> if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { <S2SV_EndBug> BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; <S2SV_EndBug> for ( x = 0 ; key_map [ x ] . name != NULL ; x ++ ) <S2SV_StartBug> ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { <S2SV_EndBug> BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }
","<S2SV_ModStart> { fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ] , O_RDWR ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> sizeof ( dev ) <S2SV_ModStart> 1 ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> , EV_KEY ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( fd <S2SV_ModStart> , EV_REL ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( fd <S2SV_ModStart> UI_SET_EVBIT , EV_SYN ) <S2SV_ModStart> x ++ ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> . mapped_id ) ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( ioctl ( <S2SV_ModStart> UI_DEV_CREATE , NULL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,531,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1265,CWE-119,"CWE-119 void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> free ( ctx -> buf ) ; } free ( ctx ) ; } }
","<S2SV_ModStart> i ++ ) vpx_free_frame_buffer <S2SV_ModEnd> ( & ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,532,,0
1266,CWE-119,"CWE-119 static void filter_selectively_vert ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> } else if ( mask_8x8 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } else if ( mask_4x4 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } } if ( mask_4x4_int & 1 ) vp9_lpf_vertical_4 ( s + 4 , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; s += 8 ; lfl += 1 ; mask_16x16 >>= 1 ; mask_8x8 >>= 1 ; mask_4x4 >>= 1 ; mask_4x4_int >>= 1 ; } }
","<S2SV_ModStart> 1 ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s , <S2SV_ModStart> 1 ) { vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> ( s +
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,533,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>,0
1268,CWE-18,"CWE-18 static krb5_error_code <S2SV_StartBug> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <S2SV_EndBug> { iakerb_ctx_id_t ctx ; krb5_error_code code ; * pctx = NULL ; ctx = k5alloc ( sizeof ( * ctx ) , & code ) ; if ( ctx == NULL ) goto cleanup ; ctx -> defcred = GSS_C_NO_CREDENTIAL ; ctx -> magic = KG_IAKERB_CONTEXT ; ctx -> state = IAKERB_AS_REQ ; ctx -> count = 0 ; <S2SV_StartBug> code = krb5_gss_init_context ( & ctx -> k5c ) ; <S2SV_EndBug> if ( code != 0 ) goto cleanup ; * pctx = ctx ; cleanup : if ( code != 0 ) iakerb_release_context ( ctx ) ; return code ; }
","<S2SV_ModStart> iakerb_ctx_id_t * pctx , int initiate <S2SV_ModStart> = 0 ; ctx -> initiate = initiate ; ctx -> established = 0 ;
",krb5@krb5/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,CVE-2015-2696,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,2015-11-09T03:59Z,534,<S2SV_ModStart> ctx ) { <S2SV_ModEnd> int ctx =,0
1270,CWE-772,"CWE-772 static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = ( Image * ) NULL ; # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; screen = AcquireImage ( image_info ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ; <S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; <S2SV_EndBug> if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> image = screen ; else AppendImageToList ( & image , screen ) ; bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( HDC ) NULL ) { DeleteDC ( hDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; } ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; bmi . bmiHeader . biPlanes = 1 ; bmi . bmiHeader . biBitCount = 24 ; bmi . bmiHeader . biCompression = BI_RGB ; bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; if ( bitmap == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; if ( bitmapOld == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , SRCCOPY ) ; ( void ) SelectObject ( bitmapDC , bitmapOld ) ; for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) { q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( p -> rgbtRed ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( p -> rgbtGreen ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( p -> rgbtBlue ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) break ; } DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; } } # elif defined ( MAGICKCORE_X11_DELEGATE ) { const char * option ; XImportInfo ximage_info ; ( void ) exception ; XGetImportInfo ( & ximage_info ) ; option = GetImageOption ( image_info , ""x:screen"" ) ; if ( option != ( const char * ) NULL ) ximage_info . screen = IsMagickTrue ( option ) ; option = GetImageOption ( image_info , ""x:silent"" ) ; if ( option != ( const char * ) NULL ) ximage_info . silent = IsMagickTrue ( option ) ; image = XImportImage ( image_info , & ximage_info ) ; } # endif return ( image ) ; }
","<S2SV_ModStart> = DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> bitmapDC = CreateCompatibleDC
",ImageMagick@ImageMagick/8c10b9247509c0484b55330458846115131ec2ae,CVE-2017-11447,https://github.com/ImageMagick/ImageMagick/commit/8c10b9247509c0484b55330458846115131ec2ae,2017-07-19T07:29Z,535,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1271,CWE-254,"CWE-254 void impeg2d_dec_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
","<S2SV_ModStart> ; while ( ( <S2SV_ModStart> ) != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
",external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z,536,<S2SV_ModStart> ( ps_stream -> u4_offset,0
1272,CWE-401,"CWE-401 static ssize_t sof_dfsentry_write ( struct file * file , const char __user * buffer , size_t count , loff_t * ppos ) { # if IS_ENABLED ( CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST ) struct snd_sof_dfsentry * dfse = file -> private_data ; struct snd_sof_dev * sdev = dfse -> sdev ; unsigned long ipc_duration_ms = 0 ; bool flood_duration_test = false ; unsigned long ipc_count = 0 ; struct dentry * dentry ; int err ; # endif size_t size ; char * string ; int ret ; string = kzalloc ( count , GFP_KERNEL ) ; if ( ! string ) return - ENOMEM ; size = simple_write_to_buffer ( string , count , ppos , buffer , count ) ; ret = size ; # if IS_ENABLED ( CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST ) dentry = file -> f_path . dentry ; if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ; if ( flood_duration_test ) ret = kstrtoul ( string , 0 , & ipc_duration_ms ) ; else ret = kstrtoul ( string , 0 , & ipc_count ) ; if ( ret < 0 ) goto out ; if ( flood_duration_test ) { if ( ! ipc_duration_ms ) { ret = size ; goto out ; } if ( ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS ) ipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS ; } else { if ( ! ipc_count ) { ret = size ; goto out ; } if ( ipc_count > MAX_IPC_FLOOD_COUNT ) ipc_count = MAX_IPC_FLOOD_COUNT ; } ret = pm_runtime_get_sync ( sdev -> dev ) ; if ( ret < 0 ) { dev_err_ratelimited ( sdev -> dev , ""error:<S2SV_blank>debugfs<S2SV_blank>write<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>%d\\n"" , ret ) ; pm_runtime_put_noidle ( sdev -> dev ) ; goto out ; } ret = sof_debug_ipc_flood_test ( sdev , dfse , flood_duration_test , ipc_duration_ms , ipc_count ) ; pm_runtime_mark_last_busy ( sdev -> dev ) ; err = pm_runtime_put_autosuspend ( sdev -> dev ) ; if ( err < 0 ) dev_err_ratelimited ( sdev -> dev , ""error:<S2SV_blank>debugfs<S2SV_blank>write<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>idle<S2SV_blank>%d\\n"" , err ) ; if ( ret >= 0 ) ret = size ; out : # endif kfree ( string ) ; return ret ; }
","<S2SV_ModStart> ""ipc_flood_duration_ms"" ) ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto out ; }
",torvalds@linux/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed,CVE-2019-18812,https://github.com/torvalds/linux/commit/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed,2019-11-07T16:15Z,537,<S2SV_ModStart> ) return - ENOMEM <S2SV_ModEnd> ; if (,0
1273,CWE-20,"CWE-20 MonoReflectionMethod * mono_reflection_bind_generic_method_parameters ( MonoReflectionMethod * rmethod , MonoArray * types ) { MonoClass * klass ; MonoMethod * method , * inflated ; MonoMethodInflated * imethod ; MonoGenericContext tmp_context ; MonoGenericInst * ginst ; MonoType * * type_argv ; int count , i ; MONO_ARCH_SAVE_REGS ; if ( ! strcmp ( rmethod -> object . vtable -> klass -> name , ""MethodBuilder"" ) ) { # ifndef DISABLE_REFLECTION_EMIT MonoReflectionMethodBuilder * mb = NULL ; MonoReflectionTypeBuilder * tb ; MonoClass * klass ; mb = ( MonoReflectionMethodBuilder * ) rmethod ; tb = ( MonoReflectionTypeBuilder * ) mb -> type ; klass = mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) tb ) ) ; method = methodbuilder_to_mono_method ( klass , mb ) ; # else g_assert_not_reached ( ) ; method = NULL ; # endif } else { method = rmethod -> method ; } klass = method -> klass ; if ( method -> is_inflated ) method = ( ( MonoMethodInflated * ) method ) -> declaring ; count = mono_method_signature ( method ) -> generic_param_count ; if ( count != mono_array_length ( types ) ) return NULL ; type_argv = g_new0 ( MonoType * , count ) ; for ( i = 0 ; i < count ; i ++ ) { MonoReflectionType * garg = mono_array_get ( types , gpointer , i ) ; type_argv [ i ] = mono_reflection_type_get_handle ( garg ) ; } ginst = mono_metadata_get_generic_inst ( count , type_argv ) ; g_free ( type_argv ) ; tmp_context . class_inst = klass -> generic_class ? klass -> generic_class -> context . class_inst : NULL ; tmp_context . method_inst = ginst ; inflated = mono_class_inflate_generic_method ( method , & tmp_context ) ; imethod = ( MonoMethodInflated * ) inflated ; if ( method -> klass -> image -> dynamic ) { MonoDynamicImage * image = ( MonoDynamicImage * ) method -> klass -> image ; mono_loader_lock ( ) ; mono_g_hash_table_insert ( image -> generic_def_objects , imethod , rmethod ) ; mono_loader_unlock ( ) ; } <S2SV_StartBug> return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ;
",mono@mono/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,CVE-2010-4254,https://github.com/mono/mono/commit/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,2010-12-06T13:44Z,538,,0
1274,CWE-119,"CWE-119 static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( ""nnnnn\\0"" ) ] ; <S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }
","<S2SV_ModStart> ) ] ; size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , buffer , size <S2SV_ModEnd> ) ) return
",torvalds@linux/201f99f170df14ba52ea4c52847779042b7a623b,CVE-2013-4512,https://github.com/torvalds/linux/commit/201f99f170df14ba52ea4c52847779042b7a623b,2013-11-12T14:35Z,539,"<S2SV_ModStart> * buf, sizeof ( buf )",0
1277,CWE-252,"CWE-252 char * _dl_dst_substitute ( struct link_map * l , const char * name , char * result , int is_path ) { <S2SV_StartBug> char * last_elem , * wp ; <S2SV_EndBug> last_elem = wp = result ; do { if ( * name == '$' ) { const char * repl ; size_t len ; <S2SV_StartBug> if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) <S2SV_EndBug> && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) || ( strncmp ( & name [ 2 ] , ""PLATFORM}"" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) { repl = ( ( len == 7 || name [ 2 ] == 'O' ) <S2SV_StartBug> ? ( __libc_enable_secure ? NULL : l -> l_origin ) <S2SV_EndBug> : _dl_platform ) ; if ( repl != NULL && repl != ( const char * ) - 1 ) { wp = __stpcpy ( wp , repl ) ; name += len ; } else { wp = last_elem ; name += len ; while ( * name != '\\0' && ( ! is_path || * name != ':' ) ) ++ name ; } } else * wp ++ = * name ++ ; } else if ( is_path && * name == ':' ) { * wp ++ = * name ++ ; last_elem = wp ; } else * wp ++ = * name ++ ; } while ( * name != '\\0' ) ; * wp = '\\0' ; return result ; }
","<S2SV_ModStart> is_path ) { const char * const start = name ; <S2SV_ModStart> 1 ] , ""ORIGIN}"" <S2SV_ModEnd> , 6 ) <S2SV_ModStart> 1 ] , ""PLATFORM}"" <S2SV_ModEnd> , 8 ) <S2SV_ModStart> ? ( __libc_enable_secure && ( ( name [ len ] != '\\0' && ( ! is_path || name [ len ] != ':' ) ) || ( name != start && ( ! is_path || name [ - 1 ] != ':' ) ) )
",bminor@glibc/2864e767053317538feafa815046fff89e5a16be,CVE-1999-0199,https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be,2020-10-06T13:15Z,540,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char *,0
1278,CWE-119,"CWE-119 H264SwDecRet H264SwDecInit ( H264SwDecInst * decInst , u32 noOutputReordering ) { u32 rv = 0 ; decContainer_t * pDecCont ; DEC_API_TRC ( ""H264SwDecInit#"" ) ; if ( ( ( - 1 ) >> 1 ) != ( - 1 ) ) { DEC_API_TRC ( ""H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>Right<S2SV_blank>shift<S2SV_blank>is<S2SV_blank>not<S2SV_blank>signed"" ) ; return ( H264SWDEC_INITFAIL ) ; } if ( decInst == NULL ) { DEC_API_TRC ( ""H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>decInst<S2SV_blank>==<S2SV_blank>NULL"" ) ; return ( H264SWDEC_PARAM_ERR ) ; } <S2SV_StartBug> pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ; <S2SV_EndBug> if ( pDecCont == NULL ) { DEC_API_TRC ( ""H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>Memory<S2SV_blank>allocation<S2SV_blank>failed"" ) ; return ( H264SWDEC_MEMFAIL ) ; } # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , ""H264SwDecInit#<S2SV_blank>decInst<S2SV_blank>%p<S2SV_blank>noOutputReordering<S2SV_blank>%d"" , ( void * ) decInst , noOutputReordering ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif rv = h264bsdInit ( & pDecCont -> storage , noOutputReordering ) ; if ( rv != HANTRO_OK ) { H264SwDecRelease ( pDecCont ) ; return ( H264SWDEC_MEMFAIL ) ; } pDecCont -> decStat = INITIALIZED ; pDecCont -> picNumber = 0 ; # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , ""H264SwDecInit#<S2SV_blank>OK:<S2SV_blank>return<S2SV_blank>%p"" , ( void * ) pDecCont ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif * decInst = ( decContainer_t * ) pDecCont ; return ( H264SWDEC_OK ) ; }
","<S2SV_ModStart> ( decContainer_t ) , 1
",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z,541,,0
1279,CWE-416,"CWE-416 static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) <S2SV_StartBug> { <S2SV_EndBug> struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; proto = inet -> inet_num ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } if ( ! opt ) <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = proto ; rfv . msg = msg ; rfv . hlen = 0 ; err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; if ( err ) goto out ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; if ( inet -> hdrincl ) fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( inet -> hdrincl ) err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; else { lock_sock ( sk ) ; err = ip6_append_data ( sk , raw6_getfrag , & rfv , len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; release_sock ( sk ) ; } done : dst_release ( dst ) ; out : fl6_sock_release ( flowlabel ) ; <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug> do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
","<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,542,<S2SV_ModStart> ipv6_txoptions * opt,0
1280,CWE-399,"CWE-399 static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } <S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INHDRERRORS ) ; drop : return - 1 ; }
","<S2SV_ModStart> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart> == 5 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> opt -> optlen
",torvalds@linux/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,CVE-2011-4087,https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,2013-06-08T13:05Z,543,<S2SV_ModStart> ; if ( ip_opt <S2SV_ModEnd> ( skb ),0
1283,CWE-119,"CWE-119 static Image * ReadAVSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; register unsigned char * p ; size_t height , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { ssize_t length ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,544,"<S2SV_ModStart> ) break ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",1
1284,CWE-200,"CWE-200 int res_unpack ( vorbis_info_residue * info , vorbis_info * vi , oggpack_buffer * opb ) { int j , k ; codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; memset ( info , 0 , sizeof ( * info ) ) ; info -> type = oggpack_read ( opb , 16 ) ; if ( info -> type > 2 || info -> type < 0 ) goto errout ; info -> begin = oggpack_read ( opb , 24 ) ; info -> end = oggpack_read ( opb , 24 ) ; info -> grouping = oggpack_read ( opb , 24 ) + 1 ; info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( info -> groupbook >= ci -> books ) goto errout ; info -> stagemasks = _ogg_malloc ( info -> partitions * sizeof ( * info -> stagemasks ) ) ; info -> stagebooks = _ogg_malloc ( info -> partitions * 8 * sizeof ( * info -> stagebooks ) ) ; for ( j = 0 ; j < info -> partitions ; j ++ ) { int cascade = oggpack_read ( opb , 3 ) ; if ( oggpack_read ( opb , 1 ) ) cascade |= ( oggpack_read ( opb , 5 ) << 3 ) ; info -> stagemasks [ j ] = cascade ; } for ( j = 0 ; j < info -> partitions ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { if ( ( info -> stagemasks [ j ] >> k ) & 1 ) { unsigned char book = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( book >= ci -> books ) goto errout ; info -> stagebooks [ j * 8 + k ] = book ; if ( k + 1 > info -> stages ) info -> stages = k + 1 ; } else info -> stagebooks [ j * 8 + k ] = 0xff ; } } if ( oggpack_eop ( opb ) ) goto errout ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> errout : res_clear_info ( info ) ; return 1 ; }
","<S2SV_ModStart> goto errout ; int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; }
",external@tremolo/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,CVE-2017-0814,https://android.googlesource.com/platform/external/tremolo/+/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,2017-10-04T01:29Z,545,<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if (,0
1285,CWE-400,"CWE-400 static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
","<S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z,546,"<S2SV_ModStart> ; if ( js_doregexec ( J, <S2SV_ModEnd> re -> prog",0
1286,CWE-119,"CWE-119 int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; } used = recv_actor ( desc , skb , offset , len ) ; if ( used < 0 ) { if ( ! copied ) copied = used ; break ; } else if ( used <= len ) { seq += used ; copied += used ; offset += used ; } skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ; if ( ! skb || ( offset + 1 != skb -> len ) ) break ; } if ( tcp_hdr ( skb ) -> fin ) { sk_eat_skb ( sk , skb , 0 ) ; ++ seq ; break ; } sk_eat_skb ( sk , skb , 0 ) ; if ( ! desc -> count ) break ; <S2SV_StartBug> } <S2SV_EndBug> tp -> copied_seq = seq ; <S2SV_StartBug> tcp_rcv_space_adjust ( sk ) ; <S2SV_EndBug> if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ; return copied ; }
","<S2SV_ModStart> ) break ; <S2SV_ModEnd> tp -> copied_seq <S2SV_ModStart> = seq ; } tp -> copied_seq = seq ;
",torvalds@linux/baff42ab1494528907bf4d5870359e31711746ae,CVE-2013-2128,https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae,2013-06-07T14:03Z,547,<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; } tp ->,0
1287,CWE-000,"CWE-000 static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; <S2SV_StartBug> krb5_key_data * key_data ; <S2SV_EndBug> if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; <S2SV_StartBug> if ( key_data_in == NULL ) <S2SV_EndBug> goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ; } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) { <S2SV_StartBug> for ( i = 0 ; i <= num_versions ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ret [ i ] != NULL ) <S2SV_EndBug> free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }
","<S2SV_ModStart> krb5_key_data * key_data = NULL ; if ( n_key_data < <S2SV_ModEnd> 0 ) return <S2SV_ModStart> ; if ( key_data <S2SV_ModEnd> == NULL ) <S2SV_ModStart> = 0 ; ret [ i ] != NULL <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ ) <S2SV_ModEnd> free ( ret
",krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16,CVE-2014-5354,https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16,2014-12-16T23:59Z,548,<S2SV_ModStart> ; if ( k2 == NULL &&,0
1288,CWE-190,"CWE-190 static int <S2SV_StartBug> _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value ) <S2SV_EndBug> { PyObject * old_item ; if ( idx >= self -> memo_size ) { if ( _Unpickler_ResizeMemoList ( self , idx * 2 ) < 0 ) return - 1 ; assert ( idx < self -> memo_size ) ; } Py_INCREF ( value ) ; old_item = self -> memo [ idx ] ; self -> memo [ idx ] = value ; if ( old_item != NULL ) { Py_DECREF ( old_item ) ; } else { self -> memo_len ++ ; } return 0 ; }
","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx , PyObject
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,549,,0
1289,CWE-190,"CWE-190 static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ; <S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug> if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }
","<S2SV_ModStart> -> zInput = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z,550,<S2SV_ModStart> ( sqlite3_int64 ),0
1290,CWE-362,"CWE-362 static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> filp ) { __sock_release <S2SV_ModEnd> ( SOCKET_I ( <S2SV_ModStart> ( inode ) , inode
",torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14,CVE-2018-12232,https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14,2018-06-12T12:29Z,551,<S2SV_ModStart> ) { struct sockaddr_lock <S2SV_ModEnd> ( inode ),0
1291,CWE-125,"CWE-125 stmt_ty <S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>target<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>iter<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ; <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,552,,0
1292,CWE-362,"CWE-362 <S2SV_StartBug> int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) <S2SV_EndBug> { reg2 uint key ; reg1 MI_KEYDEF * keyinfo ; File new_file ; my_off_t index_pos [ HA_MAX_POSSIBLE_KEY ] ; uint r_locks , w_locks ; int old_lock ; MYISAM_SHARE * share = info -> s ; MI_STATE_INFO old_state ; DBUG_ENTER ( ""mi_sort_index"" ) ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) if ( keyinfo -> key_alg == HA_KEY_ALG_RTREE ) DBUG_RETURN ( 0 ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-<S2SV_blank>Sorting<S2SV_blank>index<S2SV_blank>for<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; fn_format ( param -> temp_filename , name , """" , MI_NAME_IEXT , 2 + 4 + 32 ) ; if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; DBUG_RETURN ( - 1 ) ; } if ( filecopy ( param , new_file , share -> kfile , 0L , ( ulong ) share -> base . keystart , ""headerblock"" ) ) goto err ; param -> new_file_pos = share -> base . keystart ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) { if ( ! mi_is_key_active ( info -> s -> state . key_map , key ) ) continue ; if ( share -> state . key_root [ key ] != HA_OFFSET_ERROR ) { index_pos [ key ] = param -> new_file_pos ; if ( sort_one_index ( param , info , keyinfo , share -> state . key_root [ key ] , new_file ) ) goto err ; } else index_pos [ key ] = HA_OFFSET_ERROR ; } flush_key_blocks ( share -> key_cache , share -> kfile , FLUSH_IGNORE_CHANGED ) ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; old_state = share -> state ; r_locks = share -> r_locks ; w_locks = share -> w_locks ; old_lock = info -> lock_type ; share -> r_locks = share -> w_locks = share -> tot_locks = 0 ; ( void ) _mi_writeinfo ( info , WRITEINFO_UPDATE_KEYFILE ) ; ( void ) mysql_file_close ( share -> kfile , MYF ( MY_WME ) ) ; share -> kfile = - 1 ; ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , <S2SV_StartBug> MYF ( 0 ) ) || <S2SV_EndBug> mi_open_keyfile ( share ) ) goto err2 ; info -> lock_type = F_UNLCK ; _mi_readinfo ( info , F_WRLCK , 0 ) ; info -> lock_type = old_lock ; share -> r_locks = r_locks ; share -> w_locks = w_locks ; share -> tot_locks = r_locks + w_locks ; share -> state = old_state ; info -> state -> key_file_length = param -> new_file_pos ; info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; for ( key = 0 ; key < info -> s -> base . keys ; key ++ ) info -> s -> state . key_root [ key ] = index_pos [ key ] ; for ( key = 0 ; key < info -> s -> state . header . max_block_size_index ; key ++ ) info -> s -> state . key_del [ key ] = HA_OFFSET_ERROR ; info -> s -> state . changed &= ~ STATE_NOT_SORTED_PAGES ; DBUG_RETURN ( 0 ) ; err : ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ; err2 : ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; DBUG_RETURN ( - 1 ) ; }
","<S2SV_ModStart> char * name , my_bool no_copy_stat <S2SV_ModStart> , INDEX_TMP_EXT , no_copy_stat ? MYF ( MY_REDEL_NO_COPY_STAT ) :
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,553,"<S2SV_ModStart>, int ret <S2SV_ModEnd> ; if (",0
1293,CWE-264,"CWE-264 static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } <S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug> sk_dst_reset ( sk ) ; return opt ; }
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,554,<S2SV_ModStart> = xchg ( ( ( struct ipv6_txoptions * ),0
1295,CWE-400,"CWE-400 const char * nghttp2_strerror ( int error_code ) { switch ( error_code ) { case 0 : return ""Success"" ; case NGHTTP2_ERR_INVALID_ARGUMENT : return ""Invalid<S2SV_blank>argument"" ; case NGHTTP2_ERR_BUFFER_ERROR : return ""Out<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>space"" ; case NGHTTP2_ERR_UNSUPPORTED_VERSION : return ""Unsupported<S2SV_blank>SPDY<S2SV_blank>version"" ; case NGHTTP2_ERR_WOULDBLOCK : return ""Operation<S2SV_blank>would<S2SV_blank>block"" ; case NGHTTP2_ERR_PROTO : return ""Protocol<S2SV_blank>error"" ; case NGHTTP2_ERR_INVALID_FRAME : return ""Invalid<S2SV_blank>frame<S2SV_blank>octets"" ; case NGHTTP2_ERR_EOF : return ""EOF"" ; case NGHTTP2_ERR_DEFERRED : return ""Data<S2SV_blank>transfer<S2SV_blank>deferred"" ; case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE : return ""No<S2SV_blank>more<S2SV_blank>Stream<S2SV_blank>ID<S2SV_blank>available"" ; case NGHTTP2_ERR_STREAM_CLOSED : return ""Stream<S2SV_blank>was<S2SV_blank>already<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>invalid"" ; case NGHTTP2_ERR_STREAM_CLOSING : return ""Stream<S2SV_blank>is<S2SV_blank>closing"" ; case NGHTTP2_ERR_STREAM_SHUT_WR : return ""The<S2SV_blank>transmission<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>this<S2SV_blank>stream"" ; case NGHTTP2_ERR_INVALID_STREAM_ID : return ""Stream<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>invalid"" ; case NGHTTP2_ERR_INVALID_STREAM_STATE : return ""Invalid<S2SV_blank>stream<S2SV_blank>state"" ; case NGHTTP2_ERR_DEFERRED_DATA_EXIST : return ""Another<S2SV_blank>DATA<S2SV_blank>frame<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>deferred"" ; case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED : return ""request<S2SV_blank>HEADERS<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ; case NGHTTP2_ERR_GOAWAY_ALREADY_SENT : return ""GOAWAY<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>sent"" ; case NGHTTP2_ERR_INVALID_HEADER_BLOCK : return ""Invalid<S2SV_blank>header<S2SV_blank>block"" ; case NGHTTP2_ERR_INVALID_STATE : return ""Invalid<S2SV_blank>state"" ; case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE : return ""The<S2SV_blank>user<S2SV_blank>callback<S2SV_blank>function<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>the<S2SV_blank>temporal<S2SV_blank>error"" ; case NGHTTP2_ERR_FRAME_SIZE_ERROR : return ""The<S2SV_blank>length<S2SV_blank>of<S2SV_blank>the<S2SV_blank>frame<S2SV_blank>is<S2SV_blank>invalid"" ; case NGHTTP2_ERR_HEADER_COMP : return ""Header<S2SV_blank>compression/decompression<S2SV_blank>error"" ; case NGHTTP2_ERR_FLOW_CONTROL : return ""Flow<S2SV_blank>control<S2SV_blank>error"" ; case NGHTTP2_ERR_INSUFF_BUFSIZE : return ""Insufficient<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>given<S2SV_blank>to<S2SV_blank>function"" ; case NGHTTP2_ERR_PAUSE : return ""Callback<S2SV_blank>was<S2SV_blank>paused<S2SV_blank>by<S2SV_blank>the<S2SV_blank>application"" ; case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS : return ""Too<S2SV_blank>many<S2SV_blank>inflight<S2SV_blank>SETTINGS"" ; case NGHTTP2_ERR_PUSH_DISABLED : return ""Server<S2SV_blank>push<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>peer"" ; case NGHTTP2_ERR_DATA_EXIST : return ""DATA<S2SV_blank>or<S2SV_blank>HEADERS<S2SV_blank>frame<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>submitted<S2SV_blank>for<S2SV_blank>the<S2SV_blank>stream"" ; case NGHTTP2_ERR_SESSION_CLOSING : return ""The<S2SV_blank>current<S2SV_blank>session<S2SV_blank>is<S2SV_blank>closing"" ; case NGHTTP2_ERR_HTTP_HEADER : return ""Invalid<S2SV_blank>HTTP<S2SV_blank>header<S2SV_blank>field<S2SV_blank>was<S2SV_blank>received"" ; case NGHTTP2_ERR_HTTP_MESSAGING : return ""Violation<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>messaging<S2SV_blank>rule"" ; case NGHTTP2_ERR_REFUSED_STREAM : return ""Stream<S2SV_blank>was<S2SV_blank>refused"" ; case NGHTTP2_ERR_INTERNAL : return ""Internal<S2SV_blank>error"" ; case NGHTTP2_ERR_CANCEL : return ""Cancel"" ; case NGHTTP2_ERR_SETTINGS_EXPECTED : return ""When<S2SV_blank>a<S2SV_blank>local<S2SV_blank>endpoint<S2SV_blank>expects<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>SETTINGS<S2SV_blank>frame,<S2SV_blank>it<S2SV_blank>"" ""receives<S2SV_blank>an<S2SV_blank>other<S2SV_blank>type<S2SV_blank>of<S2SV_blank>frame"" ; case NGHTTP2_ERR_NOMEM : return ""Out<S2SV_blank>of<S2SV_blank>memory"" ; case NGHTTP2_ERR_CALLBACK_FAILURE : return ""The<S2SV_blank>user<S2SV_blank>callback<S2SV_blank>function<S2SV_blank>failed"" ; case NGHTTP2_ERR_BAD_CLIENT_MAGIC : return ""Received<S2SV_blank>bad<S2SV_blank>client<S2SV_blank>magic<S2SV_blank>byte<S2SV_blank>string"" ; case NGHTTP2_ERR_FLOODED : return ""Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>"" ""closed"" ; <S2SV_StartBug> default : <S2SV_EndBug> return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ; } }
","<S2SV_ModStart> ""Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>"" ""closed"" ; case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ;
",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z,555,,0
1296,CWE-125,"CWE-125 static UINT rdpei_recv_pdu ( RDPEI_CHANNEL_CALLBACK * callback , wStream * s ) { UINT16 eventId ; UINT32 pduLength ; UINT error ; <S2SV_StartBug> Stream_Read_UINT16 ( s , eventId ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , pduLength ) ; # ifdef WITH_DEBUG_RDPEI WLog_DBG ( TAG , ""rdpei_recv_pdu:<S2SV_blank>eventId:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>(%s)<S2SV_blank>length:<S2SV_blank>%"" PRIu32 """" , eventId , rdpei_eventid_string ( eventId ) , pduLength ) ; # endif switch ( eventId ) { case EVENTID_SC_READY : if ( ( error = rdpei_recv_sc_ready_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_sc_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } if ( ( error = rdpei_send_cs_ready_pdu ( callback ) ) ) { WLog_ERR ( TAG , ""rdpei_send_cs_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_SUSPEND_TOUCH : if ( ( error = rdpei_recv_suspend_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_suspend_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_RESUME_TOUCH : if ( ( error = rdpei_recv_resume_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_resume_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; default : break ; } return CHANNEL_RC_OK ; }
","<S2SV_ModStart> UINT error ; if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,556,<S2SV_ModStart> ( s,0
1297,CWE-134,"CWE-134 static rsRetVal initZMQ ( instanceData * pData ) { DEFiRet ; if ( NULL == s_context ) { zsys_handler_set ( NULL ) ; s_context = zctx_new ( ) ; if ( s_workerThreads > 0 ) zctx_set_iothreads ( s_context , s_workerThreads ) ; } pData -> socket = zsocket_new ( s_context , pData -> type ) ; if ( NULL == pData -> socket ) { errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>zsocket_new<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ; if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ; if ( pData -> rcvBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> rcvBuf ) ; if ( pData -> linger > - 1 ) zsocket_set_linger ( pData -> socket , pData -> linger ) ; if ( pData -> backlog > - 1 ) zsocket_set_backlog ( pData -> socket , pData -> backlog ) ; if ( pData -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( pData -> socket , pData -> sndTimeout ) ; if ( pData -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( pData -> socket , pData -> rcvTimeout ) ; if ( pData -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( pData -> socket , pData -> maxMsgSize ) ; if ( pData -> rate > - 1 ) zsocket_set_rate ( pData -> socket , pData -> rate ) ; if ( pData -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( pData -> socket , pData -> recoveryIVL ) ; if ( pData -> multicastHops > - 1 ) zsocket_set_multicast_hops ( pData -> socket , pData -> multicastHops ) ; if ( pData -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( pData -> socket , pData -> reconnectIVL ) ; if ( pData -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( pData -> socket , pData -> reconnectIVLMax ) ; if ( pData -> ipv4Only > - 1 ) zsocket_set_ipv4only ( pData -> socket , pData -> ipv4Only ) ; if ( pData -> affinity != 1 ) zsocket_set_affinity ( pData -> socket , pData -> affinity ) ; if ( pData -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( pData -> socket , pData -> rcvHWM ) ; if ( pData -> sndHWM > - 1 ) zsocket_set_sndhwm ( pData -> socket , pData -> sndHWM ) ; if ( pData -> action == ACTION_BIND ) { <S2SV_StartBug> if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>bind<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful\\n"" , pData -> description ) ; } else { <S2SV_StartBug> if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful"" , pData -> description ) ; } finalize_it : RETiRet ; }
","<S2SV_ModStart> -> socket , ""%s"" , <S2SV_ModStart> -> socket , ""%s"" ,
",rsyslog@rsyslog/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,CVE-2017-12588,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,2017-08-06T14:29Z,557,<S2SV_ModStart> = 0 ;,0
1299,CWE-310,"CWE-310 static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n"" , __func__ , skb , <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ; <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; struct flowi6 * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n"" <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> saddr , & <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> daddr ) ; <S2SV_ModStart> daddr ) ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> ) ; if <S2SV_ModStart> = 1 ; SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart> , skb , <S2SV_ModEnd> fl6 , np
",torvalds@linux/95ee62083cb6453e056562d91f597552021e6ae7,CVE-2013-4350,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,2013-09-25T10:31Z,558,<S2SV_ModStart> <S6SV_null> <S2SV_null> static struct ipv6_txoptions * np -> opt = rcu_dereference ( <S2SV_ModStart> np -> opt ) ; rcu_read_unlock ( ) ; rcu_unlock ( ) ;,0
1301,CWE-399,"CWE-399 static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,559,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, 0",1
1302,CWE-20,"CWE-20 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
",ImageMagick@ImageMagick/8a370f9ab120faf182aa160900ba692ba8e2bcf0,CVE-2016-10069,https://github.com/ImageMagick/ImageMagick/commit/8a370f9ab120faf182aa160900ba692ba8e2bcf0,2017-03-02T21:59Z,560,,0
1303,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; UINT16 length ; UINT32 failureCode ; <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> , ""RDP_NEG_FAILURE"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FAIL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,561,<S2SV_ModStart> int length < 0,0
1305,CWE-120,"CWE-120 static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ; <S2SV_StartBug> int len , result = RLC_OK ; <S2SV_EndBug> bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; <S2SV_StartBug> if ( pad != RSA_PUB ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PRV ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; if ( m_len == 0 ) { result = RLC_ERR ; } id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad - id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; result = ( r == 0 ? RLC_OK : RLC_ERR ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; <S2SV_StartBug> if ( pad != RSA_PRV ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; <S2SV_StartBug> } while ( pad != 0 && m_len > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( m_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; break ; } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }
","<S2SV_ModStart> , result = RLC_ERR <S2SV_ModEnd> ; bn_t t <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> * p_len = <S2SV_ModStart> if ( pad == <S2SV_ModEnd> RSA_PUB ) { <S2SV_ModStart> RSA_PUB ) { <S2SV_ModEnd> do { m_len <S2SV_ModStart> 8 ) ; result = ( m_len > <S2SV_ModEnd> 0 ? RLC_OK <S2SV_ModStart> RLC_ERR ) ; } } break ; case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( bn_is_zero ( t ) ) { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PRV ) { int counter = 0 ; do { counter ++ ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad == RSA_PAD && m_len > 0 ) ; id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad ^ id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; if ( r && m_len > 0 && counter >= 8 ) { result = RLC_OK ; } } } <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> m_len -- ; <S2SV_ModStart> if ( pad == <S2SV_ModEnd> RSA_PRV ) { <S2SV_ModStart> RSA_PRV ) { int counter = 0 ; do { counter ++ ; <S2SV_ModEnd> m_len -- ; <S2SV_ModStart> while ( pad == RSA_PAD <S2SV_ModEnd> && m_len > <S2SV_ModStart> 0 ) ; * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; <S2SV_ModStart> if ( m_len > 0 && counter >= 8 <S2SV_ModEnd> ) { result <S2SV_ModStart> { result = RLC_OK ; } } } <S2SV_ModEnd> break ; }
",relic-toolkit@relic/76c9a1fdf19d9e92e566a77376673e522aae9f80,CVE-2020-36316,https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80,2021-04-07T21:15Z,562,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd>  bn_2SV_null> <S2SV_null> <S2SV_null>,0
1307,CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_get_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,563,"<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd>, va_list args",1
1308,CWE-362,"CWE-362 static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
","<S2SV_ModStart> { rq = <S2SV_ModEnd> hctx -> tags <S2SV_ModStart> hctx -> tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; if (
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,564,<S2SV_ModStart>,0
1309,CWE-119,"CWE-119 SNDFILE * sf_open ( const char * path , int mode , SF_INFO * sfinfo ) { SF_PRIVATE * psf ; assert ( sizeof ( sf_count_t ) == 8 ) ; <S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf_log_printf ( psf , ""File<S2SV_blank>:<S2SV_blank>%s\\n"" , path ) ; if ( copy_filename ( psf , path ) != 0 ) { sf_errno = psf -> error ; return NULL ; } ; psf -> file . mode = mode ; if ( strcmp ( path , ""-"" ) == 0 ) psf -> error = psf_set_stdio ( psf ) ; else psf -> error = psf_fopen ( psf ) ; return psf_open_file ( psf , sfinfo ) ; }
","<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,565,<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==,1
1310,CWE-119,"CWE-119 <S2SV_StartBug> static void fix_interp_filter ( VP9_COMMON * cm ) { <S2SV_EndBug> if ( cm -> interp_filter == SWITCHABLE ) { int count [ SWITCHABLE_FILTERS ] ; int i , j , c = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) <S2SV_StartBug> count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; <S2SV_EndBug> c += ( count [ i ] > 0 ) ; } if ( c == 1 ) { for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { if ( count [ i ] ) { cm -> interp_filter = i ; break ; } } } } }
","<S2SV_ModStart> VP9_COMMON * cm , FRAME_COUNTS * counts <S2SV_ModStart> i ] += counts -> <S2SV_ModEnd> switchable_interp [ j
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,566,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1311,CWE-787,"CWE-787 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
","<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false
",radare@radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf,CVE-2018-20460,https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,2018-12-25T19:29Z,567,,0
1312,CWE-119,"CWE-119 static void init_encode_frame_mb_context ( VP9_COMP * cpi ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; <S2SV_StartBug> x -> act_zbin_adj = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; <S2SV_EndBug> vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ; vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , 0 , 0 ) ; vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; <S2SV_EndBug> xd -> mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; vpx_memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ; <S2SV_StartBug> vpx_memset ( xd -> above_seg_context , 0 , <S2SV_EndBug> sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ; }
","<S2SV_ModStart> & cpi -> td . <S2SV_ModStart> mi_cols ) ; <S2SV_ModEnd> vp9_setup_src_planes ( x <S2SV_ModStart> cpi -> Source <S2SV_ModEnd> , 0 , <S2SV_ModStart> subsampling_y ) ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> MAX_MB_PLANE ) ; memset <S2SV_ModEnd> ( xd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,568,<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( x -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( x -> <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( x ->,0
1314,CWE-000,"CWE-000 uint16_t http_DissectRequest ( struct sess * sp ) { struct http_conn * htc ; struct http * hp ; uint16_t retval ; CHECK_OBJ_NOTNULL ( sp , SESS_MAGIC ) ; htc = sp -> htc ; CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; hp = sp -> http ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; hp -> logtag = HTTP_Rx ; retval = http_splitline ( sp -> wrk , sp -> fd , hp , htc , HTTP_HDR_REQ , HTTP_HDR_URL , HTTP_HDR_PROTO ) ; if ( retval != 0 ) { WSPR ( sp , SLT_HttpGarbage , htc -> rxbuf ) ; return ( retval ) ; } http_ProtoVer ( hp ) ; <S2SV_StartBug> retval = htc_request_check_host_hdr ( hp ) ; <S2SV_EndBug> if ( retval != 0 ) { <S2SV_StartBug> WSP ( sp , SLT_Error , ""Duplicated<S2SV_blank>Host<S2SV_blank>header"" ) ; <S2SV_EndBug> return ( retval ) ; } <S2SV_StartBug> return ( retval ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; retval = htc_request_check_hdrs <S2SV_ModEnd> ( sp , <S2SV_ModStart> ( sp , hp <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",varnish@Varnish-Cache/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c,CVE-2015-8852,https://github.com/varnish/Varnish-Cache/commit/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c,2016-04-25T14:59Z,569,<S2SV_ModStart>  retval ) ; retval = NULL ;,0
1315,CWE-20,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) <S2SV_StartBug> * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> colormap = ( <S2SV_ModStart> x ++ ) { <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t )
",ImageMagick@ImageMagick/7fdf9ea808caa3c81a0eb42656e5fafc59084198,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/7fdf9ea808caa3c81a0eb42656e5fafc59084198,2017-05-22T14:29Z,570,"<S2SV_ModStart> ; status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> rows ) ; return ( exception ) ; }",0
1318,CWE-284,"CWE-284 int btpan_tap_send ( int tap_fd , const BD_ADDR src , const BD_ADDR dst , UINT16 proto , const char * buf , UINT16 len , BOOLEAN ext , BOOLEAN forward ) { UNUSED ( ext ) ; UNUSED ( forward ) ; if ( tap_fd != INVALID_FD ) { tETH_HDR eth_hdr ; memcpy ( & eth_hdr . h_dest , dst , ETH_ADDR_LEN ) ; memcpy ( & eth_hdr . h_src , src , ETH_ADDR_LEN ) ; eth_hdr . h_proto = htons ( proto ) ; char packet [ TAP_MAX_PKT_WRITE_LEN + sizeof ( tETH_HDR ) ] ; memcpy ( packet , & eth_hdr , sizeof ( tETH_HDR ) ) ; if ( len > TAP_MAX_PKT_WRITE_LEN ) { LOG_ERROR ( ""btpan_tap_send<S2SV_blank>eth<S2SV_blank>packet<S2SV_blank>size:%d<S2SV_blank>is<S2SV_blank>exceeded<S2SV_blank>limit!"" , len ) ; return - 1 ; } memcpy ( packet + sizeof ( tETH_HDR ) , buf , len ) ; <S2SV_StartBug> int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ; <S2SV_EndBug> BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ; return ret ; } return - 1 ; }
","<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sizeof ( tETH_HDR )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,571,<S2SV_ModStart> ; ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ret ) ),0
1319,CWE-119,"CWE-119 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd = ps_dec -> u4_width_at_init ; UWORD16 pic_ht = ps_dec -> u4_height_at_init ; UWORD32 num_mbs ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; } num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> s_high_profile . u1_scaling_present = 0 ; ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; <S2SV_StartBug> if ( ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ MAX_REF_BUFS ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row ++ ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row + ( ( ps_dec -> u2_frm_wd_in_mbs + 1 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row ++ ; ps_dec -> pu1_y = ps_dec -> pu1_y_scratch [ 0 ] ; ps_dec -> pu1_u = ps_dec -> pu1_u_scratch [ 0 ] ; ps_dec -> pu1_v = ps_dec -> pu1_v_scratch [ 0 ] ; ps_dec -> u1_yuv_scratch_idx = 0 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_yleft = 0 ; ps_dec -> pu1_uleft = 0 ; ps_dec -> pu1_vleft = 0 ; ps_dec -> u1_not_wait_rec = 2 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_deblk_mbn_curr = ps_dec -> ps_deblk_mbn ; ps_dec -> ps_deblk_mbn_prev = ps_dec -> ps_deblk_mbn + ps_dec -> u1_recon_mb_grp ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> { ps_dec ->
",external@libavc/f634481e940421020e52f511c1fb34aac1db4b2f,CVE-2017-0543,https://android.googlesource.com/platform/external/libavc/+/f634481e940421020e52f511c1fb34aac1db4b2f,2017-04-07T22:59Z,572,,0
1323,CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> { struct mpt_ioctl_iocinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_iocinfo * karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> struct pci_dev * pdev ; <S2SV_EndBug> int iocnum ; unsigned int port ; int cim_rev ; struct scsi_device * sdev ; VirtDevice * vdevice ; if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev0 ) ) cim_rev = 0 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev1 ) ) cim_rev = 1 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo ) ) cim_rev = 2 ; else if ( data_size == ( sizeof ( struct mpt_ioctl_iocinfo_rev0 ) + 12 ) ) cim_rev = 0 ; else return - EFAULT ; karg = memdup_user ( uarg , data_size ) ; if ( IS_ERR ( karg ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()<S2SV_blank>-<S2SV_blank>memdup_user<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>[%ld]\\n"" , __FILE__ , __LINE__ , PTR_ERR ( karg ) ) ; <S2SV_StartBug> return PTR_ERR ( karg ) ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg -> hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_getiocinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; kfree ( karg ) ; return - ENODEV ; } if ( karg -> hdr . maxDataSize != data_size ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Structure<S2SV_blank>size<S2SV_blank>mismatch.<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>completed.\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; kfree ( karg ) ; return - EFAULT ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_getiocinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> bus_type == SAS ) karg -> adapterType = MPT_IOCTL_INTERFACE_SAS ; else if ( ioc -> bus_type == FC ) karg -> adapterType = MPT_IOCTL_INTERFACE_FC ; else karg -> adapterType = MPT_IOCTL_INTERFACE_SCSI ; if ( karg -> hdr . port > 1 ) { kfree ( karg ) ; return - EINVAL ; } port = karg -> hdr . port ; karg -> port = port ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg -> pciId = pdev -> device ; karg -> hwRev = pdev -> revision ; karg -> subSystemDevice = pdev -> subsystem_device ; karg -> subSystemVendor = pdev -> subsystem_vendor ; if ( cim_rev == 1 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; } else if ( cim_rev == 2 ) { karg -> pciInfo . u . bits . busNumber = pdev -> bus -> number ; karg -> pciInfo . u . bits . deviceNumber = PCI_SLOT ( pdev -> devfn ) ; karg -> pciInfo . u . bits . functionNumber = PCI_FUNC ( pdev -> devfn ) ; karg -> pciInfo . segmentID = pci_domain_nr ( pdev -> bus ) ; } karg -> numDevices = 0 ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; karg -> numDevices ++ ; } } karg -> FWVersion = ioc -> facts . FWVersion . Word ; karg -> BIOSVersion = ioc -> biosVersion ; strncpy ( karg -> driverVersion , MPT_LINUX_PACKAGE_NAME , MPT_IOCTL_VERSION_LENGTH ) ; karg -> driverVersion [ MPT_IOCTL_VERSION_LENGTH - 1 ] = '\\0' ; karg -> busChangeEvent = 0 ; karg -> hostId = ioc -> pfacts [ port ] . PortSCSIID ; karg -> rsvd [ 0 ] = karg -> rsvd [ 1 ] = 0 ; if ( copy_to_user ( ( char __user * ) arg , karg , data_size ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_getiocinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_iocinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( karg ) ; return - EFAULT ; } kfree ( karg ) ; return 0 ; }
","<S2SV_ModStart> int mptctl_getiocinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> * karg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> pci_dev * pdev <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ( karg ) <S2SV_ModEnd> ; } if
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,573,<S2SV_ModStart> int mptctl_ADAPTERS2SV_null> <S2SV_null> <S2SV_null>,0
1324,CWE-119,"CWE-119 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
","<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,574,,0
1326,CWE-119,"CWE-119 static Image * ReadHRZImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; ssize_t count , y ; size_t length ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 256 ; image -> rows = 240 ; image -> depth = 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) ( 3 * image -> columns ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z,575,,0
1330,CWE-000,"CWE-000 inline void update_rq_clock ( struct rq * rq ) <S2SV_StartBug> { <S2SV_EndBug> if ( ! rq -> skip_clock_update ) { int cpu = cpu_of ( rq ) ; <S2SV_StartBug> u64 irq_time ; <S2SV_EndBug> rq -> clock = sched_clock_cpu ( cpu ) ; irq_time = irq_time_cpu ( cpu ) ; if ( rq -> clock - irq_time > rq -> clock_task ) rq -> clock_task = rq -> clock - irq_time ; sched_irq_time_avg_update ( rq , irq_time ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * rq ) <S2SV_ModEnd> { int cpu <S2SV_ModStart> ; u64 irq_time ; if ( rq -> skip_clock_update ) return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z,576,<S2SV_ModStart> * rq ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>,0
1332,CWE-120,"CWE-120 static void process_options ( argc , argv ) int argc ; char * argv [ ] ; { int i , l ; while ( argc > 1 && argv [ 1 ] [ 0 ] == '-' ) { argv ++ ; argc -- ; l = ( int ) strlen ( * argv ) ; if ( l < 4 ) l = 4 ; switch ( argv [ 0 ] [ 1 ] ) { case 'D' : case 'd' : if ( ( argv [ 0 ] [ 1 ] == 'D' && ! argv [ 0 ] [ 2 ] ) || ! strcmpi ( * argv , ""-debug"" ) ) { wizard = TRUE , discover = FALSE ; } else if ( ! strncmpi ( * argv , ""-DECgraphics"" , l ) ) { load_symset ( ""DECGraphics"" , PRIMARY ) ; switch_symbols ( TRUE ) ; } else { <S2SV_StartBug> raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; <S2SV_EndBug> } break ; case 'X' : discover = TRUE , wizard = FALSE ; break ; # ifdef NEWS case 'n' : iflags . news = FALSE ; break ; # endif case 'u' : if ( argv [ 0 ] [ 2 ] ) { ( void ) strncpy ( plname , argv [ 0 ] + 2 , sizeof plname - 1 ) ; } else if ( argc > 1 ) { argc -- ; argv ++ ; ( void ) strncpy ( plname , argv [ 0 ] , sizeof plname - 1 ) ; } else { raw_print ( ""Player<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-u"" ) ; } break ; case 'I' : case 'i' : if ( ! strncmpi ( * argv , ""-IBMgraphics"" , l ) ) { load_symset ( ""IBMGraphics"" , PRIMARY ) ; load_symset ( ""RogueIBM"" , ROGUESET ) ; switch_symbols ( TRUE ) ; } else { <S2SV_StartBug> raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; <S2SV_EndBug> } break ; case 'p' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2role ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrole = i ; } else if ( argc > 1 ) { argc -- ; argv ++ ; if ( ( i = str2role ( argv [ 0 ] ) ) >= 0 ) flags . initrole = i ; } break ; case 'r' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2race ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrace = i ; } else if ( argc > 1 ) { argc -- ; argv ++ ; if ( ( i = str2race ( argv [ 0 ] ) ) >= 0 ) flags . initrace = i ; } break ; case 'w' : config_error_init ( FALSE , ""command<S2SV_blank>line"" , FALSE ) ; choose_windows ( & argv [ 0 ] [ 2 ] ) ; config_error_done ( ) ; break ; case '@' : flags . randomall = 1 ; break ; default : if ( ( i = str2role ( & argv [ 0 ] [ 1 ] ) ) >= 0 ) { flags . initrole = i ; break ; } } } # ifdef SYSCF if ( argc > 1 ) raw_printf ( ""MAXPLAYERS<S2SV_blank>are<S2SV_blank>set<S2SV_blank>in<S2SV_blank>sysconf<S2SV_blank>file.\\n"" ) ; # else if ( argc > 1 ) locknum = atoi ( argv [ 1 ] ) ; # endif # ifdef MAX_NR_OF_PLAYERS if ( ! locknum || locknum > MAX_NR_OF_PLAYERS ) locknum = MAX_NR_OF_PLAYERS ; # endif # ifdef SYSCF if ( ! locknum || ( sysopt . maxplayers && locknum > sysopt . maxplayers ) ) locknum = sysopt . maxplayers ; # endif }
","<S2SV_ModStart> { raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" <S2SV_ModEnd> , * argv <S2SV_ModStart> { raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" <S2SV_ModEnd> , * argv
",NetHack@NetHack/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,CVE-2020-5210,https://github.com/NetHack/NetHack/commit/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,2020-01-28T18:15Z,577,<S2SV_ModStart> ; } } if ( str [ 0 ] == NULL ) { stderr = - 1 ; } else if (,0
1335,CWE-125,"CWE-125 static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z,578,"<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao, buf_size, 8 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( data_size, buf_size, buf_size, 8 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( buf_size, buf_size, buf_size, buf_size, buf_size, buf_size ) ) { exif_log ( en -> log, EXIF_LOG_CODE_ERROR, ""ExifMnoteNote"", EXIF_CODE_CODE_CODE_DATA, ""ExifMnoteNote"" ) ; break ; } n -> entries [ tcount ]. tag = exif_get_short ( buf + o + o + o + o + o + o + o + s -> entries [ tcount ]. entries [ tcount ]. order ) ; n -> entries [ tcount ]. order = exif_get_short ( buf + 1, n -> order ) ) ; n -> entries [ tcount ]. order = exif_get_short ( en -> entries [ tcount ]. order ) ; n -> entries [ tcount ]. order = exif_log ( en -> log, EXIF_LOG_CODE_CODE_CODE_CODE",0
1336,CWE-119,"CWE-119 static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirin<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n"" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ; <S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> mainname = stringNew ( charbuf ) ; <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , ""-links.html"" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , ""name:<S2SV_blank>%s\\n"" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , ""file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n"" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ; <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug> sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , ""%s_view_%03d"" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , ""<frameset<S2SV_blank>cols=\\""%d,<S2SV_blank>*\\"">"" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""thumbs\\""<S2SV_blank>src=\\""%s\\"">"" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , ""<frame<S2SV_blank>name=\\""views\\""<S2SV_blank>src=\\""%s\\"">"" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , ""w"" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , ""******************************************\\n"" ""Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n"" ""******************************************\\n"" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , ""num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n"" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , ""<a<S2SV_blank>href=\\""%s\\""<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\""%s\\""></a>"" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , ""w"" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }
","<S2SV_ModStart> 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , ""%s/%s.html"" , <S2SV_ModStart> charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , ""%s/%s-links.html"" , <S2SV_ModStart> factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , ""%s_thumb_%03d"" ,
",DanBloomberg@leptonica/c1079bb8e77cdd426759e466729917ca37a3ed9f,CVE-2018-7247,https://github.com/DanBloomberg/leptonica/commit/c1079bb8e77cdd426759e466729917ca37a3ed9f,2018-02-19T18:29Z,579,,0
1338,CWE-416,"CWE-416 static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { <S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
","<S2SV_ModStart> dentry * dir <S2SV_ModEnd> ; int dir_has_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL )
",torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,CVE-2017-7374,https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,2017-03-31T20:59Z,580,<S2SV_ModStart> inode * dir <S2SV_ModEnd> ; int dir_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> int dir_key =,0
1339,CWE-295,"CWE-295 <S2SV_StartBug> void unbind_ports ( void ) { <S2SV_EndBug> SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ; <S2SV_StartBug> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_EndBug> opt = service_options . next ; <S2SV_StartBug> service_options . next = NULL ; <S2SV_EndBug> service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , ""Unbinding<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; } <S2SV_StartBug> if ( opt -> ctx ) <S2SV_EndBug> SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , ""Service<S2SV_blank>[%s]<S2SV_blank>closed"" , opt -> servname ) ; <S2SV_StartBug> { <S2SV_EndBug> SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> NOEXPORT <S2SV_ModStart> 1 ) ; for ( <S2SV_ModEnd> opt = service_options <S2SV_ModStart> . next ; opt ; opt = opt -> next <S2SV_ModEnd> ) { unsigned <S2SV_ModStart> 0 ; } <S2SV_ModEnd> s_log ( LOG_DEBUG <S2SV_ModStart> servname ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,581,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1341,CWE-119,"CWE-119 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; <S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; WritePixel ( i , & context , casspecial ) ; npix -- ; } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; WritePixels ( i , & context , stackp , stack_top - stackp ) ; npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
","<S2SV_ModStart> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
",miniupnp@ngiflib/b588a2249c7abbfc52173e32ee11d6facef82f89,CVE-2018-10677,https://github.com/miniupnp/ngiflib/commit/b588a2249c7abbfc52173e32ee11d6facef82f89,2018-05-02T19:29Z,582,<S2SV_ModStart> = 0 ; <S2SV_ModEnd> break ; if,0
1343,CWE-908,"CWE-908 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z,583,"<S2SV_ModStart>, & next_op ) ;",0
1344,CWE-20,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if (
",ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7,2018-09-06T22:29Z,584,"<S2SV_ModStart>, message ) \\",0
1345,CWE-354,"CWE-354 void recovery_delete_character ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }
","<S2SV_ModStart> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; }
",keepkey@keepkey-firmware/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,CVE-2019-18672,https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,2019-12-06T18:15Z,585,,0
1346,CWE-20,"CWE-20 error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,586,"<S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;",0
1347,CWE-125,"CWE-125 static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MagickPathExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MagickPathExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
",ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z,587,,0
1348,CWE-416,"CWE-416 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } <S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
",miniupnp@miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a,CVE-2016-3179,https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a,2017-03-24T15:59Z,588,<S2SV_ModStart> ; if ( ( <S2SV_ModEnd> sock ),0
1349,CWE-000,"CWE-000 WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) { <S2SV_StartBug> WORD32 i ; <S2SV_EndBug> WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ; WORD16 * pi2_delta_poc ; UWORD32 u4_max_poc_lsb ; pic_buf_t * ps_pic_buf ; mv_buf_t * ps_mv_buf ; UWORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; WORD32 ai4_poc_st_curr_before [ MAX_DPB_SIZE ] , ai4_poc_st_foll [ MAX_DPB_SIZE ] , ai4_poc_st_curr_after [ MAX_DPB_SIZE ] ; WORD32 ai4_poc_lt_curr [ MAX_DPB_SIZE ] , ai4_poc_lt_foll [ MAX_DPB_SIZE ] ; UWORD32 u4_num_st_curr_before , u4_num_st_foll , u4_num_st_curr_after , u4_num_lt_curr , u4_num_lt_foll ; UWORD32 u4_num_total_curr ; WORD8 ai1_curr_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] , ai1_foll_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_curr [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_after [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_before [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_list_temp0 [ MAX_DPB_SIZE ] , * as_ref_pic_list_temp1 [ MAX_DPB_SIZE ] ; UWORD32 u4_num_rps_curr_temp_list0 , u4_num_rps_curr_temp_list1 ; WORD32 i4_pic_order_cnt_val ; WORD32 i4_poc_lt ; UNUSED ( as_ref_pic_lt_foll ) ; UNUSED ( as_ref_pic_st_foll ) ; UNUSED ( ps_pps ) ; RETURN_IF_NAL_INFO ; u4_max_poc_lsb = ( 1 << ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; i4_pic_order_cnt_val = ps_slice_hdr -> i4_abs_pic_order_cnt ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; pi2_delta_poc = ps_sps -> as_stref_picset [ st_rps_idx ] . ai2_delta_poc ; } else { st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; pi2_delta_poc = ps_slice_hdr -> s_stref_picset . ai2_delta_poc ; } u4_num_st_curr_before = 0 ; u4_num_st_foll = 0 ; for ( i = 0 ; i < num_neg_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_before [ u4_num_st_curr_before ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_before ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_st_curr_after = 0 ; for ( i = num_neg_pics ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_after [ u4_num_st_curr_after ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_after ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_lt_curr = 0 ; u4_num_lt_foll = 0 ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { i4_poc_lt = ps_slice_hdr -> ai4_poc_lsb_lt [ i ] ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { i4_poc_lt += i4_pic_order_cnt_val - ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] * u4_max_poc_lsb - ps_slice_hdr -> i4_pic_order_cnt_lsb ; } if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { ai4_poc_lt_curr [ u4_num_lt_curr ] = i4_poc_lt ; ai1_curr_delta_poc_msb_present_flag [ u4_num_lt_curr ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_curr ++ ; } else { ai4_poc_lt_foll [ u4_num_lt_foll ] = i4_poc_lt ; ai1_foll_delta_poc_msb_present_flag [ u4_num_lt_foll ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_foll ++ ; } } u4_num_total_curr = u4_num_lt_curr + u4_num_st_curr_after + u4_num_st_curr_before ; if ( 0 == ps_codec -> i4_pic_present ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref = UNUSED_FOR_REF ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_curr ; i ++ ) { if ( 0 == ai1_curr_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_foll ; i ++ ) { if ( 0 == ai1_foll_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_before ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_before [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_after ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_after [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_foll ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_foll [ i ] = ps_pic_buf ; } u4_num_rps_curr_temp_list0 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l0_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { while ( r_idx < u4_num_rps_curr_temp_list0 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 ? ( void * ) as_ref_pic_list_temp0 [ ps_slice_hdr -> s_rplm . i1_list_entry_l0 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp0 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } if ( ps_slice_hdr -> i1_slice_type == BSLICE ) { u4_num_rps_curr_temp_list1 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l1_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx = 0 ; while ( r_idx < u4_num_rps_curr_temp_list1 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 ? ( void * ) as_ref_pic_list_temp1 [ ps_slice_hdr -> s_rplm . i1_list_entry_l1 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp1 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } } } DEBUG_PRINT_REF_LIST_POCS ( i4_pic_order_cnt_val , ps_slice_hdr , ps_dpb_mgr , u4_num_st_curr_before , u4_num_st_curr_after , u4_num_st_foll , u4_num_lt_curr , u4_num_lt_foll , ai4_poc_st_curr_before , ai4_poc_st_curr_after , ai4_poc_st_foll , ai4_poc_lt_curr , ai4_poc_lt_foll ) ; for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) && ( UNUSED_FOR_REF == ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref ) ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ps_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> break ; } ps_mv_buf ++ ; } } } return IHEVCD_SUCCESS ; }
","<S2SV_ModStart> { WORD32 i , j <S2SV_ModStart> ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> -> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF )
",external@libhevc/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,CVE-2017-0642,https://android.googlesource.com/platform/external/libhevc/+/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,2017-06-14T13:29Z,589,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
1352,CWE-119,"CWE-119 <S2SV_StartBug> static char * print_object ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> { char * * entries = 0 , * * names = 0 ; char * out = 0 , * ptr , * ret , * str ; int len = 7 , i = 0 , j ; cJSON * child = item -> child ; int numentries = 0 , fail = 0 ; <S2SV_StartBug> while ( child ) { <S2SV_EndBug> ++ numentries ; child = child -> next ; } if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ; if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; ++ depth ; if ( fmt ) len += depth ; while ( child ) { <S2SV_StartBug> names [ i ] = str = print_string_ptr ( child -> string ) ; <S2SV_EndBug> <S2SV_StartBug> entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ; <S2SV_EndBug> if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ; else fail = 1 ; child = child -> next ; } <S2SV_StartBug> if ( ! fail ) { <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len ) ; if ( ! out ) fail = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( fail ) { <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> if ( names [ i ] ) cJSON_free ( names [ i ] ) ; if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; return 0 ; } * out = '{' ; ptr = out + 1 ; <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> * ptr ++ = '\\n' ; * ptr = 0 ; <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> if ( fmt ) <S2SV_StartBug> for ( j = 0 ; j < depth ; ++ j ) <S2SV_EndBug> * ptr ++ = '\\t' ; <S2SV_StartBug> strcpy ( ptr , names [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += strlen ( names [ i ] ) ; <S2SV_EndBug> * ptr ++ = ':' ; <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> * ptr ++ = '\\t' ; strcpy ( ptr , entries [ i ] ) ; ptr += strlen ( entries [ i ] ) ; if ( i != numentries - 1 ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; cJSON_free ( names [ i ] ) ; cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; if ( fmt ) <S2SV_StartBug> for ( i = 0 ; i < depth - 1 ; ++ i ) <S2SV_EndBug> * ptr ++ = '\\t' ; * ptr ++ = '}' ; <S2SV_StartBug> * ptr ++ = 0 ; <S2SV_EndBug> return out ; }
","<S2SV_ModStart> , int fmt , printbuffer * p <S2SV_ModStart> = 0 ; size_t tmplen = 0 ; <S2SV_ModStart> ( child ) numentries ++ , child = child -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ; else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ; if ( ! out ) return 0 ; ptr = out ; * ptr ++ = '{' ; if ( fmt ) { * ptr ++ = '\\n' ; for ( i = 0 ; i < depth ; i ++ ) * ptr ++ = '\\t' ; } * ptr ++ = '}' ; * ptr ++ = 0 ; return out ; } if ( p ) { i = p -> offset ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = '{' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = item -> child ; depth ++ ; while ( child ) { if ( fmt ) { ptr = ensure ( p , depth ) ; if ( ! ptr ) return 0 ; for ( j = 0 ; j < depth ; j ++ ) * ptr ++ = '\\t' ; p -> offset += depth ; } print_string_ptr ( child -> string , p ) ; p -> offset = update ( p ) ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len ) ; if ( ! ptr ) return 0 ; * ptr ++ = ':' ; if ( fmt ) * ptr ++ = '\\t' ; p -> offset += len ; print_value ( child , depth , fmt , p ) ; p -> offset = update ( p ) ; len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; if ( child -> next ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = child -> next ; } ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ; if ( ! ptr ) return 0 ; if ( fmt ) for ( i = 0 ; i < depth - 1 ; i ++ ) * ptr ++ = '\\t' ; * ptr ++ = '}' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! names ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; depth ++ ; if ( fmt ) len += depth ; while ( child && ! fail ) <S2SV_ModEnd> { names [ <S2SV_ModStart> child -> string , 0 <S2SV_ModStart> depth , fmt , 0 <S2SV_ModStart> ! fail ) <S2SV_ModEnd> out = ( <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( fail <S2SV_ModStart> < numentries ; i ++ <S2SV_ModEnd> ) { if <S2SV_ModStart> + 1 ; if ( fmt ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> < numentries ; i ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> < depth ; j ++ ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> = '\\t' ; tmplen = strlen ( <S2SV_ModEnd> names [ i <S2SV_ModStart> ] ) ; memcpy ( ptr , <S2SV_ModEnd> names [ i <S2SV_ModStart> [ i ] , tmplen ) ; ptr += tmplen <S2SV_ModEnd> ; * ptr <S2SV_ModStart> = ':' ; if ( fmt ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> - 1 ; i ++ ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> = '}' ; * ptr ++ = 0 ; } <S2SV_ModEnd> return out ;
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,590,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1354,CWE-787,"CWE-787 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
","<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,591,"<S2SV_ModStart> int tagval, uint32 <S2SV_ModEnd> * length )",1
1355,CWE-000,"CWE-000 static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; <S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> if ( other ) { <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> writable = 0 ; <S2SV_StartBug> } <S2SV_EndBug> sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }
","<S2SV_ModStart> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> other ) != <S2SV_ModStart> ) != sk && <S2SV_ModEnd> unix_recvq_full ( other <S2SV_ModStart> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> = 0 ; unix_state_unlock ( sk <S2SV_ModEnd> ) ; }
",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z,592,<S2SV_ModStart> = 0 ; sock_lock ( sk ) ;,0
1357,CWE-20,"CWE-20 void Rectangle ( double x , double y , double w , double h ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> h ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , <S2SV_ModStart> h ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,593,"<S2SV_ModStart> y3 ) { sprintf ( outputbuffer <S2SV_ModEnd>, ""%12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> w"", outputbuffer",0
1359,CWE-20,"CWE-20 <S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> { struct io_context * ioc ; <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
","<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
",torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z,594,<S2SV_ModStart> void task_context ( struct task <S2SV_ModEnd> ; struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; task <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; task <S2SV_ModStart> ; task <S2SV_ModEnd> -> io_context =,0
1360,CWE-200,"CWE-200 int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z,595,,0
1361,CWE-119,"CWE-119 static OM_uint32 kg_unseal_v1_iov ( krb5_context context , OM_uint32 * minor_status , krb5_gss_ctx_id_rec * ctx , gss_iov_buffer_desc * iov , int iov_count , size_t token_wrapper_len , int * conf_state , gss_qop_t * qop_state , int toktype ) { OM_uint32 code ; gss_iov_buffer_t header ; gss_iov_buffer_t trailer ; unsigned char * ptr ; int sealalg ; int signalg ; krb5_checksum cksum ; krb5_checksum md5cksum ; size_t cksum_len = 0 ; size_t conflen = 0 ; int direction ; krb5_ui_4 seqnum ; OM_uint32 retval ; size_t sumlen ; krb5_keyusage sign_usage = KG_USAGE_SIGN ; md5cksum . length = cksum . length = 0 ; md5cksum . contents = cksum . contents = NULL ; header = kg_locate_header_iov ( iov , iov_count , toktype ) ; assert ( header != NULL ) ; trailer = kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_TRAILER ) ; if ( trailer != NULL && trailer -> buffer . length != 0 ) { <S2SV_StartBug> * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; } <S2SV_StartBug> if ( header -> buffer . length < token_wrapper_len + 14 ) { <S2SV_EndBug> * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } ptr = ( unsigned char * ) header -> buffer . value + token_wrapper_len ; signalg = ptr [ 0 ] ; signalg |= ptr [ 1 ] << 8 ; sealalg = ptr [ 2 ] ; sealalg |= ptr [ 3 ] << 8 ; if ( ptr [ 4 ] != 0xFF || ptr [ 5 ] != 0xFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype == KG_TOK_WRAP_MSG && ! ( sealalg == 0xFFFF || sealalg == ctx -> sealalg ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ( ctx -> sealalg == SEAL_ALG_NONE && signalg > 1 ) || ( ctx -> sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3 ) || ( ctx -> sealalg == SEAL_ALG_DES3KD && signalg != SGN_ALG_HMAC_SHA1_DES3_KD ) || ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 && signalg != SGN_ALG_HMAC_MD5 ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_HMAC_MD5 : cksum_len = 8 ; if ( toktype != KG_TOK_WRAP_MSG ) sign_usage = 15 ; break ; case SGN_ALG_3 : cksum_len = 16 ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : cksum_len = 20 ; break ; default : * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } code = kg_get_seq_num ( context , ctx -> seq , ptr + 14 , ptr + 6 , & direction , & seqnum ) ; if ( code != 0 ) { * minor_status = code ; return GSS_S_BAD_SIG ; } if ( toktype == KG_TOK_WRAP_MSG ) { if ( sealalg != 0xFFFF ) { if ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 ) { unsigned char bigend_seqnum [ 4 ] ; krb5_keyblock * enc_key ; size_t i ; store_32_be ( seqnum , bigend_seqnum ) ; code = krb5_k_key_keyblock ( context , ctx -> enc , & enc_key ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } assert ( enc_key -> length == 16 ) ; for ( i = 0 ; i < enc_key -> length ; i ++ ) ( ( char * ) enc_key -> contents ) [ i ] ^= 0xF0 ; code = kg_arcfour_docrypt_iov ( context , enc_key , 0 , & bigend_seqnum [ 0 ] , 4 , iov , iov_count ) ; krb5_free_keyblock ( context , enc_key ) ; } else { code = kg_decrypt_iov ( context , 0 , ( ( ctx -> gss_flags & GSS_C_DCE_STYLE ) != 0 ) , 0 , 0 , ctx -> enc , KG_USAGE_SEAL , NULL , iov , iov_count ) ; } if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } } conflen = kg_confounder_size ( context , ctx -> enc -> keyblock . enctype ) ; } if ( header -> buffer . length != token_wrapper_len + 14 + cksum_len + conflen ) { retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_DES_MAC : case SGN_ALG_3 : md5cksum . checksum_type = CKSUMTYPE_RSA_MD5 ; break ; case SGN_ALG_HMAC_MD5 : md5cksum . checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : md5cksum . checksum_type = CKSUMTYPE_HMAC_SHA1_DES3 ; break ; default : abort ( ) ; } code = krb5_c_checksum_length ( context , md5cksum . checksum_type , & sumlen ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } md5cksum . length = sumlen ; code = kg_make_checksum_iov_v1 ( context , md5cksum . checksum_type , cksum_len , ctx -> seq , ctx -> enc , sign_usage , iov , iov_count , toktype , & md5cksum ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_3 : code = kg_encrypt_inplace ( context , ctx -> seq , KG_USAGE_SEAL , ( g_OID_equal ( ctx -> mech_used , gss_mech_krb5_old ) ? ctx -> seq -> keyblock . contents : NULL ) , md5cksum . contents , 16 ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } cksum . length = cksum_len ; cksum . contents = md5cksum . contents + 16 - cksum . length ; code = k5_bcmp ( cksum . contents , ptr + 14 , cksum . length ) ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : case SGN_ALG_HMAC_MD5 : code = k5_bcmp ( md5cksum . contents , ptr + 14 , cksum_len ) ; break ; default : code = 0 ; retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; break ; } if ( code != 0 ) { code = 0 ; retval = GSS_S_BAD_SIG ; goto cleanup ; } if ( toktype == KG_TOK_WRAP_MSG && ( ctx -> gss_flags & GSS_C_DCE_STYLE ) == 0 ) { retval = kg_fixup_padding_iov ( & code , iov , iov_count ) ; if ( retval != GSS_S_COMPLETE ) goto cleanup ; } if ( conf_state != NULL ) * conf_state = ( sealalg != 0xFFFF ) ; if ( qop_state != NULL ) * qop_state = GSS_C_QOP_DEFAULT ; if ( ( ctx -> initiate && direction != 0xff ) || ( ! ctx -> initiate && direction != 0 ) ) { * minor_status = ( OM_uint32 ) G_BAD_DIRECTION ; retval = GSS_S_BAD_SIG ; } code = 0 ; retval = g_order_check ( & ctx -> seqstate , ( gssint_uint64 ) seqnum ) ; cleanup : krb5_free_checksum_contents ( context , & md5cksum ) ; * minor_status = code ; return retval ; }
","<S2SV_ModStart> OM_uint32 ) KRB5_BAD_MSIZE ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> < token_wrapper_len + 22 <S2SV_ModEnd> ) { *
",krb5@krb5/e6ae703ae597d798e310368d52b8f38ee11c6a73,CVE-2014-4342,https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73,2014-07-20T11:12Z,596,<S2SV_ModStart> ; if ( len < 0 ||,0
1363,CWE-119,"CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> if ( frame != NULL ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> { vp9_ref_frame_t * const <S2SV_ModStart> YV12_BUFFER_CONFIG * fb = get_ref_frame ( & <S2SV_ModEnd> ctx -> cpi <S2SV_ModStart> ctx -> cpi -> common <S2SV_ModStart> frame -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,597,"<S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args ) <S2SV_ModStart> * ctx, <S2SV_ModEnd> va_list args )",0
1365,CWE-399,"CWE-399 long do_io_submit ( aio_context_t ctx_id , long nr , struct iocb __user * __user * iocbpp , bool compat ) { struct kioctx * ctx ; long ret = 0 ; int i = 0 ; struct blk_plug plug ; struct kiocb_batch batch ; if ( unlikely ( nr < 0 ) ) return - EINVAL ; if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) return - EFAULT ; ctx = lookup_ioctx ( ctx_id ) ; if ( unlikely ( ! ctx ) ) { pr_debug ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>invalid<S2SV_blank>context<S2SV_blank>id\\n"" ) ; return - EINVAL ; } kiocb_batch_init ( & batch , nr ) ; blk_start_plug ( & plug ) ; for ( i = 0 ; i < nr ; i ++ ) { struct iocb __user * user_iocb ; struct iocb tmp ; if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { ret = - EFAULT ; break ; } if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { ret = - EFAULT ; break ; } ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; if ( ret ) break ; } blk_finish_plug ( & plug ) ; <S2SV_StartBug> kiocb_batch_free ( & batch ) ; <S2SV_EndBug> put_ioctx ( ctx ) ; return i ? i : ret ; }
","<S2SV_ModStart> ; kiocb_batch_free ( ctx ,
",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z,598,<S2SV_ModStart> ctx ) ; <S2SV_ModEnd> return ret,0
1369,CWE-362,"CWE-362 int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , <S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> { int got_error ; uint i ; ulong length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM sort_param ; MYISAM_SHARE * share = info -> s ; HA_KEYSEG * keyseg ; ulong * rec_per_key_part ; char llbuff [ 22 ] ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; DBUG_ENTER ( ""mi_repair_by_sort"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>extra<S2SV_blank>record"" ) ; goto err ; } if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_param . filepos = new_header_length ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; sort_param . wordlist = NULL ; init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ; else length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ; sort_param . key_cmp = sort_key_cmp ; sort_param . lock_in_memory = lock_memory ; sort_param . tmpdir = param -> tmpdir ; sort_param . sort_info = & sort_info ; sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param . master = 1 ; del = info -> state -> del ; param -> glob_crc = 0 ; if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ; rec_per_key_part = param -> rec_per_key_part ; for ( sort_param . key = 0 ; sort_param . key < share -> base . keys ; rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) { sort_param . read_cache = param -> read_cache ; sort_param . keyinfo = share -> keyinfo + sort_param . key ; sort_param . seg = sort_param . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , sort_param . key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; DBUG_PRINT ( ""repair"" , ( ""skipping<S2SV_blank>seemingly<S2SV_blank>disabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; continue ; } if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , sort_param . key + 1 ) ; sort_param . max_pos = sort_param . pos = share -> pack . header_length ; keyseg = sort_param . seg ; bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ; sort_param . key_length = share -> rec_reflength ; for ( i = 0 ; keyseg [ i ] . type != HA_KEYTYPE_END ; i ++ ) { sort_param . key_length += keyseg [ i ] . length ; if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ; if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ; if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ; } info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ; sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; if ( sort_param . keyinfo -> parser == & ft_default_parser ) { sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ; } else { sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ; } sort_param . key_read = sort_ft_key_read ; sort_param . key_write = sort_ft_key_write ; } else { sort_param . key_read = sort_key_read ; sort_param . key_write = sort_key_write ; } if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) { param -> retry_repair = 1 ; goto err ; } sort_param . calc_checksum = 0 ; free_root ( & sort_param . wordroot , MYF ( 0 ) ) ; sort_info . max_records = ( ha_rows ) info -> state -> records ; if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ; mi_set_key_active ( share -> state . key_map , sort_param . key ) ; DBUG_PRINT ( ""repair"" , ( ""set<S2SV_blank>enabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; if ( sort_param . fix_datafile ) { param -> read_cache . end_of_file = sort_param . filepos ; if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; sort_param . fix_datafile = 0 ; } else info -> state -> data_file_length = sort_param . max_pos ; param -> read_cache . file = info -> dfile ; reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ; } if ( param -> testflag & T_WRITE_LOOP ) { ( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\r"" , stdout ) ; ( void ) fflush ( stdout ) ; } if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; got_error = 1 ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) { <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ; my_free ( sort_info . key_block ) ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }
","<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z,599,"<S2SV_ModStart>, int flags <S2SV_ModEnd> ; if (",0
1370,CWE-000,"CWE-000 static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ; <S2SV_StartBug> # if uECC_VLI_NATIVE_LITTLE_ENDIAN <S2SV_EndBug> uECC_word_t * p = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ; <S2SV_StartBug> EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; <S2SV_EndBug> if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; # if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0 uECC_vli_nativeToBytes ( signature , curve -> num_bytes , p ) ; # endif # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # else uECC_vli_bytesToNative ( tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # endif s [ num_n_words - 1 ] = 0 ; uECC_vli_set ( s , p , num_words ) ; uECC_vli_modMult ( s , tmp , s , curve -> n , num_n_words ) ; bits2int ( tmp , message_hash , hash_size , curve ) ; uECC_vli_modAdd ( s , tmp , s , curve -> n , num_n_words ) ; uECC_vli_modMult ( s , s , k , curve -> n , num_n_words ) ; if ( uECC_vli_numBits ( s , num_n_words ) > ( bitcount_t ) curve -> num_bytes * 8 ) { return 0 ; } # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) signature + curve -> num_bytes , ( uint8_t * ) s , curve -> num_bytes ) ; # else uECC_vli_nativeToBytes ( signature + curve -> num_bytes , curve -> num_bytes , s ) ; # endif return 1 ; }
","<S2SV_ModStart> s } ; uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> curve ) ; if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> carry ] , initial_Z <S2SV_ModEnd> , num_n_bits +
",kmackay@micro-ecc/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,CVE-2020-27209,https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,2021-05-20T21:15Z,600,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
1371,CWE-125,"CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,601,"<S2SV_ModStart> ( ndo, ""%s"", rpl_tstr <S2SV_ModEnd> ) ) ;",1
1374,CWE-190,"CWE-190 void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ; <S2SV_StartBug> } else { <S2SV_EndBug> uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; } <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ; } else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> ; } } else { free ( buf ) ; }
",viabtc@viabtc_exchange_server/4a7c27bfe98f409623d4d857894d017ff0672cc9,CVE-2018-17568,https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8,2018-09-26T22:29Z,602,<S2SV_ModStart> ; } } else { free ( buf ) ; },0
1376,CWE-269,"CWE-269 STATIC_OVL void escapes ( cp , tp ) const char * cp ; char * tp ; { <S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) { <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> const char * dp ; <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ; <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; else for ( ; * cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 10 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; } <S2SV_StartBug> cp ++ ; <S2SV_EndBug> } else if ( * cp == '^' && cp [ 1 ] ) { cval = ( * ++ cp & 0x1f ) ; cp ++ ; } else cval = * cp ++ ; if ( meta ) cval |= 0x80 ; <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug> } * tp = '\\0' ; }
","<S2SV_ModStart> tp ; { static <S2SV_ModEnd> NEARDATA const char <S2SV_ModStart> NEARDATA const char oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , <S2SV_ModStart> dp ; int cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> == 'x' || <S2SV_ModStart> == 'x' || cp [ 1 ] <S2SV_ModEnd> == 'X' ) <S2SV_ModStart> == 'X' ) && cp [ 2 ] <S2SV_ModEnd> && ( dp <S2SV_ModStart> ( hex , cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> cval = ( <S2SV_ModStart> 2 ) ; } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> { switch ( <S2SV_ModStart> cp ; } ++ cp ; } <S2SV_ModEnd> if ( meta <S2SV_ModStart> tp ++ = ( char )
",NetHack@NetHack/612755bfb5c412079795c68ba392df5d93874ed8,CVE-2020-5253,https://github.com/NetHack/NetHack/commit/612755bfb5c412079795c68ba392df5d93874ed8,2020-03-10T17:15Z,603,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> 0 <S2SV_ModStart> * cp [ 1 ] ; * cp [ 1 ] = 0 ; * cp ++ ; if ( * cp [ 1 ] == '\\0' ) p ++ ; if ( * cp [ 1 ] == '\\0' ) p ++ ; p ++ ; if ( * cp [ 1 ] == '\\0' || * cp [ 0 ] == '\\0' || * cp [ 1 ] == '\\0' ) p ++ ; if ( * cp [ 1 ] == '\\0' && * cp [ 1 ] == '\\0' && * cp [ 1 ] == '\\0' && * cp [ 1 ] = 0x' && * cp ++ ; if ( * cp [ 0 ] == '\\0' ) { * cp [ 0 ] = 0 ] = 0 ; * cp [ 0 ] = 0 ; * cp ++ ; * cp [ 1 ] = 0 ] = 0 ; * cp ++ ; * cp [ 0 ] = 0 ] = 0 ; * cp ++ ; * cp ++ ; if ( * cp == '\\0' && * cp [ 0 ] == '\\\\' <S2SV_ModEnd> == '\\0' ) <S2SV_ModStart> ; if ( <S2SV_ModStart>,0
1377,CWE-119,"CWE-119 <S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) { return 1 ; } return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,604,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
1379,CWE-125,"CWE-125 PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; <S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }
","<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1
",DanBloomberg@leptonica/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,CVE-2020-36281,https://github.com/DanBloomberg/leptonica/commit/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,2021-03-12T01:15Z,605,<S2SV_ModStart> DCT * pix = NULL,0
1381,CWE-119,"CWE-119 static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ; <S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } } } }
","<S2SV_ModStart> . vf = vpx_mse16x16 <S2SV_ModEnd> ; xd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,606,<S2SV_ModStart> best_mv ; vpx_mv = 0 ;,0
1382,CWE-000,"CWE-000 static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; <S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z,607,<S2SV_ModStart> crypto_kfree ; strncpy <S2SV_ModEnd> ( skb.,0
1385,CWE-416,"CWE-416 int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; <S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
","<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
",torvalds@linux/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,CVE-2014-4653,https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,2014-07-03T04:22Z,608,<S2SV_ModStart> -> count ; unsigned int count ; <S2SV_ModStart> -> count ; idx < <S2SV_ModEnd> count ; idx,0
1387,CWE-190,"CWE-190 MONGO_EXPORT int mongo_insert_batch ( mongo * conn , const char * ns , const bson * * bsons , int count , mongo_write_concern * custom_write_concern , int flags ) { mongo_message * mm ; mongo_write_concern * write_concern = NULL ; int i ; char * data ; <S2SV_StartBug> int overhead = 16 + 4 + strlen ( ns ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> int size = overhead ; <S2SV_EndBug> if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ; for ( i = 0 ; i < count ; i ++ ) { size += bson_size ( bsons [ i ] ) ; if ( mongo_bson_valid ( conn , bsons [ i ] , 1 ) != MONGO_OK ) return MONGO_ERROR ; } if ( ( size - overhead ) > conn -> max_bson_size ) { conn -> err = MONGO_BSON_TOO_LARGE ; return MONGO_ERROR ; } if ( mongo_choose_write_concern ( conn , custom_write_concern , & write_concern ) == MONGO_ERROR ) { return MONGO_ERROR ; } mm = mongo_message_create ( size , 0 , 0 , MONGO_OP_INSERT ) ; data = & mm -> data ; if ( flags & MONGO_CONTINUE_ON_ERROR ) data = mongo_data_append32 ( data , & ONE ) ; else data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , ns , strlen ( ns ) + 1 ) ; for ( i = 0 ; i < count ; i ++ ) { data = mongo_data_append ( data , bsons [ i ] -> data , bson_size ( bsons [ i ] ) ) ; } if ( write_concern ) { if ( mongo_message_send ( conn , mm ) == MONGO_ERROR ) { return MONGO_ERROR ; } return mongo_check_last_error ( conn , ns , write_concern ) ; } else { return mongo_message_send ( conn , mm ) ; } }
","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> overhead = 16 <S2SV_ModStart> + 1 ; size_t <S2SV_ModEnd> size = overhead
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z,609,<S2SV_ModStart> ; size_t <S2SV_ModEnd> size ; size_t,0
1394,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { UINT16 length ; WLog_DBG ( TAG , ""RDP_NEG_RSP"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) { WLog_ERR ( TAG , ""Invalid<S2SV_blank>RDP_NEG_RSP"" ) ; nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> return ; <S2SV_EndBug> } Stream_Read_UINT8 ( s , nego -> flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> SelectedProtocol ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_response ( rdpNego <S2SV_ModStart> NEGO_STATE_FAIL ; return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,610,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModStart> ; if (! Stream_GetRemainingLength ( s ) ) return FALSE,0
1395,CWE-119,"CWE-119 int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ; <S2SV_StartBug> int i , target_bits_per_mb ; <S2SV_EndBug> const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do { <S2SV_StartBug> const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , <S2SV_EndBug> <S2SV_StartBug> correction_factor ) ; <S2SV_EndBug> if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ; <S2SV_StartBug> return q ; <S2SV_EndBug> }
","<S2SV_ModStart> i , target_bits_per_mb , bits_per_mb_at_this_q <S2SV_ModStart> ; do { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> bits_per_mb_at_this_q = ( <S2SV_ModStart> i , correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( bits_per_mb_at_this_q <S2SV_ModStart> active_worst_quality ) ; if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,611,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1396,CWE-20,"CWE-20 error_t tja1101Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1101...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1101_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1101WritePhyReg ( interface , TJA1101_BASIC_CTRL , TJA1101_BASIC_CTRL_RESET ) ; while ( tja1101ReadPhyReg ( interface , TJA1101_BASIC_CTRL ) & TJA1101_BASIC_CTRL_RESET ) { } tja1101DumpPhyReg ( interface ) ; value = tja1101ReadPhyReg ( interface , TJA1101_EXTENDED_CTRL ) ; value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ; tja1101WritePhyReg ( interface , TJA1101_EXTENDED_CTRL , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_CONFIG1 ) ; value &= ~ TJA1101_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_COMM_CTRL ) ; value |= TJA1101_COMM_CTRL_AUTO_OP ; tja1101WritePhyReg ( interface , TJA1101_COMM_CTRL , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> ; tja1101WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,612,"<S2SV_ModStart> ( interface, NULL",0
1397,CWE-200,"CWE-200 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z,613,<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher.,1
1401,CWE-125,"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z,614,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1402,CWE-119,"CWE-119 static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , <S2SV_StartBug> MB_PREDICTION_MODE mode , TX_SIZE tx_size , <S2SV_EndBug> int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; <S2SV_EndBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> once ( init_intra_pred_fn_ptrs ) ; <S2SV_EndBug> if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ; <S2SV_StartBug> vpx_memset ( left_col , 129 , 64 ) ; <S2SV_EndBug> if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } <S2SV_StartBug> } <S2SV_EndBug> if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { <S2SV_StartBug> if ( x0 + 2 * bs <= frame_width ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else { <S2SV_StartBug> vpx_memcpy ( above_row , above_ref , bs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bs == 4 && right_available ) <S2SV_EndBug> vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } <S2SV_StartBug> } <S2SV_EndBug> } else { vpx_memset ( above_row , 127 , bs * 2 ) ; <S2SV_StartBug> above_row [ - 1 ] = 127 ; <S2SV_EndBug> } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }
","<S2SV_ModStart> int dst_stride , PREDICTION_MODE <S2SV_ModEnd> mode , TX_SIZE <S2SV_ModStart> int i ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> uint8_t , left_col [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> ) ; uint8_t <S2SV_ModStart> plane ] ; <S2SV_ModEnd> if ( plane <S2SV_ModStart> + y ; if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> if ( left_available <S2SV_ModStart> ; } } else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart> ( x0 + <S2SV_ModEnd> bs <= frame_width <S2SV_ModStart> frame_width ) { memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <= frame_width ) <S2SV_ModStart> - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> if ( bs <S2SV_ModStart> 4 && right_available && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> above_row [ - <S2SV_ModStart> 129 ; } else { memset <S2SV_ModEnd> ( above_row , <S2SV_ModStart> = 127 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,615,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1403,CWE-000,"CWE-000 static xsltCompMatchPtr xsltCompilePatternInternal ( const xmlChar * pattern , xmlDocPtr doc , xmlNodePtr node , xsltStylesheetPtr style , xsltTransformContextPtr runtime , int novar ) { xsltParserContextPtr ctxt = NULL ; xsltCompMatchPtr element , first = NULL , previous = NULL ; int current , start , end , level , j ; if ( pattern == NULL ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; return ( NULL ) ; } ctxt = xsltNewParserContext ( style , runtime ) ; if ( ctxt == NULL ) return ( NULL ) ; ctxt -> doc = doc ; ctxt -> elem = node ; current = end = 0 ; while ( pattern [ current ] != 0 ) { start = current ; while ( IS_BLANK_CH ( pattern [ current ] ) ) current ++ ; end = current ; level = 0 ; while ( ( pattern [ end ] != 0 ) && ( ( pattern [ end ] != '|' ) || ( level != 0 ) ) ) { if ( pattern [ end ] == '[' ) level ++ ; else if ( pattern [ end ] == ']' ) level -- ; else if ( pattern [ end ] == '\\'' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != '\\'' ) ) end ++ ; } else if ( pattern [ end ] == \'""\' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != \'""\' ) ) end ++ ; } <S2SV_StartBug> end ++ ; <S2SV_EndBug> } if ( current == end ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; goto error ; } element = xsltNewCompMatch ( ) ; if ( element == NULL ) { goto error ; } if ( first == NULL ) first = element ; else if ( previous != NULL ) previous -> next = element ; previous = element ; ctxt -> comp = element ; ctxt -> base = xmlStrndup ( & pattern [ start ] , end - start ) ; if ( ctxt -> base == NULL ) goto error ; ctxt -> cur = & ( ctxt -> base ) [ current - start ] ; element -> pattern = ctxt -> base ; element -> nsList = xmlGetNsList ( doc , node ) ; j = 0 ; if ( element -> nsList != NULL ) { while ( element -> nsList [ j ] != NULL ) j ++ ; } element -> nsNr = j ; # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsing<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; # endif element -> priority = 0 ; xsltCompileLocationPathPattern ( ctxt , novar ) ; if ( ctxt -> error ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltReverseCompMatch ( ctxt , element ) ; if ( element -> priority == 0 ) { if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_ELEM ) || ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) || ( element -> steps [ 0 ] . op == XSLT_OP_PI ) ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value2 != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_NS ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value == NULL ) && ( element -> steps [ 0 ] . value2 == NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_PI ) || ( element -> steps [ 0 ] . op == XSLT_OP_TEXT ) || ( element -> steps [ 0 ] . op == XSLT_OP_ALL ) || ( element -> steps [ 0 ] . op == XSLT_OP_NODE ) || ( element -> steps [ 0 ] . op == XSLT_OP_COMMENT ) ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else { element -> priority = 0.5 ; } } # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsed<S2SV_blank>%s,<S2SV_blank>default<S2SV_blank>priority<S2SV_blank>%f\\n"" , element -> pattern , element -> priority ) ; # endif if ( pattern [ end ] == '|' ) end ++ ; current = end ; } if ( end == 0 ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltFreeParserContext ( ctxt ) ; return ( first ) ; error : if ( ctxt != NULL ) xsltFreeParserContext ( ctxt ) ; if ( first != NULL ) xsltFreeCompMatchList ( first ) ; return ( NULL ) ; }
","<S2SV_ModStart> ++ ; } if ( pattern [ end ] == 0 ) break ;
",chromium@chromium/094c773bb6c144f07b004ff3d1886100f157f4f6,,https://github.com/chromium/chromium/commit/094c773bb6c144f07b004ff3d1886100f157f4f6, ,616,,0
1406,CWE-000,"CWE-000 static struct inode * ext4_alloc_inode ( struct super_block * sb ) { struct ext4_inode_info * ei ; ei = kmem_cache_alloc ( ext4_inode_cachep , GFP_NOFS ) ; if ( ! ei ) return NULL ; ei -> vfs_inode . i_version = 1 ; ei -> vfs_inode . i_data . writeback_index = 0 ; memset ( & ei -> i_cached_extent , 0 , sizeof ( struct ext4_ext_cache ) ) ; INIT_LIST_HEAD ( & ei -> i_prealloc_list ) ; spin_lock_init ( & ei -> i_prealloc_lock ) ; jbd2_journal_init_jbd_inode ( & ei -> jinode , & ei -> vfs_inode ) ; ei -> i_reserved_data_blocks = 0 ; ei -> i_reserved_meta_blocks = 0 ; ei -> i_allocated_meta_blocks = 0 ; ei -> i_da_metadata_calc_len = 0 ; ei -> i_delalloc_reserved_flag = 0 ; spin_lock_init ( & ( ei -> i_block_reservation_lock ) ) ; # ifdef CONFIG_QUOTA ei -> i_reserved_quota = 0 ; # endif INIT_LIST_HEAD ( & ei -> i_completed_io_list ) ; <S2SV_StartBug> ei -> cur_aio_dio = NULL ; <S2SV_EndBug> ei -> i_sync_tid = 0 ; ei -> i_datasync_tid = 0 ; return & ei -> vfs_inode ; }
","<S2SV_ModStart> i_completed_io_list ) ; spin_lock_init ( & ei -> i_completed_io_lock ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z,617,<S2SV_ModStart> = NULL ; ret = NULL ;,0
1407,CWE-476,"CWE-476 static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
",torvalds@linux/371528caec553785c37f73fa3926ea0de84f986f,CVE-2012-1146,https://github.com/torvalds/linux/commit/371528caec553785c37f73fa3926ea0de84f986f,2012-05-17T11:00Z,618,<S2SV_ModStart> ( ) ; free ( ) ;,0
1408,CWE-264,"CWE-264 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z,619,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1409,CWE-119,"CWE-119 static void write_uncompressed_header ( VP9_COMP * cpi , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; <S2SV_EndBug> write_profile ( cm -> profile , wb ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_type ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> show_frame ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> const COLOR_SPACE cs = UNKNOWN ; <S2SV_EndBug> write_sync_code ( wb ) ; <S2SV_StartBug> if ( cm -> profile > PROFILE_1 ) { <S2SV_EndBug> assert ( cm -> bit_depth > BITS_8 ) ; vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ; } vp9_wb_write_literal ( wb , cs , 3 ) ; if ( cs != SRGB ) { vp9_wb_write_bit ( wb , 0 ) ; if ( cm -> profile >= PROFILE_1 ) { vp9_wb_write_bit ( wb , cm -> subsampling_x ) ; vp9_wb_write_bit ( wb , cm -> subsampling_y ) ; vp9_wb_write_bit ( wb , 0 ) ; } } else { <S2SV_StartBug> assert ( cm -> profile == PROFILE_1 ) ; <S2SV_EndBug> vp9_wb_write_bit ( wb , 0 ) ; } write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vp9_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vp9_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { write_sync_code ( wb ) ; vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; } else { MV_REFERENCE_FRAME ref_frame ; <S2SV_StartBug> vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; <S2SV_EndBug> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) , <S2SV_EndBug> REF_FRAMES_LOG2 ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ; <S2SV_EndBug> } write_frame_size_with_refs ( cpi , wb ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ; <S2SV_EndBug> <S2SV_StartBug> fix_interp_filter ( cm ) ; <S2SV_EndBug> write_interp_filter ( cm -> interp_filter , wb ) ; } } if ( ! cm -> error_resilient_mode ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ; <S2SV_EndBug> encode_loopfilter ( & cm -> lf , wb ) ; encode_quantization ( cm , wb ) ; <S2SV_StartBug> encode_segmentation ( cpi , wb ) ; <S2SV_EndBug> write_tile_info ( cm , wb ) ; }
","<S2SV_ModStart> cpi , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> wb ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> frame_type ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> show_frame ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> KEY_FRAME ) { write_sync_code ( wb ) ; write_bitdepth_colorspace_sampling ( cm , wb ) ; write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { <S2SV_ModEnd> write_sync_code ( wb <S2SV_ModStart> -> profile > PROFILE_0 ) { write_bitdepth_colorspace_sampling ( cm , wb ) ; } vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { <S2SV_ModEnd> MV_REFERENCE_FRAME ref_frame ; <S2SV_ModStart> MV_REFERENCE_FRAME ref_frame ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ref_frame ) { assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; vpx_wb_write_literal ( wb , get_ref_frame_map_idx <S2SV_ModEnd> ( cpi , <S2SV_ModStart> REF_FRAMES_LOG2 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> wb ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> fix_interp_filter ( cm , cpi -> td . counts <S2SV_ModStart> error_resilient_mode ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> refresh_frame_context ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> ) ; } vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ; encode_segmentation ( cm , xd <S2SV_ModEnd> , wb )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,620,"<S2SV_ModStart> cm, struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> cm ) ; vpx_write_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> cm ) ; vpx_write_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> 0 ) ; vpx_bit <S2SV_ModEnd> ( wb, <S2SV_ModStart> 0 ) ; vpx_write_bit <S2SV_ModEnd> ( wb,",0
1410,CWE-134,"CWE-134 void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-autoscale-max"" , no_argument , 0 , 'M' } , { ""zoom"" , required_argument , 0 , 'm' } , { ""no-gridfit"" , no_argument , 0 , 'N' } , { ""font"" , required_argument , 0 , 'n' } , { ""logarithmic"" , no_argument , 0 , 'o' } , { ""pango-markup"" , no_argument , 0 , 'P' } , { ""font-render-mode"" , required_argument , 0 , 'R' } , { ""rigid"" , no_argument , 0 , 'r' } , { ""step"" , required_argument , 0 , 'S' } , { ""start"" , required_argument , 0 , 's' } , { ""tabwidth"" , required_argument , 0 , 'T' } , { ""title"" , required_argument , 0 , 't' } , { ""upper-limit"" , required_argument , 0 , 'u' } , { ""vertical-label"" , required_argument , 0 , 'v' } , { ""watermark"" , required_argument , 0 , 'W' } , { ""width"" , required_argument , 0 , 'w' } , { ""units-exponent"" , required_argument , 0 , 'X' } , { ""x-grid"" , required_argument , 0 , 'x' } , { ""alt-y-grid"" , no_argument , 0 , 'Y' } , { ""y-grid"" , required_argument , 0 , 'y' } , { ""lazy"" , no_argument , 0 , 'z' } , { ""units"" , required_argument , 0 , LONGOPT_UNITS_SI } , { ""alt-y-mrtg"" , no_argument , 0 , 1000 } , { ""disable-rrdtool-tag"" , no_argument , 0 , 1001 } , { ""right-axis"" , required_argument , 0 , 1002 } , { ""right-axis-label"" , required_argument , 0 , 1003 } , { ""right-axis-format"" , required_argument , 0 , 1004 } , { ""legend-position"" , required_argument , 0 , 1005 } , { ""legend-direction"" , required_argument , 0 , 1006 } , { ""border"" , required_argument , 0 , 1007 } , { ""grid-dash"" , required_argument , 0 , 1008 } , { ""dynamic-labels"" , no_argument , 0 , 1009 } , { ""left-axis-format"" , required_argument , 0 , 1010 } , { 0 , 0 , 0 , 0 } } ; optind = 0 ; opterr = 0 ; rrd_parsetime ( ""end-24h"" , & start_tv ) ; rrd_parsetime ( ""now"" , & end_tv ) ; while ( 1 ) { int option_index = 0 ; int opt ; int col_start , col_end ; opt = getopt_long ( argc , argv , ""Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:z"" , long_options , & option_index ) ; if ( opt == EOF ) break ; switch ( opt ) { case 'I' : im -> extra_flags |= NOMINOR ; break ; case 'Y' : im -> extra_flags |= ALTYGRID ; break ; case 'A' : im -> extra_flags |= ALTAUTOSCALE ; break ; case 'J' : im -> extra_flags |= ALTAUTOSCALE_MIN ; break ; case 'M' : im -> extra_flags |= ALTAUTOSCALE_MAX ; break ; case 'j' : im -> extra_flags |= ONLY_GRAPH ; break ; case 'g' : im -> extra_flags |= NOLEGEND ; break ; case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) { im -> legendposition = NORTH ; } else if ( strcmp ( optarg , ""west"" ) == 0 ) { im -> legendposition = WEST ; } else if ( strcmp ( optarg , ""south"" ) == 0 ) { im -> legendposition = SOUTH ; } else if ( strcmp ( optarg , ""east"" ) == 0 ) { im -> legendposition = EAST ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 1006 : if ( strcmp ( optarg , ""topdown"" ) == 0 ) { im -> legenddirection = TOP_DOWN ; } else if ( strcmp ( optarg , ""bottomup"" ) == 0 ) { im -> legenddirection = BOTTOM_UP ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'F' : im -> extra_flags |= FORCE_RULES_LEGEND ; break ; case 1001 : im -> extra_flags |= NO_RRDTOOL_TAG ; break ; case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) { rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ; return ; } if ( strcmp ( optarg , ""si"" ) == 0 ) im -> extra_flags |= FORCE_UNITS_SI ; else { rrd_set_error ( ""invalid<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>--units:<S2SV_blank>%s"" , optarg ) ; return ; } break ; case 'X' : im -> unitsexponent = atoi ( optarg ) ; break ; case 'L' : im -> unitslength = atoi ( optarg ) ; im -> forceleftspace = 1 ; break ; case 'T' : im -> tabwidth = atof ( optarg ) ; break ; case 'S' : im -> step = atoi ( optarg ) ; break ; case 'N' : im -> gridfit = 0 ; break ; case 'P' : im -> with_markup = 1 ; break ; case 's' : if ( ( parsetime_error = rrd_parsetime ( optarg , & start_tv ) ) ) { rrd_set_error ( ""start<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'e' : if ( ( parsetime_error = rrd_parsetime ( optarg , & end_tv ) ) ) { rrd_set_error ( ""end<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'x' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_x_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n"" , scan_gtm , & im -> xlab_user . gridst , scan_mtm , & im -> xlab_user . mgridst , scan_ltm , & im -> xlab_user . labst , & im -> xlab_user . precis , & stroff ) == 7 && stroff != 0 ) { strncpy ( im -> xlab_form , optarg + stroff , sizeof ( im -> xlab_form ) - 1 ) ; im -> xlab_form [ sizeof ( im -> xlab_form ) - 1 ] = '\\0' ; if ( ( int ) ( im -> xlab_user . gridtm = tmt_conv ( scan_gtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_gtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . mgridtm = tmt_conv ( scan_mtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_mtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . labtm = tmt_conv ( scan_ltm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_ltm ) ; return ; } im -> xlab_user . minsec = 1 ; im -> xlab_user . stst = im -> xlab_form ; } else { rrd_set_error ( ""invalid<S2SV_blank>x-grid<S2SV_blank>format"" ) ; return ; } break ; case 'y' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_y_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%lf:%d"" , & im -> ygridstep , & im -> ylabfact ) == 2 ) { if ( im -> ygridstep <= 0 ) { rrd_set_error ( ""grid<S2SV_blank>step<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } else if ( im -> ylabfact < 1 ) { rrd_set_error ( ""label<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>y-grid<S2SV_blank>format"" ) ; return ; } break ; case 1007 : im -> draw_3d_border = atoi ( optarg ) ; break ; case 1008 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> grid_dash_on , & im -> grid_dash_off ) != 2 ) { rrd_set_error ( ""expected<S2SV_blank>grid-dash<S2SV_blank>format<S2SV_blank>float:float"" ) ; return ; } break ; case 1009 : im -> dynamic_labels = 1 ; break ; case 1002 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> second_axis_scale , & im -> second_axis_shift ) == 2 ) { if ( im -> second_axis_scale == 0 ) { rrd_set_error ( ""the<S2SV_blank>second_axis_scale<S2SV_blank><S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>right-axis<S2SV_blank>format<S2SV_blank>expected<S2SV_blank>scale:shift"" ) ; return ; } break ; case 1003 : strncpy ( im -> second_axis_legend , optarg , 150 ) ; im -> second_axis_legend [ 150 ] = '\\0' ; break ; case 1004 : <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> second_axis_format , optarg , 150 ) ; im -> second_axis_format [ 150 ] = '\\0' ; break ; case 1010 : <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> primary_axis_format , optarg , 150 ) ; im -> primary_axis_format [ 150 ] = '\\0' ; break ; case 'v' : strncpy ( im -> ylegend , optarg , 150 ) ; im -> ylegend [ 150 ] = '\\0' ; break ; case 'u' : im -> maxval = atof ( optarg ) ; break ; case 'l' : im -> minval = atof ( optarg ) ; break ; case 'b' : im -> base = atol ( optarg ) ; if ( im -> base != 1024 && im -> base != 1000 ) { rrd_set_error ( ""the<S2SV_blank>only<S2SV_blank>sensible<S2SV_blank>value<S2SV_blank>for<S2SV_blank>base<S2SV_blank>apart<S2SV_blank>from<S2SV_blank>1000<S2SV_blank>is<S2SV_blank>1024"" ) ; return ; } break ; case 'w' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""width<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> xsize = long_tmp ; break ; case 'h' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""height<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> ysize = long_tmp ; break ; case 'D' : im -> extra_flags |= FULL_SIZE_MODE ; break ; case 'i' : break ; case 'r' : im -> rigid = 1 ; break ; case 'f' : im -> imginfo = optarg ; break ; case 'a' : if ( ( int ) ( im -> imgformat = if_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupported<S2SV_blank>graphics<S2SV_blank>format<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'z' : im -> lazy = 1 ; break ; case 'E' : im -> slopemode = 1 ; break ; case 'o' : im -> logarithmic = 1 ; break ; case 'c' : if ( sscanf ( optarg , ""%10[A-Z]#%n%8lx%n"" , col_nam , & col_start , & color , & col_end ) == 2 ) { int ci ; int col_len = col_end - col_start ; switch ( col_len ) { case 3 : color = ( ( ( color & 0xF00 ) * 0x110000 ) | ( ( color & 0x0F0 ) * 0x011000 ) | ( ( color & 0x00F ) * 0x001100 ) | 0x000000FF ) ; break ; case 4 : color = ( ( ( color & 0xF000 ) * 0x11000 ) | ( ( color & 0x0F00 ) * 0x01100 ) | ( ( color & 0x00F0 ) * 0x00110 ) | ( ( color & 0x000F ) * 0x00011 ) ) ; break ; case 6 : color = ( color << 8 ) + 0xff ; break ; case 8 : break ; default : rrd_set_error ( ""the<S2SV_blank>color<S2SV_blank>format<S2SV_blank>is<S2SV_blank>#RRGGBB[AA]"" ) ; return ; } if ( ( ci = grc_conv ( col_nam ) ) != - 1 ) { im -> graph_col [ ci ] = gfx_hex_to_col ( color ) ; } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>name<S2SV_blank>\'%s\'"" , col_nam ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>def<S2SV_blank>format"" ) ; return ; } break ; case 'n' : { char prop [ 15 ] ; double size = 1 ; int end ; if ( sscanf ( optarg , ""%10[A-Z]:%lf%n"" , prop , & size , & end ) >= 2 ) { int sindex , propidx ; if ( ( sindex = text_prop_conv ( prop ) ) != - 1 ) { for ( propidx = sindex ; propidx < TEXT_PROP_LAST ; propidx ++ ) { if ( size > 0 ) { rrd_set_font_desc ( im , propidx , NULL , size ) ; } if ( ( int ) strlen ( optarg ) > end + 2 ) { if ( optarg [ end ] == ':' ) { rrd_set_font_desc ( im , propidx , optarg + end + 1 , 0 ) ; } else { rrd_set_error ( ""expected<S2SV_blank>:<S2SV_blank>after<S2SV_blank>font<S2SV_blank>size<S2SV_blank>in<S2SV_blank>\'%s\'"" , optarg ) ; return ; } } if ( propidx == sindex && sindex != 0 ) break ; } } else { rrd_set_error ( ""invalid<S2SV_blank>fonttag<S2SV_blank>\'%s\'"" , prop ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>text<S2SV_blank>property<S2SV_blank>format"" ) ; return ; } break ; } case 'm' : im -> zoom = atof ( optarg ) ; if ( im -> zoom <= 0.0 ) { rrd_set_error ( ""zoom<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } break ; case 't' : strncpy ( im -> title , optarg , 150 ) ; im -> title [ 150 ] = '\\0' ; break ; case 'R' : if ( strcmp ( optarg , ""normal"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else if ( strcmp ( optarg , ""light"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_SLIGHT ) ; } else if ( strcmp ( optarg , ""mono"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_NONE ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else { rrd_set_error ( ""unknown<S2SV_blank>font-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'G' : if ( strcmp ( optarg , ""normal"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_GRAY ; else if ( strcmp ( optarg , ""mono"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_NONE ; else { rrd_set_error ( ""unknown<S2SV_blank>graph-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'B' : break ; case 'W' : strncpy ( im -> watermark , optarg , 100 ) ; im -> watermark [ 99 ] = '\\0' ; break ; case 'd' : { if ( im -> daemon_addr != NULL ) { rrd_set_error ( ""You<S2SV_blank>cannot<S2SV_blank>specify<S2SV_blank>--daemon<S2SV_blank>"" ""more<S2SV_blank>than<S2SV_blank>once."" ) ; return ; } im -> daemon_addr = strdup ( optarg ) ; if ( im -> daemon_addr == NULL ) { rrd_set_error ( ""strdup<S2SV_blank>failed"" ) ; return ; } break ; } case '?' : if ( optopt != 0 ) rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%c\'"" , optopt ) ; else rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%s\'"" , argv [ optind - 1 ] ) ; return ; } } { int status = rrdc_connect ( im -> daemon_addr ) ; if ( status != 0 ) return ; } pango_cairo_context_set_font_options ( pango_layout_get_context ( im -> layout ) , im -> font_options ) ; pango_layout_context_changed ( im -> layout ) ; if ( im -> logarithmic && im -> minval <= 0 ) { rrd_set_error ( ""for<S2SV_blank>a<S2SV_blank>logarithmic<S2SV_blank>yaxis<S2SV_blank>you<S2SV_blank>must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>lower-limit<S2SV_blank>><S2SV_blank>0"" ) ; return ; } if ( rrd_proc_start_end ( & start_tv , & end_tv , & start_tmp , & end_tmp ) == - 1 ) { return ; } if ( start_tmp < 3600 * 24 * 365 * 10 ) { rrd_set_error ( ""the<S2SV_blank>first<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>fetch<S2SV_blank>should<S2SV_blank>be<S2SV_blank>after<S2SV_blank>1980<S2SV_blank>(%ld)"" , start_tmp ) ; return ; } if ( end_tmp < start_tmp ) { rrd_set_error ( ""start<S2SV_blank>(%ld)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>end<S2SV_blank>(%ld)"" , start_tmp , end_tmp ) ; return ; } im -> start = start_tmp ; im -> end = end_tmp ; im -> step = max ( ( long ) im -> step , ( im -> end - im -> start ) / im -> xsize ) ; }
","<S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; } <S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; }
",oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z,621,<S2SV_ModStart> : if ( optarg ) { <S2SV_ModEnd> return ; },0
1411,CWE-20,"CWE-20 error_t httpClientSetQueryString ( HttpClientContext * context , const char_t * queryString ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || queryString == NULL ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { <S2SV_StartBug> q = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; } else { q = p ; m = 0 ; } n = osStrlen ( queryString ) ; if ( n == 0 ) { osMemmove ( p , p + m , context -> buffer + context -> bufferLen + 1 - q ) ; } else { n ++ ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; p [ 0 ] = '?' ; osStrncpy ( p + 1 , queryString , n - 1 ) ; } context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { q = osStrchr <S2SV_ModEnd> ( p +
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,622,<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->,0
1412,CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z,623,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1413,CWE-119,"CWE-119 static void init_frame ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; if ( pc -> frame_type == KEY_FRAME ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> vp8_init_mbmode_probs ( pc ) ; vp8_default_coef_probs ( pc ) ; <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ; <S2SV_StartBug> vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> pc -> refresh_golden_frame = 1 ; pc -> refresh_alt_ref_frame = 1 ; pc -> copy_buffer_to_gf = 0 ; pc -> copy_buffer_to_arf = 0 ; pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = 0 ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; } else { if ( ! pc -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } if ( pbi -> decoded_key_frame && pbi -> ec_enabled && ! pbi -> ec_active ) pbi -> ec_active = 1 ; } xd -> left_context = & pc -> left_context ; xd -> mode_info_context = pc -> mi ; xd -> frame_type = pc -> frame_type ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_stride = pc -> mode_info_stride ; xd -> corrupted = 0 ; xd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; }
","<S2SV_ModStart> KEY_FRAME ) { memcpy <S2SV_ModEnd> ( pc -> <S2SV_ModStart> pc ) ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> = SEGMENT_DELTADATA ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( xd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,624,<S2SV_ModStart> 0 ) ; memset <S2SV_ModEnd> ( p -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( pbi ->,0
1414,CWE-20,"CWE-20 error_t enc624j600ReceivePacket ( NetInterface * interface ) { error_t error ; <S2SV_StartBug> uint16_t n ; <S2SV_EndBug> uint32_t status ; <S2SV_StartBug> Enc624j600Context * context ; <S2SV_EndBug> context = ( Enc624j600Context * ) interface -> nicContext ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ; <S2SV_EndBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , <S2SV_StartBug> ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> context -> nextPacket = letoh16 ( context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ; <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ; <S2SV_EndBug> error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC624J600_RX_BUFFER_START ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ; <S2SV_EndBug> } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> } return error ; }
","<S2SV_ModStart> error ; uint16_t length <S2SV_ModEnd> ; uint32_t status <S2SV_ModStart> uint32_t status ; uint8_t header [ 8 ] ; <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> ) { enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_ERXRDPT <S2SV_ModEnd> , context -> <S2SV_ModStart> , ENC624J600_CMD_RRXDATA , header <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> 0 ) { length <S2SV_ModEnd> = MIN ( <S2SV_ModStart> = MIN ( length <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> ) ; error <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> ENC624J600_RX_BUFFER_STOP ) ; <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> context -> nextPacket <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> , & ancillary
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,625,"<S2SV_ModStart> int status ; uint16_t status ; uint16_t status ; uint16_t status ; uint16_t status ; uint16_t status ; uint16_t status ; size_t status ; size_t status ; status = sizeof ( status & ENC624J600_ESTAT )!= 0 ) { status = <S2SV_ModEnd> ; status = <S2SV_ModStart> ( interface, ENC624J600_ESTAT ) ; status = <S2SV_ModEnd> ; status <S2SV_ModStart> ( interface, ENC624J600_EN <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface, ENC624J600_ECON2 )!= 0 ) { status = ENC624J600_EN <S2SV_ModEnd> ; status <S2SV_ModStart> ( interface, ENC624J600_EN <S2SV_ModEnd>, sizeof ( <S2SV_ModStart> ( interface, ENC624J600_TXIF <S2SV_ModEnd>, sizeof ( <S2SV_ModStart> ( interface, ENC624J600_START ) <S2SV_ModEnd> ) ; return",0
1415,CWE-119,"CWE-119 static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , ""Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , ""Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ; <S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d"" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated"" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } iptr = ibuf + GEMSAFE_READ_QUANTUM ; while ( ( size_t ) ( iptr - ibuf ) < objlen ) { r = sc_read_binary ( card , iptr - ibuf , iptr , MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; if ( r < 0 ) { sc_log ( card -> ctx , ""Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object"" ) ; return SC_ERROR_INTERNAL ; } iptr += GEMSAFE_READ_QUANTUM ; } i = 0 ; while ( ind < objlen - 1 ) { if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) i ++ ; if ( i == gemsafe_cert_max ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d"" , ind ) ; return SC_SUCCESS ; } if ( ind + 3 >= sizeof ibuf ) return SC_ERROR_INVALID_DATA ; certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; sc_log ( card -> ctx , ""Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , i + 1 , ind , certlen ) ; gemsafe_cert [ i ] . index = ind ; gemsafe_cert [ i ] . count = certlen ; ind += certlen ; i ++ ; } else ind ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { if ( gemsafe_cert [ i ] . label ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing"" , i + 1 ) ; gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } } return SC_SUCCESS ; }
","<S2SV_ModStart> ] == 0x01 && i < gemsafe_cert_max
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z,626,<S2SV_ModStart> ] == 0x01 && i < i,0
1416,CWE-264,"CWE-264 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }
","<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu ,
",torvalds@linux/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,2014-11-10T11:55Z,627,"<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu,",1
1417,CWE-611,"CWE-611 <S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> { xmlSchemaPtr schema ; <S2SV_StartBug> xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt ( <S2SV_EndBug> ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content ) <S2SV_StartBug> ) ; <S2SV_EndBug> VALUE rb_schema ; VALUE errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ; <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> }
","<S2SV_ModStart> VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; int parse_options_int ; xmlSchemaParserCtxtPtr ctx ; <S2SV_ModEnd> xmlSchemaPtr schema ; <S2SV_ModStart> xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ; <S2SV_ModEnd> ctx = xmlSchemaNewMemParserCtxt <S2SV_ModStart> ( content ) ) ; <S2SV_ModEnd> errors = rb_ary_new <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;
",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z,628,"<S2SV_ModStart> VALUE args ) { VALUE rb_args = rb_options ; int parse_args ( rb_options, rb_options ) ; int scanned_args = rb_const_args ( rb_args ( rb_args, rb_options ) ) ; if (! rb_options ) { parse_options = rb_get ( rb_options ), rb_options ; parse_options = rb_options = rb_get ( rb_args ( rb_options ), rb_options ) ) ; if ( scanned_options = rb_args ( scanned_args ( rb_options ) ) ) rb_get ( rb_intern ( rb_options ), rb_intern ( rb_options ), rb_options ) ) ;",0
1419,CWE-295,"CWE-295 NOEXPORT int options_file ( char * path , CONF_TYPE type , SERVICE_OPTIONS * * section_ptr ) { DISK_FILE * df ; char line_text [ CONFLINELEN ] , * errstr ; char config_line [ CONFLINELEN ] , * config_opt , * config_arg ; int i , line_number = 0 ; # ifndef USE_WIN32 int fd ; char * tmp_str ; # endif s_log ( LOG_NOTICE , ""Reading<S2SV_blank>configuration<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>%s"" , type == CONF_FD ? ""descriptor"" : ""file"" , path ) ; # ifndef USE_WIN32 if ( type == CONF_FD ) { fd = ( int ) strtol ( path , & tmp_str , 10 ) ; if ( tmp_str == path || * tmp_str ) { s_log ( LOG_ERR , ""Invalid<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>number"" ) ; print_syntax ( ) ; return 1 ; } df = file_fdopen ( fd ) ; } else # endif df = file_open ( path , FILE_MODE_READ ) ; if ( ! df ) { s_log ( LOG_ERR , ""Cannot<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file"" ) ; if ( type != CONF_RELOAD ) print_syntax ( ) ; return 1 ; } while ( file_getline ( df , line_text , CONFLINELEN ) >= 0 ) { memcpy ( config_line , line_text , CONFLINELEN ) ; ++ line_number ; config_opt = config_line ; if ( line_number == 1 ) { if ( config_opt [ 0 ] == ( char ) 0xef && config_opt [ 1 ] == ( char ) 0xbb && config_opt [ 2 ] == ( char ) 0xbf ) { s_log ( LOG_NOTICE , ""UTF-8<S2SV_blank>byte<S2SV_blank>order<S2SV_blank>mark<S2SV_blank>detected"" ) ; config_opt += 3 ; } else { s_log ( LOG_NOTICE , ""UTF-8<S2SV_blank>byte<S2SV_blank>order<S2SV_blank>mark<S2SV_blank>not<S2SV_blank>detected"" ) ; } } while ( isspace ( ( unsigned char ) * config_opt ) ) ++ config_opt ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace ( ( unsigned char ) config_opt [ i ] ) ; -- i ) config_opt [ i ] = '\\0' ; if ( config_opt [ 0 ] == '\\0' || config_opt [ 0 ] == '#' || config_opt [ 0 ] == ';' ) continue ; if ( config_opt [ 0 ] == '[' && config_opt [ strlen ( config_opt ) - 1 ] == ']' ) { if ( init_section ( 0 , section_ptr ) ) { file_close ( df ) ; return 1 ; } { SERVICE_OPTIONS * new_section ; new_section = str_alloc_detached ( sizeof ( SERVICE_OPTIONS ) ) ; new_section -> next = NULL ; ( * section_ptr ) -> next = new_section ; * section_ptr = new_section ; } ++ config_opt ; config_opt [ strlen ( config_opt ) - 1 ] = '\\0' ; ( * section_ptr ) -> servname = str_dup_detached ( config_opt ) ; ( * section_ptr ) -> session = NULL ; parse_service_option ( CMD_SET_COPY , section_ptr , NULL , NULL ) ; continue ; } config_arg = strchr ( config_line , '=' ) ; if ( ! config_arg ) { s_log ( LOG_ERR , ""%s:%d:<S2SV_blank>\\""%s\\"":<S2SV_blank>No<S2SV_blank>\'=\'<S2SV_blank>found"" , path , line_number , line_text ) ; file_close ( df ) ; return 1 ; } * config_arg ++ = '\\0' ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace ( ( unsigned char ) config_opt [ i ] ) ; -- i ) config_opt [ i ] = '\\0' ; while ( isspace ( ( unsigned char ) * config_arg ) ) ++ config_arg ; errstr = option_not_found ; if ( ! new_service_options . next ) <S2SV_StartBug> errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ; <S2SV_EndBug> if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ; if ( errstr ) { s_log ( LOG_ERR , ""%s:%d:<S2SV_blank>\\""%s\\"":<S2SV_blank>%s"" , path , line_number , line_text , errstr ) ; file_close ( df ) ; return 1 ; } } file_close ( df ) ; return 0 ; }
","<S2SV_ModStart> ( CMD_SET_VALUE , & new_global_options ,
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,629,,0
1420,CWE-119,"CWE-119 int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { int x ; int chunk ; UINT8 * out ; UINT8 * ptr ; ptr = buf ; chunk = 3 * state -> xsize ; for ( ; ; ) { if ( bytes < chunk ) return ptr - buf ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ; <S2SV_StartBug> out += 4 ; <S2SV_EndBug> } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x + state -> xsize ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ; <S2SV_StartBug> out += 4 ; <S2SV_EndBug> } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; ptr += chunk ; bytes -= chunk ; } }
","<S2SV_ModStart> ; out += 3 <S2SV_ModEnd> ; } state <S2SV_ModStart> ; out += 3 <S2SV_ModEnd> ; } state
",python-pillow@Pillow/ae453aa18b66af54e7ff716f4ccb33adca60afd4,CVE-2016-2533,https://github.com/python-pillow/Pillow/commit/ae453aa18b66af54e7ff716f4ccb33adca60afd4,2016-04-13T16:59Z,630,<S2SV_ModStart> ++ ; } if ( bytes < 0 ) return 0 ;,0
1421,CWE-399,"CWE-399 static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n"" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }
","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,631,"<S2SV_ModStart> ( event, <S2SV_ModEnd> & data,",1
1423,CWE-362,"CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; <S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; <S2SV_StartBug> if ( match -> type == type && <S2SV_EndBug> match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } } <S2SV_StartBug> out : <S2SV_EndBug> if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }
","<S2SV_ModStart> err = - <S2SV_ModEnd> EALREADY ; if <S2SV_ModStart> - EINVAL ; spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> match -> type <S2SV_ModStart> ; } } spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; }
",torvalds@linux/008ba2a13f2d04c947adc536d19debb8fe66f110,CVE-2017-15649,https://github.com/torvalds/linux/commit/008ba2a13f2d04c947adc536d19debb8fe66f110,2017-10-19T22:29Z,632,<S2SV_ModStart> ; if ( err < 0 ) goto out ; err = - EINVAL ; if (,0
1424,CWE-400,"CWE-400 static void perf_output_wakeup ( struct perf_output_handle * handle ) { atomic_set ( & handle -> rb -> poll , POLL_IN ) ; <S2SV_StartBug> if ( handle -> nmi ) { <S2SV_EndBug> handle -> event -> pending_wakeup = 1 ; irq_work_queue ( & handle -> event -> pending ) ; <S2SV_StartBug> } else <S2SV_EndBug> perf_event_wakeup ( handle -> event ) ; }
","<S2SV_ModStart> POLL_IN ) ; <S2SV_ModEnd> handle -> event <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,633,<S2SV_ModStart> -> event = handle <S2SV_ModEnd> ; mutex_unlock ( <S2SV_ModStart> ) ; } <S2SV_null>,0
1425,CWE-119,"CWE-119 <S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> { u16 * op ; int size ; unicode_t u ; op = pwcs ; <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> } else { <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> } s += size ; len -= size ; } else { <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> len -- ; } } return op - pwcs ; }
","<S2SV_ModStart> int len , enum utf16_endian endian , <S2SV_ModStart> wchar_t * pwcs , int maxlen <S2SV_ModStart> ; while ( <S2SV_ModEnd> len > 0 <S2SV_ModStart> len > 0 && maxlen > 0 && * s <S2SV_ModStart> - EINVAL ; s += size ; len -= size ; <S2SV_ModStart> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <S2SV_ModStart> -= PLANE_SIZE ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | ( <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | SURROGATE_LOW <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> -- ; }
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z,634,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> char * s ; int <S2SV_ModStart> len ; <S2SV_ModEnd> len = ( u8_t <S2SV_ModStart> len ) { if ( len <S2SV_null> <S2SV_null>,0
1427,CWE-399,"CWE-399 int cib_connect ( gboolean full ) { int rc = pcmk_ok ; static gboolean need_pass = TRUE ; CRM_CHECK ( cib != NULL , return - EINVAL ) ; if ( getenv ( ""CIB_passwd"" ) != NULL ) { need_pass = FALSE ; } if ( watch_fencing && st == NULL ) { st = stonith_api_new ( ) ; } if ( watch_fencing && st -> state == stonith_disconnected ) { crm_trace ( ""Connecting<S2SV_blank>to<S2SV_blank>stonith"" ) ; rc = st -> cmds -> connect ( st , crm_system_name , NULL ) ; if ( rc == pcmk_ok ) { crm_trace ( ""Setting<S2SV_blank>up<S2SV_blank>stonith<S2SV_blank>callbacks"" ) ; st -> cmds -> register_notification ( st , T_STONITH_NOTIFY_FENCE , mon_st_callback ) ; } } if ( cib -> state != cib_connected_query && cib -> state != cib_connected_command ) { crm_trace ( ""Connecting<S2SV_blank>to<S2SV_blank>the<S2SV_blank>CIB"" ) ; if ( as_console && need_pass && cib -> variant == cib_remote ) { need_pass = FALSE ; print_as ( ""Password:"" ) ; } rc = cib -> cmds -> signon ( cib , crm_system_name , cib_query ) ; if ( rc != pcmk_ok ) { return rc ; } current_cib = get_cib_copy ( cib ) ; mon_refresh_display ( NULL ) ; if ( full ) { if ( rc == pcmk_ok ) { rc = cib -> cmds -> set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; if ( rc == - EPROTONOSUPPORT ) { <S2SV_StartBug> print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ; <S2SV_EndBug> if ( as_console ) { sleep ( 2 ) ; } rc = pcmk_ok ; } } if ( rc == pcmk_ok ) { cib -> cmds -> del_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; rc = cib -> cmds -> add_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; } if ( rc != pcmk_ok ) { print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>could<S2SV_blank>not<S2SV_blank>monitor<S2SV_blank>CIB<S2SV_blank>actions"" ) ; if ( as_console ) { sleep ( 2 ) ; } clean_up ( - rc ) ; } } } return rc ; }
","<S2SV_ModStart> { print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" <S2SV_ModEnd> ) ; if
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,635,<S2SV_ModStart> ) ) ; if ( cib -> session == NULL ) { <S2SV_ModStart> ) continue ; },0
1429,CWE-20,"CWE-20 error_t ksz8851ReceivePacket ( NetInterface * interface ) { size_t n ; uint16_t status ; Ksz8851Context * context ; NetRxAncillary ancillary ; context = ( Ksz8851Context * ) interface -> nicContext ; <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RXFHSR_RXFV ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ; <S2SV_EndBug> if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; return NO_ERROR ; } } } <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ; <S2SV_EndBug> return ERROR_INVALID_PACKET ; }
","<S2SV_ModStart> ( interface , KSZ8851_RXFHSR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> ) != 0 <S2SV_ModStart> status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> ) ) == <S2SV_ModStart> ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851ReadFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ancillary <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,636,"<S2SV_ModStart> ( interface, KSZ8851_ISR ) ; if ( ( status & KSZ8851_RXIF <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_E <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_RXS2SV_null>",0
1430,CWE-125,"CWE-125 static stmt_ty <S2SV_StartBug> ast_for_funcdef_impl ( struct compiling * c , const node * n , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * decorator_seq , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>functions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_StartBug> type_comment , LINENO ( n ) , <S2SV_EndBug> n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> const node * n0 <S2SV_ModEnd> , asdl_seq * <S2SV_ModStart> * decorator_seq , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,637,"<S2SV_ModStart> const char * n_seq <S2SV_ModEnd>, int",0
1431,CWE-264,"CWE-264 static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ; <S2SV_StartBug> pgd = pgd_offset ( mm , 0xA0000 ) ; <S2SV_EndBug> if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out : <S2SV_StartBug> flush_tlb ( ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int i ; down_write ( & mm -> mmap_sem ) ; <S2SV_ModStart> ; out : up_write ( & mm -> mmap_sem ) ;
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z,638,<S2SV_ModStart> ) ) ; ret = 0 ;,0
1434,CWE-401,"CWE-401 static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>token<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; } while ( message_left && ( * * packet_data_pptr != 0xff ) ) { uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ; uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ; message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; int8_t option_parse_result ; option_parse_result = parse_ext_option ( & option_number , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } <S2SV_StartBug> option_number += previous_option_number ; <S2SV_EndBug> option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } previous_option_number = option_number ; switch ( option_number ) { case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>options!"" ) ; return - 1 ; } break ; } if ( message_left < option_len ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>would<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>parsing<S2SV_blank>options!"" ) ; return - 1 ; } switch ( option_number ) { case COAP_OPTION_CONTENT_FORMAT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> content_format != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_CONTENT_FORMAT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> content_format = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_MAX_AGE : if ( option_len > 4 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_MAX_AGE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> max_age = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_PROXY_URI : if ( ( option_len > 1034 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_ETAG : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , <S2SV_EndBug> message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_HOST : if ( ( option_len > 255 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_host_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_LOCATION_PATH : if ( dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_path_len , COAP_OPTION_LOCATION_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PORT : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_port != COAP_OPTION_URI_PORT_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PORT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_port = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_LOCATION_QUERY : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PATH : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_OBSERVE : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> observe != COAP_OBSERVE_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_OBSERVE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> observe = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_URI_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_len , COAP_OPTION_URI_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_BLOCK2 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block2 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_BLOCK1 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block1 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_ACCEPT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> options_list_ptr -> accept != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ACCEPT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> accept = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE1 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size1 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size1 = true ; dst_coap_msg_ptr -> options_list_ptr -> size1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE2 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size2 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size2 = true ; dst_coap_msg_ptr -> options_list_ptr -> size2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; default : tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>option!"" ) ; return - 1 ; } if ( ( * packet_data_pptr - packet_data_start_ptr ) > packet_len ) { return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; } return 0 ; }
","<S2SV_ModStart> 1 ; } if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> option_parse_result = parse_ext_option <S2SV_ModStart> case COAP_OPTION_ETAG : if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_LOCATION_QUERY : if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_URI_PATH : if ( dst_coap_msg_ptr -> uri_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!"" ) ; return - 1 ; }
",mjurczak@mbed-coap/4647a68e364401e81dbd370728127d844f221d93,CVE-2020-12887,https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93,2020-06-18T19:15Z,639,<S2SV_ModStart> ; } } if (,0
1437,CWE-787,"CWE-787 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
",ImageMagick@ImageMagick/19651f3db63fa1511ed83a348c4c82fa553f8d01,CVE-2019-13308,https://github.com/ImageMagick/ImageMagick/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01,2019-07-05T01:15Z,640,<S2SV_ModStart> ( code ) \\,0
1441,CWE-20,"CWE-20 int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n"" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n"" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n"" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n"" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = ""\\x1b[0m"" ; static const char * GREEN = ""\\x1b[0;32m"" ; static const char * RED = ""\\x1b[0;31m"" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = """" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( ""\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n"" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> if ( test_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( ""\\n"" ) ; if ( fail ) { printf ( ""%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n"" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( ""All<S2SV_blank>tests<S2SV_blank>passed!\\n"" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }
","<S2SV_ModStart> -> enable ( false
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,641,<S2SV_ModStart> ) ; return false,0
1443,CWE-119,"CWE-119 void CLASS panasonic_load_raw ( ) { int row , col , i , j , sh = 0 , pred [ 2 ] , nonz [ 2 ] ; pana_bits ( 0 ) ; <S2SV_StartBug> for ( row = 0 ; row < height ; row ++ ) <S2SV_EndBug> { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < raw_width ; col ++ ) { if ( ( i = col % 14 ) == 0 ) pred [ 0 ] = pred [ 1 ] = nonz [ 0 ] = nonz [ 1 ] = 0 ; if ( i % 3 == 2 ) sh = 4 >> ( 3 - pana_bits ( 2 ) ) ; if ( nonz [ i & 1 ] ) { if ( ( j = pana_bits ( 8 ) ) ) { if ( ( pred [ i & 1 ] -= 0x80 << sh ) < 0 || sh == 4 ) pred [ i & 1 ] &= ~ ( ( ~ 0u ) << sh ) ; pred [ i & 1 ] += j << sh ; } } else if ( ( nonz [ i & 1 ] = pana_bits ( 8 ) ) || i > 11 ) pred [ i & 1 ] = nonz [ i & 1 ] << 4 | pana_bits ( 4 ) ; <S2SV_StartBug> if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width ) <S2SV_EndBug> derror ( ) ; } } }
","<S2SV_ModStart> ; row < raw_height <S2SV_ModEnd> ; row ++ <S2SV_ModStart> col < width && row < height
",LibRaw@LibRaw/f1394822a0152ceed77815eafa5cac4e8baab10a,CVE-2017-16909,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,2018-12-07T22:29Z,642,<S2SV_ModStart> ; if ( i >= width ) return 0,0
1444,CWE-787,"CWE-787 static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; <S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }
","<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev )
",torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z,643,<S2SV_ModStart> ( n ) <S2SV_ModEnd> ; } <S2SV_null>,0
1445,CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
",ImageMagick@ImageMagick/b173a352397877775c51c9a0e9d59eb6ce24c455,CVE-2016-10070,https://github.com/ImageMagick/ImageMagick/commit/b173a352397877775c51c9a0e9d59eb6ce24c455,2017-03-03T18:59Z,644,"<S2SV_ModStart>, sizeof ( double <S2SV_ModEnd> ) ) ;",0
1447,CWE-416,"CWE-416 static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <S2SV_StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <S2SV_EndBug> return HRTIMER_NORESTART ; }
","<S2SV_ModStart> ) bfq_idle_slice_timer_body ( bfqd ,
",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z,645,,0
1451,CWE-125,"CWE-125 static int update_prepare_order_info ( rdpContext * context , ORDER_INFO * orderInfo , UINT32 orderType ) { int length = 1 ; orderInfo -> fieldFlags = 0 ; orderInfo -> orderType = orderType ; orderInfo -> controlFlags = ORDER_STANDARD ; orderInfo -> controlFlags |= ORDER_TYPE_CHANGE ; length += 1 ; <S2SV_StartBug> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; <S2SV_EndBug> length += update_prepare_bounds ( context , orderInfo ) ; return length ; }
","<S2SV_ModStart> ; length += get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ; length +=
",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z,646,,0
1452,CWE-20,"CWE-20 static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ; <S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ; <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> new -> d_name . len ) ; <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> goto out_unlock ; <S2SV_StartBug> } <S2SV_EndBug> err = - ESTALE ; <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> goto out_dput ; <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ; <S2SV_StartBug> out_unlock : <S2SV_EndBug> unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }
","<S2SV_ModStart> ; olddentry = lookup_one_len ( old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> . name , old_upperdir , old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> = PTR_ERR ( olddentry <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( IS_ERR ( olddentry <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto out_unlock ; <S2SV_ModEnd> err = - <S2SV_ModStart> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> newdentry ) ; out_dput_old : dput ( olddentry ) ;
",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z,647,<S2SV_ModStart> out ; } <S2SV_ModEnd> if (!,0
1454,CWE-119,"CWE-119 void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
","<S2SV_ModStart> < MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,648,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1459,CWE-119,"CWE-119 <S2SV_StartBug> static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; <S2SV_EndBug> if ( ! frame_is_intra_only ( cm ) ) { <S2SV_StartBug> vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> rate , dist , bsize ) ; } else { MB_PREDICTION_MODE intramode = DC_PRED ; set_mode_info ( & xd -> mi [ 0 ] -> mbmi , bsize , intramode ) ; } duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; }
","<S2SV_ModStart> * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * const <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD * <S2SV_ModStart> -> e_mbd ; MB_MODE_INFO * mbmi ; <S2SV_ModStart> ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; mbmi = & <S2SV_ModEnd> xd -> mi <S2SV_ModStart> ] -> mbmi ; mbmi -> sb_type = bsize ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; if ( cm -> frame_type == KEY_FRAME ) hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; else if ( bsize >= BLOCK_8X8 ) <S2SV_ModEnd> vp9_pick_inter_mode ( cpi <S2SV_ModStart> , x , tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ; else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ; duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,649,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> int mi_row, <S2SV_ModStart> cpi, MACROBLOCKD * const tile, MACROBLOCKD * const tile, MACROBLOCKD * const x <S2SV_ModStart> mi_row, MACROBLOCKD * const x, <S2SV_ModEnd> mi_col ) <S2SV_ModStart> mi_row ) { <S2SV_ModEnd> if ( cpi <S2SV_ModStart> ( cpi, xd <S2SV_ModEnd>, mi_col )",0
1461,CWE-787,"CWE-787 MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; <S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }
","<S2SV_ModStart> = NULL ; reader . recursive_counter = 0 ;
",hoene@libmysofa/2e6fac6ab6156dae8e8c6f417741388084b70d6f,CVE-2019-20016,https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f,2019-12-27T02:15Z,650,,0
1462,CWE-908,"CWE-908 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug> { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
",ImageMagick@ImageMagick/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,CVE-2017-9098,https://github.com/ImageMagick/ImageMagick/commit/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,2017-05-19T19:29Z,651,<S2SV_ModStart> pixel_info -> rows * rows <S2SV_ModEnd> ; number_planes =,0
1464,CWE-189,"CWE-189 static int sysMapFD ( int fd , MemMapping * pMap ) { off_t start ; size_t length ; void * memPtr ; assert ( pMap != NULL ) ; if ( getFileStartAndLength ( fd , & start , & length ) < 0 ) return - 1 ; memPtr = mmap ( NULL , length , PROT_READ , MAP_PRIVATE , fd , start ) ; if ( memPtr == MAP_FAILED ) { LOGW ( ""mmap(%d,<S2SV_blank>R,<S2SV_blank>PRIVATE,<S2SV_blank>%d,<S2SV_blank>%d)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( int ) length , fd , ( int ) start , strerror ( errno ) ) ; return - 1 ; } pMap -> addr = memPtr ; pMap -> length = length ; pMap -> range_count = 1 ; <S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug> pMap -> ranges [ 0 ] . addr = memPtr ; pMap -> ranges [ 0 ] . length = length ; return 0 ; }
","<S2SV_ModStart> ) ) ; if ( pMap -> ranges == NULL ) { LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; }
",bootable@recovery/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,CVE-2016-0849,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,2016-04-18T00:59Z,652,,0
1465,CWE-476,"CWE-476 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return __this_address ; switch ( mode & S_IFMT ) { case S_IFIFO : case S_IFCHR : case S_IFBLK : case S_IFSOCK : if ( dip -> di_format != XFS_DINODE_FMT_DEV ) return __this_address ; break ; case S_IFREG : case S_IFLNK : case S_IFDIR : <S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ; if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ; if ( dip -> di_nextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { switch ( dip -> di_aformat ) { case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } } else { switch ( dip -> di_aformat ) { case 0 : case XFS_DINODE_FMT_EXTENTS : break ; default : return __this_address ; } if ( dip -> di_anextents ) return __this_address ; } fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , mode , flags ) ; if ( fa ) return fa ; if ( dip -> di_version < 3 ) return NULL ; flags2 = be64_to_cpu ( dip -> di_flags2 ) ; if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) return __this_address ; fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , mode , flags , flags2 ) ; if ( fa ) return fa ; return NULL ; }
","<S2SV_ModStart> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else {
",torvalds@linux/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,CVE-2018-13095,https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,2018-07-03T10:29Z,653,<S2SV_ModStart> break ; } if ( fa ) return fa ;,0
1468,CWE-119,"CWE-119 static vpx_codec_err_t vp8e_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx -> cfg . rc_target_bitrate ) return res ; if ( img ) res = validate_img ( ctx , img ) ; if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ; pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; <S2SV_StartBug> if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) <S2SV_EndBug> || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; } if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ; vp8_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP8_ALTR_FRAME ; vp8_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp8_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } } if ( ! res && ctx -> cpi ) { unsigned int lib_flags ; YV12_BUFFER_CONFIG sd ; int64_t dst_time_stamp , dst_end_time_stamp ; unsigned long size , cx_data_sz ; unsigned char * cx_data ; unsigned char * cx_data_end ; int comp_data_state = 0 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) ( ( VP8_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_OUTPUT_PARTITION ) ( ( VP8_COMP * ) ctx -> cpi ) -> output_partition = 1 ; lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = pts * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ; if ( vp8_receive_raw_frame ( ctx -> cpi , ctx -> next_frame_flag | lib_flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) { VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; res = update_error_state ( ctx , & cpi -> common . error ) ; } ctx -> next_frame_flag = 0 ; } cx_data = ctx -> cx_data ; cx_data_sz = ctx -> cx_data_sz ; cx_data_end = ctx -> cx_data + cx_data_sz ; lib_flags = 0 ; while ( cx_data_sz >= ctx -> cx_data_sz / 2 ) { comp_data_state = vp8_get_compressed_data ( ctx -> cpi , & lib_flags , & size , cx_data , cx_data_end , & dst_time_stamp , & dst_end_time_stamp , ! img ) ; if ( comp_data_state == VPX_CODEC_CORRUPT_FRAME ) return VPX_CODEC_CORRUPT_FRAME ; else if ( comp_data_state == - 1 ) break ; if ( size ) { vpx_codec_pts_t round , delta ; vpx_codec_cx_pkt_t pkt ; VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; <S2SV_StartBug> round = ( vpx_codec_pts_t ) 1000000 <S2SV_EndBug> * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ; pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long ) ( ( delta * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) ; pkt . data . frame . flags = lib_flags << 16 ; if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( ! cpi -> common . show_frame ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( cpi -> output_partition ) { int i ; const int num_partitions = ( 1 << cpi -> common . multi_token_partition ) + 1 ; pkt . data . frame . flags |= VPX_FRAME_IS_FRAGMENT ; for ( i = 0 ; i < num_partitions ; ++ i ) { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pkt . data . frame . buf = cpi -> partition_d [ i ] ; # else pkt . data . frame . buf = cx_data ; cx_data += cpi -> partition_sz [ i ] ; cx_data_sz -= cpi -> partition_sz [ i ] ; # endif pkt . data . frame . sz = cpi -> partition_sz [ i ] ; pkt . data . frame . partition_id = i ; if ( i == ( num_partitions - 1 ) ) pkt . data . frame . flags &= ~ VPX_FRAME_IS_FRAGMENT ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; } # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING cx_data_sz -= ctx -> cx_data_sz / 2 ; # endif } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; pkt . data . frame . partition_id = - 1 ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; cx_data += size ; cx_data_sz -= size ; } } } } return res ; }
","<S2SV_ModStart> ; if ( ! flags ) { flags = ctx -> control_frame_flags ; } ctx -> control_frame_flags = 0 ; res = set_reference_and_update ( ctx , flags ) ; <S2SV_ModEnd> if ( ctx <S2SV_ModStart> ( vpx_codec_pts_t ) 10000000 <S2SV_ModEnd> * ctx ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,654,"<S2SV_ModStart>, flags ) <S2SV_ModEnd> ; if (",0
1469,CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
",ImageMagick@ImageMagick/1bc1fd0ff8c555841c78829217ac81fa0598255d,CVE-2016-10071,https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d,2017-03-02T21:59Z,655,"<S2SV_ModStart>, sizeof ( double <S2SV_ModEnd> ) ) ;",1
1470,CWE-362,"CWE-362 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
",torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z,656,<S2SV_ModStart> ( event ) ; <S2SV_ModEnd> if ( event,0
1471,CWE-674,"CWE-674 static int bgp_attr_print ( netdissect_options * ndo , <S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> , u_int len , const unsigned attr_set_level <S2SV_ModStart> } if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else if ( <S2SV_ModStart> tptr , alen , attr_set_level + 1
",the-tcpdump-group@tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a,CVE-2018-16300,https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a,2019-10-03T16:15Z,657,"<S2SV_ModStart> int len ; ND_TCHECK2 ( tptr [ 0 ], sizeof ( int ) ) ;",0
1472,CWE-352,"CWE-352 static void do_runtime ( HttpRequest req , HttpResponse res ) { int pid = exist_daemon ( ) ; char buf [ STRLEN ] ; do_head ( res , ""_runtime"" , ""Runtime"" , 1000 ) ; StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'status-table\'><tr>"" ""<th<S2SV_blank>width=\'40%%\'>Parameter</th>"" ""<th<S2SV_blank>width=\'60%%\'>Value</th></tr>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ; if ( Run . files . log ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Logfile</td><td>%s</td></tr>"" , Run . files . log ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Pidfile</td><td>%s</td></tr>"" , Run . files . pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>State<S2SV_blank>file</td><td>%s</td></tr>"" , Run . files . state ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ; if ( Run . eventlist_dir ) { if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ; else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ; } # ifdef HAVE_OPENSSL { const char * options = Ssl_printOptions ( & ( Run . ssl ) , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>SSL<S2SV_blank>options</td><td>%s</td></tr>"" , options ) ; } # endif if ( Run . mmonits ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>M/Monit<S2SV_blank>server(s)</td><td>"" ) ; for ( Mmonit_T c = Run . mmonits ; c ; c = c -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>with<S2SV_blank>timeout<S2SV_blank>%s"" , c -> url -> url , Str_milliToTime ( c -> timeout , ( char [ 23 ] ) { } ) ) ; # ifdef HAVE_OPENSSL if ( c -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & c -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( c -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ c -> ssl . checksumType ] , c -> ssl . checksum ) ; } # endif if ( c -> url -> user ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>credentials"" ) ; if ( c -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . mailservers ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Mail<S2SV_blank>server(s)</td><td>"" ) ; for ( MailServer_T mta = Run . mailservers ; mta ; mta = mta -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s:%d"" , mta -> host , mta -> port ) ; # ifdef HAVE_OPENSSL if ( mta -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & mta -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( mta -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ mta -> ssl . checksumType ] , mta -> ssl . checksum ) ; } # endif if ( mta -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . from ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>from</td><td>"" ) ; if ( Run . MailFormat . from -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . from -> name , Run . MailFormat . from -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . from -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . replyto ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>reply<S2SV_blank>to</td><td>"" ) ; if ( Run . MailFormat . replyto -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . replyto -> name , Run . MailFormat . replyto -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . replyto -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . subject ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>subject</td><td>%s</td></tr>"" , Run . MailFormat . subject ) ; if ( Run . MailFormat . message ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>message</td><td>%s</td></tr>"" , Run . MailFormat . message ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>Send/Expect<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . sendExpectBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>file<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . fileContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . httpContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>program<S2SV_blank>output</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . programOutput , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>network<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . networkTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>check<S2SV_blank>program<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . programTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>stop<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . stopTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>start<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . startTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>restart<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . restartTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>On<S2SV_blank>reboot</td><td>%s</td></tr>"" , onrebootnames [ Run . onreboot ] ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Poll<S2SV_blank>time</td><td>%d<S2SV_blank>seconds<S2SV_blank>with<S2SV_blank>start<S2SV_blank>delay<S2SV_blank>%d<S2SV_blank>seconds</td></tr>"" , Run . polltime , Run . startdelay ) ; if ( Run . httpd . flags & Httpd_Net ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>bind<S2SV_blank>address</td><td>%s</td></tr>"" , Run . httpd . socket . net . address ? Run . httpd . socket . net . address : ""Any/All"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>portnumber</td><td>%d</td></tr>"" , Run . httpd . socket . net . port ) ; } else if ( Run . httpd . flags & Httpd_Unix ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>unix<S2SV_blank>socket</td><td>%s</td></tr>"" , Run . httpd . socket . unix . path ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>signature</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Signature ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>ssl<S2SV_blank>encryption</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Ssl ? ""True"" : ""False"" ) ; if ( Run . httpd . flags & Httpd_Ssl ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>PEM<S2SV_blank>key/certificate<S2SV_blank>file</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . pem ) ; if ( Run . httpd . socket . net . ssl . clientpem != NULL ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Enabled"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certificate<S2SV_blank>file"" ""</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . clientpem ) ; } else { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Disabled"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>Allow<S2SV_blank>self<S2SV_blank>certified<S2SV_blank>certificates<S2SV_blank>"" ""</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_AllowSelfSignedCertificates ? ""True"" : ""False"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>auth.<S2SV_blank>style</td><td>%s</td></tr>"" , Run . httpd . credentials && Engine_hasAllow ( ) ? ""Basic<S2SV_blank>Authentication<S2SV_blank>and<S2SV_blank>Host/Net<S2SV_blank>allow<S2SV_blank>list"" : Run . httpd . credentials ? ""Basic<S2SV_blank>Authentication"" : Engine_hasAllow ( ) ? ""Host/Net<S2SV_blank>allow<S2SV_blank>list"" : ""No<S2SV_blank>authentication"" ) ; print_alerts ( res , Run . maillist ) ; StringBuffer_append ( res -> outputbuffer , ""</table>"" ) ; if ( ! is_readonly ( req ) ) { StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'buttons\'><tr>"" ) ; StringBuffer_append ( res -> outputbuffer , <S2SV_StartBug> ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" <S2SV_EndBug> ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank><input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { StringBuffer_append ( res -> outputbuffer , <S2SV_StartBug> ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; <S2SV_EndBug> } StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; } do_foot ( res ) ; }
","<S2SV_ModStart> -> outputbuffer , ""<td<S2SV_blank>style=\'color:red;\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ) ; }
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z,658,<S2SV_ModStart> -> outputbuffer ; <S2SV_ModEnd> if ( res,0
1473,CWE-119,"CWE-119 void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; <S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) src_pitch ; memcpy <S2SV_ModEnd> ( dest ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,659,"<S2SV_ModStart> dest ) { memcpy <S2SV_ModEnd> ( dest,",0
1474,CWE-120,"CWE-120 bool zx_confirmZxLiquidTx ( uint32_t data_total , const EthereumSignTx * msg ) { ( void ) data_total ; const TokenType * token ; char constr1 [ 40 ] , constr2 [ 40 ] , * arStr = """" ; uint8_t * tokenAddress , * deadlineBytes ; bignum256 tokenAmount , tokenMinAmount , ethMinAmount ; uint64_t deadline ; if ( isAddLiquidityEthCall ( msg ) ) { arStr = ""uniswap<S2SV_blank>add<S2SV_blank>liquidity"" ; } else if ( isRemoveLiquidityEthCall ( msg ) ) { arStr = ""uniswap<S2SV_blank>remove<S2SV_blank>liquidity"" ; } else { return false ; } tokenAddress = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 32 - 20 ) ; token = tokenByChainAddress ( msg -> chain_id , tokenAddress ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 32 , 32 , & tokenAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 2 * 32 , 32 , & tokenMinAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 3 * 32 , 32 , & ethMinAmount ) ; deadlineBytes = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 6 * 32 - 8 ) ; deadline = ( ( uint64_t ) deadlineBytes [ 0 ] << 8 * 7 ) | ( ( uint64_t ) deadlineBytes [ 1 ] << 8 * 6 ) | ( ( uint64_t ) deadlineBytes [ 2 ] << 8 * 5 ) | ( ( uint64_t ) deadlineBytes [ 3 ] << 8 * 4 ) | ( ( uint64_t ) deadlineBytes [ 4 ] << 8 * 3 ) | ( ( uint64_t ) deadlineBytes [ 5 ] << 8 * 2 ) | ( ( uint64_t ) deadlineBytes [ 6 ] << 8 * 1 ) | ( ( uint64_t ) deadlineBytes [ 7 ] ) ; char tokbuf [ 32 ] ; ethereumFormatAmount ( & tokenAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr1 , 32 , ""%s"" , tokbuf ) ; ethereumFormatAmount ( & tokenMinAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr2 , 32 , ""%s"" , tokbuf ) ; confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""%s\\nMinimum<S2SV_blank>%s"" , constr1 , constr2 ) ; if ( ! confirmFromAccountMatch ( msg , arStr ) ) { return false ; } ethereumFormatAmount ( & ethMinAmount , NULL , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr1 , 32 , ""%s"" , tokbuf ) ; confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Minimum<S2SV_blank>%s"" , constr1 ) ; <S2SV_StartBug> snprintf ( constr1 , 32 , ""%lld"" , deadline ) ; <S2SV_EndBug> confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ; return true ; }
","<S2SV_ModStart> constr1 ) ; <S2SV_ModEnd> confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput
",keepkey@keepkey-firmware/e49d45594002d4d3fbc1f03488e6dfc0a0a65836,CVE-2021-31616,https://github.com/keepkey/keepkey-firmware/commit/e49d45594002d4d3fbc1f03488e6dfc0a0a65836,2021-05-06T13:15Z,660,<S2SV_ModStart> ) ) ; return <S2SV_ModEnd> <S2SV_null> <S2SV_null>,0
1479,CWE-119,"CWE-119 static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , ""invalid<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>config<S2SV_blank>index<S2SV_blank>%d:<S2SV_blank>"" ""type<S2SV_blank>=<S2SV_blank>0x%X,<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%d\\n"" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>interfaces:<S2SV_blank>%d,<S2SV_blank>"" ""using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n"" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { if ( size2 < sizeof ( struct usb_descriptor_header ) ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>descriptor<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>excess<S2SV_blank>"" ""byte%s,<S2SV_blank>ignoring\\n"" , cfgno , size2 , plural ( size2 ) ) ; break ; } header = ( struct usb_descriptor_header * ) buffer2 ; if ( ( header -> bLength > size2 ) || ( header -> bLength < 2 ) ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>descriptor<S2SV_blank>"" ""of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping<S2SV_blank>remainder<S2SV_blank>of<S2SV_blank>the<S2SV_blank>config\\n"" , cfgno , header -> bLength ) ; break ; } if ( header -> bDescriptorType == USB_DT_INTERFACE ) { struct usb_interface_descriptor * d ; int inum ; d = ( struct usb_interface_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>"" ""interface<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>"" ""skipping\\n"" , cfgno , d -> bLength ) ; continue ; } inum = d -> bInterfaceNumber ; if ( ( dev -> quirks & USB_QUIRK_HONOR_BNUMINTERFACES ) && n >= nintf_orig ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>more<S2SV_blank>interface<S2SV_blank>"" ""descriptors,<S2SV_blank>than<S2SV_blank>it<S2SV_blank>declares<S2SV_blank>in<S2SV_blank>"" ""bNumInterfaces,<S2SV_blank>ignoring<S2SV_blank>interface<S2SV_blank>"" ""number:<S2SV_blank>%d\\n"" , cfgno , inum ) ; continue ; } if ( inum >= nintf_orig ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>"" ""interface<S2SV_blank>number:<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , cfgno , inum , nintf_orig - 1 ) ; for ( i = 0 ; i < n ; ++ i ) { if ( inums [ i ] == inum ) break ; } if ( i < n ) { if ( nalts [ i ] < 255 ) ++ nalts [ i ] ; } else if ( n < USB_MAXINTERFACES ) { inums [ n ] = inum ; nalts [ n ] = 1 ; ++ n ; } } else if ( header -> bDescriptorType == USB_DT_INTERFACE_ASSOCIATION ) { <S2SV_StartBug> if ( iad_num == USB_MAXIADS ) { <S2SV_EndBug> dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\n"" , cfgno ) ; } else { config -> intf_assoc [ iad_num ] = <S2SV_StartBug> ( struct usb_interface_assoc_descriptor <S2SV_EndBug> * ) header ; iad_num ++ ; } } else if ( header -> bDescriptorType == USB_DT_DEVICE || header -> bDescriptorType == USB_DT_CONFIG ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>"" ""descriptor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>0x%X,<S2SV_blank>skipping\\n"" , cfgno , header -> bDescriptorType ) ; } size = buffer2 - buffer ; config -> desc . wTotalLength = cpu_to_le16 ( buffer2 - buffer0 ) ; if ( n != nintf ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>interface%s,<S2SV_blank>different<S2SV_blank>from<S2SV_blank>"" ""the<S2SV_blank>descriptor\'s<S2SV_blank>value:<S2SV_blank>%d\\n"" , cfgno , n , plural ( n ) , nintf_orig ) ; else if ( n == 0 ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interfaces?\\n"" , cfgno ) ; config -> desc . bNumInterfaces = nintf = n ; for ( i = 0 ; i < nintf ; ++ i ) { for ( j = 0 ; j < nintf ; ++ j ) { if ( inums [ j ] == i ) break ; } if ( j >= nintf ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interface<S2SV_blank>number<S2SV_blank>"" ""%d\\n"" , cfgno , i ) ; } for ( i = 0 ; i < nintf ; ++ i ) { j = nalts [ i ] ; if ( j > USB_MAXALTSETTING ) { dev_warn ( ddev , ""too<S2SV_blank>many<S2SV_blank>alternate<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>"" ""config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d:<S2SV_blank>%d,<S2SV_blank>"" ""using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n"" , cfgno , inums [ i ] , j , USB_MAXALTSETTING ) ; nalts [ i ] = j = USB_MAXALTSETTING ; } len = sizeof ( * intfc ) + sizeof ( struct usb_host_interface ) * j ; config -> intf_cache [ i ] = intfc = kzalloc ( len , GFP_KERNEL ) ; if ( ! intfc ) return - ENOMEM ; kref_init ( & intfc -> ref ) ; } config -> extra = buffer ; i = find_next_descriptor ( buffer , size , USB_DT_INTERFACE , USB_DT_INTERFACE , & n ) ; config -> extralen = i ; if ( n > 0 ) dev_dbg ( ddev , ""skipped<S2SV_blank>%d<S2SV_blank>descriptor%s<S2SV_blank>after<S2SV_blank>%s\\n"" , n , plural ( n ) , ""configuration"" ) ; buffer += i ; size -= i ; while ( size > 0 ) { retval = usb_parse_interface ( ddev , cfgno , config , buffer , size , inums , nalts ) ; if ( retval < 0 ) return retval ; buffer += retval ; size -= retval ; } for ( i = 0 ; i < nintf ; ++ i ) { intfc = config -> intf_cache [ i ] ; for ( j = 0 ; j < intfc -> num_altsetting ; ++ j ) { for ( n = 0 ; n < intfc -> num_altsetting ; ++ n ) { if ( intfc -> altsetting [ n ] . desc . bAlternateSetting == j ) break ; } if ( n >= intfc -> num_altsetting ) dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>"" ""altsetting<S2SV_blank>%d\\n"" , cfgno , inums [ i ] , j ) ; } } return 0 ; }
","<S2SV_ModStart> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n"" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> iad_num ] = d <S2SV_ModEnd> ; iad_num ++
",torvalds@linux/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb,CVE-2017-16531,https://github.com/torvalds/linux/commit/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb,2017-11-04T01:29Z,661,<S2SV_ModStart> ; int ret = 0,0
1480,CWE-190,"CWE-190 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; <S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; ue -> card = card ; ue -> info = * info ; ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }
","<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (
",torvalds@linux/82262a46627bebb0febcc26664746c25cef08563,CVE-2014-4655,https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563,2014-07-03T04:22Z,662,<S2SV_ModStart> ) return - EINVAL <S2SV_ModEnd> ; if (,0
1483,CWE-400,"CWE-400 static void perf_event_mmap_output ( struct perf_event * event , struct perf_mmap_event * mmap_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = mmap_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <S2SV_StartBug> mmap_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> if ( ret ) goto out ; mmap_event -> event_id . pid = perf_event_pid ( event , current ) ; mmap_event -> event_id . tid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , mmap_event -> event_id ) ; __output_copy ( & handle , mmap_event -> file_name , mmap_event -> file_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : mmap_event -> event_id . header . size = size ; }
","<S2SV_ModStart> header . size <S2SV_ModEnd> , 0 )
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,663,"<S2SV_ModStart>, 0, <S2SV_ModEnd> size ) ;",0
1484,CWE-264,"CWE-264 static void ifb_setup ( struct net_device * dev ) { dev -> destructor = free_netdev ; dev -> netdev_ops = & ifb_netdev_ops ; ether_setup ( dev ) ; dev -> tx_queue_len = TX_Q_LIMIT ; dev -> features |= IFB_FEATURES ; dev -> vlan_features |= IFB_FEATURES ; dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> random_ether_addr ( dev -> dev_addr ) ; }
","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; random_ether_addr (
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,664,<S2SV_ModStart> priv_flags &= ~ ( IFF_SHARING ) <S2SV_ModEnd> ; dev ->,0
1485,CWE-119,"CWE-119 void vp8_pick_intra_mode ( MACROBLOCK * x , int * rate_ ) { int error4x4 , error16x16 = INT_MAX ; int rate , best_rate = 0 , distortion , best_sse ; MB_PREDICTION_MODE mode , best_mode = DC_PRED ; int this_rd ; unsigned int sse ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; xd -> mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; pick_intra_mbuv_mode ( x ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { xd -> mode_info_context -> mbmi . mode = mode ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; <S2SV_StartBug> distortion = vp8_variance16x16 <S2SV_EndBug> ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( error16x16 > this_rd ) { error16x16 = this_rd ; best_mode = mode ; best_sse = sse ; best_rate = rate ; } } xd -> mode_info_context -> mbmi . mode = best_mode ; error4x4 = pick_intra4x4mby_modes ( x , & rate , & best_sse ) ; if ( error4x4 < error16x16 ) { xd -> mode_info_context -> mbmi . mode = B_PRED ; best_rate = rate ; } * rate_ = best_rate ; }
","<S2SV_ModStart> ; distortion = vpx_variance16x16 <S2SV_ModEnd> ( * (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,665,<S2SV_ModStart> ; # endif memcpy <S2SV_ModEnd> ( b ->,0
1486,CWE-20,"CWE-20 error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( ""Initializing<S2SV_blank>ENC624J600<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <S2SV_EndBug> if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) { <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <S2SV_EndBug> interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ; <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <S2SV_EndBug> interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ; <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <S2SV_EndBug> interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <S2SV_EndBug> temp = htole16 ( interface -> macAddr . w [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <S2SV_EndBug> temp = htole16 ( interface -> macAddr . w [ 2 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN | <S2SV_EndBug> ERXFCON_CRCEN | ERXFCON_RUNTEN | ERXFCON_UCEN | ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , 0x0000 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , <S2SV_EndBug> MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_MAMXFL , ETH_MAX_FRAME_SIZE ) ; <S2SV_StartBug> enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 | <S2SV_EndBug> PHANA_AD100FD | PHANA_AD100 | PHANA_AD10FD | PHANA_AD10 | PHANA_ADIEEE0 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EIR , 0x0000 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE | <S2SV_EndBug> EIE_LINKIE | EIE_PKTIE | EIE_TXIE | EIE_TXABTIE ) ; <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> enc624j600DumpReg ( interface ) ; enc624j600DumpPhyReg ( interface ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_ERXST <S2SV_ModEnd> , ENC624J600_RX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL <S2SV_ModEnd> , ENC624J600_RX_BUFFER_STOP ) <S2SV_ModStart> ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <S2SV_ModEnd> ) ; enc624j600DumpReg
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,666,"<S2SV_ModStart> ( interface, ENC624J600_EIR <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_EIR <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_EIR <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MACON2 <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface -> <S2SV_ModStart> ( interface, ENC624J600_MACON2 <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface -> <S2SV_ModStart> ( interface, ENC624J600_MACON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_MACON2 <S2SV_ModEnd> ) ; } }",0
1487,CWE-119,"CWE-119 void psf_asciiheader_printf ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; int maxlen ; char * start ; <S2SV_StartBug> maxlen = strlen ( ( char * ) psf -> header ) ; <S2SV_EndBug> <S2SV_StartBug> start = ( ( char * ) psf -> header ) + maxlen ; <S2SV_EndBug> <S2SV_StartBug> maxlen = sizeof ( psf -> header ) - maxlen ; <S2SV_EndBug> va_start ( argptr , format ) ; vsnprintf ( start , maxlen , format , argptr ) ; va_end ( argptr ) ; start [ maxlen - 1 ] = 0 ; <S2SV_StartBug> psf -> headindex = strlen ( ( char * ) psf -> header ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> ; maxlen = <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . len <S2SV_ModEnd> - maxlen ; <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> = strlen ( <S2SV_ModStart> psf -> header . ptr
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,667,<S2SV_ModStart> char * header <S2SV_ModEnd> ; char *,0
1490,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> if ( ctx -> priv -> alg_priv ) <S2SV_EndBug> <S2SV_StartBug> ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> ; else { <S2SV_ModEnd> ctx -> iface <S2SV_ModStart> -> destroy ( ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> ctx -> priv <S2SV_ModEnd> ) ; ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,668,<S2SV_ModStart> ctx -> priv <S2SV_ModEnd> ; if (,0
1492,CWE-119,"CWE-119 static void set_good_speed_feature ( VP9_COMP * cpi , VP9_COMMON * cm , SPEED_FEATURES * sf , int speed ) { <S2SV_StartBug> sf -> adaptive_rd_thresh = 1 ; <S2SV_EndBug> sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) { <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> less_rectangular_check = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> sf -> adaptive_rd_thresh = 2 ; <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> } if ( speed >= 2 ) { <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> : USE_LARGESTALL ; <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = LAST_AND_INTRA_SPLIT_ONLY ; sf -> adaptive_pred_interp_filter = 2 ; sf -> reference_masking = 1 ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf -> disable_filter_search_var_thresh = 100 ; sf -> comp_inter_joint_search_thresh = BLOCK_SIZES ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> sf -> adjust_partitioning_from_last_frame = 1 ; sf -> last_partitioning_redo_frequency = 3 ; } if ( speed >= 3 ) { <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; else sf -> disable_split_mask = DISABLE_ALL_INTER_SPLIT ; sf -> recode_loop = ALLOW_RECODE_KFMAXBW ; sf -> adaptive_rd_thresh = 3 ; sf -> mode_skip_start = 6 ; <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> sf -> use_fast_coef_costing = 1 ; } if ( speed >= 4 ) { sf -> use_square_partition_only = 1 ; sf -> tx_size_search_method = USE_LARGESTALL ; <S2SV_StartBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 4 ; <S2SV_EndBug> <S2SV_StartBug> sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH | <S2SV_EndBug> FLAG_EARLY_TERMINATE ; sf -> disable_filter_search_var_thresh = 200 ; <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lp32x32fdct = 1 ; <S2SV_EndBug> } if ( speed >= 5 ) { int i ; <S2SV_StartBug> sf -> partition_search_type = FIXED_PARTITION ; <S2SV_EndBug> sf -> optimize_coefficients = 0 ; <S2SV_StartBug> sf -> search_method = HEX ; <S2SV_EndBug> sf -> disable_filter_search_var_thresh = 500 ; for ( i = 0 ; i < TX_SIZES ; ++ i ) { <S2SV_StartBug> sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> } cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ; } }
","<S2SV_ModStart> speed ) { const int boosted = frame_is_boosted ( cpi ) ; <S2SV_ModStart> adaptive_rd_thresh = 1 <S2SV_ModEnd> ; sf -> <S2SV_ModStart> 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> cm ) ; } <S2SV_ModStart> ; sf -> <S2SV_ModEnd> use_rd_breakout = 1 <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <S2SV_ModStart> -> tx_size_search_method = frame_is_boosted <S2SV_ModEnd> ( cpi ) <S2SV_ModStart> : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <S2SV_ModEnd> ( cm -> <S2SV_ModStart> ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER <S2SV_ModStart> ; sf -> allow_partition_search_skip = 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> ; sf -> <S2SV_ModStart> ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <S2SV_ModEnd> ; sf -> <S2SV_ModStart> = 4 ; if ( cm -> frame_type != KEY_FRAME ) <S2SV_ModStart> -> mode_search_skip_flags |= <S2SV_ModEnd> FLAG_EARLY_TERMINATE ; sf <S2SV_ModStart> ; sf -> <S2SV_ModEnd> use_lp32x32fdct = 1 <S2SV_ModStart> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModStart> ; sf -> <S2SV_ModEnd> optimize_coefficients = 0 <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> i ] = INTRA_DC <S2SV_ModEnd> ; sf -> <S2SV_ModStart> i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,669,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
1495,CWE-284,"CWE-284 static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; <S2SV_StartBug> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <S2SV_EndBug> if ( ret == - 1 ) { APPL_TRACE_ERROR ( ""poll<S2SV_blank>ret<S2SV_blank>-1,<S2SV_blank>exit<S2SV_blank>the<S2SV_blank>thread,<S2SV_blank>errno:%d,<S2SV_blank>err:%s"" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( ""h:%d,<S2SV_blank>process_cmd_sock<S2SV_blank>return<S2SV_blank>false,<S2SV_blank>exit..."" , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( ""no<S2SV_blank>data,<S2SV_blank>select<S2SV_blank>ret:<S2SV_blank>%d"" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( ""socket<S2SV_blank>poll<S2SV_blank>thread<S2SV_blank>exiting,<S2SV_blank>h:%d"" , h ) ; return 0 ; }
","<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , - 1 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,670,"<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1, 0 )",0
1496,CWE-416,"CWE-416 void luaD_shrinkstack ( lua_State * L ) { int inuse = stackinuse ( L ) ; <S2SV_StartBug> int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; <S2SV_EndBug> if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L , goodsize , 0 ) ; else condmovestack ( L , { } , { } ) ; luaE_shrinkCI ( L ) ; }
","<S2SV_ModStart> = inuse + BASIC_STACK_SIZE <S2SV_ModEnd> ; if (
",lua@lua/6298903e35217ab69c279056f925fb72900ce0b7,CVE-2020-15888,https://github.com/lua/lua/commit/6298903e35217ab69c279056f925fb72900ce0b7,2020-07-21T22:15Z,671,<S2SV_ModStart> S2SV_null> < 0,0
1497,CWE-125,"CWE-125 PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,672,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result,1
1498,CWE-125,"CWE-125 static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ; <S2SV_StartBug> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <S2SV_EndBug> int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\'' && * raw != \'""\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) { <S2SV_StartBug> char * s = """" ; <S2SV_EndBug> char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf , sizeof ( buf ) , ""(unicode<S2SV_blank>error)<S2SV_blank>%s"" , s ) ; ast_error ( n , buf ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n , ""(unicode<S2SV_blank>error)<S2SV_blank>unknown<S2SV_blank>error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; } # endif return NULL ; } PyArena_AddPyObject ( c -> c_arena , str ) ; return Str ( str , kind , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case NUMBER : { PyObject * pynum = parsenumber ( c , STR ( ch ) ) ; if ( ! pynum ) return NULL ; PyArena_AddPyObject ( c -> c_arena , pynum ) ; return Num ( pynum , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case LPAR : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RPAR ) return Tuple ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( TYPE ( ch ) == yield_expr ) return ast_for_expr ( c , ch ) ; return ast_for_testlist_comp ( c , ch ) ; case LSQB : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RSQB ) return List ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; REQ ( ch , listmaker ) ; if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts = seq_for_testlist ( c , ch ) ; if ( ! elts ) return NULL ; return List ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else return ast_for_listcomp ( c , ch ) ; case LBRACE : { int i , size ; asdl_seq * keys , * values ; ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RBRACE ) { return Dict ( NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts ; size = ( NCH ( ch ) + 1 ) / 2 ; elts = asdl_seq_new ( size , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 2 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( elts , i / 2 , expression ) ; } return Set ( elts , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { return ast_for_setcomp ( c , ch ) ; } else if ( NCH ( ch ) > 3 && TYPE ( CHILD ( ch , 3 ) ) == comp_for ) { return ast_for_dictcomp ( c , ch ) ; } else { size = ( NCH ( ch ) + 1 ) / 4 ; keys = asdl_seq_new ( size , c -> c_arena ) ; if ( ! keys ) return NULL ; values = asdl_seq_new ( size , c -> c_arena ) ; if ( ! values ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 4 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( keys , i / 4 , expression ) ; expression = ast_for_expr ( c , CHILD ( ch , i + 2 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( values , i / 4 , expression ) ; } return Dict ( keys , values , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } case BACKQUOTE : { expr_ty expression ; if ( Py_Py3kWarningFlag && ! ast_warn ( c , n , ""backquote<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>3.x;<S2SV_blank>use<S2SV_blank>repr()"" ) ) return NULL ; expression = ast_for_testlist ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; return Repr ( expression , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } default : PyErr_Format ( PyExc_SystemError , ""unhandled<S2SV_blank>atom<S2SV_blank>%d"" , TYPE ( ch ) ) ; return NULL ; } }
","<S2SV_ModStart> , 0 ) <S2SV_ModEnd> ) ; char <S2SV_ModStart> errstr ) { const
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,673,,0
1499,CWE-119,"CWE-119 static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ; <S2SV_StartBug> int is_keyframe_qaunt_set = 0 ; <S2SV_EndBug> vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , ""="" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , ""<S2SV_blank>"" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""option<S2SV_blank>missing<S2SV_blank>value:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } <S2SV_StartBug> if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) { <S2SV_EndBug> res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> } else if ( strcmp ( ""layers"" , option_name ) == 0 ) { <S2SV_EndBug> svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) { <S2SV_EndBug> res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> if ( ! is_keyframe_qaunt_set ) { <S2SV_EndBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; } } else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) { res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ; if ( res != VPX_CODEC_OK ) break ; <S2SV_StartBug> is_keyframe_qaunt_set = 1 ; <S2SV_EndBug> } else { svc_log ( svc_ctx , SVC_LOG_ERROR , ""invalid<S2SV_blank>option:<S2SV_blank>%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } option_name = strtok_r ( NULL , ""="" , & input_ptr ) ; } free ( input_string ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
","<S2SV_ModStart> * input_ptr ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( strcmp ( ""spatial-layers"" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""temporal-layers"" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( strcmp ( ""max-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( strcmp ( ""min-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) break ; } else if ( strcmp ( ""auto-alt-refs"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) break ; } else if ( strcmp ( ""bitrates"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( ""multi-frame-contexts"" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <S2SV_ModEnd> ; } else <S2SV_ModStart> input_string ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could"" ""enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\n"" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,674,<S2SV_ModStart> ; int res = 0 <S2SV_ModStart> ; if ( option_type == NULL ) { if ( option_type == NULL ) return VPX_CODEC_FORMAT ; } else if ( <S2SV_ModStart> ) return VPX_CODEC_ERROR ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } else if ( option_type == 0 ) ) { if ( opt_type == 0 ) { res = 1 ; } else if ( <S2SV_ModStart> == VPX_CODEC_FACTORS2SV_null> 0 ) ) { vp9_null>,0
1500,CWE-416,"CWE-416 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
",torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z,675,<S2SV_ModStart> ( event ) ; <S2SV_ModEnd> if ( event,0
1504,CWE-119,"CWE-119 void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } <S2SV_StartBug> fprintf ( mvs , ""\\n"" ) ; <S2SV_EndBug> mb_index = 0 ; fprintf ( mvs , ""Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , ""xx<S2SV_blank>"" ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%5d:%-5d"" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } fprintf ( mvs , ""\\n"" ) ; <S2SV_StartBug> mb_index = 0 ; <S2SV_EndBug> fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , ""%3d:%-3d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; fclose ( mvs ) ; }
","<S2SV_ModStart> , ""\\n"" ) <S2SV_ModEnd> ; fprintf ( <S2SV_ModStart> ""\\n"" ) ; <S2SV_ModEnd> fprintf ( mvs
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,676,"<S2SV_ModStart> ) ) ; memset ( mb_col, 1 ) ;",0
1505,CWE-190,"CWE-190 static PyObject * _pickle_UnpicklerMemoProxy_copy_impl ( UnpicklerMemoProxyObject * self ) { <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; for ( i = 0 ; i < self -> unpickler -> memo_size ; i ++ ) { int status ; PyObject * key , * value ; value = self -> unpickler -> memo [ i ] ; if ( value == NULL ) continue ; key = PyLong_FromSsize_t ( i ) ; if ( key == NULL ) goto error ; status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; if ( status < 0 ) goto error ; } return new_memo ; error : Py_DECREF ( new_memo ) ; return NULL ; }
","<S2SV_ModStart> self ) { size_t <S2SV_ModEnd> i ; PyObject
",python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z,677,,0
1506,CWE-119,"CWE-119 cJSON * cJSON_CreateObject ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Object ; return item ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,678,,1
1508,CWE-416,"CWE-416 int dbd_db_login ( SV * dbh , imp_dbh_t * imp_dbh , char * dbname , char * user , char * password ) { # ifdef dTHR dTHR ; # endif dTHX ; D_imp_xxh ( dbh ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->connect:<S2SV_blank>dsn<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" ) ; imp_dbh -> stats . auto_reconnects_ok = 0 ; imp_dbh -> stats . auto_reconnects_failed = 0 ; imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> has_transactions = TRUE ; imp_dbh -> auto_reconnect = FALSE ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_dbh -> enable_utf8 = FALSE ; # endif if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) { <S2SV_StartBug> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <S2SV_EndBug> mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; return FALSE ; } DBIc_ACTIVE_on ( imp_dbh ) ; DBIc_on ( imp_dbh , DBIcf_IMPSET ) ; return TRUE ; }
","<S2SV_ModStart> ) ) { if ( imp_dbh -> pmysql )
",perl5-dbi@DBD-mysql/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,CVE-2014-9906,https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,2016-08-19T21:59Z,679,<S2SV_ModStart> return false,0
1509,CWE-284,"CWE-284 void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; <S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_unlock ( & slot_lock ) ; <S2SV_EndBug> <S2SV_StartBug> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <S2SV_EndBug> } else { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>read<S2SV_blank>while<S2SV_blank>disconnected,<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>write<S2SV_blank>while<S2SV_blank>disconnected<S2SV_blank>(or<S2SV_blank>write<S2SV_blank>failure),<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <S2SV_StartBug> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <S2SV_EndBug> cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }
","<S2SV_ModStart> ) || ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> & size ) ) <S2SV_ModStart> size ) ) { <S2SV_ModEnd> BTA_JvRfcommWrite ( slot <S2SV_ModStart> id ) ; } <S2SV_ModStart> ( need_close || TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & size )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,680,"<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart>, 0 ) )",0
1510,CWE-20,"CWE-20 static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ; <S2SV_StartBug> struct ieee_802_11_phdr phdr ; <S2SV_EndBug> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti = proto_tree_add_item ( ppi_tree , hf_ppi_head_flags , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; ppi_flags_tree = proto_item_add_subtree ( ti , ett_ppi_flags ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_alignment , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_reserved , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_len , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_dlt , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; } tot_len -= PPI_V0_HEADER_LEN ; offset += 8 ; memset ( & phdr , 0 , sizeof ( phdr ) ) ; phdr . fcs_len = - 1 ; phdr . decrypted = FALSE ; phdr . datapad = FALSE ; phdr . phy = PHDR_802_11_PHY_UNKNOWN ; phdr . presence_flags = 0 ; while ( tot_len > 0 ) { data_type = tvb_get_letohs ( tvb , offset ) ; data_len = tvb_get_letohs ( tvb , offset + 2 ) + 4 ; tot_len -= data_len ; switch ( data_type ) { case PPI_80211_COMMON : dissect_80211_common ( tvb , pinfo , ppi_tree , offset , data_len , & phdr ) ; break ; case PPI_80211N_MAC : dissect_80211n_mac ( tvb , pinfo , ppi_tree , offset , data_len , TRUE , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_80211N_MAC_PHY : dissect_80211n_mac_phy ( tvb , pinfo , ppi_tree , offset , data_len , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_SPECTRUM_MAP : ADD_BASIC_TAG ( hf_spectrum_map ) ; break ; case PPI_PROCESS_INFO : ADD_BASIC_TAG ( hf_process_info ) ; break ; case PPI_CAPTURE_INFO : ADD_BASIC_TAG ( hf_capture_info ) ; break ; case PPI_AGGREGATION_EXTENSION : dissect_aggregation_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_8023_EXTENSION : dissect_8023_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_GPS_INFO : if ( ppi_gps_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_gps , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ; } break ; default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ; } offset += data_len ; if ( IS_PPI_FLAG_ALIGN ( flags ) ) { offset += PADDING4 ( offset ) ; } } if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) { len_remain = tvb_captured_length_remaining ( tvb , offset ) ; # if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { pad_len = PADDING4 ( len_remain ) ; } # endif pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; while ( fd_head ) { ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ; fd_head = fd_head -> next ; } if ( ampdu_len > AGGREGATE_MAX ) { if ( tree ) { proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ; THROW ( ReportedBoundsError ) ; } else { return ; } } fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ; pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; if ( fd_head && tree ) { ft_fdh = fd_head ; seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; while ( ft_fdh ) { if ( ft_fdh -> tvb_data && ft_fdh -> len ) { last_frame = ft_fdh -> frame ; if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ; first_mpdu = FALSE ; proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ; proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ; } ft_fdh = ft_fdh -> next ; } if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ; } if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ; agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ; } while ( fd_head ) { if ( fd_head -> tvb_data && fd_head -> len ) { mpdu_count ++ ; mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ; next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ; add_new_data_source ( pinfo , next_tvb , mpdu_str ) ; ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ; call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ; } fd_head = fd_head -> next ; } proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ; pinfo -> fragmented = FALSE ; } else { next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ; col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ; call_dissector ( data_handle , next_tvb , pinfo , tree ) ; } return ; } next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; if ( dlt == 105 ) { call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; } else { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> ( wtap_encap_dissector_table , wtap_encap <S2SV_ModEnd> , next_tvb , <S2SV_ModStart> pinfo , tree , TRUE , phdrp
",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z,681,<S2SV_ModStart> = 0 ; struct hhdr_len = 0 ; <S2SV_ModStart> struct eth ; phdr = 0,0
1511,CWE-190,"CWE-190 sds sdsnewlen ( const void * init , size_t initlen ) { void * sh ; sds s ; char type = sdsReqType ( initlen ) ; if ( type == SDS_TYPE_5 && initlen == 0 ) type = SDS_TYPE_8 ; int hdrlen = sdsHdrSize ( type ) ; unsigned char * fp ; <S2SV_StartBug> sh = s_malloc ( hdrlen + initlen + 1 ) ; <S2SV_EndBug> if ( sh == NULL ) return NULL ; if ( init == SDS_NOINIT ) init = NULL ; else if ( ! init ) memset ( sh , 0 , hdrlen + initlen + 1 ) ; s = ( char * ) sh + hdrlen ; fp = ( ( unsigned char * ) s ) - 1 ; switch ( type ) { case SDS_TYPE_5 : { * fp = type | ( initlen << SDS_TYPE_BITS ) ; break ; } case SDS_TYPE_8 : { SDS_HDR_VAR ( 8 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_16 : { SDS_HDR_VAR ( 16 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_32 : { SDS_HDR_VAR ( 32 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_64 : { SDS_HDR_VAR ( 64 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } } if ( initlen && init ) memcpy ( s , init , initlen ) ; s [ initlen ] = '\\0' ; return s ; }
","<S2SV_ModStart> * fp ; assert ( initlen + hdrlen + 1 > initlen ) ;
",redis@redis/c992857618db99776917f10bf4f2345a5fdc78b0,CVE-2021-21309,https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0,2021-02-26T22:15Z,682,"<S2SV_ModStart>, s + 1 <S2SV_ModEnd> ) ; if",0
1512,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,683,<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL,0
1514,CWE-401,"CWE-401 static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kcalloc ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) <S2SV_StartBug> return ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not ( next ) ) break ; invert = ! invert ; continue ; } if ( N >= nr_preds ) { parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } inverts [ N ] = invert ; prog [ N ] . target = N - 1 ; len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; if ( len < 0 ) { ret = len ; goto out_free ; } ptr = next + len ; N ++ ; ret = - 1 ; while ( 1 ) { next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case ')' : case '\\0' : break ; case '&' : case '|' : if ( next [ 1 ] == next [ 0 ] ) { ptr ++ ; break ; } default : parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } invert = * top & INVERT ; if ( * top & PROCESS_AND ) { update_preds ( prog , N - 1 , invert ) ; * top &= ~ PROCESS_AND ; } if ( * next == '&' ) { * top |= PROCESS_AND ; break ; } if ( * top & PROCESS_OR ) { update_preds ( prog , N - 1 , ! invert ) ; * top &= ~ PROCESS_OR ; } if ( * next == '|' ) { * top |= PROCESS_OR ; break ; } if ( ! * next ) goto out ; if ( top == op_stack ) { ret = - 1 ; parse_error ( pe , FILT_ERR_TOO_MANY_CLOSE , ptr - str ) ; goto out_free ; } top -- ; } } out : if ( top != op_stack ) { parse_error ( pe , FILT_ERR_TOO_MANY_OPEN , ptr - str ) ; goto out_free ; } if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; } prog [ N ] . pred = NULL ; prog [ N ] . target = 1 ; prog [ N + 1 ] . pred = NULL ; prog [ N + 1 ] . target = 0 ; prog [ N - 1 ] . target = N ; prog [ N - 1 ] . when_to_branch = false ; for ( i = N - 1 ; i -- ; ) { int target = prog [ i ] . target ; if ( prog [ i ] . when_to_branch == prog [ target ] . when_to_branch ) prog [ i ] . target = prog [ target ] . target ; } for ( i = 0 ; i < N ; i ++ ) { invert = inverts [ i ] ^ prog [ i ] . when_to_branch ; prog [ i ] . when_to_branch = invert ; if ( WARN_ON ( prog [ i ] . target <= i ) ) { ret = - EINVAL ; goto out_free ; } } kfree ( op_stack ) ; kfree ( inverts ) ; return prog ; out_free : kfree ( op_stack ) ; kfree ( inverts ) ; if ( prog_stack ) { for ( i = 0 ; prog_stack [ i ] . pred ; i ++ ) kfree ( prog_stack [ i ] . pred ) ; kfree ( prog_stack ) ; } return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> > nr_parens ) { ret = - EINVAL ; goto out_free ; } <S2SV_ModEnd> * ( ++
",torvalds@linux/96c5c6e6a5b6db592acae039fed54b5c8844cd35,CVE-2019-19072,https://github.com/torvalds/linux/commit/96c5c6e6a5b6db592acae039fed54b5c8844cd35,2019-11-18T06:15Z,684,,0
1515,CWE-119,"CWE-119 static int calc_iframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) { <S2SV_StartBug> const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_EndBug> int target ; if ( cpi -> common . current_video_frame == 0 ) { <S2SV_StartBug> target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ; <S2SV_EndBug> } else { const int initial_boost = 32 ; <S2SV_StartBug> int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) { <S2SV_EndBug> kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / <S2SV_StartBug> ( cpi -> output_framerate / 2 ) ) ; <S2SV_EndBug> } <S2SV_StartBug> target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ; <S2SV_EndBug> } return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }
","<S2SV_ModStart> cpi -> rc ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <S2SV_ModStart> = ( ( rc -> <S2SV_ModEnd> starting_buffer_level / 2 <S2SV_ModStart> int ) ( rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } <S2SV_ModEnd> kf_boost = MAX <S2SV_ModStart> = MAX ( kf_boost , ( int ) ( 2 * framerate <S2SV_ModEnd> - 16 ) <S2SV_ModStart> -> frames_since_key < framerate <S2SV_ModEnd> / 2 ) <S2SV_ModStart> frames_since_key / ( framerate <S2SV_ModEnd> / 2 ) <S2SV_ModStart> * rc -> avg_frame_bandwidth <S2SV_ModEnd> ) >> 4
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,685,<S2SV_ModStart> ) { const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> ) { const VP9EncoderConfig <S2SV_ModEnd> * oxcf = <S2SV_ModStart> ) ; const VP9EncoderConfig <S2SV_ModEnd> * oxcf = <S2SV_ModStart> -> oxcf ; const VP9EncoderConfig * oxcf = & cpi -> gf_boosting ; const VP9EncoderConfig <S2SV_ModEnd> = cpi -> <S2SV_ModStart> -> oxcf ; const VP9EncoderConfig <S2SV_ModEnd> = cpi -> <S2SV_ModStart> = 0 ; if ( cpi -> baseline == KEY_FRAME ) <S2SV_ModEnd> == KEY_FRAME ) <S2SV_ModStart> ) / 2 ; if ( cpi -> oxcf. avg_frame_frame_frame_boost = ( cpi ) <S2SV_ModEnd> == KEY_FRAME ) <S2SV_ModStart> ; if ( cpi <S2SV_ModEnd> == KEY_FRAME ),0
1518,CWE-119,"CWE-119 <S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> if ( tx_mode == ALLOW_32X32 ) <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> return tx_mode ; }
","<S2SV_ModStart> TX_MODE read_tx_mode ( vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> TX_MODE tx_mode = vpx_read_literal <S2SV_ModEnd> ( r , <S2SV_ModStart> ) tx_mode += vpx_read_bit <S2SV_ModEnd> ( r )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,686,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> vpx_reader <S2SV_ModEnd> * r, <S2SV_ModStart> = vpx_reader <S2SV_ModEnd> ( r,",0
1522,CWE-674,"CWE-674 static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , RE_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 6 : <S2SV_StartBug> # line 96 ""re_grammar.y"" <S2SV_EndBug> { yr_free ( ( ( * yyvaluep ) . class_vector ) ) ; } <S2SV_StartBug> # line 1045 ""re_grammar.c"" <S2SV_EndBug> break ; case 26 : <S2SV_StartBug> # line 97 ""re_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1051 ""re_grammar.c"" break ; case 27 : <S2SV_StartBug> # line 98 ""re_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1057 ""re_grammar.c"" break ; case 28 : <S2SV_StartBug> # line 99 ""re_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1063 ""re_grammar.c"" break ; case 29 : <S2SV_StartBug> # line 100 ""re_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1069 ""re_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }
","<S2SV_ModStart> : # line 104 <S2SV_ModEnd> ""re_grammar.y"" { yr_free <S2SV_ModStart> } # line 1053 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 105 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 106 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1065 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 107 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1071 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 108 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1077 <S2SV_ModEnd> ""re_grammar.c"" break ;
",VirusTotal@yara/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,CVE-2017-9304,https://github.com/VirusTotal/yara/commit/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,2017-05-31T04:29Z,687,,0
1524,CWE-119,"CWE-119 static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ; <S2SV_StartBug> MACROBLOCKD * xd = args -> xd ; <S2SV_EndBug> TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ; <S2SV_StartBug> struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; <S2SV_EndBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ; <S2SV_StartBug> const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; <S2SV_EndBug> unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = <S2SV_StartBug> cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ; <S2SV_EndBug> const uint8_t * const band = get_band_translate ( tx_size ) ; const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ; <S2SV_StartBug> int aoff , loff ; <S2SV_EndBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; pt = get_entropy_context ( tx_size , pd -> above_context + aoff , pd -> left_context + loff ) ; so = get_scan ( xd , tx_size , type , block ) ; scan = so -> scan ; nb = so -> neighbors ; c = 0 ; while ( c < eob ) { int v = 0 ; int skip_eob = 0 ; v = qcoeff [ scan [ c ] ] ; while ( ! v ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; skip_eob = 1 ; token_cache [ scan [ c ] ] = 0 ; ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; v = qcoeff [ scan [ c ] ] ; } <S2SV_StartBug> add_token ( & t , coef_probs [ band [ c ] ] [ pt ] , <S2SV_EndBug> <S2SV_StartBug> vp9_dct_value_tokens_ptr [ v ] . extra , <S2SV_EndBug> <S2SV_StartBug> ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , <S2SV_EndBug> ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ; eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; token_cache [ scan [ c ] ] = <S2SV_StartBug> vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ; <S2SV_EndBug> ++ c ; pt = get_coef_context ( nb , token_cache , c ) ; } if ( c < seg_eob ) { add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , EOB_TOKEN , 0 , counts [ band [ c ] ] [ pt ] ) ; ++ eob_branch [ band [ c ] ] [ pt ] ; } * tp = t ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , c > 0 , aoff , loff ) ; }
","<S2SV_ModStart> -> cpi ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd <S2SV_ModEnd> ; TOKENEXTRA * <S2SV_ModStart> p = & x -> <S2SV_ModEnd> plane [ plane <S2SV_ModStart> plane_type ; const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <S2SV_ModEnd> ( * const <S2SV_ModStart> common . fc -> <S2SV_ModEnd> coef_probs [ tx_size <S2SV_ModStart> COEFF_CONTEXTS ] = td -> counts -> <S2SV_ModEnd> eob_branch [ tx_size <S2SV_ModStart> tx_size ) ; int16_t token ; EXTRABIT extra ; <S2SV_ModStart> ] ; } vp9_get_token_extra ( v , & token , & extra ) ; <S2SV_ModStart> pt ] , <S2SV_ModEnd> extra , ( <S2SV_ModStart> ( uint8_t ) <S2SV_ModEnd> token , ( <S2SV_ModStart> = vp9_pt_energy_class [ <S2SV_ModEnd> token ] ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,688,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1525,CWE-674,"CWE-674 static int renameTableSelectCb ( Walker * pWalker , Select * pSelect ) { int i ; RenameCtx * p = pWalker -> u . pRename ; <S2SV_StartBug> SrcList * pSrc = pSelect -> pSrc ; <S2SV_EndBug> if ( pSrc == 0 ) { assert ( pWalker -> pParse -> db -> mallocFailed ) ; return WRC_Abort ; } for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pSrc -> a [ i ] ; if ( pItem -> pTab == p -> pTab ) { renameTokenFind ( pWalker -> pParse , p , pItem -> zName ) ; } } renameWalkWith ( pWalker , pSelect ) ; return WRC_Continue ; }
","<S2SV_ModStart> pSelect -> pSrc ; if ( pSelect -> selFlags & SF_View ) return WRC_Prune
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z,689,<S2SV_ModStart>,0
1526,CWE-000,"CWE-000 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { <S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - EINTR ; goto out_fput ; } if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }
","<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba
",torvalds@linux/95e91b831f87ac8e1f8ed50c14d709089b4e01b8,CVE-2017-5669,https://github.com/torvalds/linux/commit/95e91b831f87ac8e1f8ed50c14d709089b4e01b8,2017-02-24T15:59Z,690,<S2SV_ModStart> ; if ( (,0
1527,CWE-404,"CWE-404 static struct svc_serv * nfs_callback_create_svc ( int minorversion ) { struct nfs_callback_data * cb_info = & nfs_callback_info [ minorversion ] ; struct svc_serv * serv ; struct svc_serv_ops * sv_ops ; if ( cb_info -> serv ) { svc_get ( cb_info -> serv ) ; return cb_info -> serv ; } switch ( minorversion ) { case 0 : sv_ops = nfs4_cb_sv_ops [ 0 ] ; break ; default : sv_ops = nfs4_cb_sv_ops [ 1 ] ; } if ( sv_ops == NULL ) return ERR_PTR ( - ENOTSUPP ) ; if ( cb_info -> users ) printk ( KERN_WARNING ""nfs_callback_create_svc:<S2SV_blank>no<S2SV_blank>kthread,<S2SV_blank>%d<S2SV_blank>users??\\n"" , cb_info -> users ) ; <S2SV_StartBug> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <S2SV_EndBug> if ( ! serv ) { printk ( KERN_ERR ""nfs_callback_create_svc:<S2SV_blank>create<S2SV_blank>service<S2SV_blank>failed\\n"" ) ; return ERR_PTR ( - ENOMEM ) ; } cb_info -> serv = serv ; serv -> sv_maxconn = 1024 ; dprintk ( ""nfs_callback_create_svc:<S2SV_blank>service<S2SV_blank>created\\n"" ) ; return serv ; }
","<S2SV_ModStart> ; serv = svc_create_pooled <S2SV_ModEnd> ( & nfs4_callback_program
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z,691,,0
1528,CWE-347,"CWE-347 <S2SV_StartBug> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <S2SV_EndBug> PointZZ_p R0 , R1 , tmp ; mpz_inits ( R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; mpz_init_set ( R0 . x , point -> x ) ; mpz_init_set ( R0 . y , point -> y ) ; pointZZ_pDouble ( & R1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pAdd ( & R0 , & R1 , & tmp , curve ) ; mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pDouble ( & R1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pAdd ( & R1 , & R0 , & tmp , curve ) ; mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pDouble ( & R0 , & tmp , curve ) ; } } mpz_init_set ( rop -> x , R0 . x ) ; mpz_init_set ( rop -> y , R0 . y ) ; mpz_clears ( R0 . x , R0 . y , R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; }
","<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
",AntonKueltz@fastecdsa/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,CVE-2020-12607,https://github.com/AntonKueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,2020-06-02T21:15Z,692,,0
1529,CWE-772,"CWE-772 gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_strings"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z,693,<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle,1
1531,CWE-284,"CWE-284 ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; if ( fd == INVALID_FD ) return socket_write ( socket , buf , count ) ; struct msghdr msg ; struct iovec iov ; char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; iov . iov_base = ( void * ) buf ; iov . iov_len = count ; msg . msg_iov = & iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_buf ; msg . msg_controllen = sizeof ( control_buf ) ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; header -> cmsg_level = SOL_SOCKET ; header -> cmsg_type = SCM_RIGHTS ; header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ; <S2SV_StartBug> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <S2SV_EndBug> close ( fd ) ; return ret ; }
","<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> msg , MSG_DONTWAIT )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,694,,0
1532,CWE-284,"CWE-284 int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) { <S2SV_StartBug> do ret = send ( sock_fd , buf , s , 0 ) ; <S2SV_EndBug> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>fd:%d<S2SV_blank>send<S2SV_blank>errno:%d,<S2SV_blank>ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }
","<S2SV_ModStart> do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> s , 0 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,695,"<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> len, 0 )",0
1533,CWE-264,"CWE-264 static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ; <S2SV_StartBug> for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { <S2SV_EndBug> const char * prop_name = ( const char * ) xIter -> name ; <S2SV_StartBug> if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) { <S2SV_EndBug> continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( ""Creation<S2SV_blank>of<S2SV_blank>%s=%s<S2SV_blank>is<S2SV_blank>allowed"" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else { <S2SV_StartBug> char * path = xml_get_path ( xml ) ; <S2SV_EndBug> crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } } <S2SV_StartBug> } <S2SV_EndBug> while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }
","<S2SV_ModStart> = NULL ; char * path = xml_get_path ( xml ) ; <S2SV_ModStart> ) == 0 && strstr ( path , ""/"" XML_CIB_TAG_ACLS ""/"" ) == NULL <S2SV_ModStart> } else { <S2SV_ModEnd> crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" <S2SV_ModStart> ; } } free ( path ) ;
",ClusterLabs@pacemaker/84ac07c7d02b3badd708b1ef13a2159dede70715,CVE-2015-1867,https://github.com/ClusterLabs/pacemaker/commit/84ac07c,2015-08-12T14:59Z,696,<S2SV_ModStart> ) ) { <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,0
1535,CWE-119,"CWE-119 <S2SV_StartBug> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_EndBug> if ( svc_ctx == NULL ) return NULL ; <S2SV_StartBug> return ( const SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> static const SvcInternal_t <S2SV_ModEnd> * get_const_svc_internal ( <S2SV_ModStart> return ( const SvcInternal_t <S2SV_ModEnd> * ) svc_ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,697,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1536,CWE-264,"CWE-264 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
","<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z,698,"<S2SV_ModStart> mq_mq_rq_rq ( q,",0
1537,CWE-787,"CWE-787 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
","<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,699,"<S2SV_ModStart> int length ; struct stream packet = * s ; <S2SV_ModStart> length ) { if (! s_check_rem ( s, length ) ) return FALSE ;",0
1538,CWE-704,"CWE-704 static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , ""params<S2SV_blank>=<S2SV_blank>"" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , ""\\n"" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( ""value"" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , ""arguments"" , sizeof ( ""arguments"" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) { <S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }
","<S2SV_ModStart> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
",m6w6@ext-http/17137d4ab1ce81a2cee0fae842340a344ef3da83,CVE-2016-7398,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,2019-09-06T19:15Z,700,,0
1539,CWE-119,"CWE-119 int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) { <S2SV_StartBug> char buffer [ 80 ] ; <S2SV_EndBug> int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>header;<S2SV_blank>not<S2SV_blank>a<S2SV_blank>YUV2MPEG2<S2SV_blank>file?\\n"" ) ; return - 1 ; } buffer [ i ] = '\\0' ; if ( memcmp ( buffer , ""YUV4MPEG"" , 8 ) ) { fprintf ( stderr , ""Incomplete<S2SV_blank>magic<S2SV_blank>for<S2SV_blank>YUV4MPEG<S2SV_blank>file.\\n"" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , ""Incorrect<S2SV_blank>YUV<S2SV_blank>input<S2SV_blank>file<S2SV_blank>version;<S2SV_blank>YUV4MPEG2<S2SV_blank>required.\\n"" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>YUV4MPEG2<S2SV_blank>header.\\n"" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , ""Warning:<S2SV_blank>Input<S2SV_blank>video<S2SV_blank>interlacing<S2SV_blank>format<S2SV_blank>unknown;<S2SV_blank>"" ""assuming<S2SV_blank>progressive<S2SV_blank>scan.\\n"" ) ; } else if ( _y4m -> interlace != 'p' ) { fprintf ( stderr , ""Input<S2SV_blank>video<S2SV_blank>is<S2SV_blank>interlaced;<S2SV_blank>"" ""Only<S2SV_blank>progressive<S2SV_blank>scan<S2SV_blank>handled.\\n"" ) ; return - 1 ; } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ; <S2SV_StartBug> _y4m -> vpx_bps = 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 || <S2SV_EndBug> strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <S2SV_StartBug> } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) { <S2SV_EndBug> _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422jpeg_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ; <S2SV_StartBug> _y4m -> vpx_bps = 16 ; <S2SV_EndBug> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; <S2SV_StartBug> _y4m -> convert = y4m_convert_null ; <S2SV_EndBug> } } else if ( strcmp ( _y4m -> chroma_type , ""411"" ) == 0 ) { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_411_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , ""444"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ; <S2SV_StartBug> _y4m -> vpx_bps = 24 ; <S2SV_EndBug> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } <S2SV_StartBug> } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) { <S2SV_EndBug> _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; <S2SV_StartBug> if ( only_420 ) { <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_c_dec_h = 2 ; <S2SV_EndBug> _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> vpx_bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { <S2SV_StartBug> fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h <S2SV_EndBug> + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ; <S2SV_StartBug> _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> [ 80 ] = { 0 } <S2SV_ModStart> ; _y4m -> bps <S2SV_ModEnd> = 12 ; <S2SV_ModStart> = 12 ; _y4m -> bit_depth = 8 ; <S2SV_ModStart> -> chroma_type , ""420p10"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""420p12"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , <S2SV_ModStart> ; _y4m -> bps <S2SV_ModEnd> = 16 ; <S2SV_ModStart> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""422p10"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""422p12"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 <S2SV_ModStart> ; _y4m -> bps <S2SV_ModEnd> = 24 ; <S2SV_ModStart> -> chroma_type , ""444p10"" <S2SV_ModEnd> ) == 0 <S2SV_ModStart> = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <S2SV_ModStart> only_420 ) { <S2SV_ModEnd> fprintf ( stderr <S2SV_ModStart> ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""444p12"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ; return - 1 ; } <S2SV_ModStart> dst_c_dec_v ) ; if ( _y4m -> bit_depth == 8 ) <S2SV_ModStart> dst_buf_sz ) ; else _y4m -> dst_buf <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) malloc ( 2 * _y4m -> dst_buf_sz ) ; if ( <S2SV_ModStart> _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,701,<S2SV_ModStart> int buffer [ 8 <S2SV_ModEnd> ] ; int,0
1540,CWE-120,"CWE-120 boolean proc_wizkit_line ( buf ) char * buf ; { <S2SV_StartBug> struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ; <S2SV_EndBug> if ( otmp ) { if ( otmp != & zeroobj ) wizkit_addinv ( otmp ) ; } else { config_error_add ( ""Bad<S2SV_blank>wizkit<S2SV_blank>item:<S2SV_blank>\\""%.60s\\"""" , buf ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> struct obj * otmp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0' ;
",NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z,702,<S2SV_ModStart> ( buf ) <S2SV_ModEnd> ; if (,0
1541,CWE-20,"CWE-20 int read_filesystem_tables_4 ( ) { <S2SV_StartBug> long long directory_table_end , table_start ; <S2SV_EndBug> if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( read_uids_guids ( & table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( parse_exports_table ( & table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <S2SV_EndBug> return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> { long long table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_xattrs_from_disk <S2SV_ModStart> == 0 ) goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_id_table <S2SV_ModEnd> ( & table_start <S2SV_ModStart> == FALSE ) goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( parse_exports_table <S2SV_ModStart> == FALSE ) goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_fragment_table <S2SV_ModStart> read_fragment_table ( & table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_inode_table <S2SV_ModStart> == FALSE ) goto corrupted <S2SV_ModEnd> ; if ( <S2SV_ModStart> return TRUE ; corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\n"" ) ; return FALSE ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z,703,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> inode_table_table_start ( int ) <S2SV_ModStart> ; if (! sBlk. table_start <S2SV_ModEnd> ) return FALSE <S2SV_ModStart> ; if ( <S2SV_ModEnd> ) return FALSE <S2SV_ModStart> ) return FALSE ; } return FALSE <S2SV_ModStart> ; } if (! s_start ) return FALSE <S2SV_ModEnd> ; } if (,0
1542,CWE-732,"CWE-732 static struct env * <S2SV_StartBug> createenv ( const struct rule * rule ) <S2SV_EndBug> { struct env * env ; u_int i ; env = malloc ( sizeof ( * env ) ) ; if ( ! env ) err ( 1 , NULL ) ; RB_INIT ( & env -> root ) ; <S2SV_StartBug> env -> count = 0 ; <S2SV_EndBug> if ( rule -> options & KEEPENV ) { extern char * * environ ; for ( i = 0 ; environ [ i ] != NULL ; i ++ ) { struct envnode * node ; const char * e , * eq ; size_t len ; char keybuf [ 1024 ] ; e = environ [ i ] ; if ( ( eq = strchr ( e , '=' ) ) == NULL || eq == e ) continue ; len = eq - e ; if ( len > sizeof ( keybuf ) - 1 ) continue ; memcpy ( keybuf , e , len ) ; keybuf [ len ] = '\\0' ; node = createnode ( keybuf , eq + 1 ) ; if ( RB_INSERT ( envtree , & env -> root , node ) ) { freenode ( node ) ; } else { env -> count ++ ; } } <S2SV_StartBug> } <S2SV_EndBug> return env ; }
","<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw <S2SV_ModStart> count = 0 ; addnode ( env , ""DOAS_USER"" , mypw -> pw_name ) <S2SV_ModStart> } } } else { static const char * copyset [ ] = { ""DISPLAY"" , ""TERM"" , NULL } ; addnode ( env , ""HOME"" , targpw -> pw_dir ) ; addnode ( env , ""LOGNAME"" , targpw -> pw_name ) ; addnode ( env , ""PATH"" , getenv ( ""PATH"" ) ) ; addnode ( env , ""SHELL"" , targpw -> pw_shell ) ; addnode ( env , ""USER"" , targpw -> pw_name ) ; fillenv ( env , copyset ) ; }
",Duncaen@OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168,CVE-2019-25016,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,2021-01-28T20:15Z,704,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1544,CWE-119,"CWE-119 void vp9_setup_in_frame_q_adj ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; struct segmentation * const seg = & cm -> seg ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { int segment ; <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; <S2SV_EndBug> vpx_memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ; for ( segment = 1 ; segment < 2 ; segment ++ ) { const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , <S2SV_StartBug> in_frame_q_adj_ratio [ segment ] ) ; <S2SV_EndBug> vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ; vp9_set_segdata ( seg , segment , SEG_LVL_ALT_Q , qindex_delta ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> -> seg ; vpx_clear_system_state <S2SV_ModEnd> ( ) ; <S2SV_ModStart> int segment ; const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <S2SV_ModEnd> qindex_delta = vp9_compute_qdelta_by_rate <S2SV_ModStart> -> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <S2SV_ModEnd> vp9_enable_segfeature ( seg <S2SV_ModStart> } } } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,705,"<S2SV_ModStart> ; memset <S2SV_ModEnd> ( seg,",0
1545,CWE-125,"CWE-125 static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! Module_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_EndBug> 1 ) ; <S2SV_StartBug> if ( ! Interactive_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ; <S2SV_EndBug> if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields , <S2SV_StartBug> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! FunctionDef_type ) return 0 ; <S2SV_EndBug> AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , <S2SV_StartBug> AsyncFunctionDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! AsyncFunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ClassDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ; <S2SV_EndBug> if ( ! Return_type ) return 0 ; <S2SV_StartBug> Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; <S2SV_EndBug> if ( ! Delete_type ) return 0 ; <S2SV_StartBug> Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ; <S2SV_EndBug> if ( ! Assign_type ) return 0 ; <S2SV_StartBug> AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; <S2SV_EndBug> if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ; if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ; if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" , stmt_type , With_fields , 2 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , AsyncWith_fields , 2 ) ; if ( ! AsyncWith_type ) return 0 ; Raise_type = make_type ( ""Raise"" , stmt_type , Raise_fields , 2 ) ; if ( ! Raise_type ) return 0 ; Try_type = make_type ( ""Try"" , stmt_type , Try_fields , 4 ) ; if ( ! Try_type ) return 0 ; Assert_type = make_type ( ""Assert"" , stmt_type , Assert_fields , 2 ) ; if ( ! Assert_type ) return 0 ; Import_type = make_type ( ""Import"" , stmt_type , Import_fields , 1 ) ; if ( ! Import_type ) return 0 ; ImportFrom_type = make_type ( ""ImportFrom"" , stmt_type , ImportFrom_fields , 3 ) ; if ( ! ImportFrom_type ) return 0 ; Global_type = make_type ( ""Global"" , stmt_type , Global_fields , 1 ) ; if ( ! Global_type ) return 0 ; Nonlocal_type = make_type ( ""Nonlocal"" , stmt_type , Nonlocal_fields , 1 ) ; if ( ! Nonlocal_type ) return 0 ; Expr_type = make_type ( ""Expr"" , stmt_type , Expr_fields , 1 ) ; if ( ! Expr_type ) return 0 ; Pass_type = make_type ( ""Pass"" , stmt_type , NULL , 0 ) ; if ( ! Pass_type ) return 0 ; Break_type = make_type ( ""Break"" , stmt_type , NULL , 0 ) ; if ( ! Break_type ) return 0 ; Continue_type = make_type ( ""Continue"" , stmt_type , NULL , 0 ) ; if ( ! Continue_type ) return 0 ; expr_type = make_type ( ""expr"" , & AST_type , NULL , 0 ) ; if ( ! expr_type ) return 0 ; if ( ! add_attributes ( expr_type , expr_attributes , 4 ) ) return 0 ; BoolOp_type = make_type ( ""BoolOp"" , expr_type , BoolOp_fields , 2 ) ; if ( ! BoolOp_type ) return 0 ; NamedExpr_type = make_type ( ""NamedExpr"" , expr_type , NamedExpr_fields , 2 ) ; if ( ! NamedExpr_type ) return 0 ; BinOp_type = make_type ( ""BinOp"" , expr_type , BinOp_fields , 3 ) ; if ( ! BinOp_type ) return 0 ; UnaryOp_type = make_type ( ""UnaryOp"" , expr_type , UnaryOp_fields , 2 ) ; if ( ! UnaryOp_type ) return 0 ; Lambda_type = make_type ( ""Lambda"" , expr_type , Lambda_fields , 2 ) ; if ( ! Lambda_type ) return 0 ; IfExp_type = make_type ( ""IfExp"" , expr_type , IfExp_fields , 3 ) ; if ( ! IfExp_type ) return 0 ; Dict_type = make_type ( ""Dict"" , expr_type , Dict_fields , 2 ) ; if ( ! Dict_type ) return 0 ; Set_type = make_type ( ""Set"" , expr_type , Set_fields , 1 ) ; if ( ! Set_type ) return 0 ; ListComp_type = make_type ( ""ListComp"" , expr_type , ListComp_fields , 2 ) ; if ( ! ListComp_type ) return 0 ; SetComp_type = make_type ( ""SetComp"" , expr_type , SetComp_fields , 2 ) ; if ( ! SetComp_type ) return 0 ; DictComp_type = make_type ( ""DictComp"" , expr_type , DictComp_fields , 3 ) ; if ( ! DictComp_type ) return 0 ; GeneratorExp_type = make_type ( ""GeneratorExp"" , expr_type , GeneratorExp_fields , 2 ) ; if ( ! GeneratorExp_type ) return 0 ; Await_type = make_type ( ""Await"" , expr_type , Await_fields , 1 ) ; if ( ! Await_type ) return 0 ; Yield_type = make_type ( ""Yield"" , expr_type , Yield_fields , 1 ) ; if ( ! Yield_type ) return 0 ; YieldFrom_type = make_type ( ""YieldFrom"" , expr_type , YieldFrom_fields , 1 ) ; if ( ! YieldFrom_type ) return 0 ; Compare_type = make_type ( ""Compare"" , expr_type , Compare_fields , 3 ) ; if ( ! Compare_type ) return 0 ; Call_type = make_type ( ""Call"" , expr_type , Call_fields , 3 ) ; if ( ! Call_type ) return 0 ; FormattedValue_type = make_type ( ""FormattedValue"" , expr_type , FormattedValue_fields , 3 ) ; if ( ! FormattedValue_type ) return 0 ; JoinedStr_type = make_type ( ""JoinedStr"" , expr_type , JoinedStr_fields , 1 ) ; if ( ! JoinedStr_type ) return 0 ; Constant_type = make_type ( ""Constant"" , expr_type , Constant_fields , 1 ) ; if ( ! Constant_type ) return 0 ; Attribute_type = make_type ( ""Attribute"" , expr_type , Attribute_fields , 3 ) ; if ( ! Attribute_type ) return 0 ; Subscript_type = make_type ( ""Subscript"" , expr_type , Subscript_fields , 3 ) ; if ( ! Subscript_type ) return 0 ; Starred_type = make_type ( ""Starred"" , expr_type , Starred_fields , 2 ) ; if ( ! Starred_type ) return 0 ; Name_type = make_type ( ""Name"" , expr_type , Name_fields , 2 ) ; if ( ! Name_type ) return 0 ; List_type = make_type ( ""List"" , expr_type , List_fields , 2 ) ; if ( ! List_type ) return 0 ; Tuple_type = make_type ( ""Tuple"" , expr_type , Tuple_fields , 2 ) ; if ( ! Tuple_type ) return 0 ; expr_context_type = make_type ( ""expr_context"" , & AST_type , NULL , 0 ) ; if ( ! expr_context_type ) return 0 ; if ( ! add_attributes ( expr_context_type , NULL , 0 ) ) return 0 ; Load_type = make_type ( ""Load"" , expr_context_type , NULL , 0 ) ; if ( ! Load_type ) return 0 ; Load_singleton = PyType_GenericNew ( Load_type , NULL , NULL ) ; if ( ! Load_singleton ) return 0 ; Store_type = make_type ( ""Store"" , expr_context_type , NULL , 0 ) ; if ( ! Store_type ) return 0 ; Store_singleton = PyType_GenericNew ( Store_type , NULL , NULL ) ; if ( ! Store_singleton ) return 0 ; Del_type = make_type ( ""Del"" , expr_context_type , NULL , 0 ) ; if ( ! Del_type ) return 0 ; Del_singleton = PyType_GenericNew ( Del_type , NULL , NULL ) ; if ( ! Del_singleton ) return 0 ; AugLoad_type = make_type ( ""AugLoad"" , expr_context_type , NULL , 0 ) ; if ( ! AugLoad_type ) return 0 ; AugLoad_singleton = PyType_GenericNew ( AugLoad_type , NULL , NULL ) ; if ( ! AugLoad_singleton ) return 0 ; AugStore_type = make_type ( ""AugStore"" , expr_context_type , NULL , 0 ) ; if ( ! AugStore_type ) return 0 ; AugStore_singleton = PyType_GenericNew ( AugStore_type , NULL , NULL ) ; if ( ! AugStore_singleton ) return 0 ; Param_type = make_type ( ""Param"" , expr_context_type , NULL , 0 ) ; if ( ! Param_type ) return 0 ; Param_singleton = PyType_GenericNew ( Param_type , NULL , NULL ) ; if ( ! Param_singleton ) return 0 ; NamedStore_type = make_type ( ""NamedStore"" , expr_context_type , NULL , 0 ) ; if ( ! NamedStore_type ) return 0 ; NamedStore_singleton = PyType_GenericNew ( NamedStore_type , NULL , NULL ) ; if ( ! NamedStore_singleton ) return 0 ; slice_type = make_type ( ""slice"" , & AST_type , NULL , 0 ) ; if ( ! slice_type ) return 0 ; if ( ! add_attributes ( slice_type , NULL , 0 ) ) return 0 ; Slice_type = make_type ( ""Slice"" , slice_type , Slice_fields , 3 ) ; if ( ! Slice_type ) return 0 ; ExtSlice_type = make_type ( ""ExtSlice"" , slice_type , ExtSlice_fields , 1 ) ; if ( ! ExtSlice_type ) return 0 ; Index_type = make_type ( ""Index"" , slice_type , Index_fields , 1 ) ; if ( ! Index_type ) return 0 ; boolop_type = make_type ( ""boolop"" , & AST_type , NULL , 0 ) ; if ( ! boolop_type ) return 0 ; if ( ! add_attributes ( boolop_type , NULL , 0 ) ) return 0 ; And_type = make_type ( ""And"" , boolop_type , NULL , 0 ) ; if ( ! And_type ) return 0 ; And_singleton = PyType_GenericNew ( And_type , NULL , NULL ) ; if ( ! And_singleton ) return 0 ; Or_type = make_type ( ""Or"" , boolop_type , NULL , 0 ) ; if ( ! Or_type ) return 0 ; Or_singleton = PyType_GenericNew ( Or_type , NULL , NULL ) ; if ( ! Or_singleton ) return 0 ; operator_type = make_type ( ""operator"" , & AST_type , NULL , 0 ) ; if ( ! operator_type ) return 0 ; if ( ! add_attributes ( operator_type , NULL , 0 ) ) return 0 ; Add_type = make_type ( ""Add"" , operator_type , NULL , 0 ) ; if ( ! Add_type ) return 0 ; Add_singleton = PyType_GenericNew ( Add_type , NULL , NULL ) ; if ( ! Add_singleton ) return 0 ; Sub_type = make_type ( ""Sub"" , operator_type , NULL , 0 ) ; if ( ! Sub_type ) return 0 ; Sub_singleton = PyType_GenericNew ( Sub_type , NULL , NULL ) ; if ( ! Sub_singleton ) return 0 ; Mult_type = make_type ( ""Mult"" , operator_type , NULL , 0 ) ; if ( ! Mult_type ) return 0 ; Mult_singleton = PyType_GenericNew ( Mult_type , NULL , NULL ) ; if ( ! Mult_singleton ) return 0 ; MatMult_type = make_type ( ""MatMult"" , operator_type , NULL , 0 ) ; if ( ! MatMult_type ) return 0 ; MatMult_singleton = PyType_GenericNew ( MatMult_type , NULL , NULL ) ; if ( ! MatMult_singleton ) return 0 ; Div_type = make_type ( ""Div"" , operator_type , NULL , 0 ) ; if ( ! Div_type ) return 0 ; Div_singleton = PyType_GenericNew ( Div_type , NULL , NULL ) ; if ( ! Div_singleton ) return 0 ; Mod_type = make_type ( ""Mod"" , operator_type , NULL , 0 ) ; if ( ! Mod_type ) return 0 ; Mod_singleton = PyType_GenericNew ( Mod_type , NULL , NULL ) ; if ( ! Mod_singleton ) return 0 ; Pow_type = make_type ( ""Pow"" , operator_type , NULL , 0 ) ; if ( ! Pow_type ) return 0 ; Pow_singleton = PyType_GenericNew ( Pow_type , NULL , NULL ) ; if ( ! Pow_singleton ) return 0 ; LShift_type = make_type ( ""LShift"" , operator_type , NULL , 0 ) ; if ( ! LShift_type ) return 0 ; LShift_singleton = PyType_GenericNew ( LShift_type , NULL , NULL ) ; if ( ! LShift_singleton ) return 0 ; RShift_type = make_type ( ""RShift"" , operator_type , NULL , 0 ) ; if ( ! RShift_type ) return 0 ; RShift_singleton = PyType_GenericNew ( RShift_type , NULL , NULL ) ; if ( ! RShift_singleton ) return 0 ; BitOr_type = make_type ( ""BitOr"" , operator_type , NULL , 0 ) ; if ( ! BitOr_type ) return 0 ; BitOr_singleton = PyType_GenericNew ( BitOr_type , NULL , NULL ) ; if ( ! BitOr_singleton ) return 0 ; BitXor_type = make_type ( ""BitXor"" , operator_type , NULL , 0 ) ; if ( ! BitXor_type ) return 0 ; BitXor_singleton = PyType_GenericNew ( BitXor_type , NULL , NULL ) ; if ( ! BitXor_singleton ) return 0 ; BitAnd_type = make_type ( ""BitAnd"" , operator_type , NULL , 0 ) ; if ( ! BitAnd_type ) return 0 ; BitAnd_singleton = PyType_GenericNew ( BitAnd_type , NULL , NULL ) ; if ( ! BitAnd_singleton ) return 0 ; FloorDiv_type = make_type ( ""FloorDiv"" , operator_type , NULL , 0 ) ; if ( ! FloorDiv_type ) return 0 ; FloorDiv_singleton = PyType_GenericNew ( FloorDiv_type , NULL , NULL ) ; if ( ! FloorDiv_singleton ) return 0 ; unaryop_type = make_type ( ""unaryop"" , & AST_type , NULL , 0 ) ; if ( ! unaryop_type ) return 0 ; if ( ! add_attributes ( unaryop_type , NULL , 0 ) ) return 0 ; Invert_type = make_type ( ""Invert"" , unaryop_type , NULL , 0 ) ; if ( ! Invert_type ) return 0 ; Invert_singleton = PyType_GenericNew ( Invert_type , NULL , NULL ) ; if ( ! Invert_singleton ) return 0 ; Not_type = make_type ( ""Not"" , unaryop_type , NULL , 0 ) ; if ( ! Not_type ) return 0 ; Not_singleton = PyType_GenericNew ( Not_type , NULL , NULL ) ; if ( ! Not_singleton ) return 0 ; UAdd_type = make_type ( ""UAdd"" , unaryop_type , NULL , 0 ) ; if ( ! UAdd_type ) return 0 ; UAdd_singleton = PyType_GenericNew ( UAdd_type , NULL , NULL ) ; if ( ! UAdd_singleton ) return 0 ; USub_type = make_type ( ""USub"" , unaryop_type , NULL , 0 ) ; if ( ! USub_type ) return 0 ; USub_singleton = PyType_GenericNew ( USub_type , NULL , NULL ) ; if ( ! USub_singleton ) return 0 ; cmpop_type = make_type ( ""cmpop"" , & AST_type , NULL , 0 ) ; if ( ! cmpop_type ) return 0 ; if ( ! add_attributes ( cmpop_type , NULL , 0 ) ) return 0 ; Eq_type = make_type ( ""Eq"" , cmpop_type , NULL , 0 ) ; if ( ! Eq_type ) return 0 ; Eq_singleton = PyType_GenericNew ( Eq_type , NULL , NULL ) ; if ( ! Eq_singleton ) return 0 ; NotEq_type = make_type ( ""NotEq"" , cmpop_type , NULL , 0 ) ; if ( ! NotEq_type ) return 0 ; NotEq_singleton = PyType_GenericNew ( NotEq_type , NULL , NULL ) ; if ( ! NotEq_singleton ) return 0 ; Lt_type = make_type ( ""Lt"" , cmpop_type , NULL , 0 ) ; if ( ! Lt_type ) return 0 ; Lt_singleton = PyType_GenericNew ( Lt_type , NULL , NULL ) ; if ( ! Lt_singleton ) return 0 ; LtE_type = make_type ( ""LtE"" , cmpop_type , NULL , 0 ) ; if ( ! LtE_type ) return 0 ; LtE_singleton = PyType_GenericNew ( LtE_type , NULL , NULL ) ; if ( ! LtE_singleton ) return 0 ; Gt_type = make_type ( ""Gt"" , cmpop_type , NULL , 0 ) ; if ( ! Gt_type ) return 0 ; Gt_singleton = PyType_GenericNew ( Gt_type , NULL , NULL ) ; if ( ! Gt_singleton ) return 0 ; GtE_type = make_type ( ""GtE"" , cmpop_type , NULL , 0 ) ; if ( ! GtE_type ) return 0 ; GtE_singleton = PyType_GenericNew ( GtE_type , NULL , NULL ) ; if ( ! GtE_singleton ) return 0 ; Is_type = make_type ( ""Is"" , cmpop_type , NULL , 0 ) ; if ( ! Is_type ) return 0 ; Is_singleton = PyType_GenericNew ( Is_type , NULL , NULL ) ; if ( ! Is_singleton ) return 0 ; IsNot_type = make_type ( ""IsNot"" , cmpop_type , NULL , 0 ) ; if ( ! IsNot_type ) return 0 ; IsNot_singleton = PyType_GenericNew ( IsNot_type , NULL , NULL ) ; if ( ! IsNot_singleton ) return 0 ; In_type = make_type ( ""In"" , cmpop_type , NULL , 0 ) ; if ( ! In_type ) return 0 ; In_singleton = PyType_GenericNew ( In_type , NULL , NULL ) ; if ( ! In_singleton ) return 0 ; NotIn_type = make_type ( ""NotIn"" , cmpop_type , NULL , 0 ) ; if ( ! NotIn_type ) return 0 ; NotIn_singleton = PyType_GenericNew ( NotIn_type , NULL , NULL ) ; if ( ! NotIn_singleton ) return 0 ; comprehension_type = make_type ( ""comprehension"" , & AST_type , comprehension_fields , 4 ) ; if ( ! comprehension_type ) return 0 ; if ( ! add_attributes ( comprehension_type , NULL , 0 ) ) return 0 ; excepthandler_type = make_type ( ""excepthandler"" , & AST_type , NULL , 0 ) ; if ( ! excepthandler_type ) return 0 ; if ( ! add_attributes ( excepthandler_type , excepthandler_attributes , 4 ) ) return 0 ; ExceptHandler_type = make_type ( ""ExceptHandler"" , excepthandler_type , ExceptHandler_fields , 3 ) ; if ( ! ExceptHandler_type ) return 0 ; arguments_type = make_type ( ""arguments"" , & AST_type , arguments_fields , 6 ) ; if ( ! arguments_type ) return 0 ; if ( ! add_attributes ( arguments_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ; <S2SV_EndBug> if ( ! arg_type ) return 0 ; if ( ! add_attributes ( arg_type , arg_attributes , 4 ) ) return 0 ; keyword_type = make_type ( ""keyword"" , & AST_type , keyword_fields , 2 ) ; if ( ! keyword_type ) return 0 ; if ( ! add_attributes ( keyword_type , NULL , 0 ) ) return 0 ; alias_type = make_type ( ""alias"" , & AST_type , alias_fields , 2 ) ; if ( ! alias_type ) return 0 ; if ( ! add_attributes ( alias_type , NULL , 0 ) ) return 0 ; withitem_type = make_type ( ""withitem"" , & AST_type , withitem_fields , 2 ) ; if ( ! withitem_type ) return 0 ; if ( ! add_attributes ( withitem_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> initialized = 1 ; <S2SV_EndBug> return 1 ; }
","<S2SV_ModStart> , Module_fields , 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_ModStart> if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , Expression_fields , <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> if ( ! Expression_type ) return 0 ; FunctionType_type = make_type ( ""FunctionType"" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , FunctionType_fields , 2 ) ; if ( ! FunctionType_type <S2SV_ModEnd> ) return 0 <S2SV_ModStart> , FunctionDef_fields , 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , <S2SV_ModStart> if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( ""Return"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncFor_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncWith_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , arg_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> return 0 ; type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,706,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1546,CWE-284,"CWE-284 static void update_logging ( ) { bool should_log = module_started && ( logging_enabled_via_api || stack_config -> get_btsnoop_turned_on ( ) ) ; if ( should_log == is_logging ) return ; is_logging = should_log ; if ( should_log ) { btsnoop_net_open ( ) ; const char * log_path = stack_config -> get_btsnoop_log_path ( ) ; if ( stack_config -> get_btsnoop_should_save_last ( ) ) { char last_log_path [ PATH_MAX ] ; snprintf ( last_log_path , PATH_MAX , ""%s.%llu"" , log_path , btsnoop_timestamp ( ) ) ; if ( ! rename ( log_path , last_log_path ) && errno != ENOENT ) LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>rename<S2SV_blank>\'%s\'<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , log_path , last_log_path , strerror ( errno ) ) ; } <S2SV_StartBug> logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ; <S2SV_EndBug> if ( logfile_fd == INVALID_FD ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , log_path , strerror ( errno ) ) ; is_logging = false ; return ; } <S2SV_StartBug> write ( logfile_fd , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 ) ; <S2SV_EndBug> } else { if ( logfile_fd != INVALID_FD ) close ( logfile_fd ) ; logfile_fd = INVALID_FD ; btsnoop_net_close ( ) ; } }
","<S2SV_ModStart> } logfile_fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> S_IWGRP | S_IROTH ) <S2SV_ModStart> return ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,707,<S2SV_ModStart> ) ; } TEMP_FAILURE_RETRY (,0
1547,CWE-787,"CWE-787 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
",miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a,CVE-2019-16347,https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a,2019-09-16T13:15Z,708,<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; case 4 : context -> pass = <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; case 2 : context -> pass = <S2SV_ModEnd> break ; case 2 : context -> pass <S2SV_ModStart> ; break ; case 2 : context -> pass = context -> height + 1 ; break ; case 2 : context -> pass = i -> height + 1 ; break ; case 4 : context -> pass = i -> height + 1 ; break ; break ; break ; } else if ( context -> pass == 0 ) { context -> pass = i -> height ) { context -> pass = i -> pass = i -> height ; break ; } else { case 2 ; case 4 : context -> pass = i -> height ; } else { case 4 : context -> pass = i -> posY + 1 ; } else { context -> pass = i -> posY + 1 ; break ; } else { context -> pass = i -> posY + 1 ; },0
1548,CWE-119,"CWE-119 static void sum_intra_stats ( VP8_COMP * cpi , MACROBLOCK * x ) { const MACROBLOCKD * xd = & x -> e_mbd ; const MB_PREDICTION_MODE m = xd -> mode_info_context -> mbmi . mode ; const MB_PREDICTION_MODE uvm = xd -> mode_info_context -> mbmi . uv_mode ; # ifdef MODE_STATS const int is_key = cpi -> common . frame_type == KEY_FRAME ; ++ ( is_key ? uv_modes : inter_uv_modes ) [ uvm ] ; if ( m == B_PRED ) { unsigned int * const bct = is_key ? b_modes : inter_b_modes ; int b = 0 ; do { ++ bct [ xd -> block [ b ] . bmi . mode ] ; } while ( ++ b < 16 ) ; } <S2SV_StartBug> # endif <S2SV_EndBug> ++ x -> ymode_count [ m ] ; ++ x -> uv_mode_count [ uvm ] ; }
","<S2SV_ModStart> ; } # else ( void ) cpi ; #
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,709,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1551,CWE-706,"CWE-706 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; size = ( off_t ) ull ; <S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = NO ; statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( ""%s"" , j != EPIPE ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { if ( wrerr == NO ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; if ( count != 0 && wrerr == NO && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && ftruncate ( ofd , size ) != 0 ) { run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } if ( close ( ofd ) == - 1 ) { wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; if ( setimes && wrerr == NO ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; break ; case DISPLAYED : break ; } } screwup : run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
",openssh@openssh-portable/6010c0303a422a9c5fa8860c061bf7105eb7f8b2,CVE-2018-20685,https://github.com/openssh/openssh-portable/commit/6010c0303a422a9c5fa8860c061bf7105eb7f8b2,2019-01-10T21:29Z,710,<S2SV_ModStart> ; if ( * cp == NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> )!= NULL || <S2SV_ModEnd> strcmp ( cp,0
1552,CWE-20,"CWE-20 int DoOneObject ( char * cinput ) { <S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ; <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> return ( 0 ) ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" , axohelp , nameobject ) ; <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) { <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>no<S2SV_blank>extra<S2SV_blank>numbers<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""Curve"" ) == 0 ) { Curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) { Polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) { Polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) { <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> if ( num2 != 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>two<S2SV_blank>numbers<S2SV_blank>after<S2SV_blank>the<S2SV_blank>coordinates\\n<S2SV_blank><S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; DashCurve ( argbuf , num1 ) ; free ( argbuf ) ; <S2SV_StartBug> } <S2SV_EndBug> } else { <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < sizeof ( commands ) / sizeof ( KEYWORD ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; SetLineWidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>%d(+1)<S2SV_blank>arguments<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( KEYWORD ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; CleanupOutput ( StartClean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }
","<S2SV_ModStart> num1 , num2 , retcode <S2SV_ModStart> , * t <S2SV_ModEnd> ; double * <S2SV_ModStart> argbuf = 0 ; retcode = - 1 <S2SV_ModStart> t ++ ; fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> = outputbuffer ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ] == 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> = 1 ; fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> , VERSION , <S2SV_ModStart> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" <S2SV_ModStart> nameobject ) ; goto EXIT ; } } <S2SV_ModEnd> if ( ( <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; for ( <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } } <S2SV_ModStart> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> argbuf ) ; } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> ) ; }
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,711,<S2SV_ModStart> char * s <S2SV_ModEnd> ; char * <S2SV_ModStart> const char * c ; char * c ; char * c ; char * c ; char * c ; if ( ( ( ( ( * ) == '\\0' ) == '\\0' ) ) return 0 ; if ( ( ( * ) == '\\0' ) || ( ( * s == '\\0' ) == '\\0' || ( * s == '\\0' || ( * s == '\\0' ) ) outputbuffer [ 1 ] = '\\0' ; char * s ++ ] = 0 ; if ( ( ( * ) == '\\0' || ( * s == '\\0' || ( * s == '\\0' ) ) || ( ( * s2 [ 0 ] == '\\0' ) || ( ( * s2 [ 0 ] == '\\0' ) == '\\0' ) ) ; if ( ( ( ( * s == '\\0' ) ) == '\\0' || ( ( char * s2 [ 1 ] = 1 ) == '\\0' || ( ( ( * ) == '\\0' ) == '\\0' ) ) ; if ( ( ( ( * ) == '\\0' || ( ( ( * ) == '\\0' ) == '\\0',0
1554,CWE-326,"CWE-326 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 hash , id ; <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
","<S2SV_ModStart> segs ) { <S2SV_ModEnd> u32 hash , <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; hash = siphash_3u32 <S2SV_ModEnd> ( ( __force <S2SV_ModStart> iph -> protocol , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id
",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z,712,"<S2SV_ModStart> net * net <S2SV_ModEnd> ; u32 id <S2SV_ModStart> ; u32 ip_id_key <S2SV_ModEnd> ( net, <S2SV_ModStart>, sizeof ( struct ip_key <S2SV_ModEnd> ) ; net",0
1555,CWE-125,"CWE-125 int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_lower ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> slice_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( dims , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; <S2SV_EndBug> return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lower , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { slice_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,713,"<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_lineno, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; } if ( tmp == NULL ) { PyErr_SetString ( PyId_None ) ; return 1 ; } else { int res = NULL ; } else { int res ; res = obj2ast_expr ( tmp, & tmp, & tmp, & tmp ) ; if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; } if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; } else { Py_CLEAR ( tmp ) ; } else { int res = NULL ; Py_CLEAR ( tmp ) ; } else { int res = obj2ast_expr ( tmp, & tmp, & tmp ) ; } else { int res = obj2ast_expr ( tmp, & tmp, & tmp, & tmp ) ; if ( tmp == NULL ) goto failed ; } else { int res = NULL ; } if ( tmp == Py_CLEAR ( tmp ) goto failed ; } else { int res = NULL ; } else { int res = NULL ; } else { int res = NULL",0
1556,CWE-119,"CWE-119 <S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }
","<S2SV_ModStart> void write_intra_mode ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * w , PREDICTION_MODE <S2SV_ModEnd> mode , const <S2SV_ModStart> mode , const vpx_prob <S2SV_ModEnd> * probs )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,714,"<S2SV_ModStart> void write_mode ( vpx_writer <S2SV_ModEnd> * w,",0
1557,CWE-000,"CWE-000 static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , ""%s,%s,%s,%s,%s"" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ; <S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug> warn ( ""setpwnam<S2SV_blank>failed"" ) ; # endif printf ( _ ( ""Finger<S2SV_blank>information<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later.\\n"" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( ""Finger<S2SV_blank>information<S2SV_blank>changed.\\n"" ) ) ; return 0 ; }
","<S2SV_ModStart> ctl -> pw , "".chfn""
",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z,715,<S2SV_ModStart> ) return - 1 <S2SV_ModEnd> ; if,0
1559,CWE-401,"CWE-401 static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ; <S2SV_StartBug> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ; <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> list_add ( & match -> list , & alink -> dscp_map ) ; <S2SV_EndBug> } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ; <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> }
","<S2SV_ModStart> extack ) ) { err = - EOPNOTSUPP ; <S2SV_ModStart> goto err_delete ; } <S2SV_ModStart> ""conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter"" ) ; err = - EOPNOTSUPP ; <S2SV_ModStart> ! match ) { err = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto err_delete ; } <S2SV_ModStart> ) ; return err <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/78beef629fd95be4ed853b2d37b832f766bd96ca,CVE-2019-19076,https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca,2019-11-18T06:15Z,716,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1562,CWE-119,"CWE-119 static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store"" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store"" ) ; } <S2SV_StartBug> stream -> config . cfg . g_pass = global -> passes == 2 <S2SV_EndBug> ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; <S2SV_StartBug> if ( pass ) <S2SV_EndBug> stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ; <S2SV_StartBug> stream -> cx_time = 0 ; <S2SV_EndBug> stream -> nbytes = 0 ; stream -> frames_out = 0 ; }
","<S2SV_ModStart> ) ; } # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ; } # endif <S2SV_ModStart> ( pass ) { <S2SV_ModStart> stats ) ; # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,717,<S2SV_ModStart> == 0 ) { <S2SV_ModStart> = 0 ; },0
1564,CWE-74,"CWE-74 static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; <S2SV_StartBug> else <S2SV_EndBug> g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }
","<S2SV_ModStart> ) ; else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; else
",flatpak@flatpak/8279c5818425b6812523e3805bbe242fb6a5d961,CVE-2021-21381,https://github.com/flatpak/flatpak/commit/8279c5818425b6812523e3805bbe242fb6a5d961,2021-03-11T17:15Z,718,,0
1565,CWE-119,"CWE-119 static const uint8_t * decode_tiles ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; int tile_row , tile_col ; <S2SV_StartBug> const uint8_t * end = NULL ; <S2SV_EndBug> <S2SV_StartBug> vp9_reader r ; <S2SV_EndBug> assert ( tile_rows <= 4 ) ; assert ( tile_cols <= ( 1 << 6 ) ) ; <S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ; <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; <S2SV_EndBug> for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { <S2SV_StartBug> const int last_tile = tile_row == tile_rows - 1 && <S2SV_EndBug> tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ; TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; buf -> data = data ; buf -> size = size ; data += size ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> oxcf . inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; const int last_tile = tile_row == tile_rows - 1 && col == tile_cols - 1 ; const TileBuffer * const buf = & tile_buffers [ tile_row ] [ col ] ; TileInfo tile ; vp9_tile_init ( & tile , cm , tile_row , col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & r ) ; decode_tile ( pbi , & tile , & r ) ; if ( last_tile ) end = vp9_reader_find_end ( & r ) ; } } return end ; }
","<S2SV_ModStart> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> , tile_col ; int mi_row , mi_col ; TileData * tile_data <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <S2SV_ModEnd> assert ( tile_rows <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> aligned_cols ) ; memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> aligned_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <S2SV_ModStart> ) { const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data"" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * <S2SV_ModEnd> tile_rows - 1 <S2SV_ModStart> tile_rows - 1 ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,719,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1566,CWE-119,"CWE-119 <S2SV_StartBug> VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ; <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; <S2SV_EndBug> if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ; <S2SV_StartBug> vp9_initialize_dec ( ) ; <S2SV_EndBug> vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; <S2SV_StartBug> cm -> current_video_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> pbi -> oxcf = * oxcf ; <S2SV_EndBug> pbi -> ready_for_new_data = 1 ; <S2SV_StartBug> pbi -> decoded_key_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_dequantizer ( cm ) ; <S2SV_EndBug> vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }
","<S2SV_ModStart> * vp9_decoder_create ( BufferPool * const pool <S2SV_ModEnd> ) { VP9Decoder <S2SV_ModStart> { VP9Decoder * volatile <S2SV_ModStart> ; VP9_COMMON * volatile <S2SV_ModStart> = 1 ; CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <S2SV_ModEnd> ( & cm <S2SV_ModStart> ) ) ; memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <S2SV_ModStart> ; pbi -> <S2SV_ModEnd> ready_for_new_data = 1 <S2SV_ModStart> ; pbi -> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; vpx_get_worker_interface ( ) -> init <S2SV_ModEnd> ( & pbi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,720,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void vpx_writer <S2SV_ModEnd> * pbi <S2SV_ModStart> * pbi ; VP9_COMMON * pbi = & pbi -> common ; VP9_COMMON * pbi = & pbi -> common ; VP9_COMMON * pbi = & pbi -> common ; VP9_COMMON * pbi = & pbi -> common ; VP9_COMMON * pbi = & pbi -> last_frame_frame_frame_frame_frame_data ; vpx_write_frame_frame_data ( & pbi -> frame_frame_data, cm ) ; vp9_data = NULL ; cm -> frame_data = NULL ; vpx_write_frame_frame_data = NULL ; pbi -> frame_frame_data = NULL ; vpx_free ( pbi ) ; cm -> frame_data = NULL ; vpx_write_frame_data = 0 ; pbi -> frame_frame_frame_data = 0 ; pbi -> last_frame_frame_frame_frame_frame_frame_frame = pbi -> last_frame_frame_frame_frame_frame_frame_frame",0
1567,CWE-401,"CWE-401 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> } return GF_OK ; }
","<S2SV_ModStart> dref ) { GF_Box * dref ; <S2SV_ModStart> ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ; }
",gpac@gpac/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,CVE-2018-21017,https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,2019-09-16T13:15Z,721,<S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( s,0
1570,CWE-362,"CWE-362 void cipso_v4_req_delattr ( struct request_sock * req ) { <S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> struct inet_request_sock * req_inet ; req_inet = inet_rsk ( req ) ; opt = req_inet -> opt ; <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> return ; cipso_v4_delopt ( & req_inet -> opt ) ; }
","<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> || opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z,722,<S2SV_ModStart> opt ; struct ip_options_rcu <S2SV_ModEnd> * opt =,0
1571,CWE-119,"CWE-119 <S2SV_StartBug> static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree , <S2SV_EndBug> int i , int v , int l ) { v += v ; ++ l ; do { <S2SV_StartBug> const vp9_tree_index j = tree [ i ++ ] ; <S2SV_EndBug> if ( j <= 0 ) { tokens [ - j ] . value = v ; tokens [ - j ] . len = l ; } else { tree2tok ( tokens , tree , j , v , l ) ; } } while ( ++ v & 1 ) ; }
","<S2SV_ModStart> tokens , const vpx_tree_index <S2SV_ModEnd> * tree , <S2SV_ModStart> do { const vpx_tree_index <S2SV_ModEnd> j = tree
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,723,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1572,CWE-119,"CWE-119 static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_StartBug> if ( img ) <S2SV_EndBug> <S2SV_StartBug> res = validate_img ( ctx , img ) ; <S2SV_EndBug> pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; } <S2SV_StartBug> if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | <S2SV_EndBug> VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } } <S2SV_StartBug> if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int lib_flags ; <S2SV_EndBug> YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> int64_t dst_time_stamp , dst_end_time_stamp ; <S2SV_EndBug> size_t size , cx_data_sz ; unsigned char * cx_data ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) <S2SV_StartBug> ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; <S2SV_EndBug> lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = ( pts * 10000000 * ctx -> cfg . g_timebase . num ) / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ; <S2SV_StartBug> if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags , <S2SV_EndBug> & sd , dst_time_stamp , dst_end_time_stamp ) ) { <S2SV_StartBug> VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ; <S2SV_EndBug> res = update_error_state ( ctx , & cpi -> common . error ) ; } <S2SV_StartBug> } <S2SV_EndBug> cx_data = ctx -> cx_data ; <S2SV_StartBug> cx_data_sz = ctx -> cx_data_sz ; <S2SV_EndBug> lib_flags = 0 ; if ( ctx -> pending_cx_data ) { memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; ctx -> pending_cx_data = cx_data ; cx_data += ctx -> pending_cx_data_sz ; cx_data_sz -= ctx -> pending_cx_data_sz ; if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { ctx -> base . err_detail = ""Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small"" ; return VPX_CODEC_ERROR ; } } while ( cx_data_sz >= ctx -> cx_data_sz / 2 && <S2SV_StartBug> - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size , <S2SV_EndBug> cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) { if ( size ) { <S2SV_StartBug> vpx_codec_pts_t round , delta ; <S2SV_EndBug> vpx_codec_cx_pkt_t pkt ; <S2SV_StartBug> VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . show_frame == 0 ) { <S2SV_EndBug> if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ; ctx -> pending_cx_data_sz += size ; ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; cx_data += size ; cx_data_sz -= size ; <S2SV_StartBug> continue ; <S2SV_EndBug> } round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ; <S2SV_StartBug> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; <S2SV_EndBug> pkt . data . frame . pts = <S2SV_StartBug> ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) <S2SV_EndBug> / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long ) <S2SV_StartBug> ( ( delta * ctx -> cfg . g_timebase . den + round ) <S2SV_EndBug> / ctx -> cfg . g_timebase . num / 10000000 ) ; <S2SV_StartBug> pkt . data . frame . flags = lib_flags << 16 ; <S2SV_EndBug> if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( cpi -> common . show_frame == 0 ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( ctx -> pending_cx_data ) { ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; ctx -> pending_frame_magnitude |= size ; ctx -> pending_cx_data_sz += size ; <S2SV_StartBug> size += write_superframe_index ( ctx ) ; <S2SV_EndBug> pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = ctx -> pending_cx_data_sz ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; } pkt . data . frame . partition_id = - 1 ; <S2SV_StartBug> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; <S2SV_EndBug> cx_data += size ; cx_data_sz -= size ; <S2SV_StartBug> } <S2SV_EndBug> } } return res ; }
","<S2SV_ModStart> = VPX_CODEC_OK ; VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; <S2SV_ModStart> if ( img != NULL ) { <S2SV_ModEnd> res = validate_img <S2SV_ModStart> img ) ; if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <S2SV_ModStart> VPX_CODEC_INVALID_PARAM ; } vp9_apply_encoding_flags ( cpi , flags ) ; <S2SV_ModEnd> if ( ctx <S2SV_ModStart> == VPX_CODEC_OK && <S2SV_ModEnd> cpi != NULL <S2SV_ModStart> unsigned int lib_flags = 0 <S2SV_ModStart> ; int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <S2SV_ModEnd> ; size_t size <S2SV_ModStart> & VPX_CODEC_USE_PSNR ) cpi <S2SV_ModEnd> -> b_calculate_psnr = <S2SV_ModStart> b_calculate_psnr = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags <S2SV_ModEnd> , & sd <S2SV_ModStart> ) ) { <S2SV_ModEnd> res = update_error_state <S2SV_ModStart> ) ; } ctx -> next_frame_flags = 0 ; <S2SV_ModStart> ctx -> cx_data_sz <S2SV_ModEnd> ; if ( <S2SV_ModStart> != vp9_get_compressed_data ( <S2SV_ModEnd> cpi , & <S2SV_ModStart> size ) { <S2SV_ModEnd> vpx_codec_cx_pkt_t pkt ; <S2SV_ModStart> vpx_codec_cx_pkt_t pkt ; # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! <S2SV_ModEnd> cpi -> common <S2SV_ModStart> common . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <S2SV_ModEnd> ) { if <S2SV_ModStart> -= size ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , <S2SV_ModEnd> dst_end_time_stamp - dst_time_stamp <S2SV_ModStart> ; pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <S2SV_ModStart> . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) <S2SV_ModEnd> ; pkt . <S2SV_ModStart> unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <S2SV_ModEnd> ) ; pkt <S2SV_ModStart> . flags = get_frame_pkt_flags ( cpi , lib_flags ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> += size ; if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <S2SV_ModStart> - 1 ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <S2SV_ModStart> -= size ; # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,724,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
1575,CWE-674,"CWE-674 static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = NULL , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = NULL ; * count_out = 0 ; while ( len > 0 ) { <S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = ASN1_BAD_ID ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == NULL ) { ret = ENOMEM ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }
","<S2SV_ModStart> , & len , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z,725,"<S2SV_ModStart>, & len, 0",1
1576,CWE-119,"CWE-119 <S2SV_StartBug> void fadst16_8col ( __m128i * in ) { <S2SV_EndBug> __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ; const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ; const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ; const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ; const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ; const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ; const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ; const __m128i k__cospi_m28_p04 = pair_set_epi16 ( - cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m12_p20 = pair_set_epi16 ( - cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; <S2SV_StartBug> const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; const __m128i kZero = _mm_set1_epi16 ( 0 ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( in [ 15 ] , in [ 0 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( in [ 13 ] , in [ 2 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( in [ 11 ] , in [ 4 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( in [ 9 ] , in [ 6 ] ) ; u [ 8 ] = _mm_unpacklo_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 9 ] = _mm_unpackhi_epi16 ( in [ 7 ] , in [ 8 ] ) ; u [ 10 ] = _mm_unpacklo_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 11 ] = _mm_unpackhi_epi16 ( in [ 5 ] , in [ 10 ] ) ; u [ 12 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 13 ] = _mm_unpackhi_epi16 ( in [ 3 ] , in [ 12 ] ) ; u [ 14 ] = _mm_unpacklo_epi16 ( in [ 1 ] , in [ 14 ] ) ; u [ 15 ] = _mm_unpackhi_epi16 ( in [ 1 ] , in [ 14 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p01_p31 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p01_p31 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p31_m01 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p31_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p05_p27 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p05_p27 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p27_m05 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p27_m05 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p09_p23 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p09_p23 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p23_m09 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p23_m09 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p13_p19 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p13_p19 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p19_m13 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p19_m13 ) ; v [ 16 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p17_p15 ) ; v [ 17 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p17_p15 ) ; v [ 18 ] = _mm_madd_epi16 ( u [ 8 ] , k__cospi_p15_m17 ) ; v [ 19 ] = _mm_madd_epi16 ( u [ 9 ] , k__cospi_p15_m17 ) ; v [ 20 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p21_p11 ) ; v [ 21 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p21_p11 ) ; v [ 22 ] = _mm_madd_epi16 ( u [ 10 ] , k__cospi_p11_m21 ) ; v [ 23 ] = _mm_madd_epi16 ( u [ 11 ] , k__cospi_p11_m21 ) ; v [ 24 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p25_p07 ) ; v [ 25 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p25_p07 ) ; v [ 26 ] = _mm_madd_epi16 ( u [ 12 ] , k__cospi_p07_m25 ) ; v [ 27 ] = _mm_madd_epi16 ( u [ 13 ] , k__cospi_p07_m25 ) ; v [ 28 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p29_p03 ) ; v [ 29 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p29_p03 ) ; v [ 30 ] = _mm_madd_epi16 ( u [ 14 ] , k__cospi_p03_m29 ) ; v [ 31 ] = _mm_madd_epi16 ( u [ 15 ] , k__cospi_p03_m29 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , v [ 31 ] ) ; u [ 16 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 16 ] ) ; u [ 17 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 17 ] ) ; u [ 18 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 18 ] ) ; u [ 19 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 19 ] ) ; u [ 20 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 20 ] ) ; u [ 21 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 21 ] ) ; u [ 22 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 22 ] ) ; u [ 23 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 23 ] ) ; u [ 24 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 24 ] ) ; u [ 25 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 25 ] ) ; u [ 26 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 26 ] ) ; u [ 27 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 27 ] ) ; u [ 28 ] = _mm_sub_epi32 ( v [ 12 ] , v [ 28 ] ) ; u [ 29 ] = _mm_sub_epi32 ( v [ 13 ] , v [ 29 ] ) ; u [ 30 ] = _mm_sub_epi32 ( v [ 14 ] , v [ 30 ] ) ; u [ 31 ] = _mm_sub_epi32 ( v [ 15 ] , v [ 31 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 16 ] = _mm_add_epi32 ( u [ 16 ] , k__DCT_CONST_ROUNDING ) ; v [ 17 ] = _mm_add_epi32 ( u [ 17 ] , k__DCT_CONST_ROUNDING ) ; v [ 18 ] = _mm_add_epi32 ( u [ 18 ] , k__DCT_CONST_ROUNDING ) ; v [ 19 ] = _mm_add_epi32 ( u [ 19 ] , k__DCT_CONST_ROUNDING ) ; v [ 20 ] = _mm_add_epi32 ( u [ 20 ] , k__DCT_CONST_ROUNDING ) ; v [ 21 ] = _mm_add_epi32 ( u [ 21 ] , k__DCT_CONST_ROUNDING ) ; v [ 22 ] = _mm_add_epi32 ( u [ 22 ] , k__DCT_CONST_ROUNDING ) ; v [ 23 ] = _mm_add_epi32 ( u [ 23 ] , k__DCT_CONST_ROUNDING ) ; v [ 24 ] = _mm_add_epi32 ( u [ 24 ] , k__DCT_CONST_ROUNDING ) ; v [ 25 ] = _mm_add_epi32 ( u [ 25 ] , k__DCT_CONST_ROUNDING ) ; v [ 26 ] = _mm_add_epi32 ( u [ 26 ] , k__DCT_CONST_ROUNDING ) ; v [ 27 ] = _mm_add_epi32 ( u [ 27 ] , k__DCT_CONST_ROUNDING ) ; v [ 28 ] = _mm_add_epi32 ( u [ 28 ] , k__DCT_CONST_ROUNDING ) ; v [ 29 ] = _mm_add_epi32 ( u [ 29 ] , k__DCT_CONST_ROUNDING ) ; v [ 30 ] = _mm_add_epi32 ( u [ 30 ] , k__DCT_CONST_ROUNDING ) ; v [ 31 ] = _mm_add_epi32 ( u [ 31 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; u [ 16 ] = _mm_srai_epi32 ( v [ 16 ] , DCT_CONST_BITS ) ; u [ 17 ] = _mm_srai_epi32 ( v [ 17 ] , DCT_CONST_BITS ) ; u [ 18 ] = _mm_srai_epi32 ( v [ 18 ] , DCT_CONST_BITS ) ; u [ 19 ] = _mm_srai_epi32 ( v [ 19 ] , DCT_CONST_BITS ) ; u [ 20 ] = _mm_srai_epi32 ( v [ 20 ] , DCT_CONST_BITS ) ; u [ 21 ] = _mm_srai_epi32 ( v [ 21 ] , DCT_CONST_BITS ) ; u [ 22 ] = _mm_srai_epi32 ( v [ 22 ] , DCT_CONST_BITS ) ; u [ 23 ] = _mm_srai_epi32 ( v [ 23 ] , DCT_CONST_BITS ) ; u [ 24 ] = _mm_srai_epi32 ( v [ 24 ] , DCT_CONST_BITS ) ; u [ 25 ] = _mm_srai_epi32 ( v [ 25 ] , DCT_CONST_BITS ) ; u [ 26 ] = _mm_srai_epi32 ( v [ 26 ] , DCT_CONST_BITS ) ; u [ 27 ] = _mm_srai_epi32 ( v [ 27 ] , DCT_CONST_BITS ) ; u [ 28 ] = _mm_srai_epi32 ( v [ 28 ] , DCT_CONST_BITS ) ; u [ 29 ] = _mm_srai_epi32 ( v [ 29 ] , DCT_CONST_BITS ) ; u [ 30 ] = _mm_srai_epi32 ( v [ 30 ] , DCT_CONST_BITS ) ; u [ 31 ] = _mm_srai_epi32 ( v [ 31 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; s [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; s [ 2 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; s [ 3 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; s [ 4 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; s [ 5 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; s [ 6 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; s [ 7 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; s [ 8 ] = _mm_packs_epi32 ( u [ 16 ] , u [ 17 ] ) ; s [ 9 ] = _mm_packs_epi32 ( u [ 18 ] , u [ 19 ] ) ; s [ 10 ] = _mm_packs_epi32 ( u [ 20 ] , u [ 21 ] ) ; s [ 11 ] = _mm_packs_epi32 ( u [ 22 ] , u [ 23 ] ) ; s [ 12 ] = _mm_packs_epi32 ( u [ 24 ] , u [ 25 ] ) ; s [ 13 ] = _mm_packs_epi32 ( u [ 26 ] , u [ 27 ] ) ; s [ 14 ] = _mm_packs_epi32 ( u [ 28 ] , u [ 29 ] ) ; s [ 15 ] = _mm_packs_epi32 ( u [ 30 ] , u [ 31 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 8 ] , s [ 9 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 12 ] , s [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p04_p28 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p04_p28 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_m04 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_m04 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_m20 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_m20 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m28_p04 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m28_p04 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p04_p28 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p04_p28 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m12_p20 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m12_p20 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p20_p12 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p20_p12 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , v [ 15 ] ) ; u [ 8 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 8 ] ) ; u [ 9 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 9 ] ) ; u [ 10 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 10 ] ) ; u [ 11 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 11 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 4 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 5 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 6 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 7 ] , v [ 15 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; v [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; v [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; v [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; v [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; v [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; v [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; v [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; u [ 8 ] = _mm_srai_epi32 ( v [ 8 ] , DCT_CONST_BITS ) ; u [ 9 ] = _mm_srai_epi32 ( v [ 9 ] , DCT_CONST_BITS ) ; u [ 10 ] = _mm_srai_epi32 ( v [ 10 ] , DCT_CONST_BITS ) ; u [ 11 ] = _mm_srai_epi32 ( v [ 11 ] , DCT_CONST_BITS ) ; u [ 12 ] = _mm_srai_epi32 ( v [ 12 ] , DCT_CONST_BITS ) ; u [ 13 ] = _mm_srai_epi32 ( v [ 13 ] , DCT_CONST_BITS ) ; u [ 14 ] = _mm_srai_epi32 ( v [ 14 ] , DCT_CONST_BITS ) ; u [ 15 ] = _mm_srai_epi32 ( v [ 15 ] , DCT_CONST_BITS ) ; x [ 0 ] = _mm_add_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 1 ] = _mm_add_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 2 ] = _mm_add_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 3 ] = _mm_add_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 4 ] = _mm_sub_epi16 ( s [ 0 ] , s [ 4 ] ) ; x [ 5 ] = _mm_sub_epi16 ( s [ 1 ] , s [ 5 ] ) ; x [ 6 ] = _mm_sub_epi16 ( s [ 2 ] , s [ 6 ] ) ; x [ 7 ] = _mm_sub_epi16 ( s [ 3 ] , s [ 7 ] ) ; x [ 8 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; x [ 9 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; x [ 10 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; x [ 11 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; x [ 12 ] = _mm_packs_epi32 ( u [ 8 ] , u [ 9 ] ) ; x [ 13 ] = _mm_packs_epi32 ( u [ 10 ] , u [ 11 ] ) ; x [ 14 ] = _mm_packs_epi32 ( u [ 12 ] , u [ 13 ] ) ; x [ 15 ] = _mm_packs_epi32 ( u [ 14 ] , u [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( x [ 4 ] , x [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( x [ 6 ] , x [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( x [ 12 ] , x [ 13 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( x [ 14 ] , x [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( x [ 14 ] , x [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p08_p24 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_m08 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_p08 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_p08 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_p24 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_p24 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p08_p24 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p08_p24 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p24_m08 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p24_m08 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m24_p08 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m24_p08 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p08_p24 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p08_p24 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 4 ] = _mm_sub_epi32 ( v [ 0 ] , v [ 4 ] ) ; u [ 5 ] = _mm_sub_epi32 ( v [ 1 ] , v [ 5 ] ) ; u [ 6 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 7 ] = _mm_sub_epi32 ( v [ 3 ] , v [ 7 ] ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 12 ] = _mm_sub_epi32 ( v [ 8 ] , v [ 12 ] ) ; u [ 13 ] = _mm_sub_epi32 ( v [ 9 ] , v [ 13 ] ) ; u [ 14 ] = _mm_sub_epi32 ( v [ 10 ] , v [ 14 ] ) ; u [ 15 ] = _mm_sub_epi32 ( v [ 11 ] , v [ 15 ] ) ; u [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( u [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( u [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( u [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( u [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( u [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( u [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( u [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( u [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; s [ 0 ] = _mm_add_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 1 ] = _mm_add_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 2 ] = _mm_sub_epi16 ( x [ 0 ] , x [ 2 ] ) ; s [ 3 ] = _mm_sub_epi16 ( x [ 1 ] , x [ 3 ] ) ; s [ 4 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; s [ 5 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; s [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; s [ 7 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 8 ] = _mm_add_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 9 ] = _mm_add_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 10 ] = _mm_sub_epi16 ( x [ 8 ] , x [ 10 ] ) ; s [ 11 ] = _mm_sub_epi16 ( x [ 9 ] , x [ 11 ] ) ; s [ 12 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; s [ 13 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; s [ 14 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; s [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 6 ] , s [ 7 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 10 ] , s [ 11 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 14 ] , s [ 15 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 14 ] , s [ 15 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_m16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_m16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_m16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_m16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p16_p16 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p16_p16 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m16_p16 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m16_p16 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m16_m16 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m16_m16 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p16_m16 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p16_m16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 0 ] = s [ 0 ] ; in [ 1 ] = _mm_sub_epi16 ( kZero , s [ 8 ] ) ; in [ 2 ] = s [ 12 ] ; in [ 3 ] = _mm_sub_epi16 ( kZero , s [ 4 ] ) ; in [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 8 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 12 ] = s [ 5 ] ; in [ 13 ] = _mm_sub_epi16 ( kZero , s [ 13 ] ) ; in [ 14 ] = s [ 9 ] ; in [ 15 ] = _mm_sub_epi16 ( kZero , s [ 1 ] ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> = _mm_set1_epi16 ( ( int16_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,726,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1577,CWE-119,"CWE-119 <S2SV_StartBug> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <S2SV_EndBug> ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ; if ( max_bits < 0 ) max_bits = 0 ; else if ( max_bits > rc -> max_frame_bandwidth ) max_bits = rc -> max_frame_bandwidth ; return ( int ) max_bits ; }
","<S2SV_ModStart> rc , const VP9EncoderConfig <S2SV_ModEnd> * oxcf ) <S2SV_ModStart> ) rc -> avg_frame_bandwidth <S2SV_ModEnd> * ( int64_t
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,727,<S2SV_ModStart> ) { const VP9EncoderConfig <S2SV_ModEnd> * oxcf =,0
1578,CWE-190,"CWE-190 static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) { <S2SV_StartBug> uchar magicbuf [ MIF_MAGICLEN ] ; <S2SV_EndBug> char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ; jas_tvparser_t * tvp ; int id ; hdr = 0 ; tvp = 0 ; if ( jas_stream_read ( in , magicbuf , MIF_MAGICLEN ) != MIF_MAGICLEN ) { goto error ; } if ( magicbuf [ 0 ] != ( MIF_MAGIC >> 24 ) || magicbuf [ 1 ] != ( ( MIF_MAGIC >> 16 ) & 0xff ) || magicbuf [ 2 ] != ( ( MIF_MAGIC >> 8 ) & 0xff ) || magicbuf [ 3 ] != ( MIF_MAGIC & 0xff ) ) { jas_eprintf ( ""error:<S2SV_blank>bad<S2SV_blank>signature\\n"" ) ; goto error ; } if ( ! ( hdr = mif_hdr_create ( 0 ) ) ) { goto error ; } done = false ; do { if ( ! mif_getline ( in , buf , sizeof ( buf ) ) ) { jas_eprintf ( ""mif_getline<S2SV_blank>failed\\n"" ) ; goto error ; } if ( buf [ 0 ] == '\\0' ) { continue ; } JAS_DBGLOG ( 10 , ( ""header<S2SV_blank>line:<S2SV_blank>len=%d;<S2SV_blank>%s\\n"" , strlen ( buf ) , buf ) ) ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { jas_eprintf ( ""jas_tvparser_create<S2SV_blank>failed\\n"" ) ; goto error ; } if ( jas_tvparser_next ( tvp ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>record<S2SV_blank>type\\n"" ) ; goto error ; } id = jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags2 , jas_tvparser_gettag ( tvp ) ) ) -> id ; jas_tvparser_destroy ( tvp ) ; tvp = 0 ; switch ( id ) { case MIF_CMPT : if ( mif_process_cmpt ( hdr , buf ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>component<S2SV_blank>information\\n"" ) ; goto error ; } break ; case MIF_END : done = 1 ; break ; default : jas_eprintf ( ""invalid<S2SV_blank>header<S2SV_blank>information:<S2SV_blank>%s\\n"" , buf ) ; goto error ; break ; } } while ( ! done ) ; return hdr ; error : if ( hdr ) { mif_hdr_destroy ( hdr ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> magicbuf [ MIF_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,728,<S2SV_ModStart> char jas_uchar <S2SV_ModEnd> ; if (,0
1580,CWE-119,"CWE-119 <S2SV_StartBug> static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , <S2SV_EndBug> <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ; <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && <S2SV_EndBug> cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ; <S2SV_StartBug> x -> skip_optimize = ctx -> is_coded ; <S2SV_EndBug> ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ; <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_EndBug> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; vp9_update_zbin_extra ( cpi , x ) ; } } else { <S2SV_StartBug> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; <S2SV_EndBug> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; } cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ; vp9_update_zbin_extra ( cpi , x ) ; } if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ; vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ; <S2SV_StartBug> vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , <S2SV_EndBug> & xd -> block_refs [ ref ] -> sf ) ; } <S2SV_StartBug> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> mbmi -> skip = 1 ; vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_StartBug> vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> mbmi -> skip = 1 ; if ( output_enabled ) cm -> counts . skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ; reset_skip_context ( xd , MAX ( bsize , BLOCK_8X8 ) ) ; } } if ( output_enabled ) { if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip || <S2SV_StartBug> vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , <S2SV_EndBug> <S2SV_StartBug> & cm -> counts . tx ) [ mbmi -> tx_size ] ; <S2SV_EndBug> } else { int x , y ; TX_SIZE tx_size ; if ( is_inter_block ( & mi -> mbmi ) ) { tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , max_txsize_lookup [ bsize ] ) ; } else { tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ; } for ( y = 0 ; y < mi_height ; y ++ ) for ( x = 0 ; x < mi_width ; x ++ ) if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ; } <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> mbmi ; const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) <S2SV_ModEnd> ; const int <S2SV_ModStart> ! x -> select_tx_size <S2SV_ModEnd> && mbmi -> <S2SV_ModStart> . allow_skip_recode ; if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> ; if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ; vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ) ; for <S2SV_ModStart> ] ) ; assert ( cfg != NULL ) ; <S2SV_ModStart> ) ; } if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby <S2SV_ModEnd> ( xd , <S2SV_ModStart> ) ) ; vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) <S2SV_ModEnd> ; vp9_encode_sb ( <S2SV_ModStart> vp9_tokenize_sb ( cpi , td <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> -> skip || seg_skip <S2SV_ModEnd> ) ) ) <S2SV_ModStart> bsize ] , get_tx_size_context <S2SV_ModEnd> ( xd ) <S2SV_ModStart> ) , & td -> counts -> <S2SV_ModEnd> tx ) [ <S2SV_ModStart> tx_size ; } ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,729,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> { VP9_COMMON * const VP9_COMMON * x = & cpi -> common ; VP9_COMMON * const x = & cpi -> common ; MACROBLOCKD * const x -> common ; MACROBLOCKD * const x = & cpi -> common ; MACROBLOCKD * const x -> mb ; x -> mbmi_mode = & cpi -> mb ; x -> mbmi_mode = & cpi -> mbmi_mode_mode ; <S2SV_ModStart> -> oxcf. mbmi_mode_mode = & cpi -> mbmi_mode_mode_mode ; <S2SV_ModStart> ; } # if CONFIG_VP9_VP9_HIGHBITDEPTH if CONFIG_VP9_8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8x8 ; if ( cpi -> mode_mode == BLOCK_8X8X8X8X8X8X8X8X8X8X,0
1583,CWE-119,"CWE-119 static inline void header_put_be_int ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z,730,<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header. ptr,0
1584,CWE-129,"CWE-129 static int cbs_av1_read_uvlc ( CodedBitstreamContext * ctx , GetBitContext * gbc , const char * name , uint32_t * write_to , uint32_t range_min , uint32_t range_max ) { <S2SV_StartBug> uint32_t value ; <S2SV_EndBug> <S2SV_StartBug> int position , zeroes , i , j ; <S2SV_EndBug> char bits [ 65 ] ; if ( ctx -> trace_enable ) position = get_bits_count ( gbc ) ; <S2SV_StartBug> zeroes = i = 0 ; <S2SV_EndBug> while ( 1 ) { <S2SV_StartBug> if ( get_bits_left ( gbc ) < zeroes + 1 ) { <S2SV_EndBug> av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\n"" , name ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> if ( get_bits1 ( gbc ) ) { <S2SV_EndBug> bits [ i ++ ] = '1' ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { bits [ i ++ ] = '0' ; ++ zeroes ; } } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { value = get_bits_long ( gbc , zeroes ) ; for ( j = 0 ; j < zeroes ; j ++ ) <S2SV_StartBug> bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ; <S2SV_EndBug> <S2SV_StartBug> value += ( 1 << zeroes ) - 1 ; <S2SV_EndBug> } if ( ctx -> trace_enable ) { bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , value ) ; } if ( value < range_min || value > range_max ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""%s<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>"" ""%"" PRIu32 "",<S2SV_blank>but<S2SV_blank>must<S2SV_blank>be<S2SV_blank>in<S2SV_blank>[%"" PRIu32 "",%"" PRIu32 ""].\\n"" , name , value , range_min , range_max ) ; return AVERROR_INVALIDDATA ; } * write_to = value ; return 0 ; }
","<S2SV_ModStart> ) { uint32_t zeroes , bits_value , <S2SV_ModStart> ; int position <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; zeroes = <S2SV_ModEnd> 0 ; while <S2SV_ModStart> gbc ) < <S2SV_ModEnd> 1 ) { <S2SV_ModStart> gbc ) ) break ; ++ zeroes ; } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { if ( get_bits_left ( gbc ) < zeroes ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\n"" , name ) ; return AVERROR_INVALIDDATA ; } bits_value = get_bits_long ( gbc , zeroes ) ; value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ; } if ( ctx -> trace_enable ) { char bits [ 65 ] ; int i , j , k ; if ( zeroes >= 32 ) { while ( zeroes > 32 ) { k = FFMIN ( zeroes - 32 , 32 ) ; for ( i = 0 ; i < k ; i ++ ) bits [ i ] = '0' ; bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ; zeroes -= k ; position += k ; } } for ( i = 0 ; i < zeroes ; i ++ ) bits [ i ] = '0' ; <S2SV_ModEnd> bits [ i <S2SV_ModStart> = '1' ; if ( zeroes < 32 ) { <S2SV_ModEnd> for ( j <S2SV_ModStart> ] = ( bits_value <S2SV_ModEnd> >> ( zeroes <S2SV_ModStart> : '0' ; } <S2SV_ModEnd> bits [ i
",FFmpeg@FFmpeg/b97a4b658814b2de8b9f2a3bce491c002d34de31,CVE-2019-1000016,https://github.com/FFmpeg/FFmpeg/commit/b97a4b658814b2de8b9f2a3bce491c002d34de31,2019-02-04T21:29Z,731,"<S2SV_ModStart>, & 1, <S2SV_ModEnd> ) { int",0
1586,CWE-000,"CWE-000 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
","<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
",torvalds@linux/a642fc305053cc1c6e47e4f4df327895747ab485,CVE-2014-3646,https://github.com/torvalds/linux/commit/a642fc305053cc1c6e47e4f4df327895747ab485,2014-11-10T11:55Z,732,<S2SV_ModStart> case EXIT_REASON_NONE :,0
1587,CWE-20,"CWE-20 error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '=' ) { separatorFound = TRUE ; param -> nameLen = p + i - param -> name ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { } else { error = ERROR_INVALID_SYNTAX ; } } else if ( ! separatorFound ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == '=' ) { separatorFound = TRUE ; } else if ( c == \'\\""\' ) { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> value == NULL ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == \'\\""\' ) { param -> value = p + i ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { param -> value = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( param -> value [ 0 ] == \'\\""\' ) { if ( c == '\\0' ) { error = ERROR_INVALID_SYNTAX ; } else if ( escapeFlag ) { escapeFlag = FALSE ; } else if ( c == '\\\\' ) { escapeFlag = TRUE ; } else if ( c == \'\\""\' ) { i ++ ; param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } else if ( isprint ( c ) || c == '\\t' || c >= 128 ) { } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( c == '\\0' || c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { } else { error = ERROR_INVALID_SYNTAX ; } } } if ( error == ERROR_IN_PROGRESS ) i ++ ; } if ( param -> valueLen >= 2 && param -> value [ 0 ] == \'\\""\' ) { param -> value ++ ; param -> valueLen -= 2 ; } * pos = p + i ; return error ; }
","<S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,733,<S2SV_ModStart> { if ( c == NULL &&,0
1588,CWE-416,"CWE-416 static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , <S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug> packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }
","<S2SV_ModStart> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->
",ntop@nDPI/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,CVE-2020-15475,https://github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,2020-07-01T11:15Z,734,<S2SV_ModStart> = 0 ; packet -> header. len = 0 ;,0
1589,CWE-20,"CWE-20 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> out : return ERR_PTR ( error ) ; }
","<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return
",torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z,735,<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return,1
1590,CWE-617,"CWE-617 static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> return r ; }
","<S2SV_ModStart> ++ r ; if <S2SV_ModEnd> ( pow ( <S2SV_ModStart> , dim ) <= entries ) return - 1 ; if <S2SV_ModEnd> ( ( int <S2SV_ModStart> dim ) ) > entries ) return - 1 <S2SV_ModEnd> ; return r
",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13223,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z,736,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> uint32 ( int,0
1591,CWE-20,"CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> return MagickTrue ; }
","<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,737,"<S2SV_ModStart>, y, MagickMin <S2SV_ModEnd> ( 4,",0
1592,CWE-665,"CWE-665 static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } <S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INHDRERRORS ) ; drop : return - 1 ; }
","<S2SV_ModStart> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart> == 5 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> opt -> optlen
",torvalds@linux/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,CVE-2011-4087,https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,2013-06-08T13:05Z,738,<S2SV_ModStart> ; if ( ip_hdr <S2SV_ModEnd> ( skb ),0
1594,CWE-284,"CWE-284 static int a2dp_ctrl_receive ( struct a2dp_stream_common * common , void * buffer , int length ) { <S2SV_StartBug> int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""ack<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; if ( errno == EINTR ) { <S2SV_StartBug> ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""ack<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } else { skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } return ret ; }
","<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> length , MSG_NOSIGNAL ) <S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> length , MSG_NOSIGNAL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,739,<S2SV_ModStart> int ret ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> length ),0
1595,CWE-20,"CWE-20 void BezierOval ( double w , double h , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , w , - h * BzK , w * BzK , - h , - h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - w * BzK , - h , - w , - h * BzK , - w , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,740,<S2SV_ModStart> y3 ) { sendClean ( outputbuffer ) ;,0
1596,CWE-200,"CWE-200 static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { <S2SV_StartBug> int i ; <S2SV_EndBug> memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , ""prompt="" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""debug_file="" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , ""stdout"" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , ""stderr"" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , ""syslog"" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else { <S2SV_StartBug> struct stat st ; <S2SV_EndBug> FILE * file ; <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> if ( S_ISREG ( st . st_mode ) ) { <S2SV_StartBug> file = fopen ( filename , ""a"" ) ; <S2SV_EndBug> if ( file != NULL ) { cfg -> debug_file = file ; <S2SV_StartBug> } <S2SV_EndBug> } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , ""called."" ) ; D ( cfg -> debug_file , ""flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d"" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , ""argv[%d]=%s"" , i , argv [ i ] ) ; } D ( cfg -> debug_file , ""max_devices=%d"" , cfg -> max_devs ) ; D ( cfg -> debug_file , ""debug=%d"" , cfg -> debug ) ; D ( cfg -> debug_file , ""interactive=%d"" , cfg -> interactive ) ; D ( cfg -> debug_file , ""cue=%d"" , cfg -> cue ) ; D ( cfg -> debug_file , ""nodetect=%d"" , cfg -> nodetect ) ; D ( cfg -> debug_file , ""manual=%d"" , cfg -> manual ) ; D ( cfg -> debug_file , ""nouserok=%d"" , cfg -> nouserok ) ; D ( cfg -> debug_file , ""openasuser=%d"" , cfg -> openasuser ) ; D ( cfg -> debug_file , ""alwaysok=%d"" , cfg -> alwaysok ) ; D ( cfg -> debug_file , ""authfile=%s"" , cfg -> auth_file ? cfg -> auth_file : ""(null)"" ) ; D ( cfg -> debug_file , ""authpending_file=%s"" , cfg -> authpending_file ? cfg -> authpending_file : ""(null)"" ) ; D ( cfg -> debug_file , ""origin=%s"" , cfg -> origin ? cfg -> origin : ""(null)"" ) ; D ( cfg -> debug_file , ""appid=%s"" , cfg -> appid ? cfg -> appid : ""(null)"" ) ; D ( cfg -> debug_file , ""prompt=%s"" , cfg -> prompt ? cfg -> prompt : ""(null)"" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> , & st <S2SV_ModStart> == 0 ) && <S2SV_ModEnd> S_ISREG ( st <S2SV_ModStart> { file = fdopen ( fd <S2SV_ModEnd> , ""a"" ) <S2SV_ModStart> = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> } } } <S2SV_ModStart> ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;
",Yubico@pam-u2f/18b1914e32b74ff52000f10e97067e841e5fff62,CVE-2019-12210,https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62,2019-06-04T21:29Z,741,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1599,CWE-20,"CWE-20 void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,742,"<S2SV_ModStart> y12 ; sprintf ( outputbuffer <S2SV_ModEnd>, outputbuffer )",0
1600,CWE-125,"CWE-125 static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }
","<S2SV_ModStart> , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1
",FreeRDP@FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65,CVE-2020-11047,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,2020-05-07T20:15Z,743,"<S2SV_ModStart>, rdp, NULL",0
1602,CWE-119,"CWE-119 static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; cpi -> tplist [ mb_row ] . start = * tp ; xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; xd -> mb_to_bottom_edge = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; x -> mb_activity_ptr = & cpi -> mb_activity_map [ map_index ] ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) * tp = cpi -> tok ; # endif xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; xd -> mb_to_right_edge = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; xd -> dst . y_buffer = cm -> yv12_fb [ dst_fb_idx ] . y_buffer + recon_yoffset ; xd -> dst . u_buffer = cm -> yv12_fb [ dst_fb_idx ] . u_buffer + recon_uvoffset ; xd -> dst . v_buffer = cm -> yv12_fb [ dst_fb_idx ] . v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; x -> rddiv = cpi -> RDDIV ; x -> rdmult = cpi -> RDMULT ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) { * current_mb_col = mb_col - 1 ; if ( ( mb_col & ( nsync - 1 ) ) == 0 ) { while ( mb_col > ( * last_row_current_mb_col - nsync ) ) { x86_pause_hint ( ) ; thread_sleep ( 0 ) ; } } } # endif if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) vp8_activity_masking ( cpi , x ) ; if ( xd -> segmentation_enabled ) { if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ; else xd -> mode_info_context -> mbmi . segment_id = 0 ; vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; } else xd -> mode_info_context -> mbmi . segment_id = 0 ; x -> active_ptr = cpi -> active_map + map_index + mb_col ; if ( cm -> frame_type == KEY_FRAME ) { * totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ; # ifdef MODE_STATS y_modes [ xd -> mbmi . mode ] ++ ; # endif } else { * totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ; # ifdef MODE_STATS inter_y_modes [ xd -> mbmi . mode ] ++ ; if ( xd -> mbmi . mode == SPLITMV ) { int b ; for ( b = 0 ; b < xd -> mbmi . partition_count ; b ++ ) { inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ; } } # endif <S2SV_StartBug> if ( ( cpi -> current_layer == 0 ) && <S2SV_EndBug> ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; <S2SV_StartBug> else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) <S2SV_EndBug> { if ( cpi -> cyclic_refresh_map [ map_index + mb_col ] == 1 ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = 0 ; } else cpi -> cyclic_refresh_map [ map_index + mb_col ] = 1 ; } } cpi -> tplist [ mb_row ] . stop = * tp ; # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { int tok_count = * tp - tp_start ; <S2SV_StartBug> pack_tokens ( w , tp_start , tok_count ) ; <S2SV_EndBug> } # endif x -> gf_active_ptr ++ ; x -> mb_activity_ptr ++ ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; segment_counts [ xd -> mode_info_context -> mbmi . segment_id ] ++ ; xd -> mode_info_context ++ ; x -> partition_info ++ ; xd -> above_context ++ ; } vp8_extend_mb_row ( & cm -> yv12_fb [ dst_fb_idx ] , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded != 0 ) * current_mb_col = rightmost_col ; # endif xd -> mode_info_context ++ ; x -> partition_info ++ ; }
","<S2SV_ModStart> endif if ( <S2SV_ModEnd> cpi -> current_layer <S2SV_ModStart> == 0 ) { if <S2SV_ModEnd> ( xd -> <S2SV_ModStart> mode == ZEROMV && <S2SV_ModEnd> xd -> mode_info_context <S2SV_ModStart> == LAST_FRAME ) { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <S2SV_ModStart> - tp_start ; vp8_pack_tokens <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,744,<S2SV_ModStart> ) ) { memcpy <S2SV_ModEnd> ( cpi ->,0
1603,CWE-000,"CWE-000 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_add_pvc()\\n"" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ; <S2SV_StartBug> else <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }
","<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z,745,<S2SV_ModStart> ; if ( <S2SV_ModEnd> dev -> priv_flags &,0
1604,CWE-119,"CWE-119 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , ""cliprdr_process(),<S2SV_blank>type=%d,<S2SV_blank>status=%d,<S2SV_blank>length=%d"" , type , status , length ) ; <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>error<S2SV_blank>(type=%d)"" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>%d"" , type ) ; } }
","<S2SV_ModStart> * data ; struct stream packet = * s ; <S2SV_ModStart> ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } if (
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z,746,"<S2SV_ModStart> * data ; struct stream packet = * s ; <S2SV_ModStart> ; if (! s_check_rem ( s, length ) ) { if (",0
1605,CWE-000,"CWE-000 int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }
","<S2SV_ModStart> # if CONFIG_MULTITHREAD <S2SV_ModEnd> vp8_decoder_remove_threads ( pbi
",external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z,747,,0
1607,CWE-119,"CWE-119 void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; configASSERT ( pxEnd ) ; vTaskSuspendAll ( ) ; { if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { <S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { <S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) { xMinimumEverFreeBytesRemaining = xFreeBytesRemaining ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } pxBlock -> xBlockSize |= xBlockAllocatedBit ; pxBlock -> pxNextFreeBlock = NULL ; xNumberOfSuccessfulAllocations ++ ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } traceMALLOC ( pvReturn , xWantedSize ) ; } ( void ) xTaskResumeAll ( ) ; # if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if ( pvReturn == NULL ) { extern void vApplicationMallocFailedHook ( void ) ; vApplicationMallocFailedHook ( ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } # endif return pvReturn ; }
","<S2SV_ModStart> { if ( ( <S2SV_ModStart> > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) <S2SV_ModStart> 0x00 ) { if ( ( xWantedSize + <S2SV_ModEnd> ( portBYTE_ALIGNMENT - <S2SV_ModStart> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> ; } if
",FreeRTOS@FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63,CVE-2021-32020,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63,2021-05-03T22:15Z,748,<S2SV_ModStart> } if ( (,0
1608,CWE-119,"CWE-119 <S2SV_StartBug> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }
","<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,749,"<S2SV_ModStart> tx_type, const tran_low_t <S2SV_ModEnd> * input,",1
1609,CWE-400,"CWE-400 static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break ; case 2 : asm ( ""stlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; case 3 : asm ( ""stlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,750,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",1
1611,CWE-787,"CWE-787 void process_bitmap_updates ( STREAM s ) { <S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }
","<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,751,"<S2SV_ModStart> uint16 size, sizeof ( s )",0
1615,CWE-000,"CWE-000 static int errorLogDirective ( MaState * state , cchar * key , cchar * value ) { MprTicks stamp ; char * option , * ovalue , * tok , * path ; ssize size ; int level , flags , backup ; if ( mprGetCmdlineLogging ( ) ) { mprLog ( ""info<S2SV_blank>appweb<S2SV_blank>config"" , 4 , ""Already<S2SV_blank>logging.<S2SV_blank>Ignoring<S2SV_blank>ErrorLog<S2SV_blank>directive"" ) ; return 0 ; } size = MAXINT ; stamp = 0 ; level = 0 ; backup = 0 ; path = 0 ; flags = 0 ; for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = mprJoinPath ( httpGetRouteVar ( state -> route , ""LOG_DIR"" ) , httpExpandRouteVars ( state -> route , option ) ) ; } else { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""size"" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , ""level"" ) ) { level = atoi ( ovalue ) ; } else if ( smatch ( option , ""backup"" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , ""anew"" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , ""stamp"" ) ) { stamp = httpGetTicks ( ovalue ) ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>ErrorLog<S2SV_blank>option<S2SV_blank>%s"" , option ) ; } } } if ( size < ( 10 * 1000 ) ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small.<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>10K"" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( path == 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Missing<S2SV_blank>filename"" ) ; return MPR_ERR_BAD_SYNTAX ; } mprSetLogBackup ( size , backup , flags ) ; if ( ! smatch ( path , ""stdout"" ) && ! smatch ( path , ""stderr"" ) ) { path = httpMakePath ( state -> route , state -> configDir , path ) ; } if ( mprStartLogging ( path , MPR_LOG_DETAILED ) < 0 ) { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Cannot<S2SV_blank>write<S2SV_blank>to<S2SV_blank>ErrorLog:<S2SV_blank>%s"" , path ) ; return MPR_ERR_BAD_SYNTAX ; } mprSetLogLevel ( level ) ; mprLogHeader ( ) ; if ( stamp ) { httpSetTimestamp ( stamp ) ; } return 0 ; }
","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,752,"<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option,",1
1616,CWE-119,"CWE-119 static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , <S2SV_StartBug> vp9_coeff_stats * coef_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <S2SV_EndBug> vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 0 ] , coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 1 ] ) ; } } } } }
","<S2SV_ModStart> vp9_coeff_stats * coef_branch_ct , <S2SV_ModEnd> vp9_coeff_probs_model * coef_probs <S2SV_ModStart> vp9_coeff_probs_model * coef_probs ) { vp9_coeff_count * coef_counts <S2SV_ModStart> = cpi -> td . rd_counts . <S2SV_ModEnd> coef_counts [ tx_size
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,753,"<S2SV_ModStart> cpi, vpx_writer <S2SV_ModEnd> * probs,",0
1617,CWE-255,"CWE-255 static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; <S2SV_StartBug> assert ( name ) ; <S2SV_EndBug> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? ""\\033%G"" : ""\\033%@"" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>term<S2SV_blank>processing<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>iutf8<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , enable_disable ( utf8 ) , name ) ; log_debug ( ""UTF-8<S2SV_blank>kbdmode<S2SV_blank>%sd<S2SV_blank>on<S2SV_blank>%s"" , enable_disable ( utf8 ) , name ) ; return 0 ; }
","<S2SV_ModStart> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" ,
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z,754,<S2SV_ModStart> r = 0 <S2SV_ModEnd> ; r =,0
1618,CWE-119,"CWE-119 <S2SV_StartBug> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> msleep ( 300 ) ; <S2SV_EndBug> obuf [ 0 ] = 0xe ; <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>DS3000/TS2020!"" ) ; return - EIO ; }
","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; msleep ( 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z,755,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
1620,CWE-119,"CWE-119 vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> * iface , const <S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return SAVE_STATUS
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,756,<S2SV_ModStart> <S2SV_null> <S2SV_null> static,0
1621,CWE-119,"CWE-119 static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , <S2SV_StartBug> int uv_block_size , <S2SV_EndBug> int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) { const int which_mv = 0 ; const MV mv = { mv_row , mv_col } ; const InterpKernel * const kernel = <S2SV_StartBug> vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; <S2SV_EndBug> enum mv_precision mv_precision_uv ; int uv_stride ; <S2SV_StartBug> if ( uv_block_size == 8 ) { <S2SV_EndBug> uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q4 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } <S2SV_StartBug> vp9_build_inter_predictor ( y_mb_ptr , stride , <S2SV_EndBug> & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ; vp9_build_inter_predictor ( u_mb_ptr , uv_stride , <S2SV_StartBug> & pred [ 256 ] , uv_block_size , <S2SV_EndBug> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; vp9_build_inter_predictor ( v_mb_ptr , uv_stride , <S2SV_StartBug> & pred [ 512 ] , uv_block_size , <S2SV_EndBug> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; }
","<S2SV_ModStart> stride , int uv_block_width , int uv_block_height <S2SV_ModEnd> , int mv_row <S2SV_ModStart> const kernel = vp9_filter_kernels [ <S2SV_ModEnd> xd -> mi <S2SV_ModStart> mbmi . interp_filter ] <S2SV_ModEnd> ; enum mv_precision <S2SV_ModStart> ; if ( uv_block_width <S2SV_ModEnd> == 8 ) <S2SV_ModStart> MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <S2SV_ModStart> 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv , <S2SV_ModStart> 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,757,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null,0
1622,CWE-120,"CWE-120 boolean parse_config_line ( origbuf ) char * origbuf ; { # if defined ( MICRO ) && ! defined ( NOCWD_ASSUMPTIONS ) static boolean ramdisk_specified = FALSE ; # endif # ifdef SYSCF int n , src = iflags . parse_config_file_src ; # endif char * bufp , buf [ 4 * BUFSZ ] ; uchar translate [ MAXPCHARS ] ; int len ; boolean retval = TRUE ; <S2SV_StartBug> mungspaces ( strcpy ( buf , origbuf ) ) ; <S2SV_EndBug> bufp = find_optparam ( buf ) ; if ( ! bufp ) { config_error_add ( ""Not<S2SV_blank>a<S2SV_blank>config<S2SV_blank>statement,<S2SV_blank>missing<S2SV_blank>\'=\'"" ) ; return FALSE ; } ++ bufp ; if ( * bufp == '<S2SV_blank>' ) ++ bufp ; if ( match_varname ( buf , ""OPTIONS"" , 4 ) ) { bufp = find_optparam ( origbuf ) ; ++ bufp ; if ( ! parseoptions ( bufp , TRUE , TRUE ) ) retval = FALSE ; } else if ( match_varname ( buf , ""AUTOPICKUP_EXCEPTION"" , 5 ) ) { add_autopickup_exception ( bufp ) ; } else if ( match_varname ( buf , ""BINDINGS"" , 4 ) ) { if ( ! parsebindings ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , ""AUTOCOMPLETE"" , 5 ) ) { parseautocomplete ( bufp , TRUE ) ; } else if ( match_varname ( buf , ""MSGTYPE"" , 7 ) ) { if ( ! msgtype_parse_add ( bufp ) ) retval = FALSE ; # ifdef NOCWD_ASSUMPTIONS } else if ( match_varname ( buf , ""HACKDIR"" , 4 ) ) { adjust_prefix ( bufp , HACKPREFIX ) ; } else if ( match_varname ( buf , ""LEVELDIR"" , 4 ) || match_varname ( buf , ""LEVELS"" , 4 ) ) { adjust_prefix ( bufp , LEVELPREFIX ) ; } else if ( match_varname ( buf , ""SAVEDIR"" , 4 ) ) { adjust_prefix ( bufp , SAVEPREFIX ) ; } else if ( match_varname ( buf , ""BONESDIR"" , 5 ) ) { adjust_prefix ( bufp , BONESPREFIX ) ; } else if ( match_varname ( buf , ""DATADIR"" , 4 ) ) { adjust_prefix ( bufp , DATAPREFIX ) ; } else if ( match_varname ( buf , ""SCOREDIR"" , 4 ) ) { adjust_prefix ( bufp , SCOREPREFIX ) ; } else if ( match_varname ( buf , ""LOCKDIR"" , 4 ) ) { adjust_prefix ( bufp , LOCKPREFIX ) ; } else if ( match_varname ( buf , ""CONFIGDIR"" , 4 ) ) { adjust_prefix ( bufp , CONFIGPREFIX ) ; } else if ( match_varname ( buf , ""TROUBLEDIR"" , 4 ) ) { adjust_prefix ( bufp , TROUBLEPREFIX ) ; # else # ifdef MICRO } else if ( match_varname ( buf , ""HACKDIR"" , 4 ) ) { ( void ) strncpy ( hackdir , bufp , PATHLEN - 1 ) ; # ifdef MFLOPPY } else if ( match_varname ( buf , ""RAMDISK"" , 3 ) ) { # ifndef AMIGA if ( strlen ( bufp ) >= PATHLEN ) bufp [ PATHLEN - 1 ] = '\\0' ; Strcpy ( levels , bufp ) ; ramdisk = ( strcmp ( permbones , levels ) != 0 ) ; ramdisk_specified = TRUE ; # endif # endif } else if ( match_varname ( buf , ""LEVELS"" , 4 ) ) { if ( strlen ( bufp ) >= PATHLEN ) bufp [ PATHLEN - 1 ] = '\\0' ; Strcpy ( permbones , bufp ) ; if ( ! ramdisk_specified || ! * levels ) Strcpy ( levels , bufp ) ; ramdisk = ( strcmp ( permbones , levels ) != 0 ) ; } else if ( match_varname ( buf , ""SAVE"" , 4 ) ) { # ifdef MFLOPPY extern int saveprompt ; # endif char * ptr ; if ( ( ptr = index ( bufp , ';' ) ) != 0 ) { * ptr = '\\0' ; # ifdef MFLOPPY if ( * ( ptr + 1 ) == 'n' || * ( ptr + 1 ) == 'N' ) { saveprompt = FALSE ; } # endif } # if defined ( SYSFLAGS ) && defined ( MFLOPPY ) else saveprompt = sysflags . asksavedisk ; # endif ( void ) strncpy ( SAVEP , bufp , SAVESIZE - 1 ) ; append_slash ( SAVEP ) ; # endif # endif } else if ( match_varname ( buf , ""NAME"" , 4 ) ) { ( void ) strncpy ( plname , bufp , PL_NSIZ - 1 ) ; } else if ( match_varname ( buf , ""ROLE"" , 4 ) || match_varname ( buf , ""CHARACTER"" , 4 ) ) { if ( ( len = str2role ( bufp ) ) >= 0 ) flags . initrole = len ; } else if ( match_varname ( buf , ""DOGNAME"" , 3 ) ) { ( void ) strncpy ( dogname , bufp , PL_PSIZ - 1 ) ; } else if ( match_varname ( buf , ""CATNAME"" , 3 ) ) { ( void ) strncpy ( catname , bufp , PL_PSIZ - 1 ) ; # ifdef SYSCF } else if ( src == SET_IN_SYS && match_varname ( buf , ""WIZARDS"" , 7 ) ) { if ( sysopt . wizards ) free ( ( genericptr_t ) sysopt . wizards ) ; sysopt . wizards = dupstr ( bufp ) ; if ( strlen ( sysopt . wizards ) && strcmp ( sysopt . wizards , ""*"" ) ) { if ( sysopt . fmtd_wizard_list ) free ( ( genericptr_t ) sysopt . fmtd_wizard_list ) ; sysopt . fmtd_wizard_list = build_english_list ( sysopt . wizards ) ; } } else if ( src == SET_IN_SYS && match_varname ( buf , ""SHELLERS"" , 8 ) ) { if ( sysopt . shellers ) free ( ( genericptr_t ) sysopt . shellers ) ; sysopt . shellers = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""EXPLORERS"" , 7 ) ) { if ( sysopt . explorers ) free ( ( genericptr_t ) sysopt . explorers ) ; sysopt . explorers = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""DEBUGFILES"" , 5 ) ) { if ( sysopt . env_dbgfl <= 0 ) { if ( sysopt . debugfiles ) free ( ( genericptr_t ) sysopt . debugfiles ) ; sysopt . debugfiles = dupstr ( bufp ) ; } } else if ( src == SET_IN_SYS && match_varname ( buf , ""DUMPLOGFILE"" , 7 ) ) { # ifdef DUMPLOG if ( sysopt . dumplogfile ) free ( ( genericptr_t ) sysopt . dumplogfile ) ; sysopt . dumplogfile = dupstr ( bufp ) ; # endif # ifdef WIN32 } else if ( src == SET_IN_SYS && match_varname ( buf , ""portable_device_top"" , 8 ) ) { if ( sysopt . portable_device_top ) free ( ( genericptr_t ) sysopt . portable_device_top ) ; sysopt . portable_device_top = dupstr ( bufp ) ; # endif } else if ( src == SET_IN_SYS && match_varname ( buf , ""GENERICUSERS"" , 12 ) ) { if ( sysopt . genericusers ) free ( ( genericptr_t ) sysopt . genericusers ) ; sysopt . genericusers = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""BONES_POOLS"" , 10 ) ) { n = atoi ( bufp ) ; sysopt . bones_pools = ( n <= 0 ) ? 0 : min ( n , 10 ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""SUPPORT"" , 7 ) ) { if ( sysopt . support ) free ( ( genericptr_t ) sysopt . support ) ; sysopt . support = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""RECOVER"" , 7 ) ) { if ( sysopt . recover ) free ( ( genericptr_t ) sysopt . recover ) ; sysopt . recover = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""CHECK_SAVE_UID"" , 14 ) ) { n = atoi ( bufp ) ; sysopt . check_save_uid = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""CHECK_PLNAME"" , 12 ) ) { n = atoi ( bufp ) ; sysopt . check_plname = n ; } else if ( match_varname ( buf , ""SEDUCE"" , 6 ) ) { n = ! ! atoi ( bufp ) ; if ( src != SET_IN_SYS && n != 0 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>SEDUCE"" ) ; return FALSE ; } sysopt . seduce = n ; sysopt_seduce_set ( sysopt . seduce ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""MAXPLAYERS"" , 10 ) ) { n = atoi ( bufp ) ; if ( n < 0 || n > 25 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>MAXPLAYERS<S2SV_blank>(maximum<S2SV_blank>is<S2SV_blank>25)."" ) ; return FALSE ; } sysopt . maxplayers = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PERSMAX"" , 7 ) ) { n = atoi ( bufp ) ; if ( n < 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PERSMAX<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . persmax = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PERS_IS_UID"" , 11 ) ) { n = atoi ( bufp ) ; if ( n != 0 && n != 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PERS_IS_UID<S2SV_blank>(must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . pers_is_uid = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""ENTRYMAX"" , 8 ) ) { n = atoi ( bufp ) ; if ( n < 10 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>ENTRYMAX<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>10)."" ) ; return FALSE ; } sysopt . entrymax = n ; } else if ( ( src == SET_IN_SYS ) && match_varname ( buf , ""POINTSMIN"" , 9 ) ) { n = atoi ( bufp ) ; if ( n < 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>POINTSMIN<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . pointsmin = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""MAX_STATUENAME_RANK"" , 10 ) ) { n = atoi ( bufp ) ; if ( n < 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>MAX_STATUENAME_RANK<S2SV_blank>(minimum<S2SV_blank>is<S2SV_blank>1)."" ) ; return FALSE ; } sysopt . tt_oname_maxrank = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PANICTRACE_LIBC"" , 15 ) ) { n = atoi ( bufp ) ; # if defined ( PANICTRACE ) && defined ( PANICTRACE_LIBC ) if ( n < 0 || n > 2 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PANICTRACE_LIBC<S2SV_blank>(not<S2SV_blank>0,1,2)."" ) ; return FALSE ; } # endif sysopt . panictrace_libc = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""PANICTRACE_GDB"" , 14 ) ) { n = atoi ( bufp ) ; # if defined ( PANICTRACE ) if ( n < 0 || n > 2 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>PANICTRACE_GDB<S2SV_blank>(not<S2SV_blank>0,1,2)."" ) ; return FALSE ; } # endif sysopt . panictrace_gdb = n ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""GDBPATH"" , 7 ) ) { # if defined ( PANICTRACE ) && ! defined ( VMS ) if ( ! file_exists ( bufp ) ) { config_error_add ( ""File<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>GDBPATH<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist."" ) ; return FALSE ; } # endif if ( sysopt . gdbpath ) free ( ( genericptr_t ) sysopt . gdbpath ) ; sysopt . gdbpath = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""GREPPATH"" , 7 ) ) { # if defined ( PANICTRACE ) && ! defined ( VMS ) if ( ! file_exists ( bufp ) ) { config_error_add ( ""File<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>GREPPATH<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist."" ) ; return FALSE ; } # endif if ( sysopt . greppath ) free ( ( genericptr_t ) sysopt . greppath ) ; sysopt . greppath = dupstr ( bufp ) ; } else if ( src == SET_IN_SYS && match_varname ( buf , ""ACCESSIBILITY"" , 13 ) ) { n = atoi ( bufp ) ; if ( n < 0 || n > 1 ) { config_error_add ( ""Illegal<S2SV_blank>value<S2SV_blank>in<S2SV_blank>ACCESSIBILITY<S2SV_blank>(not<S2SV_blank>0,1)."" ) ; return FALSE ; } sysopt . accessibility = n ; # endif } else if ( match_varname ( buf , ""BOULDER"" , 3 ) ) { ( void ) get_uchars ( bufp , & ov_primary_syms [ SYM_BOULDER + SYM_OFF_X ] , TRUE , 1 , ""BOULDER"" ) ; } else if ( match_varname ( buf , ""MENUCOLOR"" , 9 ) ) { if ( ! add_menu_coloring ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , ""HILITE_STATUS"" , 6 ) ) { # ifdef STATUS_HILITES if ( ! parse_status_hl1 ( bufp , TRUE ) ) retval = FALSE ; # endif } else if ( match_varname ( buf , ""WARNINGS"" , 5 ) ) { ( void ) get_uchars ( bufp , translate , FALSE , WARNCOUNT , ""WARNINGS"" ) ; assign_warnings ( translate ) ; } else if ( match_varname ( buf , ""ROGUESYMBOLS"" , 4 ) ) { if ( ! parsesymbols ( bufp , ROGUESET ) ) { config_error_add ( ""Error<S2SV_blank>in<S2SV_blank>ROGUESYMBOLS<S2SV_blank>definition<S2SV_blank>\'%s\'"" , bufp ) ; retval = FALSE ; } switch_symbols ( TRUE ) ; } else if ( match_varname ( buf , ""SYMBOLS"" , 4 ) ) { if ( ! parsesymbols ( bufp , PRIMARY ) ) { config_error_add ( ""Error<S2SV_blank>in<S2SV_blank>SYMBOLS<S2SV_blank>definition<S2SV_blank>\'%s\'"" , bufp ) ; retval = FALSE ; } switch_symbols ( TRUE ) ; } else if ( match_varname ( buf , ""WIZKIT"" , 6 ) ) { ( void ) strncpy ( wizkit , bufp , WIZKIT_MAX - 1 ) ; # ifdef AMIGA } else if ( match_varname ( buf , ""FONT"" , 4 ) ) { char * t ; if ( t = strchr ( buf + 5 , ':' ) ) { * t = 0 ; amii_set_text_font ( buf + 5 , atoi ( t + 1 ) ) ; * t = ':' ; } } else if ( match_varname ( buf , ""PATH"" , 4 ) ) { ( void ) strncpy ( PATH , bufp , PATHLEN - 1 ) ; } else if ( match_varname ( buf , ""DEPTH"" , 5 ) ) { extern int amii_numcolors ; int val = atoi ( bufp ) ; amii_numcolors = 1L << min ( DEPTH , val ) ; # ifdef SYSFLAGS } else if ( match_varname ( buf , ""DRIPENS"" , 7 ) ) { int i , val ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; t != ( char * ) 0 ; i < 20 && ( t = strtok ( ( char * ) 0 , "",/"" ) ) , ++ i ) { sscanf ( t , ""%d"" , & val ) ; sysflags . amii_dripens [ i ] = val ; } # endif } else if ( match_varname ( buf , ""SCREENMODE"" , 10 ) ) { extern long amii_scrnmode ; if ( ! stricmp ( bufp , ""req"" ) ) amii_scrnmode = 0xffffffff ; else if ( sscanf ( bufp , ""%x"" , & amii_scrnmode ) != 1 ) amii_scrnmode = 0 ; } else if ( match_varname ( buf , ""MSGPENS"" , 7 ) ) { extern int amii_msgAPen , amii_msgBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_msgAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_msgBPen ) ; } } else if ( match_varname ( buf , ""TEXTPENS"" , 8 ) ) { extern int amii_textAPen , amii_textBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_textAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_textBPen ) ; } } else if ( match_varname ( buf , ""MENUPENS"" , 8 ) ) { extern int amii_menuAPen , amii_menuBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_menuAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_menuBPen ) ; } } else if ( match_varname ( buf , ""STATUSPENS"" , 10 ) ) { extern int amii_statAPen , amii_statBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_statAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_statBPen ) ; } } else if ( match_varname ( buf , ""OTHERPENS"" , 9 ) ) { extern int amii_otherAPen , amii_otherBPen ; char * t = strtok ( bufp , "",/"" ) ; if ( t ) { sscanf ( t , ""%d"" , & amii_otherAPen ) ; if ( t = strtok ( ( char * ) 0 , "",/"" ) ) sscanf ( t , ""%d"" , & amii_otherBPen ) ; } } else if ( match_varname ( buf , ""PENS"" , 4 ) ) { extern unsigned short amii_init_map [ AMII_MAXCOLORS ] ; int i ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; i < AMII_MAXCOLORS && t != ( char * ) 0 ; t = strtok ( ( char * ) 0 , "",/"" ) , ++ i ) { sscanf ( t , ""%hx"" , & amii_init_map [ i ] ) ; } amii_setpens ( amii_numcolors = i ) ; } else if ( match_varname ( buf , ""FGPENS"" , 6 ) ) { extern int foreg [ AMII_MAXCOLORS ] ; int i ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; i < AMII_MAXCOLORS && t != ( char * ) 0 ; t = strtok ( ( char * ) 0 , "",/"" ) , ++ i ) { sscanf ( t , ""%d"" , & foreg [ i ] ) ; } } else if ( match_varname ( buf , ""BGPENS"" , 6 ) ) { extern int backg [ AMII_MAXCOLORS ] ; int i ; char * t ; for ( i = 0 , t = strtok ( bufp , "",/"" ) ; i < AMII_MAXCOLORS && t != ( char * ) 0 ; t = strtok ( ( char * ) 0 , "",/"" ) , ++ i ) { sscanf ( t , ""%d"" , & backg [ i ] ) ; } # endif # ifdef USER_SOUNDS } else if ( match_varname ( buf , ""SOUNDDIR"" , 8 ) ) { sounddir = dupstr ( bufp ) ; } else if ( match_varname ( buf , ""SOUND"" , 5 ) ) { add_sound_mapping ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_TILEWIDTH"" , 12 ) ) { # ifdef QT_GRAPHICS extern char * qt_tilewidth ; if ( qt_tilewidth == NULL ) qt_tilewidth = dupstr ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_TILEHEIGHT"" , 13 ) ) { # ifdef QT_GRAPHICS extern char * qt_tileheight ; if ( qt_tileheight == NULL ) qt_tileheight = dupstr ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_FONTSIZE"" , 11 ) ) { # ifdef QT_GRAPHICS extern char * qt_fontsize ; if ( qt_fontsize == NULL ) qt_fontsize = dupstr ( bufp ) ; # endif } else if ( match_varname ( buf , ""QT_COMPACT"" , 10 ) ) { # ifdef QT_GRAPHICS extern int qt_compact_mode ; qt_compact_mode = atoi ( bufp ) ; # endif } else { config_error_add ( ""Unknown<S2SV_blank>config<S2SV_blank>statement"" ) ; return FALSE ; } return retval ; }
","<S2SV_ModStart> = TRUE ; while ( * origbuf == '<S2SV_blank>' || * origbuf == '\\t' ) ++ origbuf ; ( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ; buf [ sizeof buf - 1 ] = '\\0' ; mungspaces ( buf <S2SV_ModEnd> ) ; bufp
",NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z,758,"<S2SV_ModStart> buf, buf <S2SV_ModEnd> ) ; if",0
1623,CWE-119,"CWE-119 <S2SV_StartBug> cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) <S2SV_EndBug> { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateFloat ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
","<S2SV_ModStart> * cJSON_CreateFloatArray ( const float <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,759,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
1624,CWE-400,"CWE-400 static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( ""lockd:<S2SV_blank>unlock<S2SV_blank>failed<S2SV_blank>(err<S2SV_blank>=<S2SV_blank>%d)\\n"" , - task -> tk_status ) ; <S2SV_StartBug> goto retry_rebind ; <S2SV_EndBug> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING ""lockd:<S2SV_blank>unexpected<S2SV_blank>unlock<S2SV_blank>status:<S2SV_blank>%d\\n"" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }
","<S2SV_ModStart> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> goto retry_rebind ; }
",torvalds@linux/0b760113a3a155269a3fba93a409c640031dd68f,CVE-2011-2491,https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f,2013-03-01T12:37Z,760,<S2SV_ModStart> break ; } if ( task -> tk_status == NULL ) goto error ;,0
1626,CWE-119,"CWE-119 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
","<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0
",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13217,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z,761,"<S2SV_ModStart>, n ) ; if ( w == NULL ) return 0",1
1627,CWE-787,"CWE-787 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z,762,,0
1628,CWE-119,"CWE-119 static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; <S2SV_StartBug> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; <S2SV_EndBug> <S2SV_StartBug> TileBuffer tile_buffers [ 1 << 6 ] ; <S2SV_EndBug> int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) { <S2SV_StartBug> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; <S2SV_EndBug> int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers , <S2SV_StartBug> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; <S2SV_EndBug> for ( i = 0 ; i < num_threads ; ++ i ) { <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <S2SV_EndBug> ++ pbi -> num_tile_workers ; <S2SV_StartBug> vp9_worker_init ( worker ) ; <S2SV_EndBug> CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ; <S2SV_StartBug> if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) { <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } } for ( n = 0 ; n < num_workers ; ++ n ) { <S2SV_StartBug> pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ; <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ; <S2SV_StartBug> for ( n = 0 ; n < tile_cols ; ++ n ) { <S2SV_EndBug> const size_t size = <S2SV_StartBug> get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ; <S2SV_EndBug> TileBuffer * const buf = & tile_buffers [ n ] ; buf -> data = data ; buf -> size = size ; buf -> col = n ; data += size ; } qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ; tile_buffers [ group_end ] = largest ; group_start = group_end + 1 ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VP9Worker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ n ] ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader ) ; init_macroblockd ( cm , & tile_data -> xd ) ; vp9_zero ( tile_data -> xd . dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || n == tile_cols - 1 ) { vp9_worker_execute ( worker ) ; } else { <S2SV_StartBug> vp9_worker_launch ( worker ) ; <S2SV_EndBug> } if ( buf -> col == tile_cols - 1 ) { final_worker = i ; } ++ n ; } for ( ; i > 0 ; -- i ) { <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ; <S2SV_EndBug> } if ( final_worker > - 1 ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ final_worker ] . data1 ; <S2SV_StartBug> bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ; <S2SV_EndBug> <S2SV_StartBug> final_worker = - 1 ; <S2SV_EndBug> } } return bit_reader_end ; }
","<S2SV_ModStart> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> ( pbi -> <S2SV_ModEnd> max_threads & ~ <S2SV_ModStart> tile_buffers [ 1 ] [ 1 <S2SV_ModStart> = pbi -> <S2SV_ModEnd> max_threads & ~ <S2SV_ModStart> pbi -> tile_workers ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <S2SV_ModStart> i ) { VPxWorker <S2SV_ModEnd> * const worker <S2SV_ModStart> -> num_tile_workers ; winterface -> init ( worker <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 && ! winterface -> reset <S2SV_ModEnd> ( worker ) <S2SV_ModStart> n ) { VPxWorker * const worker = & <S2SV_ModStart> [ n ] ; winterface -> sync ( worker ) ; worker -> <S2SV_ModEnd> hook = ( <S2SV_ModStart> hook = ( VPxWorkerHook <S2SV_ModEnd> ) tile_worker_hook ; <S2SV_ModStart> ) tile_worker_hook ; worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> aligned_mi_cols ) ; memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> aligned_mi_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <S2SV_ModEnd> n == tile_cols <S2SV_ModStart> tile_cols - 1 ) { winterface -> execute <S2SV_ModEnd> ( worker ) <S2SV_ModStart> } else { winterface -> launch <S2SV_ModEnd> ( worker ) <S2SV_ModStart> i ) { VPxWorker <S2SV_ModEnd> * const worker <S2SV_ModStart> corrupted |= ! winterface -> sync <S2SV_ModEnd> ( worker ) <S2SV_ModStart> ; bit_reader_end = vpx_reader_find_end <S2SV_ModEnd> ( & tile_data <S2SV_ModStart> - 1 ; } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,763,<S2SV_ModStart> <S2SV_null> <S2SV_null,0
1629,CWE-835,"CWE-835 void CLASS parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , SEEK_SET ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'M' || fgetc ( ifp ) - 'R' ) return ; order = fgetc ( ifp ) * 0x101 ; <S2SV_StartBug> offset = base + get4 ( ) + 8 ; <S2SV_EndBug> while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ; <S2SV_StartBug> switch ( tag ) <S2SV_EndBug> { case 0x505244 : fseek ( ifp , 8 , SEEK_CUR ) ; high = get2 ( ) ; wide = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . makernotes . sony . prd_ImageHeight = get2 ( ) ; imgdata . makernotes . sony . prd_ImageWidth = get2 ( ) ; fseek ( ifp , 1L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_RawBitDepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_StorageMethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_BayerPattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef LIBRAW_LIBRARY_BUILD case 0x524946 : if ( ! strncasecmp ( model , ""DSLR-A100"" , 9 ) ) { fseek ( ifp , 8 , SEEK_CUR ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 2 ] = get2 ( ) ; get4 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 2 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Daylight ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Flash ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Cloudy ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_Shade ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_D ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_N ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_W ] [ 3 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 1 ] = imgdata . color . WB_Coeffs [ LIBRAW_WBI_FL_WW ] [ 3 ] = 0x100 ; } break ; # endif case 0x574247 : get4 ( ) ; i = strcmp ( model , ""DiMAGE<S2SV_blank>A200"" ) ? 0 : 3 ; FORC4 cam_mul [ c ^ ( c >> 1 ) ^ i ] = get2 ( ) ; break ; case 0x545457 : parse_tiff ( ftell ( ifp ) ) ; data_offset = offset ; } fseek ( ifp , save + len + 8 , SEEK_SET ) ; } raw_height = high ; raw_width = wide ; order = sorder ; }
","<S2SV_ModStart> + 8 ; # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <S2SV_ModStart> ( ) ; if ( len < 0 ) return ;
",LibRaw@LibRaw/e47384546b43d0fd536e933249047bc397a4d88b,CVE-2018-5813,https://github.com/LibRaw/LibRaw/commit/e47384546b43d0fd536e933249047bc397a4d88b,2018-12-07T22:29Z,764,<S2SV_ModStart> ; if ( len < 1 ) return 0,0
1631,CWE-119,"CWE-119 void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ; <S2SV_StartBug> struct segmentation * seg = & cm -> seg ; <S2SV_EndBug> const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int qindex_delta , segment_rdmult ; <S2SV_EndBug> <S2SV_StartBug> if ( Q_RATIO ( i ) == 1 ) { <S2SV_EndBug> RDMULT_RATIO ( i ) = 1 ; continue ; } <S2SV_StartBug> qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; <S2SV_EndBug> <S2SV_StartBug> segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + <S2SV_EndBug> cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }
","<S2SV_ModStart> cm -> seg <S2SV_ModEnd> ; int i <S2SV_ModStart> = SEGMENT_DELTADATA ; vpx_clear_system_state <S2SV_ModEnd> ( ) ; <S2SV_ModStart> ( i = 0 ; i < MAX_SEGMENTS ; ++ i <S2SV_ModEnd> ) { int <S2SV_ModStart> { int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <S2SV_ModEnd> continue ; } <S2SV_ModStart> continue ; } <S2SV_ModEnd> vp9_set_segdata ( seg <S2SV_ModStart> ( seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q , <S2SV_ModStart> ( seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q ) <S2SV_ModStart> SEG_LVL_ALT_Q ) ; <S2SV_ModEnd> } } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,765,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1634,CWE-119,"CWE-119 static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) <S2SV_StartBug> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <S2SV_EndBug> return error -> error_code ; }
","<S2SV_ModStart> -> error_code ) set_error_detail ( ctx , <S2SV_ModEnd> error -> has_detail <S2SV_ModStart> detail : NULL )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,766,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
1636,CWE-399,"CWE-399 static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( ""Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( ""Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel"" , regs , 0 ) ; return - 1 ; } }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,767,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",1
1639,CWE-20,"CWE-20 void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; <S2SV_StartBug> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <S2SV_EndBug> ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec -> ps_dec_err_status -> u1_err_flag = ACCEPT_ALL_PICS ; ps_dec -> ps_dec_err_status -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; ps_dec -> ps_dec_err_status -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; ps_dec -> ps_dec_err_status -> u4_cur_frm = INIT_FRAME ; ps_dec -> ps_dec_err_status -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; ps_dec -> u1_pr_sl_type = 0xFF ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_prev_poc = & ps_dec -> s_prev_pic_poc ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb = 0 ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_top_field_order_count = ps_cur_poc -> i4_top_field_order_count = 0 ; ps_prev_poc -> i4_bottom_field_order_count = ps_cur_poc -> i4_bottom_field_order_count = 0 ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst = 0 ; ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = 0 ; ps_dec -> i4_max_poc = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> u1_recon_mb_grp = 4 ; ps_dec -> u1_second_field = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; ps_dec -> u2_crop_offset_y = 0 ; ps_dec -> u2_crop_offset_uv = 0 ; ps_dec -> i4_vui_frame_rate = - 1 ; ps_dec -> i4_pic_type = - 1 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u1_res_changed = 0 ; ps_dec -> u1_frame_decoded_flag = 0 ; ps_dec -> u4_skip_frm_mask = SKIP_NONE ; ps_dec -> pf_cavlc_4x4res_block [ 0 ] = ih264d_cavlc_4x4res_block_totalcoeff_1 ; ps_dec -> pf_cavlc_4x4res_block [ 1 ] = ih264d_cavlc_4x4res_block_totalcoeff_2to10 ; ps_dec -> pf_cavlc_4x4res_block [ 2 ] = ih264d_cavlc_4x4res_block_totalcoeff_11to16 ; ps_dec -> pf_cavlc_parse4x4coeff [ 0 ] = ih264d_cavlc_parse4x4coeff_n0to7 ; ps_dec -> pf_cavlc_parse4x4coeff [ 1 ] = ih264d_cavlc_parse4x4coeff_n8 ; ps_dec -> pf_cavlc_parse_8x8block [ 0 ] = ih264d_cavlc_parse_8x8block_none_available ; ps_dec -> pf_cavlc_parse_8x8block [ 1 ] = ih264d_cavlc_parse_8x8block_left_available ; ps_dec -> pf_cavlc_parse_8x8block [ 2 ] = ih264d_cavlc_parse_8x8block_top_available ; ps_dec -> pf_cavlc_parse_8x8block [ 3 ] = ih264d_cavlc_parse_8x8block_both_available ; ps_dec -> pf_fill_bs1 [ 0 ] [ 0 ] = ih264d_fill_bs1_16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 0 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 0 ] = ih264d_fill_bs1_16x16mb_bslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_bslice ; ps_dec -> pf_fill_bs_xtra_left_edge [ 0 ] = ih264d_fill_bs_xtra_left_edge_cur_frm ; ps_dec -> pf_fill_bs_xtra_left_edge [ 1 ] = ih264d_fill_bs_xtra_left_edge_cur_fld ; ih264d_init_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_dec -> u2_prv_frame_num = 0 ; ps_dec -> u1_top_bottom_decoded = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> s_cab_dec_env . cabac_table = gau4_ih264d_cabac_table ; ps_dec -> pu1_left_mv_ctxt_inc = ps_dec -> u1_left_mv_ctxt_inc_arr [ 0 ] ; ps_dec -> pi1_left_ref_idx_ctxt_inc = & ps_dec -> i1_left_ref_idx_ctx_inc_arr [ 0 ] [ 0 ] ; ps_dec -> pu1_left_yuv_dc_csbp = & ps_dec -> u1_yuv_dc_csbp_topmb ; ps_dec -> u1_flushfrm = 0 ; { ps_dec -> s_cab_dec_env . pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_bitstrm -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_cur_slice -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ( void * ) ps_dec ; } memset ( ps_dec -> disp_bufs , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( disp_buf_t ) ) ; memset ( ps_dec -> u4_disp_buf_mapping , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; memset ( ps_dec -> u4_disp_buf_to_be_freed , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; ih264d_init_arch ( ps_dec ) ; ih264d_init_function_ptr ( ps_dec ) ; ps_dec -> e_frm_out_mode = IVD_DISPLAY_FRAME_OUT ; ps_dec -> init_done = 1 ; }
","<S2SV_ModStart> , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )
",external@libavc/ecf6c7ce6d5a22d52160698aab44fc234c63291a,CVE-2016-3743,https://android.googlesource.com/platform/external/libavc/+/ecf6c7ce6d5a22d52160698aab44fc234c63291a,2016-07-11T01:59Z,768,,0
1640,CWE-000,"CWE-000 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; <S2SV_StartBug> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && <S2SV_EndBug> end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && <S2SV_StartBug> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
","<S2SV_ModStart> goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )
",torvalds@linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1,CVE-2018-18397,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,2018-12-12T10:29Z,769,,0
1642,CWE-284,"CWE-284 static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>packet."" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) { <S2SV_StartBug> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>driver:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( ""%s<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>reached."" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; buffer -> len = MIN ( btpan_cb . congest_packet_size , buffer -> len ) ; if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) { tETH_HDR hdr ; memcpy ( & hdr , packet , sizeof ( tETH_HDR ) ) ; buffer -> len -= sizeof ( tETH_HDR ) ; buffer -> offset += sizeof ( tETH_HDR ) ; if ( forward_bnep ( & hdr , buffer ) != FORWARD_CONGEST ) btpan_cb . congest_packet_size = 0 ; } else { BTIF_TRACE_WARNING ( ""%s<S2SV_blank>dropping<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d"" , __func__ , buffer -> len ) ; btpan_cb . congest_packet_size = 0 ; GKI_freebuf ( buffer ) ; } ufd . fd = fd ; ufd . events = POLLIN ; ufd . revents = 0 ; <S2SV_StartBug> if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) <S2SV_EndBug> break ; } btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; }
","<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> btpan_cb . congest_packet ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 0 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z,770,"<S2SV_ModStart> ; int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart>, 0 ) )",0
1645,CWE-190,"CWE-190 <S2SV_StartBug> static int getnum ( const char * * fmt , int df ) { <S2SV_EndBug> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; <S2SV_StartBug> do { <S2SV_EndBug> a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }
","<S2SV_ModStart> int getnum ( lua_State * L , <S2SV_ModStart> ; do { if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ;
",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z,771,<S2SV_ModStart> char * a <S2SV_ModEnd> ) { char,0
1646,CWE-125,"CWE-125 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; <S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug> markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }
","<S2SV_ModStart> , g -> allgc <S2SV_ModEnd> , g ->
",lua@lua/127e7a6c8942b362aa3c6627f44d660a4fb75312,CVE-2020-15889,https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312,2020-07-21T22:15Z,772,<S2SV_ModStart> g ) ; g -> gcstate = Ggc ;,0
1647,CWE-401,"CWE-401 static int af9005_identify_state ( struct usb_device * udev , struct dvb_usb_device_properties * props , struct dvb_usb_device_description * * desc , int * cold ) { int ret ; u8 reply , * buf ; buf = kmalloc ( FW_BULKOUT_SIZE + 2 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; ret = af9005_boot_packet ( udev , FW_CONFIG , & reply , buf , FW_BULKOUT_SIZE + 2 ) ; if ( ret ) goto err ; deb_info ( ""result<S2SV_blank>of<S2SV_blank>FW_CONFIG<S2SV_blank>in<S2SV_blank>identify<S2SV_blank>state<S2SV_blank>%d\\n"" , reply ) ; if ( reply == 0x01 ) * cold = 1 ; else if ( reply == 0x02 ) * cold = 0 ; else <S2SV_StartBug> return - EIO ; <S2SV_EndBug> deb_info ( ""Identify<S2SV_blank>state<S2SV_blank>cold<S2SV_blank>=<S2SV_blank>%d\\n"" , * cold ) ; err : kfree ( buf ) ; return ret ; }
","<S2SV_ModStart> 0 ; else ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; if ( ! ret )
",torvalds@linux/2289adbfa559050d2a38bcd9caac1c18b800e928,CVE-2019-18809,https://github.com/torvalds/linux/commit/2289adbfa559050d2a38bcd9caac1c18b800e928,2019-11-07T16:15Z,773,<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =,0
1648,CWE-295,"CWE-295 NOEXPORT char * pgsql_server ( CLI * c , SERVICE_OPTIONS * opt , const PHASE phase ) { uint8_t buffer [ 8 ] , ssl_ok [ 1 ] = { 'S' } ; <S2SV_StartBug> ( void ) opt ; <S2SV_EndBug> if ( phase != PROTOCOL_EARLY ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> memset ( buffer , 0 , sizeof buffer ) ; s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ; <S2SV_StartBug> if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ; <S2SV_EndBug> throw_exception ( c , 1 ) ; } <S2SV_StartBug> s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> 'S' } ; static const uint8_t gss_request [ 8 ] = { 0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 } ; static const uint8_t gss_response [ 62 ] = { 'E' , 0 , 0 , 0 , 61 , 'S' , 'E' , 'R' , 'R' , 'O' , 'R' , 0 , 'C' , 'X' , 'X' , '0' , '0' , '0' , 0 , 'M' , 'S' , 'S' , 'L' , '<S2SV_blank>' , 'e' , 'x' , 'p' , 'e' , 'c' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'u' , 't' , '<S2SV_blank>' , 'n' , 'o' , 't' , '<S2SV_blank>' , 'r' , 'e' , 'q' , 'u' , 'e' , 's' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'y' , '<S2SV_blank>' , 'c' , 'l' , 'i' , 'e' , 'n' , 't' , 0 , 0 } ; <S2SV_ModStart> ) return NULL ; s_log ( LOG_DEBUG , ""Started<S2SV_blank>server-side<S2SV_blank>psql<S2SV_blank>protcol<S2SV_blank>negotiation"" ) <S2SV_ModStart> ; if ( ! <S2SV_ModStart> ( buffer , gss_request , sizeof gss_request <S2SV_ModEnd> ) ) { <S2SV_ModStart> { s_log ( LOG_INFO , ""GSSAPI<S2SV_blank>encryption<S2SV_blank>requested,<S2SV_blank>rejecting<S2SV_blank>gracefully"" ) ; <S2SV_ModEnd> s_write ( c <S2SV_ModStart> . fd , gss_response , sizeof gss_response ) ; throw_exception ( c , 2 ) ; } if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_DEBUG , ""SSLRequest<S2SV_blank>received"" ) ; s_write ( c , c -> local_wfd . fd ,
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z,774,"<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( buffer, <S2SV_ModStart> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>",0
1649,CWE-399,"CWE-399 static int <S2SV_StartBug> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <S2SV_EndBug> { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ; <S2SV_StartBug> struct sockaddr_in addr ; <S2SV_EndBug> int rc = 0 ; <S2SV_StartBug> char * server = private -> server ; <S2SV_EndBug> int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks = <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> . dispatch = cib_remote_dispatch , <S2SV_EndBug> <S2SV_StartBug> . destroy = cib_remote_connection_destroy , <S2SV_EndBug> } ; connection -> socket = 0 ; connection -> session = NULL ; <S2SV_StartBug> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <S2SV_EndBug> if ( sock == - 1 ) { crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ; # else memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = inet_addr ( server ) ; # endif addr . sin_port = htons ( private -> port ) ; if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; close ( sock ) ; return - 1 ; } if ( connection -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H <S2SV_StartBug> gnutls_global_init ( ) ; <S2SV_EndBug> gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ; <S2SV_StartBug> connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ; <S2SV_EndBug> if ( connection -> session == NULL ) { crm_perror ( LOG_ERR , ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ; <S2SV_StartBug> close ( sock ) ; <S2SV_EndBug> cib_tls_close ( cib ) ; return - 1 ; } # else return - EPROTONOSUPPORT ; # endif } else { connection -> session = GUINT_TO_POINTER ( sock ) ; } login = create_xml_node ( NULL , ""cib_command"" ) ; crm_xml_add ( login , ""op"" , ""authenticate"" ) ; crm_xml_add ( login , ""user"" , private -> user ) ; crm_xml_add ( login , ""password"" , private -> passwd ) ; crm_xml_add ( login , ""hidden"" , ""password"" ) ; crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ; free_xml ( login ) ; <S2SV_StartBug> answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; <S2SV_EndBug> crm_log_xml_trace ( answer , ""Reply"" ) ; if ( answer == NULL ) { rc = - EPROTO ; } else { const char * msg_type = crm_element_value ( answer , F_CIB_OPERATION ) ; const char * tmp_ticket = crm_element_value ( answer , F_CIB_CLIENTID ) ; if ( safe_str_neq ( msg_type , CRM_OP_REGISTER ) ) { crm_err ( ""Invalid<S2SV_blank>registration<S2SV_blank>message:<S2SV_blank>%s"" , msg_type ) ; rc = - EPROTO ; } else if ( tmp_ticket == NULL ) { rc = - EPROTO ; } else { connection -> token = strdup ( tmp_ticket ) ; } } <S2SV_StartBug> if ( rc != 0 ) { <S2SV_EndBug> cib_tls_close ( cib ) ; <S2SV_StartBug> } <S2SV_EndBug> connection -> socket = sock ; connection -> source = mainloop_add_fd ( ""cib-remote"" , G_PRIORITY_HIGH , connection -> socket , cib , & cib_fd_callbacks ) ; return rc ; }
","<S2SV_ModStart> remote_connection_s * connection , gboolean event_channel <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> int rc = <S2SV_ModStart> = 0 ; int disconnected = 0 <S2SV_ModEnd> ; xmlNode * <S2SV_ModStart> mainloop_fd_callbacks cib_fd_callbacks = { 0 , } ; cib_fd_callbacks <S2SV_ModEnd> . dispatch = <S2SV_ModStart> . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <S2SV_ModEnd> . destroy = <S2SV_ModStart> destroy = cib_remote_connection_destroy <S2SV_ModEnd> ; connection -> <S2SV_ModStart> ; sock = crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ; } connection -> socket = sock ; <S2SV_ModEnd> if ( connection <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) { <S2SV_ModStart> anon_cred_c ) ; remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <S2SV_ModEnd> ( sock , <S2SV_ModStart> sock , GNUTLS_CLIENT , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> <S2SV_ModEnd> server , private <S2SV_ModStart> port ) ; gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <S2SV_ModEnd> ; cib_tls_close ( <S2SV_ModStart> login ) ; <S2SV_ModEnd> crm_recv_remote_msg ( connection <S2SV_ModStart> -> session , & connection -> recv_buf , <S2SV_ModStart> connection -> encrypted , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <S2SV_ModStart> ; } } free_xml ( answer ) ; answer = NULL ; <S2SV_ModStart> cib ) ; return rc ; } crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) <S2SV_ModEnd> ; connection ->
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,775,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1650,CWE-119,"CWE-119 struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ; <S2SV_StartBug> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <S2SV_EndBug> if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ; <S2SV_StartBug> cpi -> kf_overspend_bits = 0 ; <S2SV_EndBug> cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; cpi -> twopass . gf_decay_rate = 0 ; cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; cpi -> gold_is_last = 0 ; cpi -> alt_is_last = 0 ; cpi -> gold_is_alt = 0 ; cpi -> active_map_enabled = 0 ; # if 0 if ( cpi -> pass == 0 ) { cpi -> one_pass_frame_index = 0 ; for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) { cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; } } # endif <S2SV_StartBug> cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ; <S2SV_EndBug> cpi -> cyclic_refresh_mode_index = 0 ; cpi -> cyclic_refresh_q = 32 ; if ( cpi -> cyclic_refresh_mode_enabled ) { CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; } else cpi -> cyclic_refresh_map = ( signed char * ) NULL ; <S2SV_StartBug> # ifdef VP8_ENTROPY_STATS <S2SV_EndBug> init_context_counters ( ) ; # endif cpi -> activity_avg = 90 << 12 ; cpi -> frames_since_key = 8 ; cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; cpi -> this_key_frame_forced = 0 ; cpi -> next_key_frame_forced = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 0 ; cpi -> common . refresh_alt_ref_frame = 0 ; <S2SV_StartBug> cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ; <S2SV_EndBug> # if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ; cpi -> count = 0 ; cpi -> bytes = 0 ; if ( cpi -> b_calculate_psnr ) { cpi -> total_sq_error = 0.0 ; cpi -> total_sq_error2 = 0.0 ; cpi -> total_y = 0.0 ; cpi -> total_u = 0.0 ; cpi -> total_v = 0.0 ; cpi -> total = 0.0 ; cpi -> totalp_y = 0.0 ; cpi -> totalp_u = 0.0 ; cpi -> totalp_v = 0.0 ; cpi -> totalp = 0.0 ; cpi -> tot_recode_hits = 0 ; cpi -> summed_quality = 0 ; cpi -> summed_weights = 0 ; } if ( cpi -> b_calculate_ssimg ) { cpi -> total_ssimg_y = 0 ; cpi -> total_ssimg_u = 0 ; cpi -> total_ssimg_v = 0 ; cpi -> total_ssimg_all = 0 ; } # endif cpi -> first_time_stamp_ever = 0x7FFFFFFF ; cpi -> frames_till_gf_update_due = 0 ; cpi -> key_frame_count = 1 ; cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; cpi -> ni_tot_qi = 0 ; cpi -> ni_frames = 0 ; cpi -> total_byte_count = 0 ; cpi -> drop_frame = 0 ; cpi -> rate_correction_factor = 1.0 ; cpi -> key_frame_rate_correction_factor = 1.0 ; cpi -> gf_rate_correction_factor = 1.0 ; cpi -> twopass . est_max_qcorrection_factor = 1.0 ; for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) { cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; } # ifdef OUTPUT_YUV_SRC yuv_file = fopen ( ""bd.yuv"" , ""ab"" ) ; # endif <S2SV_StartBug> # if 0 <S2SV_EndBug> framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ; kf_list = fopen ( ""kf_list.stt"" , ""w"" ) ; # endif cpi -> output_pkt_list = oxcf -> output_pkt_list ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) { vp8_init_first_pass ( cpi ) ; } else if ( cpi -> pass == 2 ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in + ( packets - 1 ) * packet_sz ) ; vp8_init_second_pass ( cpi ) ; } # endif if ( cpi -> compressor_speed == 2 ) { cpi -> avg_encode_time = 0 ; cpi -> avg_pick_mode_time = 0 ; } vp8_set_speed_features ( cpi ) ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; } # ifdef VP8_ENTROPY_STATS init_mv_ref_counts ( ) ; # endif # if CONFIG_MULTITHREAD if ( vp8cx_create_encoder_threads ( cpi ) ) { vp8_remove_compressor ( & cpi ) ; return 0 ; } # endif <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ; <S2SV_EndBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ; <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ; <S2SV_EndBug> # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; # endif cpi -> full_search_sad = vp8_full_search_sad ; cpi -> diamond_search_sad = vp8_diamond_search_sad ; cpi -> refining_search_sad = vp8_refining_search_sad ; cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; vp8cx_init_quantizer ( cpi ) ; vp8_loop_filter_init ( cm ) ; cpi -> common . error . setjmp = 0 ; # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id > 0 ) vp8_cal_low_res_mb_cols ( cpi ) ; # endif cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; vp8_setup_block_ptrs ( & cpi -> mb ) ; vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; return cpi ; }
","<S2SV_ModStart> -> common ; memset <S2SV_ModEnd> ( cpi , <S2SV_ModStart> ; cpi -> temporal_layer_id = - 1 ; cpi -> <S2SV_ModStart> endif cpi -> mse_source_denoised = 0 ; cpi -> <S2SV_ModStart> / 5 ; if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <S2SV_ModStart> ) NULL ; CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <S2SV_ModStart> ; cpi -> force_maxqp = 0 ; cpi -> <S2SV_ModStart> # endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( ""denoised.yuv"" , ""ab"" ) ; # endif # <S2SV_ModStart> . sdf = vpx_sad16x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance16x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance16x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf_halfpix_h = vpx_variance_halfpixvar16x16_h <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf_halfpix_v = vpx_variance_halfpixvar16x16_v <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad16x16x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad16x16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad16x16x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad16x8x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad16x8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad16x8x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad8x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance8x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance8x16 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad8x16x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad8x16x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad8x16x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad8x8x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad8x8x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad8x8x4d <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdf = vpx_sad4x4 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . vf = vpx_variance4x4 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . svf = vpx_sub_pixel_variance4x4 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx3f = vpx_sad4x4x3 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx8f = vpx_sad4x4x8 <S2SV_ModEnd> ; cpi -> <S2SV_ModStart> . sdx4df = vpx_sad4x4x4d <S2SV_ModEnd> ; # if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,776,<S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->,0
1652,CWE-399,"CWE-399 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z,777,"<S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address <S2SV_ModStart>, 1, <S2SV_ModEnd> regs, address",0
1653,CWE-125,"CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]"" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } else ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , mldv2_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,778,<S2SV_ModStart> i ; } if ( len < 4 ) goto trunc ;,0
1655,CWE-835,"CWE-835 static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ; <S2SV_StartBug> while ( ( c != '\\n' ) && ( c != '\\0' ) ) <S2SV_EndBug> { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ; <S2SV_StartBug> ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , <S2SV_EndBug> & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , <S2SV_StartBug> & white_point [ 0 ] , & white_point [ 1 ] ) ; <S2SV_EndBug> image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ; <S2SV_StartBug> break ; <S2SV_EndBug> } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } case 'Y' : case 'y' : { char target [ ] = ""Y"" ; if ( strcmp ( keyword , target ) == 0 ) { int height , width ; <S2SV_StartBug> ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; <S2SV_EndBug> image -> columns = ( size_t ) width ; <S2SV_StartBug> image -> rows = ( size_t ) height ; <S2SV_EndBug> break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value , exception ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace , exception ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace , exception ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( image , 0 , q ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> != '\\0' ) && ( c != EOF ) <S2SV_ModStart> 2 ] ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> 1 ] ) == 8 ) { <S2SV_ModEnd> image -> chromaticity <S2SV_ModStart> 1 ] ; } <S2SV_ModStart> , width ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> & width ) == 2 ) { <S2SV_ModEnd> image -> columns <S2SV_ModStart> ) height ; }
",ImageMagick@ImageMagick/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6,CVE-2015-8900,https://github.com/ImageMagick/ImageMagick/commit/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6,2017-02-27T22:59Z,779,"<S2SV_ModStart> ) ; } status = SetImageExtent ( image, image -> columns, image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception, & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }",0
1656,CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_mpt_command ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_command karg ; <S2SV_EndBug> MPT_ADAPTER * ioc ; int iocnum ; int rc ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_mpt_command<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_command<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } <S2SV_StartBug> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <S2SV_EndBug> return rc ; }
","<S2SV_ModStart> int mptctl_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_command karg <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> rc = mptctl_do_mpt_command <S2SV_ModStart> = mptctl_do_mpt_command ( ioc ,
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z,780,"<S2SV_ModStart> int mptctl_init ( MPT_ADAPTER * ioc, <S2SV_ModStart> return MPT_ADAPTER * ioc, <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctl ;",0
1657,CWE-834,"CWE-834 static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image <S2SV_StartBug> * image ; <S2SV_EndBug> MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , <S2SV_StartBug> padding , <S2SV_EndBug> value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { value = XBMInteger ( image , hex_digits ) ; <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> length , padding <S2SV_ModEnd> , version , <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> hex_digits ) ; if ( c < 0 ) break ; <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
",ImageMagick@ImageMagick/b8c63b156bf26b52e710b1a0643c846a6cd01e56,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/b8c63b156bf26b52e710b1a0643c846a6cd01e56,2017-09-07T06:29Z,781,"<S2SV_ModStart>, size_t length, <S2SV_ModEnd> buffer ) ; image",0
1658,CWE-190,"CWE-190 static int jpc_enc_encodemainhdr ( jpc_enc_t * enc ) { jpc_siz_t * siz ; jpc_cod_t * cod ; jpc_qcd_t * qcd ; int i ; long startoff ; long mainhdrlen ; jpc_enc_cp_t * cp ; jpc_qcc_t * qcc ; jpc_enc_tccp_t * tccp ; uint_fast16_t cmptno ; jpc_tsfb_band_t bandinfos [ JPC_MAXBANDS ] ; jpc_fix_t mctsynweight ; jpc_enc_tcp_t * tcp ; jpc_tsfb_t * tsfb ; jpc_tsfb_band_t * bandinfo ; uint_fast16_t numbands ; uint_fast16_t bandno ; uint_fast16_t rlvlno ; uint_fast16_t analgain ; jpc_fix_t absstepsize ; char buf [ 1024 ] ; jpc_com_t * com ; cp = enc -> cp ; startoff = jas_stream_getrwcount ( enc -> out ) ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOC ) ) ) { return - 1 ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>SOC<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SIZ ) ) ) { return - 1 ; } siz = & enc -> mrk -> parms . siz ; siz -> caps = 0 ; siz -> xoff = cp -> imgareatlx ; siz -> yoff = cp -> imgareatly ; siz -> width = cp -> refgrdwidth ; siz -> height = cp -> refgrdheight ; siz -> tilexoff = cp -> tilegrdoffx ; siz -> tileyoff = cp -> tilegrdoffy ; siz -> tilewidth = cp -> tilewidth ; siz -> tileheight = cp -> tileheight ; siz -> numcomps = cp -> numcmpts ; siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ; assert ( siz -> comps ) ; for ( i = 0 ; i < JAS_CAST ( int , cp -> numcmpts ) ; ++ i ) { siz -> comps [ i ] . prec = cp -> ccps [ i ] . prec ; siz -> comps [ i ] . sgnd = cp -> ccps [ i ] . sgnd ; siz -> comps [ i ] . hsamp = cp -> ccps [ i ] . sampgrdstepx ; siz -> comps [ i ] . vsamp = cp -> ccps [ i ] . sampgrdstepy ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>SIZ<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_COM ) ) ) { return - 1 ; } sprintf ( buf , ""Creator:<S2SV_blank>JasPer<S2SV_blank>Version<S2SV_blank>%s"" , jas_getversion ( ) ) ; com = & enc -> mrk -> parms . com ; com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ; com -> regid = JPC_COM_LATIN ; <S2SV_StartBug> if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) { <S2SV_EndBug> abort ( ) ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>COM<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; # if 0 if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_CRG ) ) ) { return - 1 ; } crg = & enc -> mrk -> parms . crg ; crg -> comps = jas_alloc2 ( crg -> numcomps , sizeof ( jpc_crgcomp_t ) ) ; if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>CRG<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; # endif tcp = & cp -> tcp ; tccp = & cp -> tccp ; for ( cmptno = 0 ; cmptno < cp -> numcmpts ; ++ cmptno ) { tsfb = jpc_cod_gettsfb ( tccp -> qmfbid , tccp -> maxrlvls - 1 ) ; jpc_tsfb_getbands ( tsfb , 0 , 0 , 1 << tccp -> maxrlvls , 1 << tccp -> maxrlvls , bandinfos ) ; jpc_tsfb_destroy ( tsfb ) ; mctsynweight = jpc_mct_getsynweight ( tcp -> mctid , cmptno ) ; numbands = 3 * tccp -> maxrlvls - 2 ; for ( bandno = 0 , bandinfo = bandinfos ; bandno < numbands ; ++ bandno , ++ bandinfo ) { rlvlno = ( bandno ) ? ( ( bandno - 1 ) / 3 + 1 ) : 0 ; analgain = JPC_NOMINALGAIN ( tccp -> qmfbid , tccp -> maxrlvls , rlvlno , bandinfo -> orient ) ; if ( ! tcp -> intmode ) { absstepsize = jpc_fix_div ( jpc_inttofix ( 1 << ( analgain + 1 ) ) , bandinfo -> synenergywt ) ; } else { absstepsize = jpc_inttofix ( 1 ) ; } cp -> ccps [ cmptno ] . stepsizes [ bandno ] = jpc_abstorelstepsize ( absstepsize , cp -> ccps [ cmptno ] . prec + analgain ) ; } cp -> ccps [ cmptno ] . numstepsizes = numbands ; } if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_COD ) ) ) { return - 1 ; } cod = & enc -> mrk -> parms . cod ; cod -> csty = cp -> tccp . csty | cp -> tcp . csty ; cod -> compparms . csty = cp -> tccp . csty | cp -> tcp . csty ; cod -> compparms . numdlvls = cp -> tccp . maxrlvls - 1 ; cod -> compparms . numrlvls = cp -> tccp . maxrlvls ; cod -> prg = cp -> tcp . prg ; cod -> numlyrs = cp -> tcp . numlyrs ; cod -> compparms . cblkwidthval = JPC_COX_CBLKSIZEEXPN ( cp -> tccp . cblkwidthexpn ) ; cod -> compparms . cblkheightval = JPC_COX_CBLKSIZEEXPN ( cp -> tccp . cblkheightexpn ) ; cod -> compparms . cblksty = cp -> tccp . cblksty ; cod -> compparms . qmfbid = cp -> tccp . qmfbid ; cod -> mctrans = ( cp -> tcp . mctid != JPC_MCT_NONE ) ; if ( tccp -> csty & JPC_COX_PRT ) { for ( rlvlno = 0 ; rlvlno < tccp -> maxrlvls ; ++ rlvlno ) { cod -> compparms . rlvls [ rlvlno ] . parwidthval = tccp -> prcwidthexpns [ rlvlno ] ; cod -> compparms . rlvls [ rlvlno ] . parheightval = tccp -> prcheightexpns [ rlvlno ] ; } } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannot<S2SV_blank>write<S2SV_blank>COD<S2SV_blank>marker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_QCD ) ) ) { return - 1 ; } qcd = & enc -> mrk -> parms . qcd ; qcd -> compparms . qntsty = ( tccp -> qmfbid == JPC_COX_INS ) ? JPC_QCX_SEQNT : JPC_QCX_NOQNT ; qcd -> compparms . numstepsizes = cp -> ccps [ 0 ] . numstepsizes ; qcd -> compparms . numguard = cp -> tccp . numgbits ; qcd -> compparms . stepsizes = cp -> ccps [ 0 ] . stepsizes ; if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { return - 1 ; } qcd -> compparms . stepsizes = 0 ; jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; tccp = & cp -> tccp ; for ( cmptno = 1 ; cmptno < cp -> numcmpts ; ++ cmptno ) { if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_QCC ) ) ) { return - 1 ; } qcc = & enc -> mrk -> parms . qcc ; qcc -> compno = cmptno ; qcc -> compparms . qntsty = ( tccp -> qmfbid == JPC_COX_INS ) ? JPC_QCX_SEQNT : JPC_QCX_NOQNT ; qcc -> compparms . numstepsizes = cp -> ccps [ cmptno ] . numstepsizes ; qcc -> compparms . numguard = cp -> tccp . numgbits ; qcc -> compparms . stepsizes = cp -> ccps [ cmptno ] . stepsizes ; if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { return - 1 ; } qcc -> compparms . stepsizes = 0 ; jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; } # define MAINTLRLEN 2 mainhdrlen = jas_stream_getrwcount ( enc -> out ) - startoff ; enc -> len += mainhdrlen ; if ( enc -> cp -> totalsize != UINT_FAST32_MAX ) { uint_fast32_t overhead ; overhead = mainhdrlen + MAINTLRLEN ; enc -> mainbodysize = ( enc -> cp -> totalsize >= overhead ) ? ( enc -> cp -> totalsize - overhead ) : 0 ; } else { enc -> mainbodysize = UINT_FAST32_MAX ; } return 0 ; }
","<S2SV_ModStart> = JAS_CAST ( jas_uchar <S2SV_ModEnd> * , jas_strdup
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z,782,,0
1659,CWE-120,"CWE-120 void irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( ""+"" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , '<S2SV_blank>' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == '<S2SV_blank>' ) pos_args ++ ; argv = weechat_string_split ( pos_args , ""<S2SV_blank>"" , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\\0' ; new_args [ 0 ] = '\\0' ; current_arg = 0 ; chanmode_found = 0 ; pos = str_modes ; while ( pos && pos [ 0 ] ) { if ( ( pos [ 0 ] == '+' ) || ( pos [ 0 ] == '-' ) ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; } else { ptr_arg = NULL ; switch ( irc_mode_get_chanmode_type ( server , pos [ 0 ] ) ) { case 'A' : case 'B' : case 'C' : ptr_arg = ( current_arg < argc ) ? argv [ current_arg ] : NULL ; break ; case 'D' : break ; } if ( ptr_arg ) current_arg ++ ; if ( pos [ 0 ] == chanmode ) { <S2SV_StartBug> chanmode_found = 1 ; <S2SV_EndBug> if ( set_flag == '+' ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( argument ) { if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , argument ) ; } } } <S2SV_StartBug> else <S2SV_EndBug> { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( ptr_arg ) { if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , ptr_arg ) ; } } } pos ++ ; } if ( ! chanmode_found ) { if ( set_flag == '+' ) { if ( argument ) { str_mode [ 0 ] = chanmode ; str_mode [ 1 ] = '\\0' ; strcat ( new_modes , str_mode ) ; if ( new_args [ 0 ] ) strcat ( new_args , ""<S2SV_blank>"" ) ; strcat ( new_args , argument ) ; } else { pos = new_modes ; while ( pos [ 0 ] == '+' ) pos ++ ; memmove ( pos + 1 , pos , strlen ( pos ) + 1 ) ; pos [ 0 ] = chanmode ; } } } if ( new_args [ 0 ] ) { length = strlen ( new_modes ) + 1 + strlen ( new_args ) + 1 ; str_temp = malloc ( length ) ; if ( str_temp ) { snprintf ( str_temp , length , ""%s<S2SV_blank>%s"" , new_modes , new_args ) ; if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = str_temp ; } } else { if ( channel -> modes ) free ( channel -> modes ) ; channel -> modes = strdup ( new_modes ) ; } } if ( new_modes ) free ( new_modes ) ; if ( new_args ) free ( new_args ) ; if ( str_modes ) free ( str_modes ) ; if ( argv ) weechat_string_free_split ( argv ) ; }
","<S2SV_ModStart> chanmode ) { if ( ! chanmode_found ) { <S2SV_ModStart> } } } }
",weechat@weechat/6f4f147d8e86adf9ad34a8ffd7e7f1f23a7e74da,CVE-2020-8955,https://github.com/weechat/weechat/commit/6f4f147d8e86adf9ad34a8ffd7e7f1f23a7e74da,2020-02-12T22:15Z,783,,0
1660,CWE-119,"CWE-119 <S2SV_StartBug> static int decode_uniform ( vp9_reader * r ) { <S2SV_EndBug> const int l = 8 ; const int m = ( 1 << l ) - 191 ; <S2SV_StartBug> const int v = vp9_read_literal ( r , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int decode_uniform ( vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> int v = vpx_read_literal <S2SV_ModEnd> ( r , <S2SV_ModStart> - m + vpx_read_bit <S2SV_ModEnd> ( r )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,784,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> vpx_read_literal <S2SV_ModEnd> ( r, <S2SV_ModStart> int r, vpx_read_literal <S2SV_ModEnd> ( r,",0
1662,CWE-119,"CWE-119 <S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }
","<S2SV_ModStart> costs , const vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_tree <S2SV_ModEnd> tree ) {
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,785,"<S2SV_ModStart> * probs, vpx_prob <S2SV_ModEnd> * probs,",0
1663,CWE-119,"CWE-119 static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode = <S2SV_StartBug> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }
","<S2SV_ModStart> * xd , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> ( REFERENCE_MODE ) vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> comp_inter_prob [ ctx <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> comp_inter [ ctx
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,786,"<S2SV_ModStart> * cm, vpx_reader <S2SV_ModEnd> * r )",0
1665,CWE-119,"CWE-119 static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; <S2SV_StartBug> if ( ! stream ) <S2SV_EndBug> <S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; <S2SV_EndBug> if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; <S2SV_StartBug> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; <S2SV_StartBug> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <S2SV_EndBug> <S2SV_StartBug> stream -> config . write_webm = 1 ; <S2SV_EndBug> # if CONFIG_WEBM_IO <S2SV_StartBug> stream -> ebml . last_pts_ms = - 1 ; <S2SV_EndBug> # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }
","<S2SV_ModStart> ; if ( stream == NULL ) { <S2SV_ModEnd> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; } <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <S2SV_ModStart> ; stream -> ebml . last_pts_ns <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,787,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1666,CWE-125,"CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>"" , tok2str ( icmp6_opt_values , ""unknown"" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , ""%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s"" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? ""badlen"" : """" , bittok2str ( icmp6_opt_pi_flag_values , ""none"" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s"" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u%s"" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? ""bad<S2SV_blank>option<S2SV_blank>length"" : """" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,"" , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>addr:<S2SV_blank>%s"" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):"" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%ums"" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u"" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%u"" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref=%s"" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lifetime=%s"" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ; <S2SV_EndBug> return ; # undef ECHECK }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,788,"<S2SV_ModStart> ndo, cp <S2SV_ModEnd> ) ; if",0
1667,CWE-674,"CWE-674 int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }
","<S2SV_ModStart> re_ast ) -> levels = 0 ; ( * re_ast ) ->
",VirusTotal@yara/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,CVE-2017-9304,https://github.com/VirusTotal/yara/commit/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,2017-05-31T04:29Z,789,,0
1669,CWE-20,"CWE-20 static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; <S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug> str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }
","<S2SV_ModStart> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> , & error <S2SV_ModStart> if ( ret > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> , error ) <S2SV_ModStart> 1 ; } <S2SV_ModEnd> else if (
",dovecot@core/000030feb7a30f193197f1aab8a7b04a26b42735,CVE-2017-2669,https://github.com/dovecot/core/commit/000030feb7a30f193197f1aab8a7b04a26b42735,2018-06-21T13:29Z,790,<S2SV_ModStart> return - 1 <S2SV_ModEnd> ; if (,0
1670,CWE-189,"CWE-189 static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ; <S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ; <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
","<S2SV_ModStart> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart> -> nla_len > <S2SV_ModEnd> skb -> len <S2SV_ModStart> skb -> len - A
",torvalds@linux/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,CVE-2014-3145,https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,2014-05-11T21:55Z,791,<S2SV_ModStart> ; if ( skb -> len < sizeof ( skb ) ) return 0 ; if (,0
1671,CWE-189,"CWE-189 static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . bits_per_pixel = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ; icon_file . directory [ i ] . offset = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } one = 1 ; for ( i = 0 ; i < icon_file . count ; i ++ ) { offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) icon_file . directory [ i ] . offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . size = ReadBlobLSBLong ( image ) ; icon_info . width = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) ) ; icon_info . height = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) / 2 ) ; icon_info . planes = ReadBlobLSBShort ( image ) ; icon_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( ( icon_info . planes == 18505 ) && ( icon_info . bits_per_pixel == 21060 ) ) || ( icon_info . size == 0x474e5089 ) ) { Image * icon_image ; ImageInfo * read_info ; size_t length ; unsigned char * png ; <S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug> png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ; if ( png == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) CopyMagickMemory ( png , ""\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015"" , 12 ) ; png [ 12 ] = ( unsigned char ) icon_info . planes ; png [ 13 ] = ( unsigned char ) ( icon_info . planes >> 8 ) ; png [ 14 ] = ( unsigned char ) icon_info . bits_per_pixel ; png [ 15 ] = ( unsigned char ) ( icon_info . bits_per_pixel >> 8 ) ; count = ReadBlob ( image , length - 16 , png + 16 ) ; icon_image = ( Image * ) NULL ; if ( count > 0 ) { read_info = CloneImageInfo ( image_info ) ; ( void ) CopyMagickString ( read_info -> magick , ""PNG"" , MagickPathExtent ) ; icon_image = BlobToImage ( read_info , png , length + 16 , exception ) ; read_info = DestroyImageInfo ( read_info ) ; } png = ( unsigned char * ) RelinquishMagickMemory ( png ) ; if ( icon_image == ( Image * ) NULL ) { if ( count != ( ssize_t ) ( length - 16 ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } DestroyBlob ( icon_image ) ; icon_image -> blob = ReferenceBlob ( image -> blob ) ; ReplaceImageInList ( & image , icon_image ) ; } else { if ( icon_info . bits_per_pixel > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . compression = ReadBlobLSBLong ( image ) ; icon_info . image_size = ReadBlobLSBLong ( image ) ; icon_info . x_pixels = ReadBlobLSBLong ( image ) ; icon_info . y_pixels = ReadBlobLSBLong ( image ) ; icon_info . number_colors = ReadBlobLSBLong ( image ) ; icon_info . colors_important = ReadBlobLSBLong ( image ) ; image -> alpha_trait = BlendPixelTrait ; image -> columns = ( size_t ) icon_file . directory [ i ] . width ; if ( ( ssize_t ) image -> columns > icon_info . width ) image -> columns = ( size_t ) icon_info . width ; if ( image -> columns == 0 ) image -> columns = 256 ; image -> rows = ( size_t ) icon_file . directory [ i ] . height ; if ( ( ssize_t ) image -> rows > icon_info . height ) image -> rows = ( size_t ) icon_info . height ; if ( image -> rows == 0 ) image -> rows = 256 ; image -> depth = icon_info . bits_per_pixel ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank>scene<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) i ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . size ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>width<S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . width ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>height<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>colors<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . number_colors ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>planes<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . planes ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>bpp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . bits_per_pixel ) ; } if ( ( icon_info . number_colors != 0 ) || ( icon_info . bits_per_pixel <= 16U ) ) { image -> storage_class = PseudoClass ; image -> colors = icon_info . number_colors ; if ( image -> colors == 0 ) image -> colors = one << icon_info . bits_per_pixel ; } if ( image -> storage_class == PseudoClass ) { register ssize_t i ; unsigned char * icon_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; icon_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4UL * sizeof ( * icon_colormap ) ) ; if ( icon_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) ( 4 * image -> colors ) , icon_colormap ) ; if ( count != ( ssize_t ) ( 4 * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = icon_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; p ++ ; } icon_colormap = ( unsigned char * ) RelinquishMagickMemory ( icon_colormap ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_line = ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) >> 3 ; ( void ) bytes_per_line ; scanline_pad = ( ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) - ( image -> columns * icon_info . bits_per_pixel ) ) >> 3 ; switch ( icon_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelIndex ( image , ( ( byte ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 8 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 16 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; byte |= ( size_t ) ( ReadBlobByte ( image ) << 8 ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; if ( icon_info . bits_per_pixel == 32 ) SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( icon_info . bits_per_pixel == 24 ) for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( image_info -> ping == MagickFalse ) ( void ) SyncImage ( image , exception ) ; if ( icon_info . bits_per_pixel != 32 ) { image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 32 ) != 0 ) for ( x = 0 ; x < ( ssize_t ) ( ( 32 - ( image -> columns % 32 ) ) / 8 ) ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( i < ( ssize_t ) ( icon_file . count - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" )
",ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z,792,,0
1672,CWE-20,"CWE-20 void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send ( <S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }
","<S2SV_ModStart> ; stbbr_send ( ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>""
",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z,793,,0
1673,CWE-415,"CWE-415 static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }
","<S2SV_ModStart> -> cac_id , serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16425,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad,2018-09-04T00:29Z,794,"<S2SV_ModStart> -> cac_id, serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN",1
1674,CWE-125,"CWE-125 static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <S2SV_StartBug> return tok ; <S2SV_EndBug> }
","<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,795,<S2SV_ModStart> ; tok -> type_comments = 0 ; tok ->,0
1675,CWE-476,"CWE-476 void AV1_RewriteESDescriptorEx ( GF_MPEGVisualSampleEntryBox * av1 , GF_MediaBox * mdia ) { GF_BitRateBox * btrt = gf_isom_sample_entry_get_bitrate ( ( GF_SampleEntryBox * ) av1 , GF_FALSE ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( GF_Descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderConfig -> streamType = GF_STREAM_VISUAL ; av1 -> emul_esd -> decoderConfig -> objectTypeIndication = GF_CODECID_AV1 ; if ( btrt ) { av1 -> emul_esd -> decoderConfig -> bufferSizeDB = btrt -> bufferSizeDB ; av1 -> emul_esd -> decoderConfig -> avgBitrate = btrt -> avgBitrate ; av1 -> emul_esd -> decoderConfig -> maxBitrate = btrt -> maxBitrate ; } <S2SV_StartBug> if ( av1 -> av1_config ) { <S2SV_EndBug> GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> data , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> dataLength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }
","<S2SV_ModStart> av1 -> av1_config && av1 -> av1_config -> config
",gpac@gpac/b2eab95e07cb5819375a50358d4806a8813b6e50,CVE-2021-31262,https://github.com/gpac/gpac/commit/b2eab95e07cb5819375a50358d4806a8813b6e50,2021-04-19T19:15Z,796,,0
1676,CWE-400,"CWE-400 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> } return GF_OK ; }
","<S2SV_ModStart> dref ) { GF_Box * dref ; <S2SV_ModStart> ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ; }
",gpac@gpac/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,CVE-2018-21017,https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,2019-09-16T13:15Z,797,<S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( s,0
1677,CWE-415,"CWE-415 static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , ""ID-kaart"" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , ""AS<S2SV_blank>Sertifitseerimiskeskus"" ) ; sc_format_path ( ""3f00eeee5044"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""select<S2SV_blank>esteid<S2SV_blank>PD<S2SV_blank>failed"" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""read<S2SV_blank>document<S2SV_blank>number<S2SV_blank>failed"" ) ; <S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; static char const * esteid_cert_paths [ 2 ] = { ""3f00eeeeaace"" , ""3f00eeeeddce"" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs15_object cert_obj ; memset ( & cert_info , 0 , sizeof ( cert_info ) ) ; memset ( & cert_obj , 0 , sizeof ( cert_obj ) ) ; cert_info . id . value [ 0 ] = esteid_cert_ids [ i ] ; cert_info . id . len = 1 ; sc_format_path ( esteid_cert_paths [ i ] , & cert_info . path ) ; strlcpy ( cert_obj . label , esteid_cert_names [ i ] , sizeof ( cert_obj . label ) ) ; r = sc_pkcs15emu_add_x509_cert ( p15card , & cert_obj , & cert_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( i == 0 ) { sc_pkcs15_cert_t * cert = NULL ; r = sc_pkcs15_read_certificate ( p15card , & cert_info , & cert ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( cert -> key -> algorithm == SC_ALGORITHM_EC ) field_length = cert -> key -> u . ec . params . field_length ; else modulus_length = cert -> key -> u . rsa . modulus . len * 8 ; if ( r == SC_SUCCESS ) { static const struct sc_object_id cn_oid = { { 2 , 5 , 4 , 3 , - 1 } } ; u8 * cn_name = NULL ; size_t cn_len = 0 ; sc_pkcs15_get_name_from_dn ( card -> ctx , cert -> subject , cert -> subject_len , & cn_oid , & cn_name , & cn_len ) ; if ( cn_len > 0 ) { char * token_name = malloc ( cn_len + 1 ) ; if ( token_name ) { memcpy ( token_name , cn_name , cn_len ) ; token_name [ cn_len ] = '\\0' ; set_string ( & p15card -> tokeninfo -> label , ( const char * ) token_name ) ; free ( token_name ) ; } } free ( cn_name ) ; sc_pkcs15_free_certificate ( cert ) ; } } } sc_format_path ( ""3f000016"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; for ( i = 0 ; i < 3 ; i ++ ) { unsigned char tries_left ; static const char * esteid_pin_names [ 3 ] = { ""PIN1"" , ""PIN2"" , ""PUK"" } ; static const int esteid_pin_min [ 3 ] = { 4 , 5 , 8 } ; static const int esteid_pin_ref [ 3 ] = { 1 , 2 , 0 } ; static const int esteid_pin_authid [ 3 ] = { 1 , 2 , 3 } ; static const int esteid_pin_flags [ 3 ] = { 0 , 0 , SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN } ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; r = sc_read_record ( card , i + 1 , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; tries_left = buff [ 5 ] ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = esteid_pin_authid [ i ] ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = esteid_pin_ref [ i ] ; pin_info . attrs . pin . flags = esteid_pin_flags [ i ] ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = esteid_pin_min [ i ] ; pin_info . attrs . pin . stored_length = 12 ; pin_info . attrs . pin . max_length = 12 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = ( int ) tries_left ; pin_info . max_tries = 3 ; strlcpy ( pin_obj . label , esteid_pin_names [ i ] , sizeof ( pin_obj . label ) ) ; pin_obj . flags = esteid_pin_flags [ i ] ; if ( i < 2 ) { pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 3 ; } r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } for ( i = 0 ; i < 2 ; i ++ ) { static int prkey_pin [ 2 ] = { 1 , 2 } ; static const char * prkey_name [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; struct sc_pkcs15_prkey_info prkey_info ; struct sc_pkcs15_object prkey_obj ; memset ( & prkey_info , 0 , sizeof ( prkey_info ) ) ; memset ( & prkey_obj , 0 , sizeof ( prkey_obj ) ) ; prkey_info . id . len = 1 ; prkey_info . id . value [ 0 ] = prkey_pin [ i ] ; prkey_info . native = 1 ; prkey_info . key_reference = i + 1 ; prkey_info . field_length = field_length ; prkey_info . modulus_length = modulus_length ; if ( i == 1 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION ; else if ( field_length > 0 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE ; else prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT ; strlcpy ( prkey_obj . label , prkey_name [ i ] , sizeof ( prkey_obj . label ) ) ; prkey_obj . auth_id . len = 1 ; prkey_obj . auth_id . value [ 0 ] = prkey_pin [ i ] ; prkey_obj . user_consent = 0 ; prkey_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; if ( field_length > 0 ) r = sc_pkcs15emu_add_ec_prkey ( p15card , & prkey_obj , & prkey_info ) ; else r = sc_pkcs15emu_add_rsa_prkey ( p15card , & prkey_obj , & prkey_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } return SC_SUCCESS ; }
","<S2SV_ModStart> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] = '\\0'
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16425,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad,2018-09-04T00:29Z,798,<S2SV_ModStart> ] ) ; <S2SV_ModEnd> char buf [ 0,0
1678,CWE-119,"CWE-119 u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ; <S2SV_StartBug> ASSERT ( dpbSize ) ; <S2SV_EndBug> dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t * ) ; ALLOCATE ( dpb -> outBuf , dpb -> dpbSize + 1 , dpbOutPicture_t ) ; if ( dpb -> list == NULL || dpb -> outBuf == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> list , 0 , ( ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t * ) ) ) ; dpb -> numOut = dpb -> outIndex = 0 ; return ( HANTRO_OK ) ; }
","<S2SV_ModStart> dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( ""b/28533562"" ) ; android_errorWriteLog ( 0x534e4554 , ""28533562"" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }
",frameworks@av/590d1729883f700ab905cdc9ad850f3ddd7e1f56,CVE-2016-3819,https://android.googlesource.com/platform/frameworks/av/+/590d1729883f700ab905cdc9ad850f3ddd7e1f56,2016-08-05T20:59Z,799,,0
1679,CWE-552,"CWE-552 static int _hostsock_getpeername ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; <S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> addrlen_in = * addrlen ; <S2SV_EndBug> if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! addr || ! addrlen <S2SV_ModStart> OE_EINVAL ) ; <S2SV_ModEnd> addrlen_in = * <S2SV_ModStart> = * addrlen ; if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ;
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z,800,<S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> (! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = * addrlen ; OE_RAISE_ERRNO ( OE_EINVAL ) ;,0
1680,CWE-119,"CWE-119 static cJSON * cJSON_New_Item ( void ) { cJSON * node = ( cJSON * ) cJSON_malloc ( sizeof ( cJSON ) ) ; if ( node ) memset ( node , 0 , sizeof ( cJSON ) ) ; return node ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z,801,,1
1681,CWE-125,"CWE-125 BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>TPDU<S2SV_blank>length<S2SV_blank>indicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>routing<S2SV_blank>token<S2SV_blank>or<S2SV_blank>cookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>negotiation<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%"" PRIu8 """" , type ) ; return FALSE ; } <S2SV_StartBug> nego_process_negotiation_request ( nego , s ) ; <S2SV_EndBug> } return tpkt_ensure_stream_consumed ( s , length ) ; }
","<S2SV_ModStart> FALSE ; } if ( ! <S2SV_ModStart> , s ) ) return FALSE
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,802,<S2SV_ModStart> ; if (! s ) return FALSE,0
1682,CWE-264,"CWE-264 static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <S2SV_StartBug> struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && lsa -> l2tp_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = lsa -> l2tp_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; } if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; } <S2SV_StartBug> if ( opt == NULL ) <S2SV_EndBug> opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : lock_sock ( sk ) ; err = ip6_append_data ( sk , ip_generic_getfrag , msg , ulen , transhdrlen , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; if ( err ) ip6_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = l2tp_ip6_push_pending_frames ( sk ) ; release_sock ( sk ) ; done : dst_release ( dst ) ; out : <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> return err < 0 ? err : len ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
","<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt_to_free = NULL <S2SV_ModStart> } if ( ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z,803,<S2SV_ModStart> ) ) { struct ipv6_txoptions * opt = NULL ; <S2SV_ModStart> * opt = rcu_dereference (,0
1683,CWE-119,"CWE-119 int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ; <S2SV_StartBug> unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ; <S2SV_EndBug> unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ; <S2SV_StartBug> uint32_t valign , falign , hdr_size , j ; <S2SV_EndBug> struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [ 128 ] ; # endif if ( ! ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>ctx<S2SV_blank>==<S2SV_blank>NULL\\n"" ) ; return CL_ENULLARG ; } # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { pe_json = get_pe_property ( ctx ) ; } # endif map = * ctx -> fmap ; if ( fmap_readn ( map , & e_magic , 0 , sizeof ( e_magic ) ) != sizeof ( e_magic ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE && EC16 ( e_magic ) != PE_IMAGE_DOS_SIGNATURE_OLD ) { cli_dbgmsg ( ""Invalid<S2SV_blank>DOS<S2SV_blank>signature\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & e_lfanew , 58 + sizeof ( e_magic ) , sizeof ( e_lfanew ) ) != sizeof ( e_lfanew ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>new<S2SV_blank>header<S2SV_blank>address\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } e_lfanew = EC32 ( e_lfanew ) ; cli_dbgmsg ( ""e_lfanew<S2SV_blank>==<S2SV_blank>%d\\n"" , e_lfanew ) ; if ( ! e_lfanew ) { cli_dbgmsg ( ""Not<S2SV_blank>a<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; return CL_CLEAN ; } if ( fmap_readn ( map , & file_hdr , e_lfanew , sizeof ( struct pe_image_file_hdr ) ) != sizeof ( struct pe_image_file_hdr ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>file<S2SV_blank>header\\n"" ) ; return CL_CLEAN ; } if ( EC32 ( file_hdr . Magic ) != PE_IMAGE_NT_SIGNATURE ) { cli_dbgmsg ( ""Invalid<S2SV_blank>PE<S2SV_blank>signature<S2SV_blank>(probably<S2SV_blank>NE<S2SV_blank>file)\\n"" ) ; return CL_CLEAN ; } if ( EC16 ( file_hdr . Characteristics ) & 0x2000 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""DLL"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>DLL\\n"" ) ; dll = 1 ; } else if ( EC16 ( file_hdr . Characteristics ) & 0x01 ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json , ""Type"" , ""EXE"" ) ; # endif cli_dbgmsg ( ""File<S2SV_blank>type:<S2SV_blank>Executable\\n"" ) ; } switch ( EC16 ( file_hdr . Machine ) ) { case 0x0 : archtype = ""Unknown"" ; break ; case 0x14c : archtype = ""80386"" ; break ; case 0x14d : archtype = ""80486"" ; break ; case 0x14e : archtype = ""80586"" ; break ; case 0x160 : archtype = ""R30000<S2SV_blank>(big-endian)"" ; break ; case 0x162 : archtype = ""R3000"" ; break ; case 0x166 : archtype = ""R4000"" ; break ; case 0x168 : archtype = ""R10000"" ; break ; case 0x184 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP"" ; break ; case 0x284 : archtype = ""DEC<S2SV_blank>Alpha<S2SV_blank>AXP<S2SV_blank>64bit"" ; break ; case 0x1f0 : archtype = ""PowerPC"" ; break ; case 0x200 : archtype = ""IA64"" ; break ; case 0x268 : archtype = ""M68k"" ; break ; case 0x266 : archtype = ""MIPS16"" ; break ; case 0x366 : archtype = ""MIPS+FPU"" ; break ; case 0x466 : archtype = ""MIPS16+FPU"" ; break ; case 0x1a2 : archtype = ""Hitachi<S2SV_blank>SH3"" ; break ; case 0x1a3 : archtype = ""Hitachi<S2SV_blank>SH3-DSP"" ; break ; case 0x1a4 : archtype = ""Hitachi<S2SV_blank>SH3-E"" ; break ; case 0x1a6 : archtype = ""Hitachi<S2SV_blank>SH4"" ; break ; case 0x1a8 : archtype = ""Hitachi<S2SV_blank>SH5"" ; break ; case 0x1c0 : archtype = ""ARM"" ; break ; case 0x1c2 : archtype = ""THUMB"" ; break ; case 0x1d3 : archtype = ""AM33"" ; break ; case 0x520 : archtype = ""Infineon<S2SV_blank>TriCore"" ; break ; case 0xcef : archtype = ""CEF"" ; break ; case 0xebc : archtype = ""EFI<S2SV_blank>Byte<S2SV_blank>Code"" ; break ; case 0x9041 : archtype = ""M32R"" ; break ; case 0xc0ee : archtype = ""CEEE"" ; break ; case 0x8664 : archtype = ""AMD64"" ; break ; default : archtype = ""Unknown"" ; } if ( ( archtype ) ) { cli_dbgmsg ( ""Machine<S2SV_blank>type:<S2SV_blank>%s\\n"" , archtype ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""ArchType"" , archtype ) ; # endif } nsections = EC16 ( file_hdr . NumberOfSections ) ; if ( nsections < 1 || nsections > 96 ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadNumberOfSections"" ) ; # endif if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( ! ctx -> corrupted_input ) { if ( nsections ) cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>%d<S2SV_blank>sections\\n"" , nsections ) ; else cli_warnmsg ( ""PE<S2SV_blank>file<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>sections\\n"" ) ; } return CL_CLEAN ; } cli_dbgmsg ( ""NumberOfSections:<S2SV_blank>%d\\n"" , nsections ) ; timestamp = ( time_t ) EC32 ( file_hdr . TimeDateStamp ) ; cli_dbgmsg ( ""TimeDateStamp:<S2SV_blank>%s"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""TimeDateStamp"" , cli_ctime ( & timestamp , timestr , sizeof ( timestr ) ) ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader:<S2SV_blank>%x\\n"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""SizeOfOptionalHeader"" , EC16 ( file_hdr . SizeOfOptionalHeader ) ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) < sizeof ( struct pe_image_optional_hdr32 ) ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSize"" ) ; # endif cli_dbgmsg ( ""SizeOfOptionalHeader<S2SV_blank>too<S2SV_blank>small\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at = e_lfanew + sizeof ( struct pe_image_file_hdr ) ; if ( fmap_readn ( map , & optional_hdr32 , at , sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr32 ) ; if ( EC16 ( optional_hdr64 . Magic ) == PE32P_SIGNATURE ) { # if HAVE_JSON pe_add_heuristic_property ( ctx , ""BadOptionalHeaderSizePE32Plus"" ) ; # endif if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr64 ) ) { cli_dbgmsg ( ""Incorrect<S2SV_blank>SizeOfOptionalHeader<S2SV_blank>for<S2SV_blank>PE32+\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } pe_plus = 1 ; } if ( ! pe_plus ) { if ( EC16 ( file_hdr . SizeOfOptionalHeader ) != sizeof ( struct pe_image_optional_hdr32 ) ) { at += EC16 ( file_hdr . SizeOfOptionalHeader ) - sizeof ( struct pe_image_optional_hdr32 ) ; } if ( DCONF & PE_CONF_UPACK ) upack = ( EC16 ( file_hdr . SizeOfOptionalHeader ) == 0x148 ) ; vep = EC32 ( optional_hdr32 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr32 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr32 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr32 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr32 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr32 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr32 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr32 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr32 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr32 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr32 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr32 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr32 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } else { if ( fmap_readn ( map , & optional_hdr32 + 1 , at , sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) != sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>optional<S2SV_blank>file<S2SV_blank>header\\n"" ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_optional_hdr64 ) - sizeof ( struct pe_image_optional_hdr32 ) ; vep = EC32 ( optional_hdr64 . AddressOfEntryPoint ) ; hdr_size = EC32 ( optional_hdr64 . SizeOfHeaders ) ; cli_dbgmsg ( ""File<S2SV_blank>format:<S2SV_blank>PE32+\\n"" ) ; cli_dbgmsg ( ""MajorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MajorLinkerVersion ) ; cli_dbgmsg ( ""MinorLinkerVersion:<S2SV_blank>%d\\n"" , optional_hdr64 . MinorLinkerVersion ) ; cli_dbgmsg ( ""SizeOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_dbgmsg ( ""SizeOfInitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_dbgmsg ( ""SizeOfUninitializedData:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_dbgmsg ( ""AddressOfEntryPoint:<S2SV_blank>0x%x\\n"" , vep ) ; cli_dbgmsg ( ""BaseOfCode:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_dbgmsg ( ""SectionAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_dbgmsg ( ""FileAlignment:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_dbgmsg ( ""MajorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_dbgmsg ( ""MinorSubsystemVersion:<S2SV_blank>%d\\n"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; cli_dbgmsg ( ""SizeOfImage:<S2SV_blank>0x%x\\n"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_dbgmsg ( ""SizeOfHeaders:<S2SV_blank>0x%x\\n"" , hdr_size ) ; cli_dbgmsg ( ""NumberOfRvaAndSizes:<S2SV_blank>%d\\n"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; dirs = optional_hdr64 . DataDirectory ; # if HAVE_JSON cli_jsonint ( pe_json , ""MajorLinkerVersion"" , optional_hdr64 . MajorLinkerVersion ) ; cli_jsonint ( pe_json , ""MinorLinkerVersion"" , optional_hdr64 . MinorLinkerVersion ) ; cli_jsonint ( pe_json , ""SizeOfCode"" , EC32 ( optional_hdr64 . SizeOfCode ) ) ; cli_jsonint ( pe_json , ""SizeOfInitializedData"" , EC32 ( optional_hdr64 . SizeOfInitializedData ) ) ; cli_jsonint ( pe_json , ""SizeOfUninitializedData"" , EC32 ( optional_hdr64 . SizeOfUninitializedData ) ) ; cli_jsonint ( pe_json , ""NumberOfRvaAndSizes"" , EC32 ( optional_hdr64 . NumberOfRvaAndSizes ) ) ; cli_jsonint ( pe_json , ""MajorSubsystemVersion"" , EC16 ( optional_hdr64 . MajorSubsystemVersion ) ) ; cli_jsonint ( pe_json , ""MinorSubsystemVersion"" , EC16 ( optional_hdr64 . MinorSubsystemVersion ) ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . BaseOfCode ) ) ; cli_jsonstr ( pe_json , ""BaseOfCode"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SectionAlignment ) ) ; cli_jsonstr ( pe_json , ""SectionAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . FileAlignment ) ) ; cli_jsonstr ( pe_json , ""FileAlignment"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , EC32 ( optional_hdr64 . SizeOfImage ) ) ; cli_jsonstr ( pe_json , ""SizeOfImage"" , jsonbuf ) ; snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , hdr_size ) ; cli_jsonstr ( pe_json , ""SizeOfHeaders"" , jsonbuf ) ; # endif } # if HAVE_JSON if ( ctx -> options & CL_SCAN_FILE_PROPERTIES ) { snprintf ( jsonbuf , sizeof ( jsonbuf ) , ""0x%x"" , vep ) ; cli_jsonstr ( pe_json , ""EntryPoint"" , jsonbuf ) ; } # endif switch ( pe_plus ? EC16 ( optional_hdr64 . Subsystem ) : EC16 ( optional_hdr32 . Subsystem ) ) { case 0 : subsystem = ""Unknown"" ; break ; case 1 : subsystem = ""Native<S2SV_blank>(svc)"" ; native = 1 ; break ; case 2 : subsystem = ""Win32<S2SV_blank>GUI"" ; break ; case 3 : subsystem = ""Win32<S2SV_blank>console"" ; break ; case 5 : subsystem = ""OS/2<S2SV_blank>console"" ; break ; case 7 : subsystem = ""POSIX<S2SV_blank>console"" ; break ; case 8 : subsystem = ""Native<S2SV_blank>Win9x<S2SV_blank>driver"" ; break ; case 9 : subsystem = ""WinCE<S2SV_blank>GUI"" ; break ; case 10 : subsystem = ""EFI<S2SV_blank>application"" ; break ; case 11 : subsystem = ""EFI<S2SV_blank>driver"" ; break ; case 12 : subsystem = ""EFI<S2SV_blank>runtime<S2SV_blank>driver"" ; break ; case 13 : subsystem = ""EFI<S2SV_blank>ROM<S2SV_blank>image"" ; break ; case 14 : subsystem = ""Xbox"" ; break ; case 16 : subsystem = ""Boot<S2SV_blank>application"" ; break ; default : subsystem = ""Unknown"" ; } cli_dbgmsg ( ""Subsystem:<S2SV_blank>%s\\n"" , subsystem ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Subsystem"" , subsystem ) ; # endif cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ) % 0x1000 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>virtual<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } if ( DETECT_BROKEN_PE && ! native && ( ! ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) || ( pe_plus ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ) % 0x200 ) ) { cli_dbgmsg ( ""Bad<S2SV_blank>file<S2SV_blank>alignemnt\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } fsize = map -> len ; section_hdr = ( struct pe_image_section_hdr * ) cli_calloc ( nsections , sizeof ( struct pe_image_section_hdr ) ) ; if ( ! section_hdr ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; return CL_EMEM ; } exe_sections = ( struct cli_exe_section * ) cli_calloc ( nsections , sizeof ( struct cli_exe_section ) ) ; if ( ! exe_sections ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>section<S2SV_blank>headers\\n"" ) ; free ( section_hdr ) ; return CL_EMEM ; } valign = ( pe_plus ) ? EC32 ( optional_hdr64 . SectionAlignment ) : EC32 ( optional_hdr32 . SectionAlignment ) ; falign = ( pe_plus ) ? EC32 ( optional_hdr64 . FileAlignment ) : EC32 ( optional_hdr32 . FileAlignment ) ; if ( fmap_readn ( map , section_hdr , at , sizeof ( struct pe_image_section_hdr ) * nsections ) != ( int ) ( nsections * sizeof ( struct pe_image_section_hdr ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>section<S2SV_blank>header\\n"" ) ; cli_dbgmsg ( ""Possibly<S2SV_blank>broken<S2SV_blank>PE<S2SV_blank>file\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } at += sizeof ( struct pe_image_section_hdr ) * nsections ; for ( i = 0 ; falign != 0x200 && i < nsections ; i ++ ) { if ( falign && section_hdr [ i ] . SizeOfRawData && EC32 ( section_hdr [ i ] . PointerToRawData ) % falign && ! ( EC32 ( section_hdr [ i ] . PointerToRawData ) % 0x200 ) ) { cli_dbgmsg ( ""Found<S2SV_blank>misaligned<S2SV_blank>section,<S2SV_blank>using<S2SV_blank>0x200\\n"" ) ; falign = 0x200 ; } } hdr_size = PESALIGN ( hdr_size , valign ) ; # if HAVE_JSON cli_jsonint ( pe_json , ""NumberOfSections"" , nsections ) ; # endif <S2SV_StartBug> for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> sname [ 8 ] = 0 ; <S2SV_EndBug> exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; # if HAVE_JSON add_section_info ( ctx , & exe_sections [ i ] ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { free ( section_hdr ) ; free ( exe_sections ) ; return CL_ETIMEOUT ; } # endif if ( ! exe_sections [ i ] . vsz && exe_sections [ i ] . rsz ) exe_sections [ i ] . vsz = PESALIGN ( exe_sections [ i ] . ursz , valign ) ; if ( exe_sections [ i ] . rsz && fsize > exe_sections [ i ] . raw && ! CLI_ISCONTAINED ( 0 , ( uint32_t ) fsize , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) ) exe_sections [ i ] . rsz = fsize - exe_sections [ i ] . raw ; cli_dbgmsg ( ""Section<S2SV_blank>%d\\n"" , i ) ; cli_dbgmsg ( ""Section<S2SV_blank>name:<S2SV_blank>%s\\n"" , sname ) ; cli_dbgmsg ( ""Section<S2SV_blank>data<S2SV_blank>(from<S2SV_blank>headers<S2SV_blank>-<S2SV_blank>in<S2SV_blank>memory)\\n"" ) ; cli_dbgmsg ( ""VirtualSize:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uvsz , exe_sections [ i ] . vsz ) ; cli_dbgmsg ( ""VirtualAddress:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . urva , exe_sections [ i ] . rva ) ; cli_dbgmsg ( ""SizeOfRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . ursz , exe_sections [ i ] . rsz ) ; cli_dbgmsg ( ""PointerToRawData:<S2SV_blank>0x%x<S2SV_blank>0x%x\\n"" , exe_sections [ i ] . uraw , exe_sections [ i ] . raw ) ; if ( exe_sections [ i ] . chr & 0x20 ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>executable<S2SV_blank>code\\n"" ) ; if ( exe_sections [ i ] . vsz < exe_sections [ i ] . rsz ) { cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\n"" ) ; } } if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\n"" ) ; if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\n"" ) ; if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) { cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\n"" ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rsz ) { <S2SV_StartBug> if ( exe_sections [ i ] . raw >= fsize ) { <S2SV_EndBug> cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_POLIPOS ) && ! * sname && exe_sections [ i ] . vsz > 40000 && exe_sections [ i ] . vsz < 70000 && exe_sections [ i ] . chr == 0xe0000060 ) polipos = i ; if ( ( DCONF & PE_CONF_MD5SECT ) && ctx -> engine -> hm_mdb ) { ret = scan_pe_mdb ( ctx , & exe_sections [ i ] ) ; if ( ret != CL_CLEAN ) { if ( ret != CL_VIRUS ) cli_errmsg ( ""scan_pe:<S2SV_blank>scan_pe_mdb<S2SV_blank>failed:<S2SV_blank>%s!\\n"" , cl_strerror ( ret ) ) ; cli_dbgmsg ( ""------------------------------------\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return ret ; } } } cli_dbgmsg ( ""------------------------------------\\n"" ) ; if ( exe_sections [ i ] . urva >> 31 || exe_sections [ i ] . uvsz >> 31 || ( exe_sections [ i ] . rsz && exe_sections [ i ] . uraw >> 31 ) || exe_sections [ i ] . ursz >> 31 ) { cli_dbgmsg ( ""Found<S2SV_blank>PE<S2SV_blank>values<S2SV_blank>with<S2SV_blank>sign<S2SV_blank>bit<S2SV_blank>set\\n"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } if ( ! i ) { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva != hdr_size ) { cli_dbgmsg ( ""First<S2SV_blank>section<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>place\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } min = exe_sections [ i ] . rva ; max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; } else { if ( DETECT_BROKEN_PE && exe_sections [ i ] . urva - exe_sections [ i - 1 ] . urva != exe_sections [ i - 1 ] . vsz ) { cli_dbgmsg ( ""Virtually<S2SV_blank>misplaced<S2SV_blank>section<S2SV_blank>(wrong<S2SV_blank>order,<S2SV_blank>overlapping,<S2SV_blank>non<S2SV_blank>contiguous)\\n"" ) ; cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; free ( section_hdr ) ; free ( exe_sections ) ; return CL_VIRUS ; } if ( exe_sections [ i ] . rva < min ) min = exe_sections [ i ] . rva ; if ( exe_sections [ i ] . rva + exe_sections [ i ] . rsz > max ) { max = exe_sections [ i ] . rva + exe_sections [ i ] . rsz ; overlays = exe_sections [ i ] . raw + exe_sections [ i ] . rsz ; } } } free ( section_hdr ) ; if ( ! ( ep = cli_rawaddr ( vep , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""EntryPoint<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n"" ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } # if HAVE_JSON cli_jsonint ( pe_json , ""EntryPointOffset"" , ep ) ; if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif cli_dbgmsg ( ""EntryPoint<S2SV_blank>offset:<S2SV_blank>0x%x<S2SV_blank>(%d)\\n"" , ep , ep ) ; if ( pe_plus ) { free ( exe_sections ) ; return CL_CLEAN ; } epsize = fmap_readn ( map , epbuff , ep , 4096 ) ; if ( overlays ) { int overlays_sz = fsize - overlays ; if ( overlays_sz > 0 ) { ret = cli_scanishield ( ctx , overlays , overlays_sz ) ; if ( ret != CL_CLEAN ) { free ( exe_sections ) ; return ret ; } } } pedata . nsections = nsections ; pedata . ep = ep ; pedata . offset = 0 ; memcpy ( & pedata . file_hdr , & file_hdr , sizeof ( file_hdr ) ) ; memcpy ( & pedata . opt32 , & pe_opt . opt32 , sizeof ( pe_opt . opt32 ) ) ; memcpy ( & pedata . opt64 , & pe_opt . opt64 , sizeof ( pe_opt . opt64 ) ) ; memcpy ( & pedata . dirs , dirs , sizeof ( pedata . dirs ) ) ; pedata . e_lfanew = e_lfanew ; pedata . overlays = overlays ; pedata . overlays_sz = fsize - overlays ; pedata . hdr_size = hdr_size ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; free ( exe_sections ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_ALL , map ) ; switch ( ret ) { case CL_ENULLARG : cli_warnmsg ( ""cli_scanpe:<S2SV_blank>NULL<S2SV_blank>argument<S2SV_blank>supplied\\n"" ) ; break ; case CL_VIRUS : case CL_BREAK : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return ret == CL_VIRUS ? CL_VIRUS : CL_CLEAN ; } cli_bytecode_context_destroy ( bc_ctx ) ; if ( SCAN_ALGO && ( DCONF & PE_CONF_PARITE ) && ! dll && epsize == 4096 && ep == exe_sections [ nsections - 1 ] . raw ) { const char * pt = cli_memstr ( epbuff , 4040 , ""\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00"" , 15 ) ; if ( pt ) { pt += 15 ; if ( ( ( ( uint32_t ) cli_readint32 ( pt ) ^ ( uint32_t ) cli_readint32 ( pt + 4 ) ) == 0x505a4f ) && ( ( ( uint32_t ) cli_readint32 ( pt + 8 ) ^ ( uint32_t ) cli_readint32 ( pt + 12 ) ) == 0xffffb ) && ( ( ( uint32_t ) cli_readint32 ( pt + 16 ) ^ ( uint32_t ) cli_readint32 ( pt + 20 ) ) == 0xb8 ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Parite.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_KRIZ ) && epsize >= 200 && CLI_ISCONTAINED ( exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz , ep , 0x0fd2 ) && epbuff [ 1 ] == '\\x9c' && epbuff [ 2 ] == '\\x60' ) { enum { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSXORPRFX , KZSXOR , KZSDDELTA , KZSLOOP , KZSTOP } ; uint8_t kzs [ ] = { KZSTRASH , KZSCDELTA , KZSPDELTA , KZSGETSIZE , KZSTRASH , KZSXORPRFX , KZSXOR , KZSTRASH , KZSDDELTA , KZSTRASH , KZSLOOP , KZSTOP } ; uint8_t * kzstate = kzs ; uint8_t * kzcode = ( uint8_t * ) epbuff + 3 ; uint8_t kzdptr = 0xff , kzdsize = 0xff ; int kzlen = 197 , kzinitlen = 0xffff , kzxorlen = - 1 ; cli_dbgmsg ( ""in<S2SV_blank>kriz\\n"" ) ; while ( * kzstate != KZSTOP ) { uint8_t op ; if ( kzlen <= 6 ) break ; op = * kzcode ++ ; kzlen -- ; switch ( * kzstate ) { case KZSTRASH : case KZSGETSIZE : { int opsz = 0 ; switch ( op ) { case 0x81 : kzcode += 5 ; kzlen -= 5 ; break ; case 0xb8 : case 0xb9 : case 0xba : case 0xbb : case 0xbd : case 0xbe : case 0xbf : if ( * kzstate == KZSGETSIZE && cli_readint32 ( kzcode ) == 0x0fd2 ) { kzinitlen = kzlen - 5 ; kzdsize = op - 0xb8 ; kzstate ++ ; op = 4 ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>size<S2SV_blank>counter\\n"" , kzdsize ) ; } opsz = 4 ; case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4d : case 0x4e : case 0x4f : op &= 7 ; if ( op != kzdptr && op != kzdsize ) { kzcode += opsz ; kzlen -= opsz ; break ; } default : kzcode -- ; kzlen ++ ; kzstate ++ ; } break ; } case KZSCDELTA : if ( op == 0xe8 && ( uint32_t ) cli_readint32 ( kzcode ) < 0xff ) { kzlen -= * kzcode + 4 ; kzcode += * kzcode + 4 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSPDELTA : if ( ( op & 0xf8 ) == 0x58 && ( kzdptr = op - 0x58 ) != 4 ) { kzstate ++ ; cli_dbgmsg ( ""kriz:<S2SV_blank>using<S2SV_blank>#%d<S2SV_blank>as<S2SV_blank>pointer\\n"" , kzdptr ) ; } else * kzstate = KZSTOP ; break ; case KZSXORPRFX : kzstate ++ ; if ( op == 0x3e ) break ; case KZSXOR : if ( op == 0x80 && * kzcode == kzdptr + 0xb0 ) { kzxorlen = kzlen ; kzcode += + 6 ; kzlen -= + 6 ; kzstate ++ ; } else * kzstate = KZSTOP ; break ; case KZSDDELTA : if ( op == kzdptr + 0x48 ) kzstate ++ ; else * kzstate = KZSTOP ; break ; case KZSLOOP : if ( op == kzdsize + 0x48 && * kzcode == 0x75 && kzlen - ( int8_t ) kzcode [ 1 ] - 3 <= kzinitlen && kzlen - ( int8_t ) kzcode [ 1 ] >= kzxorlen ) { cli_append_virus ( ctx , ""Heuristics.W32.Kriz"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } cli_dbgmsg ( ""kriz:<S2SV_blank>loop<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds,<S2SV_blank>corrupted<S2SV_blank>sample?\\n"" ) ; kzstate ++ ; } } } if ( SCAN_ALGO && ( DCONF & PE_CONF_MAGISTR ) && ! dll && ( nsections > 1 ) && ( exe_sections [ nsections - 1 ] . chr & 0x80000000 ) ) { uint32_t rsize , vsize , dam = 0 ; vsize = exe_sections [ nsections - 1 ] . uvsz ; rsize = exe_sections [ nsections - 1 ] . rsz ; if ( rsize < exe_sections [ nsections - 1 ] . ursz ) { rsize = exe_sections [ nsections - 1 ] . ursz ; dam = 1 ; } if ( vsize >= 0x612c && rsize >= 0x612c && ( ( vsize & 0xff ) == 0xec ) ) { int bw = rsize < 0x7000 ? rsize : 0x7000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x2c\\x61\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.A.dam"" : ""Heuristics.W32.Magistr.A"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } else if ( rsize >= 0x7000 && vsize >= 0x7000 && ( ( vsize & 0xff ) == 0xed ) ) { int bw = rsize < 0x8000 ? rsize : 0x8000 ; const char * tbuff ; if ( ( tbuff = fmap_need_off_once ( map , exe_sections [ nsections - 1 ] . raw + rsize - bw , 4096 ) ) ) { if ( cli_memstr ( tbuff , 4091 , ""\\xe8\\x04\\x72\\x00\\x00"" , 5 ) ) { cli_append_virus ( ctx , dam ? ""Heuristics.W32.Magistr.B.dam"" : ""Heuristics.W32.Magistr.B"" ) ; if ( ! SCAN_ALL ) { free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } } } while ( polipos && ! dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && ( EC16 ( optional_hdr32 . Subsystem ) == 2 || EC16 ( optional_hdr32 . Subsystem ) == 3 ) && EC16 ( file_hdr . Machine ) == 0x14c && optional_hdr32 . SizeOfStackReserve >= 0x80000 ) { uint32_t jump , jold , * jumps = NULL ; const uint8_t * code ; unsigned int xsjs = 0 ; if ( exe_sections [ 0 ] . rsz > CLI_MAX_ALLOCATION ) break ; if ( ! exe_sections [ 0 ] . rsz ) break ; if ( ! ( code = fmap_need_off_once ( map , exe_sections [ 0 ] . raw , exe_sections [ 0 ] . rsz ) ) ) break ; for ( i = 0 ; i < exe_sections [ 0 ] . rsz - 5 ; i ++ ) { if ( ( uint8_t ) ( code [ i ] - 0xe8 ) > 1 ) continue ; jump = cli_rawaddr ( exe_sections [ 0 ] . rva + i + 5 + cli_readint32 ( & code [ i + 1 ] ) , exe_sections , nsections , & err , fsize , hdr_size ) ; if ( err || ! CLI_ISCONTAINED ( exe_sections [ polipos ] . raw , exe_sections [ polipos ] . rsz , jump , 9 ) ) continue ; if ( xsjs % 128 == 0 ) { if ( xsjs == 1280 ) break ; if ( ! ( jumps = ( uint32_t * ) cli_realloc2 ( jumps , ( xsjs + 128 ) * sizeof ( uint32_t ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } } j = 0 ; for ( ; j < xsjs ; j ++ ) { if ( jumps [ j ] < jump ) continue ; if ( jumps [ j ] == jump ) { xsjs -- ; break ; } jold = jumps [ j ] ; jumps [ j ] = jump ; jump = jold ; } jumps [ j ] = jump ; xsjs ++ ; } if ( ! xsjs ) break ; cli_dbgmsg ( ""Polipos:<S2SV_blank>Checking<S2SV_blank>%d<S2SV_blank>xsect<S2SV_blank>jump(s)\\n"" , xsjs ) ; for ( i = 0 ; i < xsjs ; i ++ ) { if ( ! ( code = fmap_need_off_once ( map , jumps [ i ] , 9 ) ) ) continue ; if ( ( jump = cli_readint32 ( code ) ) == 0x60ec8b55 || ( code [ 4 ] == 0x0ec && ( ( jump == 0x83ec8b55 && code [ 6 ] == 0x60 ) || ( jump == 0x81ec8b55 && ! code [ 7 ] && ! code [ 8 ] ) ) ) ) { cli_append_virus ( ctx , ""Heuristics.W32.Polipos.A"" ) ; if ( ! SCAN_ALL ) { free ( jumps ) ; free ( exe_sections ) ; return CL_VIRUS ; } viruses_found ++ ; } } free ( jumps ) ; break ; } if ( SCAN_ALGO && ( DCONF & PE_CONF_SWIZZOR ) && nsections > 1 && fsize > 64 * 1024 && fsize < 4 * 1024 * 1024 ) { if ( dirs [ 2 ] . Size ) { struct swizz_stats * stats = cli_calloc ( 1 , sizeof ( * stats ) ) ; unsigned int m = 1000 ; ret = CL_CLEAN ; if ( ! stats ) ret = CL_EMEM ; else { cli_parseres_special ( EC32 ( dirs [ 2 ] . VirtualAddress ) , EC32 ( dirs [ 2 ] . VirtualAddress ) , map , exe_sections , nsections , fsize , hdr_size , 0 , 0 , & m , stats ) ; if ( ( ret = cli_detect_swizz ( stats ) ) == CL_VIRUS ) { cli_append_virus ( ctx , ""Heuristics.Trojan.Swizzor.Gen"" ) ; } free ( stats ) ; } if ( ret != CL_CLEAN ) { if ( ! ( ret == CL_VIRUS && SCAN_ALL ) ) { free ( exe_sections ) ; return ret ; } viruses_found ++ ; } } } corrupted_cur = ctx -> corrupted_input ; ctx -> corrupted_input = 2 ; found = 0 ; if ( DCONF & ( PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW ) ) { for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz && exe_sections [ i ] . vsz && exe_sections [ i + 1 ] . rsz && exe_sections [ i + 1 ] . vsz ) { found = 1 ; cli_dbgmsg ( ""UPX/FSG/MEW:<S2SV_blank>empty<S2SV_blank>section<S2SV_blank>found<S2SV_blank>-<S2SV_blank>assuming<S2SV_blank>compression\\n"" ) ; # if HAVE_JSON cli_jsonbool ( pe_json , ""HasEmptySection"" , 1 ) ; # endif break ; } } } if ( found && ( DCONF & PE_CONF_MEW ) && epsize >= 16 && epbuff [ 0 ] == '\\xe9' ) { uint32_t fileoffset ; const char * tbuff ; fileoffset = ( vep + cli_readint32 ( epbuff + 1 ) + 5 ) ; while ( fileoffset == 0x154 || fileoffset == 0x158 ) { char * src ; uint32_t offdiff , uselzma ; cli_dbgmsg ( ""MEW:<S2SV_blank>found<S2SV_blank>MEW<S2SV_blank>characteristics<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>%08X<S2SV_blank>+<S2SV_blank>5<S2SV_blank>=<S2SV_blank>%08X\\n"" , cli_readint32 ( epbuff + 1 ) , vep , cli_readint32 ( epbuff + 1 ) + vep + 5 ) ; if ( ! ( tbuff = fmap_need_off_once ( map , fileoffset , 0xb0 ) ) ) break ; if ( fileoffset == 0x154 ) cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>set!\\n"" ) ; else cli_dbgmsg ( ""MEW:<S2SV_blank>Win9x<S2SV_blank>compatibility<S2SV_blank>was<S2SV_blank>NOT<S2SV_blank>set!\\n"" ) ; if ( ( offdiff = cli_readint32 ( tbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) ) <= exe_sections [ i + 1 ] . rva || offdiff >= exe_sections [ i + 1 ] . rva + exe_sections [ i + 1 ] . raw - 4 ) { cli_dbgmsg ( ""MEW:<S2SV_blank>ESI<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>proper<S2SV_blank>section\\n"" ) ; break ; } offdiff -= exe_sections [ i + 1 ] . rva ; if ( ! exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>mew<S2SV_blank>section<S2SV_blank>is<S2SV_blank>empty\\n"" ) ; break ; } ssize = exe_sections [ i + 1 ] . vsz ; dsize = exe_sections [ i ] . vsz ; cli_dbgmsg ( ""MEW:<S2SV_blank>ssize<S2SV_blank>%08x<S2SV_blank>dsize<S2SV_blank>%08x<S2SV_blank>offdiff:<S2SV_blank>%08x\\n"" , ssize , dsize , offdiff ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize , dsize ) ) ; CLI_UNPSIZELIMITS ( ""MEW"" , MAX ( ssize + dsize , exe_sections [ i + 1 ] . rsz ) ) ; if ( exe_sections [ i + 1 ] . rsz < offdiff + 12 || exe_sections [ i + 1 ] . rsz > ssize ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Size<S2SV_blank>mismatch:<S2SV_blank>%08x\\n"" , exe_sections [ i + 1 ] . rsz ) ; break ; } if ( ! ( src = cli_calloc ( ssize + dsize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( bytes = fmap_readn ( map , src + dsize , exe_sections [ i + 1 ] . raw , exe_sections [ i + 1 ] . rsz ) ) != exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""MEW:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>[read:<S2SV_blank>%lu]\\n"" , exe_sections [ i + 1 ] . rsz , ( unsigned long ) bytes ) ; free ( exe_sections ) ; free ( src ) ; return CL_EREAD ; } cli_dbgmsg ( ""MEW:<S2SV_blank>%u<S2SV_blank>(%08x)<S2SV_blank>bytes<S2SV_blank>read\\n"" , ( unsigned int ) bytes , ( unsigned int ) bytes ) ; if ( tbuff [ 0x7b ] == '\\xe8' ) { if ( ! CLI_ISCONTAINED ( exe_sections [ 1 ] . rva , exe_sections [ 1 ] . vsz , cli_readint32 ( tbuff + 0x7c ) + fileoffset + 0x80 , 4 ) ) { cli_dbgmsg ( ""MEW:<S2SV_blank>lzma<S2SV_blank>proc<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds!\\n"" ) ; free ( src ) ; break ; } uselzma = cli_readint32 ( tbuff + 0x7c ) - ( exe_sections [ 0 ] . rva - fileoffset - 0x80 ) ; } else { uselzma = 0 ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""MEW"" ) ; # endif CLI_UNPTEMP ( ""MEW"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""MEW"" , ( unmew11 ( src , offdiff , ssize , dsize , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , uselzma , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } } if ( epsize < 168 ) { free ( exe_sections ) ; return CL_CLEAN ; } if ( found || upack ) { while ( ( ( upack && nsections == 3 ) && ( ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x50' ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > min && epbuff [ 5 ] == '\\xff' && epbuff [ 6 ] == '\\x36' ) ) ) || ( ( ! upack && nsections == 2 ) && ( ( epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xe8' && cli_readint32 ( epbuff + 2 ) == 0x9 ) || ( epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) > 0 && epbuff [ 5 ] == '\\xad' && epbuff [ 6 ] == '\\x8b' && epbuff [ 7 ] == '\\xf8' ) ) ) ) { uint32_t vma , off ; int a , b , c ; cli_dbgmsg ( ""Upack<S2SV_blank>characteristics<S2SV_blank>found.\\n"" ) ; a = exe_sections [ 0 ] . vsz ; b = exe_sections [ 1 ] . vsz ; if ( upack ) { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>set\\n"" ) ; c = exe_sections [ 2 ] . vsz ; ssize = exe_sections [ 0 ] . ursz + exe_sections [ 0 ] . uraw ; off = exe_sections [ 0 ] . rva ; vma = EC32 ( optional_hdr32 . ImageBase ) + exe_sections [ 0 ] . rva ; } else { cli_dbgmsg ( ""Upack:<S2SV_blank>var<S2SV_blank>NOT<S2SV_blank>set\\n"" ) ; c = exe_sections [ 1 ] . rva ; ssize = exe_sections [ 1 ] . uraw ; off = 0 ; vma = exe_sections [ 1 ] . rva - exe_sections [ 1 ] . uraw ; } dsize = a + b + c ; CLI_UNPSIZELIMITS ( ""Upack"" , MAX ( MAX ( dsize , ssize ) , exe_sections [ 1 ] . ursz ) ) ; if ( ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . ursz ) || ( upack && ! CLI_ISCONTAINED ( 0 , dsize , exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , ssize ) ) || ssize > dsize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>probably<S2SV_blank>malformed<S2SV_blank>pe-header,<S2SV_blank>skipping<S2SV_blank>to<S2SV_blank>next<S2SV_blank>unpacker\\n"" ) ; break ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( unsigned int ) fmap_readn ( map , dest , 0 , ssize ) != ssize ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>0\\n"" ) ; free ( dest ) ; break ; } if ( upack ) memmove ( dest + exe_sections [ 2 ] . rva - exe_sections [ 0 ] . rva , dest , ssize ) ; if ( ( unsigned int ) fmap_readn ( map , dest + exe_sections [ 1 ] . rva - off , exe_sections [ 1 ] . uraw , exe_sections [ 1 ] . ursz ) != exe_sections [ 1 ] . ursz ) { cli_dbgmsg ( ""Upack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>1\\n"" ) ; free ( dest ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Upack"" ) ; # endif CLI_UNPTEMP ( ""Upack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Upack"" , ( unupack ( upack , dest , dsize , epbuff , vma , ep , EC32 ( optional_hdr32 . ImageBase ) , exe_sections [ 0 ] . rva , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\x87' && epbuff [ 1 ] == '\\x25' ) { const char * dst ; uint32_t newesi , newedi , newebx , newedx ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } newedx = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>xchg<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>(%x),<S2SV_blank>giving<S2SV_blank>up\\n"" , newedx ) ; break ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_ESEEK ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( newedx < exe_sections [ i + 1 ] . rva || ! CLI_ISCONTAINED ( src , ssize , dst , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newedx , 4 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>ESP<S2SV_blank>(%x)<S2SV_blank>is<S2SV_blank>wrong\\n"" , newedx ) ; break ; } dst = src + newedx - exe_sections [ i + 1 ] . rva ; if ( ! CLI_ISCONTAINED ( src , ssize , dst , 32 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>New<S2SV_blank>stack<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedi = cli_readint32 ( dst ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( dst + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newebx = cli_readint32 ( dst + 16 ) - EC32 ( optional_hdr32 . ImageBase ) ; newedx = cli_readint32 ( dst + 20 ) ; if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>buffer<S2SV_blank>(edi<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( ! CLI_ISCONTAINED ( exe_sections [ i + 1 ] . rva , exe_sections [ i + 1 ] . rsz , newebx , 16 ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>functions<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" ) ; break ; } newedx = cli_readint32 ( newebx + 12 - exe_sections [ i + 1 ] . rva + src ) - EC32 ( optional_hdr32 . ImageBase ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , newedx ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG2 ( ""FSG"" , ( unfsg_200 ( newesi - exe_sections [ i + 1 ] . rva + src , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , newedi , EC32 ( optional_hdr32 . ImageBase ) , newedx , ndesc ) ) , 1 , ( dest , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbe' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min ) { int sectcnt = 0 ; const char * support ; uint32_t newesi , newedi , oldep , gp , t ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! ( t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ) && err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) ; if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } newedi = cli_readint32 ( support + 4 ) - EC32 ( optional_hdr32 . ImageBase ) ; newesi = cli_readint32 ( support + 8 ) - EC32 ( optional_hdr32 . ImageBase ) ; if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . rsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } for ( t = 12 ; t < gp - 4 ; t += 4 ) { uint32_t rva = cli_readint32 ( support + t ) ; if ( ! rva ) break ; rva -= EC32 ( optional_hdr32 . ImageBase ) + 1 ; sectcnt ++ ; if ( rva % 0x1000 ) cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>misaligned\\n"" , sectcnt ) ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 4 || cli_readint32 ( support + t ) ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 1 ; t <= ( uint32_t ) sectcnt ; t ++ ) sections [ t ] . rva = cli_readint32 ( support + 8 + t * 4 ) - 1 - EC32 ( optional_hdr32 . ImageBase ) ; if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } oldep = vep + 161 + 6 + cli_readint32 ( epbuff + 163 ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } while ( found && ( DCONF & PE_CONF_FSG ) && epbuff [ 0 ] == '\\xbb' && cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) < min && epbuff [ 5 ] == '\\xbf' && epbuff [ 10 ] == '\\xbe' && vep >= exe_sections [ i + 1 ] . rva && vep - exe_sections [ i + 1 ] . rva > exe_sections [ i + 1 ] . rva - 0xe0 ) { int sectcnt = 0 ; uint32_t gp , t = cli_rawaddr ( cli_readint32 ( epbuff + 1 ) - EC32 ( optional_hdr32 . ImageBase ) , NULL , 0 , & err , fsize , hdr_size ) ; const char * support ; uint32_t newesi = cli_readint32 ( epbuff + 11 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t newedi = cli_readint32 ( epbuff + 6 ) - EC32 ( optional_hdr32 . ImageBase ) ; uint32_t oldep = vep - exe_sections [ i + 1 ] . rva ; struct cli_exe_section * sections ; ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz ; if ( err ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Support<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>padding<S2SV_blank>area\\n"" ) ; break ; } if ( newesi < exe_sections [ i + 1 ] . rva || newesi - exe_sections [ i + 1 ] . rva >= exe_sections [ i + 1 ] . raw ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Source<S2SV_blank>buffer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section<S2SV_blank>bounds\\n"" ) ; break ; } if ( newedi != exe_sections [ i ] . rva ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Bad<S2SV_blank>destination<S2SV_blank>(is<S2SV_blank>%x<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%x)\\n"" , newedi , exe_sections [ i ] . rva ) ; break ; } CLI_UNPSIZELIMITS ( ""FSG"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } gp = exe_sections [ i + 1 ] . raw - t ; CLI_UNPSIZELIMITS ( ""FSG"" , gp ) if ( ! ( support = fmap_need_off_once ( map , t , gp ) ) ) { cli_dbgmsg ( ""Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>padding<S2SV_blank>area\\n"" , gp ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( t = 0 ; t < gp - 2 ; t += 2 ) { uint32_t rva = support [ t ] | ( support [ t + 1 ] << 8 ) ; if ( rva == 2 || rva == 1 ) break ; rva = ( ( rva - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; sectcnt ++ ; if ( rva < exe_sections [ i ] . rva || rva - exe_sections [ i ] . rva >= exe_sections [ i ] . vsz ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Original<S2SV_blank>section<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n"" , sectcnt ) ; break ; } } if ( t >= gp - 10 || cli_readint32 ( support + t + 6 ) != 2 ) { break ; } if ( ( sections = ( struct cli_exe_section * ) cli_malloc ( ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ) == NULL ) { cli_errmsg ( ""FSG:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>sections<S2SV_blank>%lu\\n"" , ( sectcnt + 1 ) * sizeof ( struct cli_exe_section ) ) ; free ( exe_sections ) ; return CL_EMEM ; } sections [ 0 ] . rva = newedi ; for ( t = 0 ; t <= ( uint32_t ) sectcnt - 1 ; t ++ ) { sections [ t + 1 ] . rva = ( ( ( support [ t * 2 ] | ( support [ t * 2 + 1 ] << 8 ) ) - 2 ) << 12 ) - EC32 ( optional_hdr32 . ImageBase ) ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""FSG:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i ) ; free ( exe_sections ) ; free ( sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; free ( sections ) ; return CL_EMEM ; } gp = 0xda + 6 * ( epbuff [ 16 ] == '\\xe8' ) ; oldep = vep + gp + 6 + cli_readint32 ( src + gp + 2 + oldep ) ; cli_dbgmsg ( ""FSG:<S2SV_blank>found<S2SV_blank>old<S2SV_blank>EP<S2SV_blank>@%x\\n"" , oldep ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""FSG"" ) ; # endif CLI_UNPTEMP ( ""FSG"" , ( dest , sections , exe_sections , 0 ) ) ; CLI_UNPRESULTSFSG1 ( ""FSG"" , ( unfsg_133 ( src + newesi - exe_sections [ i + 1 ] . rva , dest , ssize + exe_sections [ i + 1 ] . rva - newesi , dsize , sections , sectcnt , EC32 ( optional_hdr32 . ImageBase ) , oldep , ndesc ) ) , 1 , ( dest , sections , 0 ) ) ; break ; } if ( found && ( DCONF & PE_CONF_UPX ) ) { ssize = exe_sections [ i + 1 ] . rsz ; dsize = exe_sections [ i ] . vsz + exe_sections [ i + 1 ] . vsz ; CLI_UNPSIZELIMITS ( ""UPX"" , MAX ( dsize , ssize ) ) ; if ( ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Size<S2SV_blank>mismatch<S2SV_blank>or<S2SV_blank>dsize<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(ssize:<S2SV_blank>%d,<S2SV_blank>dsize:<S2SV_blank>%d)\\n"" , ssize , dsize ) ; free ( exe_sections ) ; return CL_CLEAN ; } if ( ! exe_sections [ i + 1 ] . rsz || ! ( src = fmap_need_off_once ( map , exe_sections [ i + 1 ] . raw , ssize ) ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>raw<S2SV_blank>data<S2SV_blank>of<S2SV_blank>section<S2SV_blank>%d\\n"" , i + 1 ) ; free ( exe_sections ) ; return CL_EREAD ; } if ( ( dest = ( char * ) cli_calloc ( dsize + 8192 , sizeof ( char ) ) ) == NULL ) { free ( exe_sections ) ; return CL_EMEM ; } if ( cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2B , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2B<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2b ; } else if ( cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2D , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2D<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2d ; } else if ( cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 , 13 ) || cli_memstr ( UPX_NRV2E , 24 , epbuff + 0x69 + 8 , 13 ) ) { cli_dbgmsg ( ""UPX:<S2SV_blank>Looks<S2SV_blank>like<S2SV_blank>a<S2SV_blank>NRV2E<S2SV_blank>decompression<S2SV_blank>routine\\n"" ) ; upxfn = upx_inflate2e ; } if ( upxfn ) { int skew = cli_readint32 ( epbuff + 2 ) - EC32 ( optional_hdr32 . ImageBase ) - exe_sections [ i + 1 ] . rva ; if ( epbuff [ 1 ] != '\\xbe' || skew <= 0 || skew > 0xfff ) { skew = 0 ; } else if ( ( unsigned int ) skew > ssize ) { skew = 0 ; } else { cli_dbgmsg ( ""UPX:<S2SV_blank>UPX1<S2SV_blank>seems<S2SV_blank>skewed<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bytes\\n"" , skew ) ; } if ( upxfn ( src + skew , ssize - skew , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - skew ) >= 0 ) { upx_success = 1 ; } else if ( skew && ( upxfn ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ) ) { upx_success = 1 ; } if ( upx_success ) cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed\\n"" ) ; else cli_dbgmsg ( ""UPX:<S2SV_blank>Preferred<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } if ( ! upx_success && upxfn != upx_inflate2b ) { if ( upx_inflate2b ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2b ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2B<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2B\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2d ) { if ( upx_inflate2d ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2d ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2D<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2D\\n"" ) ; } } if ( ! upx_success && upxfn != upx_inflate2e ) { if ( upx_inflate2e ( src , ssize , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) == - 1 && upx_inflate2e ( src + 0x15 , ssize - 0x15 , dest , & dsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep - 0x15 ) == - 1 ) { cli_dbgmsg ( ""UPX:<S2SV_blank>NRV2E<S2SV_blank>decompressor<S2SV_blank>failed\\n"" ) ; } else { upx_success = 1 ; cli_dbgmsg ( ""UPX:<S2SV_blank>Successfully<S2SV_blank>decompressed<S2SV_blank>with<S2SV_blank>NRV2E\\n"" ) ; } } if ( cli_memstr ( UPX_LZMA2 , 20 , epbuff + 0x2f , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x21 ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } else if ( cli_memstr ( UPX_LZMA1 , 20 , epbuff + 0x39 , 20 ) ) { uint32_t strictdsize = cli_readint32 ( epbuff + 0x2b ) , skew = 0 ; if ( ssize > 0x15 && epbuff [ 0 ] == '\\x60' && epbuff [ 1 ] == '\\xbe' ) { skew = cli_readint32 ( epbuff + 2 ) - exe_sections [ i + 1 ] . rva - optional_hdr32 . ImageBase ; if ( skew != 0x15 ) skew = 0 ; } if ( strictdsize <= dsize ) upx_success = upx_inflatelzma ( src + skew , ssize - skew , dest , & strictdsize , exe_sections [ i ] . rva , exe_sections [ i + 1 ] . rva , vep ) >= 0 ; } if ( ! upx_success ) { cli_dbgmsg ( ""UPX:<S2SV_blank>All<S2SV_blank>decompressors<S2SV_blank>failed\\n"" ) ; free ( dest ) ; } } if ( upx_success ) { free ( exe_sections ) ; CLI_UNPTEMP ( ""UPX/FSG"" , ( dest , 0 ) ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""UPX"" ) ; # endif if ( ( unsigned int ) write ( ndesc , dest , dsize ) != dsize ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Can\'t<S2SV_blank>write<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( tempfile ) ; free ( dest ) ; close ( ndesc ) ; return CL_EWRITE ; } free ( dest ) ; if ( lseek ( ndesc , 0 , SEEK_SET ) == - 1 ) { cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>lseek()<S2SV_blank>failed\\n"" ) ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_ESEEK ; } if ( ctx -> engine -> keeptmp ) cli_dbgmsg ( ""UPX/FSG:<S2SV_blank>Decompressed<S2SV_blank>data<S2SV_blank>saved<S2SV_blank>in<S2SV_blank>%s\\n"" , tempfile ) ; cli_dbgmsg ( ""*****<S2SV_blank>Scanning<S2SV_blank>decompressed<S2SV_blank>file<S2SV_blank>*****\\n"" ) ; SHA_OFF ; if ( ( ret = cli_magic_scandesc ( ndesc , ctx ) ) == CL_VIRUS ) { close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; SHA_RESET ; return CL_VIRUS ; } SHA_RESET ; close ( ndesc ) ; CLI_TMPUNLK ( ) ; free ( tempfile ) ; return ret ; } if ( epsize < 200 ) { free ( exe_sections ) ; return CL_CLEAN ; } found = 2 ; if ( epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 1 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) { if ( nsections < 2 || epbuff [ 0 ] != '\\xb8' || ( uint32_t ) cli_readint32 ( epbuff + 1 ) != exe_sections [ nsections - 2 ] . rva + EC32 ( optional_hdr32 . ImageBase ) ) found = 0 ; else found = 1 ; } if ( found && ( DCONF & PE_CONF_PETITE ) ) { cli_dbgmsg ( ""Petite:<S2SV_blank>v2.%d<S2SV_blank>compression<S2SV_blank>detected\\n"" , found ) ; if ( cli_readint32 ( epbuff + 0x80 ) == 0x163c988d ) { cli_dbgmsg ( ""Petite:<S2SV_blank>level<S2SV_blank>zero<S2SV_blank>compression<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet\\n"" ) ; } else { dsize = max - min ; CLI_UNPSIZELIMITS ( ""Petite"" , dsize ) ; if ( ( dest = ( char * ) cli_calloc ( dsize , sizeof ( char ) ) ) == NULL ) { cli_dbgmsg ( ""Petite:<S2SV_blank>Can\'t<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dsize ) ; free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < nsections ; i ++ ) { if ( exe_sections [ i ] . raw ) { if ( ! exe_sections [ i ] . rsz || ( unsigned int ) fmap_readn ( map , dest + exe_sections [ i ] . rva - min , exe_sections [ i ] . raw , exe_sections [ i ] . ursz ) != exe_sections [ i ] . ursz ) { free ( exe_sections ) ; free ( dest ) ; return CL_CLEAN ; } } } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Petite"" ) ; # endif CLI_UNPTEMP ( ""Petite"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Petite"" , ( petite_inflate2x_1to9 ( dest , min , max - min , exe_sections , nsections - ( found == 1 ? 1 : 0 ) , EC32 ( optional_hdr32 . ImageBase ) , vep , ndesc , found , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . VirtualAddress ) , EC32 ( optional_hdr32 . DataDirectory [ 2 ] . Size ) ) ) , 0 , ( dest , 0 ) ) ; } } if ( ( DCONF & PE_CONF_PESPIN ) && nsections > 1 && vep >= exe_sections [ nsections - 1 ] . rva && vep < exe_sections [ nsections - 1 ] . rva + exe_sections [ nsections - 1 ] . rsz - 0x3217 - 4 && memcmp ( epbuff + 4 , ""\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3"" , 10 ) == 0 ) { char * spinned ; CLI_UNPSIZELIMITS ( ""PEspin"" , fsize ) ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""PESping:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""PESpin:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""PEspin"" ) ; # endif CLI_UNPTEMP ( ""PESpin"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS_ ( ""PEspin"" , SPINCASE ( ) , ( unspin ( spinned , fsize , exe_sections , nsections - 1 , vep , ndesc , ctx ) ) , 0 , ( spinned , 0 ) ) ; } if ( ( DCONF & PE_CONF_YC ) && nsections > 1 && ( EC32 ( optional_hdr32 . AddressOfEntryPoint ) == exe_sections [ nsections - 1 ] . rva + 0x60 ) ) { uint32_t ecx = 0 ; int16_t offset ; if ( ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED"" , 15 ) && ! memcmp ( epbuff + 0x26 , ""\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC"" , 13 ) && ( ( uint8_t ) epbuff [ 0x13 ] == 0xB9 ) && ( ( uint16_t ) ( cli_readint16 ( epbuff + 0x18 ) ) == 0xE981 ) && ! memcmp ( epbuff + 0x1e , ""\\x8B\\xD5\\x81\\xC2"" , 4 ) ) { offset = 0 ; if ( 0x6c - cli_readint32 ( epbuff + 0xf ) + cli_readint32 ( epbuff + 0x22 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x14 ) - cli_readint32 ( epbuff + 0x1a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57"" , 9 ) && ! memcmp ( epbuff + 0x17 , ""\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 8 ) && ( ( uint8_t ) epbuff [ 0x23 ] == 0xB9 ) ) { offset = 0x10 ; if ( 0x6c - cli_readint32 ( epbuff + 0x1f ) + cli_readint32 ( epbuff + 0x32 ) == 0xC6 ) ecx = cli_readint32 ( epbuff + 0x24 ) - cli_readint32 ( epbuff + 0x2a ) ; } if ( ! ecx && ! memcmp ( epbuff , ""\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed"" , 9 ) && ( ( uint8_t ) epbuff [ 0xd ] == 0xb9 ) && ( ( uint16_t ) cli_readint16 ( epbuff + 0x12 ) == 0xbd8d ) && ! memcmp ( epbuff + 0x18 , ""\\x8b\\xf7\\xac"" , 3 ) ) { offset = - 0x18 ; if ( 0x66 - cli_readint32 ( epbuff + 0x9 ) + cli_readint32 ( epbuff + 0x14 ) == 0xae ) ecx = cli_readint32 ( epbuff + 0xe ) ; } if ( ecx > 0x800 && ecx < 0x2000 && ! memcmp ( epbuff + 0x63 + offset , ""\\xaa\\xe2\\xcc"" , 3 ) && ( fsize >= exe_sections [ nsections - 1 ] . raw + 0xC6 + ecx + offset ) ) { char * spinned ; if ( ( spinned = ( char * ) cli_malloc ( fsize ) ) == NULL ) { cli_errmsg ( ""yC:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>spinned<S2SV_blank>%lu\\n"" , ( unsigned long ) fsize ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , spinned , 0 , fsize ) != fsize ) { cli_dbgmsg ( ""yC:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes\\n"" , ( unsigned long ) fsize ) ; free ( spinned ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""yC"" ) ; # endif cli_dbgmsg ( ""%d,%d,%d,%d\\n"" , nsections - 1 , e_lfanew , ecx , offset ) ; CLI_UNPTEMP ( ""yC"" , ( spinned , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""yC"" , ( yc_decrypt ( spinned , fsize , exe_sections , nsections - 1 , e_lfanew , ndesc , ecx , offset ) ) , 0 , ( spinned , 0 ) ) ; } } while ( ( DCONF & PE_CONF_WWPACK ) && nsections > 1 && vep == exe_sections [ nsections - 1 ] . rva && memcmp ( epbuff , ""\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb"" , 7 ) == 0 && memcmp ( epbuff + 0x68 , ""\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50"" , 19 ) == 0 ) { uint32_t head = exe_sections [ nsections - 1 ] . raw ; uint8_t * packer ; char * src ; ssize = 0 ; for ( i = 0 ; ; i ++ ) { if ( exe_sections [ i ] . raw < head ) head = exe_sections [ i ] . raw ; if ( i + 1 == nsections ) break ; if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; } if ( ! head || ! ssize || head > ssize ) break ; CLI_UNPSIZELIMITS ( ""WWPack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } if ( ( size_t ) fmap_readn ( map , src , 0 , head ) != head ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>headers\\n"" , head ) ; free ( src ) ; free ( exe_sections ) ; return CL_EREAD ; } for ( i = 0 ; i < ( unsigned int ) nsections - 1 ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i + 1 != nsections ) { cli_dbgmsg ( ""WWpack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } if ( ( packer = ( uint8_t * ) cli_calloc ( exe_sections [ nsections - 1 ] . rsz , sizeof ( char ) ) ) == NULL ) { free ( src ) ; free ( exe_sections ) ; return CL_EMEM ; } if ( ! exe_sections [ nsections - 1 ] . rsz || ( size_t ) fmap_readn ( map , packer , exe_sections [ nsections - 1 ] . raw , exe_sections [ nsections - 1 ] . rsz ) != exe_sections [ nsections - 1 ] . rsz ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>wwpack<S2SV_blank>sect\\n"" , exe_sections [ nsections - 1 ] . rsz ) ; free ( src ) ; free ( packer ) ; free ( exe_sections ) ; return CL_EREAD ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""WWPack"" ) ; # endif CLI_UNPTEMP ( ""WWPack"" , ( src , packer , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""WWPack"" , ( wwunpack ( ( uint8_t * ) src , ssize , packer , exe_sections , nsections - 1 , e_lfanew , ndesc ) ) , 0 , ( src , packer , 0 ) ) ; break ; } while ( ( DCONF & PE_CONF_ASPACK ) && ep + 58 + 0x70e < fsize && ! memcmp ( epbuff , ""\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb"" , 8 ) ) { char * src ; if ( epsize < 0x3bf || memcmp ( epbuff + 0x3b9 , ""\\x68\\x00\\x00\\x00\\x00\\xc3"" , 6 ) ) break ; ssize = 0 ; for ( i = 0 ; i < nsections ; i ++ ) if ( ssize < exe_sections [ i ] . rva + exe_sections [ i ] . vsz ) ssize = exe_sections [ i ] . rva + exe_sections [ i ] . vsz ; if ( ! ssize ) break ; CLI_UNPSIZELIMITS ( ""Aspack"" , ssize ) ; if ( ! ( src = ( char * ) cli_calloc ( ssize , sizeof ( char ) ) ) ) { free ( exe_sections ) ; return CL_EMEM ; } for ( i = 0 ; i < ( unsigned int ) nsections ; i ++ ) { if ( ! exe_sections [ i ] . rsz ) continue ; if ( ! CLI_ISCONTAINED ( src , ssize , src + exe_sections [ i ] . rva , exe_sections [ i ] . rsz ) ) break ; if ( ( unsigned int ) fmap_readn ( map , src + exe_sections [ i ] . rva , exe_sections [ i ] . raw , exe_sections [ i ] . rsz ) != exe_sections [ i ] . rsz ) break ; } if ( i != nsections ) { cli_dbgmsg ( ""Aspack:<S2SV_blank>Probably<S2SV_blank>hacked/damaged<S2SV_blank>Aspack<S2SV_blank>file.\\n"" ) ; free ( src ) ; break ; } # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""Aspack"" ) ; # endif CLI_UNPTEMP ( ""Aspack"" , ( src , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""Aspack"" , ( unaspack212 ( ( uint8_t * ) src , ssize , exe_sections , nsections , vep - 1 , EC32 ( optional_hdr32 . ImageBase ) , ndesc ) ) , 1 , ( src , 0 ) ) ; break ; } while ( DCONF & PE_CONF_NSPACK ) { uint32_t eprva = vep ; uint32_t start_of_stuff , rep = ep ; unsigned int nowinldr ; const char * nbuff ; src = epbuff ; if ( * epbuff == '\\xe9' ) { eprva = cli_readint32 ( epbuff + 1 ) + vep + 5 ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) break ; if ( ! ( nbuff = fmap_need_off_once ( map , rep , 24 ) ) ) break ; src = nbuff ; } if ( memcmp ( src , ""\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00"" , 13 ) ) break ; nowinldr = 0x54 - cli_readint32 ( src + 17 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>Found<S2SV_blank>*start_of_stuff<S2SV_blank>@delta-%x\\n"" , nowinldr ) ; if ( ! ( nbuff = fmap_need_off_once ( map , rep - nowinldr , 4 ) ) ) break ; start_of_stuff = rep + cli_readint32 ( nbuff ) ; if ( ! ( nbuff = fmap_need_off_once ( map , start_of_stuff , 20 ) ) ) break ; src = nbuff ; if ( ! cli_readint32 ( nbuff ) ) { start_of_stuff += 4 ; src += 4 ; } ssize = cli_readint32 ( src + 5 ) | 0xff ; dsize = cli_readint32 ( src + 9 ) ; CLI_UNPSIZELIMITS ( ""NsPack"" , MAX ( ssize , dsize ) ) ; if ( ! ssize || ! dsize || dsize != exe_sections [ 0 ] . vsz ) break ; if ( ! ( dest = cli_malloc ( dsize ) ) ) { cli_errmsg ( ""NsPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>dest<S2SV_blank>%u\\n"" , dsize ) ; break ; } if ( ! ( src = fmap_need_off ( map , start_of_stuff , ssize ) ) ) { free ( dest ) ; break ; } eprva += 0x27a ; if ( ! ( rep = cli_rawaddr ( eprva , exe_sections , nsections , & err , fsize , hdr_size ) ) && err ) { free ( dest ) ; break ; } if ( ! ( nbuff = fmap_need_off_once ( map , rep , 5 ) ) ) { free ( dest ) ; break ; } fmap_unneed_off ( map , start_of_stuff , ssize ) ; eprva = eprva + 5 + cli_readint32 ( nbuff + 1 ) ; cli_dbgmsg ( ""NsPack:<S2SV_blank>OEP<S2SV_blank>=<S2SV_blank>%08x\\n"" , eprva ) ; # if HAVE_JSON cli_jsonstr ( pe_json , ""Packer"" , ""NsPack"" ) ; # endif CLI_UNPTEMP ( ""NsPack"" , ( dest , exe_sections , 0 ) ) ; CLI_UNPRESULTS ( ""NsPack"" , ( unspack ( src , dest , ctx , exe_sections [ 0 ] . rva , EC32 ( optional_hdr32 . ImageBase ) , eprva , ndesc ) ) , 0 , ( dest , 0 ) ) ; break ; } ctx -> corrupted_input = corrupted_cur ; bc_ctx = cli_bytecode_context_alloc ( ) ; if ( ! bc_ctx ) { cli_errmsg ( ""cli_scanpe:<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>bc_ctx\\n"" ) ; return CL_EMEM ; } cli_bytecode_context_setpe ( bc_ctx , & pedata , exe_sections ) ; cli_bytecode_context_setctx ( bc_ctx , ctx ) ; ret = cli_bytecode_runhook ( ctx , ctx -> engine , bc_ctx , BC_PE_UNPACKER , map ) ; switch ( ret ) { case CL_VIRUS : free ( exe_sections ) ; cli_bytecode_context_destroy ( bc_ctx ) ; return CL_VIRUS ; case CL_SUCCESS : ndesc = cli_bytecode_context_getresult_file ( bc_ctx , & tempfile ) ; cli_bytecode_context_destroy ( bc_ctx ) ; if ( ndesc != - 1 && tempfile ) { CLI_UNPRESULTS ( ""bytecode<S2SV_blank>PE<S2SV_blank>hook"" , 1 , 1 , ( 0 ) ) ; } break ; default : cli_bytecode_context_destroy ( bc_ctx ) ; } free ( exe_sections ) ; # if HAVE_JSON if ( cli_json_timeout_cycle_check ( ctx , & toval ) != CL_SUCCESS ) { return CL_ETIMEOUT ; } # endif if ( SCAN_ALL && viruses_found ) return CL_VIRUS ; return CL_CLEAN ; }
","<S2SV_ModStart> int i , j , <S2SV_ModStart> overlays = 0 , rescan = 1 <S2SV_ModStart> falign , hdr_size <S2SV_ModEnd> ; struct cli_exe_section <S2SV_ModStart> ; # endif while ( rescan == 1 ) { rescan = 0 ; <S2SV_ModStart> ++ ) { exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; if ( exe_sections [ i ] . rsz ) { if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) { cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>or<S2SV_blank>exists<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; if ( nsections == 1 ) { free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ; for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ; nsections -- ; rescan = 1 ; break ; } } } } for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_ModStart> ] = 0 <S2SV_ModEnd> ; # if <S2SV_ModStart> rsz ) { <S2SV_ModEnd> if ( SCAN_ALGO
",vrtadmin@clamav-devel/fc3794a54d2affe5770c1f876484a871c783e91e,CVE-2014-9050,https://github.com/vrtadmin/clamav-devel/commit/fc3794a54d2affe5770c1f876484a871c783e91e,2014-12-01T15:59Z,804,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1684,CWE-20,"CWE-20 uint16_t dm9000ReadPhyReg ( uint8_t address ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> usleep ( 5 ) ; <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,805,<S2SV_ModStart> ; dm9000WriteReg ( DM9000ReadReg ( DM9000WriteReg <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; dm9000WriteReg ( DM9000ReadReg ( DM9000WriteReg <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ) ; dm9000WriteReg ( DM9000WriteReg ( DM9000WriteReg ( DM9000ReadReg ( DM9000_RSR ) ) ; dm9000WriteReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000_RSR ) ) ; dm9000ReadReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000_R ) ) ) ; dm9000ReadReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000ReadReg ( DM9000_RSR ) ) <S2SV_ModEnd> ) ;,0
1685,CWE-787,"CWE-787 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z,806,"<S2SV_ModStart>, buffer, t2p -> tiff_datasize,",1
1689,CWE-269,"CWE-269 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
","<S2SV_ModStart> new_parent ) { <S2SV_ModEnd> __ptrace_link ( child <S2SV_ModStart> , new_parent , current_cred ( ) <S2SV_ModEnd> ) ; }
",torvalds@linux/6994eefb0053799d2e07cd140df6c2ea106c41ee,CVE-2019-13272,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,2019-07-17T13:15Z,807,<S2SV_ModStart> new_parent ) ; <S2SV_ModEnd> <S2SV_null> <S2SV_null>,0
1691,CWE-399,"CWE-399 int cib_remote_signon ( cib_t * cib , const char * name , enum cib_conn_type type ) { int rc = pcmk_ok ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( private -> passwd == NULL ) { struct termios settings ; int rc ; rc = tcgetattr ( 0 , & settings ) ; settings . c_lflag &= ~ ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; fprintf ( stderr , ""Password:<S2SV_blank>"" ) ; private -> passwd = calloc ( 1 , 1024 ) ; rc = scanf ( ""%s"" , private -> passwd ) ; fprintf ( stdout , ""\\n"" ) ; if ( rc < 1 ) { private -> passwd = NULL ; } settings . c_lflag |= ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; } if ( private -> server == NULL || private -> user == NULL ) { rc = - EINVAL ; } if ( rc == pcmk_ok ) { <S2SV_StartBug> rc = cib_tls_signon ( cib , & ( private -> command ) ) ; <S2SV_EndBug> } if ( rc == pcmk_ok ) { <S2SV_StartBug> rc = cib_tls_signon ( cib , & ( private -> callback ) ) ; <S2SV_EndBug> } if ( rc == pcmk_ok ) { xmlNode * hello = cib_create_op ( 0 , private -> callback . token , CRM_OP_REGISTER , NULL , NULL , NULL , 0 , NULL ) ; crm_xml_add ( hello , F_CIB_CLIENTNAME , name ) ; crm_send_remote_msg ( private -> command . session , hello , private -> command . encrypted ) ; free_xml ( hello ) ; } if ( rc == pcmk_ok ) { fprintf ( stderr , ""%s:<S2SV_blank>Opened<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d\\n"" , name , private -> server , private -> port ) ; cib -> state = cib_connected_command ; cib -> type = cib_command ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed:<S2SV_blank>%s\\n"" , name , private -> server , private -> port , pcmk_strerror ( rc ) ) ; } return rc ; }
","<S2SV_ModStart> -> command ) , FALSE <S2SV_ModStart> -> callback ) , TRUE
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,808,<S2SV_ModStart> 0 ) ; if ( private -> session == NULL ) { <S2SV_ModStart> ) ; rc = NULL ; },0
1692,CWE-20,"CWE-20 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; <S2SV_StartBug> msg . msg_name = ( struct sockaddr * ) & address ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_namelen = sizeof ( address ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> . msg_name = addr ? <S2SV_ModStart> ) & address : NULL <S2SV_ModStart> . msg_namelen = 0 <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,809,<S2SV_ModStart> data -> msg_namelen = 0,0
1693,CWE-119,"CWE-119 static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ; <S2SV_StartBug> int num00 , tmp_err , n , sr = 0 ; <S2SV_EndBug> int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ; <S2SV_StartBug> int new_mv_mode_penalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <S2SV_EndBug> while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> step_param , <S2SV_StartBug> x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_EndBug> x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> best_mv -> col = tmp_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { ++ n ; if ( num00 ) { -- num00 ; } else { <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_StartBug> x -> nmvjointcost , <S2SV_EndBug> x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> best_mv -> col = tmp_mv . col ; } } } }
","<S2SV_ModStart> tmp_err , n <S2SV_ModEnd> ; const BLOCK_SIZE <S2SV_ModStart> bsize ] ; const <S2SV_ModStart> int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <S2SV_ModEnd> ; const int <S2SV_ModStart> ; const int sr = get_search_range ( cpi ) <S2SV_ModEnd> ; step_param += <S2SV_ModStart> bsize ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <S2SV_ModStart> x , & cpi -> ss_cfg , & <S2SV_ModStart> , & v_fn_ptr <S2SV_ModEnd> , ref_mv ) <S2SV_ModStart> = tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } n <S2SV_ModStart> diamond_search_sad ( x , & cpi -> ss_cfg <S2SV_ModStart> & v_fn_ptr , <S2SV_ModEnd> ref_mv ) ; <S2SV_ModStart> = tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z,810,<S2SV_ModStart> <S2SV_null> <S2SV_null>,0
1694,CWE-119,"CWE-119 hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , <S2SV_StartBug> ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , <S2SV_EndBug> filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }
","<S2SV_ModStart> ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry""
",libguestfs@hivex/4bbdf555f88baeae0fa804a369a81a83908bd705,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/4bbdf555f88baeae0fa804a369a81a83908bd705,2014-12-08T16:59Z,811,<S2SV_ModStart> ; goto error <S2SV_ModEnd> ; } if,0
1695,CWE-611,"CWE-611 void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , NULL ) ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Merge<S2SV_blank>parent<S2SV_blank>%pp<S2SV_blank>child<S2SV_blank>%pp<S2SV_blank>RESULT<S2SV_blank>%pp"" , _parent , _child , merged ) ; # endif if ( merged == NULL ) return NULL ; merged -> is_enabled = ( child -> is_enabled == NOT_SET ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == NOT_SET ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == NOT_SET ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == NOT_SET ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == NOT_SET ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == NOT_SET ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == NOT_SET ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == NOT_SET ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == NOT_SET ? parent -> if_limit_action : child -> if_limit_action ) ; merged -> of_limit_action = ( child -> of_limit_action == NOT_SET ? parent -> of_limit_action : child -> of_limit_action ) ; merged -> reqintercept_oe = ( child -> reqintercept_oe == NOT_SET ? parent -> reqintercept_oe : child -> reqintercept_oe ) ; if ( child -> of_mime_types != NOT_SET_P ) { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = 1 ; } else { if ( parent -> of_mime_types == NOT_SET_P ) { merged -> of_mime_types = child -> of_mime_types ; merged -> of_mime_types_cleared = NOT_SET ; } else { merged -> of_mime_types = apr_table_overlay ( mp , parent -> of_mime_types , child -> of_mime_types ) ; if ( merged -> of_mime_types == NULL ) return NULL ; } } } else { if ( child -> of_mime_types_cleared == 1 ) { merged -> of_mime_types_cleared = 1 ; } else { merged -> of_mime_types = parent -> of_mime_types ; merged -> of_mime_types_cleared = parent -> of_mime_types_cleared ; } } if ( child -> debuglog_fd == NOT_SET_P ) { merged -> debuglog_name = parent -> debuglog_name ; merged -> debuglog_fd = parent -> debuglog_fd ; } else { merged -> debuglog_name = child -> debuglog_name ; merged -> debuglog_fd = child -> debuglog_fd ; } merged -> debuglog_level = ( child -> debuglog_level == NOT_SET ? parent -> debuglog_level : child -> debuglog_level ) ; merged -> cookie_format = ( child -> cookie_format == NOT_SET ? parent -> cookie_format : child -> cookie_format ) ; merged -> argument_separator = ( child -> argument_separator == NOT_SET ? parent -> argument_separator : child -> argument_separator ) ; merged -> cookiev0_separator = ( child -> cookiev0_separator == NOT_SET_P ? parent -> cookiev0_separator : child -> cookiev0_separator ) ; if ( ( child -> rule_inheritance == NOT_SET ) || ( child -> rule_inheritance == 1 ) ) { merged -> rule_inheritance = parent -> rule_inheritance ; if ( ( child -> ruleset == NULL ) && ( parent -> ruleset == NULL ) ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""No<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif } else if ( child -> ruleset == NULL ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>parent<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; } else if ( parent -> ruleset == NULL ) { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>child<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } else { # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Using<S2SV_blank>parent<S2SV_blank>then<S2SV_blank>child<S2SV_blank>rules<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context."" ) ; # endif merged -> ruleset = msre_ruleset_create ( parent -> ruleset -> engine , mp ) ; copy_rules ( mp , parent -> ruleset , merged -> ruleset , child -> rule_exceptions ) ; apr_array_cat ( merged -> ruleset -> phase_request_headers , child -> ruleset -> phase_request_headers ) ; apr_array_cat ( merged -> ruleset -> phase_request_body , child -> ruleset -> phase_request_body ) ; apr_array_cat ( merged -> ruleset -> phase_response_headers , child -> ruleset -> phase_response_headers ) ; apr_array_cat ( merged -> ruleset -> phase_response_body , child -> ruleset -> phase_response_body ) ; apr_array_cat ( merged -> ruleset -> phase_logging , child -> ruleset -> phase_logging ) ; } } else { merged -> rule_inheritance = 0 ; if ( child -> ruleset != NULL ) { merged -> ruleset = msre_ruleset_create ( child -> ruleset -> engine , mp ) ; merged -> ruleset -> phase_request_headers = apr_array_copy ( mp , child -> ruleset -> phase_request_headers ) ; merged -> ruleset -> phase_request_body = apr_array_copy ( mp , child -> ruleset -> phase_request_body ) ; merged -> ruleset -> phase_response_headers = apr_array_copy ( mp , child -> ruleset -> phase_response_headers ) ; merged -> ruleset -> phase_response_body = apr_array_copy ( mp , child -> ruleset -> phase_response_body ) ; merged -> ruleset -> phase_logging = apr_array_copy ( mp , child -> ruleset -> phase_logging ) ; } } merged -> rule_exceptions = apr_array_append ( mp , parent -> rule_exceptions , child -> rule_exceptions ) ; merged -> hash_method = apr_array_append ( mp , parent -> hash_method , child -> hash_method ) ; merged -> auditlog_flag = ( child -> auditlog_flag == NOT_SET ? parent -> auditlog_flag : child -> auditlog_flag ) ; merged -> auditlog_type = ( child -> auditlog_type == NOT_SET ? parent -> auditlog_type : child -> auditlog_type ) ; merged -> max_rule_time = ( child -> max_rule_time == NOT_SET ? parent -> max_rule_time : child -> max_rule_time ) ; merged -> auditlog_dirperms = ( child -> auditlog_dirperms == NOT_SET ? parent -> auditlog_dirperms : child -> auditlog_dirperms ) ; merged -> auditlog_fileperms = ( child -> auditlog_fileperms == NOT_SET ? parent -> auditlog_fileperms : child -> auditlog_fileperms ) ; if ( child -> auditlog_fd != NOT_SET_P ) { merged -> auditlog_fd = child -> auditlog_fd ; merged -> auditlog_name = child -> auditlog_name ; } else { merged -> auditlog_fd = parent -> auditlog_fd ; merged -> auditlog_name = parent -> auditlog_name ; } if ( child -> auditlog2_fd != NOT_SET_P ) { merged -> auditlog2_fd = child -> auditlog2_fd ; merged -> auditlog2_name = child -> auditlog2_name ; } else { merged -> auditlog2_fd = parent -> auditlog2_fd ; merged -> auditlog2_name = parent -> auditlog2_name ; } merged -> auditlog_storage_dir = ( child -> auditlog_storage_dir == NOT_SET_P ? parent -> auditlog_storage_dir : child -> auditlog_storage_dir ) ; merged -> auditlog_parts = ( child -> auditlog_parts == NOT_SET_P ? parent -> auditlog_parts : child -> auditlog_parts ) ; merged -> auditlog_relevant_regex = ( child -> auditlog_relevant_regex == NOT_SET_P ? parent -> auditlog_relevant_regex : child -> auditlog_relevant_regex ) ; merged -> tmp_dir = ( child -> tmp_dir == NOT_SET_P ? parent -> tmp_dir : child -> tmp_dir ) ; merged -> upload_dir = ( child -> upload_dir == NOT_SET_P ? parent -> upload_dir : child -> upload_dir ) ; merged -> upload_keep_files = ( child -> upload_keep_files == NOT_SET ? parent -> upload_keep_files : child -> upload_keep_files ) ; merged -> upload_validates_files = ( child -> upload_validates_files == NOT_SET ? parent -> upload_validates_files : child -> upload_validates_files ) ; merged -> upload_filemode = ( child -> upload_filemode == NOT_SET ? parent -> upload_filemode : child -> upload_filemode ) ; merged -> upload_file_limit = ( child -> upload_file_limit == NOT_SET ? parent -> upload_file_limit : child -> upload_file_limit ) ; merged -> data_dir = ( child -> data_dir == NOT_SET_P ? parent -> data_dir : child -> data_dir ) ; merged -> webappid = ( child -> webappid == NOT_SET_P ? parent -> webappid : child -> webappid ) ; merged -> sensor_id = ( child -> sensor_id == NOT_SET_P ? parent -> sensor_id : child -> sensor_id ) ; merged -> httpBlkey = ( child -> httpBlkey == NOT_SET_P ? parent -> httpBlkey : child -> httpBlkey ) ; merged -> content_injection_enabled = ( child -> content_injection_enabled == NOT_SET ? parent -> content_injection_enabled : child -> content_injection_enabled ) ; merged -> stream_inbody_inspection = ( child -> stream_inbody_inspection == NOT_SET ? parent -> stream_inbody_inspection : child -> stream_inbody_inspection ) ; merged -> stream_outbody_inspection = ( child -> stream_outbody_inspection == NOT_SET ? parent -> stream_outbody_inspection : child -> stream_outbody_inspection ) ; merged -> geo = ( child -> geo == NOT_SET_P ? parent -> geo : child -> geo ) ; merged -> gsb = ( child -> gsb == NOT_SET_P ? parent -> gsb : child -> gsb ) ; merged -> u_map = ( child -> u_map == NOT_SET_P ? parent -> u_map : child -> u_map ) ; merged -> cache_trans = ( child -> cache_trans == NOT_SET ? parent -> cache_trans : child -> cache_trans ) ; merged -> cache_trans_incremental = ( child -> cache_trans_incremental == NOT_SET ? parent -> cache_trans_incremental : child -> cache_trans_incremental ) ; merged -> cache_trans_min = ( child -> cache_trans_min == ( apr_size_t ) NOT_SET ? parent -> cache_trans_min : child -> cache_trans_min ) ; merged -> cache_trans_max = ( child -> cache_trans_max == ( apr_size_t ) NOT_SET ? parent -> cache_trans_max : child -> cache_trans_max ) ; merged -> cache_trans_maxitems = ( child -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ? parent -> cache_trans_maxitems : child -> cache_trans_maxitems ) ; merged -> component_signatures = apr_array_append ( mp , parent -> component_signatures , child -> component_signatures ) ; merged -> request_encoding = ( child -> request_encoding == NOT_SET_P ? parent -> request_encoding : child -> request_encoding ) ; merged -> disable_backend_compression = ( child -> disable_backend_compression == NOT_SET ? parent -> disable_backend_compression : child -> disable_backend_compression ) ; merged -> col_timeout = ( child -> col_timeout == NOT_SET ? parent -> col_timeout : child -> col_timeout ) ; merged -> crypto_key = ( child -> crypto_key == NOT_SET_P ? parent -> crypto_key : child -> crypto_key ) ; merged -> crypto_key_len = ( child -> crypto_key_len == NOT_SET ? parent -> crypto_key_len : child -> crypto_key_len ) ; merged -> crypto_key_add = ( child -> crypto_key_add == NOT_SET ? parent -> crypto_key_add : child -> crypto_key_add ) ; merged -> crypto_param_name = ( child -> crypto_param_name == NOT_SET_P ? parent -> crypto_param_name : child -> crypto_param_name ) ; merged -> hash_is_enabled = ( child -> hash_is_enabled == NOT_SET ? parent -> hash_is_enabled : child -> hash_is_enabled ) ; merged -> hash_enforcement = ( child -> hash_enforcement == NOT_SET ? parent -> hash_enforcement : child -> hash_enforcement ) ; merged -> crypto_hash_href_rx = ( child -> crypto_hash_href_rx == NOT_SET ? parent -> crypto_hash_href_rx : child -> crypto_hash_href_rx ) ; merged -> crypto_hash_faction_rx = ( child -> crypto_hash_faction_rx == NOT_SET ? parent -> crypto_hash_faction_rx : child -> crypto_hash_faction_rx ) ; merged -> crypto_hash_location_rx = ( child -> crypto_hash_location_rx == NOT_SET ? parent -> crypto_hash_location_rx : child -> crypto_hash_location_rx ) ; merged -> crypto_hash_iframesrc_rx = ( child -> crypto_hash_iframesrc_rx == NOT_SET ? parent -> crypto_hash_iframesrc_rx : child -> crypto_hash_iframesrc_rx ) ; merged -> crypto_hash_framesrc_rx = ( child -> crypto_hash_framesrc_rx == NOT_SET ? parent -> crypto_hash_framesrc_rx : child -> crypto_hash_framesrc_rx ) ; merged -> crypto_hash_href_pm = ( child -> crypto_hash_href_pm == NOT_SET ? parent -> crypto_hash_href_pm : child -> crypto_hash_href_pm ) ; merged -> crypto_hash_faction_pm = ( child -> crypto_hash_faction_pm == NOT_SET ? parent -> crypto_hash_faction_pm : child -> crypto_hash_faction_pm ) ; merged -> crypto_hash_location_pm = ( child -> crypto_hash_location_pm == NOT_SET ? parent -> crypto_hash_location_pm : child -> crypto_hash_location_pm ) ; merged -> crypto_hash_iframesrc_pm = ( child -> crypto_hash_iframesrc_pm == NOT_SET ? parent -> crypto_hash_iframesrc_pm : child -> crypto_hash_iframesrc_pm ) ; merged -> crypto_hash_framesrc_pm = ( child -> crypto_hash_framesrc_pm == NOT_SET ? parent -> crypto_hash_framesrc_pm : child -> crypto_hash_framesrc_pm ) ; <S2SV_StartBug> return merged ; <S2SV_EndBug> }
","<S2SV_ModStart> crypto_hash_framesrc_pm ) ; merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;
",SpiderLabs@ModSecurity/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,CVE-2013-1915,https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,2013-04-25T23:55Z,812,,0
1696,CWE-476,"CWE-476 static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; err = - ENOBUFS ; if ( msg_sys -> msg_controllen > INT_MAX ) goto out_freeiov ; ctl_len = msg_sys -> msg_controllen ; if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len ) { err = cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , sizeof ( ctl ) ) ; if ( err ) goto out_freeiov ; ctl_buf = msg_sys -> msg_control ; ctl_len = msg_sys -> msg_controllen ; } else if ( ctl_len ) { if ( ctl_len > sizeof ( ctl ) ) { ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ) ; if ( ctl_buf == NULL ) goto out_freeiov ; } err = - EFAULT ; if ( copy_from_user ( ctl_buf , ( void __user __force * ) msg_sys -> msg_control , ctl_len ) ) goto out_freectl ; msg_sys -> msg_control = ctl_buf ; } msg_sys -> msg_flags = flags ; if ( sock -> file -> f_flags & O_NONBLOCK ) msg_sys -> msg_flags |= MSG_DONTWAIT ; <S2SV_StartBug> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <S2SV_EndBug> <S2SV_StartBug> ! memcmp ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> used_address -> name_len ) ) { err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; goto out_freectl ; } err = sock_sendmsg ( sock , msg_sys , total_len ) ; if ( used_address && err >= 0 ) { used_address -> name_len = msg_sys -> msg_namelen ; <S2SV_StartBug> memcpy ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> used_address -> name_len ) ; } out_freectl : if ( ctl_buf != ctl ) sock_kfree_s ( sock -> sk , ctl_buf , ctl_len ) ; out_freeiov : if ( iov != iovstack ) sock_kfree_s ( sock -> sk , iov , iov_size ) ; out : return err ; }
","<S2SV_ModStart> ( used_address && msg_sys -> msg_name && <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name , <S2SV_ModStart> -> msg_namelen ; if ( msg_sys -> msg_name ) <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name ,
",torvalds@linux/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c,CVE-2011-4594,https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c,2012-05-17T11:00Z,813,"<S2SV_ModStart> -> name ; if ( msg_sys <S2SV_ModEnd> -> name, <S2SV_ModStart> -> name, msg_sys <S2SV_ModEnd> -> name,",0
1698,CWE-119,"CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , <S2SV_StartBug> offset , <S2SV_EndBug> pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; <S2SV_StartBug> p = pixels + offset ; <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length ) <S2SV_ModStart> + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } <S2SV_ModStart> + offset ; <S2SV_ModEnd> for ( i
",ImageMagick@ImageMagick/73fb0aac5b958521e1511e179ecc0ad49f70ebaf,CVE-2016-10050,https://github.com/ImageMagick/ImageMagick/commit/73fb0aac5b958521e1511e179ecc0ad49f70ebaf,2017-03-23T17:59Z,814,<S2SV_ModStart> pixel_info -> rows * rows <S2SV_ModEnd> ; number_planes =,0
1699,CWE-119,"CWE-119 static int newkeys_to_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b ; struct sshcipher_ctx * cc ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey ; int r ; if ( ( newkey = ssh -> state -> newkeys [ mode ] ) == NULL ) return SSH_ERR_INTERNAL_ERROR ; enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; cc = ( mode == MODE_OUT ) ? ssh -> state -> send_context : ssh -> state -> receive_context ; if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ; if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ; if ( ( r = sshbuf_put_cstring ( b , enc -> name ) ) != 0 || ( r = sshbuf_put ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> enabled ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> block_size ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> key , enc -> key_len ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> iv , enc -> iv_len ) ) != 0 ) goto out ; if ( cipher_authlen ( enc -> cipher ) == 0 ) { if ( ( r = sshbuf_put_cstring ( b , mac -> name ) ) != 0 || ( r = sshbuf_put_u32 ( b , mac -> enabled ) ) != 0 || ( r = sshbuf_put_string ( b , mac -> key , mac -> key_len ) ) != 0 ) goto out ; } if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 || <S2SV_StartBug> ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 || <S2SV_EndBug> ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0 ) goto out ; r = sshbuf_put_stringb ( m , b ) ; out : sshbuf_free ( b ) ; return r ; }
","<S2SV_ModStart> ( r = <S2SV_ModEnd> sshbuf_put_cstring ( b
",openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9,CVE-2016-10012,https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9,2017-01-05T02:59Z,815,<S2SV_ModStart> comp -> type <S2SV_ModEnd> ) )!=,0
1700,CWE-000,"CWE-000 static int traceDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; route -> trace = httpCreateTrace ( route -> trace ) ; for ( option = stok ( sclone ( value ) , ""<S2SV_blank>\\t"" , & tok ) ; option ; option = stok ( 0 , ""<S2SV_blank>\\t"" , & tok ) ) { <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""content"" ) ) { httpSetTraceContentSize ( route -> trace , ( ssize ) getnum ( ovalue ) ) ; } else { httpSetTraceEventLevel ( route -> trace , option , atoi ( ovalue ) ) ; } } return 0 ; }
","<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z,816,"<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option,",1
1701,CWE-399,"CWE-399 void cib_remote_connection_destroy ( gpointer user_data ) { <S2SV_StartBug> cib_client_t * client = user_data ; <S2SV_EndBug> if ( client == NULL ) { return ; } crm_trace ( ""Cleaning<S2SV_blank>up<S2SV_blank>after<S2SV_blank>client<S2SV_blank>disconnect:<S2SV_blank>%s/%s"" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( ""Client<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hashtable"" , client -> name ) ; } } crm_trace ( ""Destroying<S2SV_blank>%s<S2SV_blank>(%p)"" , client -> name , user_data ) ; num_clients -- ; crm_trace ( ""Num<S2SV_blank>unfree\'d<S2SV_blank>clients:<S2SV_blank>%d"" , num_clients ) ; <S2SV_StartBug> free ( client -> name ) ; <S2SV_EndBug> free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; <S2SV_StartBug> free ( client ) ; <S2SV_EndBug> crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }
","<S2SV_ModStart> client = user_data ; int csock = 0 <S2SV_ModStart> num_clients ) ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <S2SV_ModStart> free ( client -> recv_buf ) ; free ( client
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z,817,<S2SV_ModStart> client ) { <S2SV_ModEnd> if ( client,0
1702,CWE-763,"CWE-763 static int remarkupvals ( global_State * g ) { lua_State * thread ; lua_State * * p = & g -> twups ; int work = 0 ; while ( ( thread = * p ) != NULL ) { work ++ ; lua_assert ( ! isblack ( thread ) ) ; if ( isgray ( thread ) && thread -> openupval != NULL ) p = & thread -> twups ; else { UpVal * uv ; <S2SV_StartBug> * p = thread -> twups ; <S2SV_EndBug> thread -> twups = thread ; for ( uv = thread -> openupval ; uv != NULL ; uv = uv -> u . open . next ) { <S2SV_StartBug> work ++ ; <S2SV_EndBug> if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ; } } } return work ; }
","<S2SV_ModStart> * uv ; lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ; <S2SV_ModStart> next ) { lua_assert ( getage ( uv ) <= getage ( thread ) ) ;
",lua@lua/a6da1472c0c5e05ff249325f979531ad51533110,CVE-2020-24371,https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110,2020-08-17T17:15Z,818,<S2SV_ModStart> ; p = 0,0
