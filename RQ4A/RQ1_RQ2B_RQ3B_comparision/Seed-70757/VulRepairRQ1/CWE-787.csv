Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0.1,raw_predictions,correctly_predicted
18,CWE-787,"CWE-787 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
","<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
",torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe,CVE-2018-11506,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,2018-05-28T04:29Z,18,"<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] ; <S2SV_ModStart> -> buflen, sense_buffer, sense_buffer, & sshdr, cgc -> timeout, IOCTL_RETRIES, 0, 0, NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense, sense_buffer, sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if",0
21,CWE-787,"CWE-787 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
","<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;
",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z,21,"<S2SV_ModStart>. left ; luaL_checkstack ( L, 1, ""in <S2SV_blank> function <S2SV_blank> mp_unpack_full"" ) ;",1
41,CWE-787,"CWE-787 static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; <S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
","<S2SV_ModStart> , password , length <S2SV_ModEnd> ) ; attr
",FreeRADIUS@pam_radius/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,CVE-2015-9542,https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,2020-02-24T15:15Z,41,"<S2SV_ModStart> ( password ) ) ; md5_init ( & md5_secret ) ; MD5Update ( & md5_secret, ( unsigned char * ) password, strlen ( password ) ) ; my_md5 = md5_secret ; MD5Final ( misc, & my_md5 ) ; xor ( hashed [ 0 ], misc, AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5, & hashed [ i * AUTH_PASS_LEN ], AUTH_PASS_LEN ) ; xor ( hashed [ i * AUTH_PASS_LEN ], misc, AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5, & hashed [ i * AUTH_PASS_LEN ], AUTH_PASS_LEN ) ; xor ( hashed [ i * AUTH_PASS_LEN ], misc, AUTH_PASS_LEN ) ; }",0
75,CWE-787,"CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }
","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z,75,"<S2SV_ModStart> ) ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; <S2SV_ModStart> ) ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; <S2SV_ModStart> } } } if ( num!= 1 ) { av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", num ) ; return AVERROR_PATCHWELCOME ; } <S2SV_ModStart> ) ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; <S2SV_ModStart> ) ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; <S2SV_ModStart> } den = avio_read_varlen ( pb ) ; if ( den!= 1 ) { av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d <S2SV_blank> is <S2SV_blank> not <S2SV_blank> 1\\n"", den ) ; return AVERROR_PATCHWELCOME ; } if ( num!= den ) { av_log ( s, AV_LOG_ERROR, ""number <S2SV_blank> of <S2SV_blank> video <S2SV_blank> tracks <S2SV_blank> %d\\n",0
80,CWE-787,"CWE-787 static unsigned int ipv6_defrag ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { int err ; # if IS_ENABLED ( CONFIG_NF_CONNTRACK ) if ( skb -> nfct && ! nf_ct_is_template ( ( struct nf_conn * ) skb -> nfct ) ) return NF_ACCEPT ; # endif err = nf_ct_frag6_gather ( state -> net , skb , nf_ct6_defrag_user ( state -> hook , skb ) ) ; if ( err == - EINPROGRESS ) return NF_STOLEN ; <S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> }
","<S2SV_ModStart> NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,CVE-2016-9755,https://github.com/torvalds/linux/commit/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,2016-12-28T07:59Z,80,<S2SV_ModStart> NF_STOLEN ; return err == 0? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>,1
276,CWE-787,"CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
","<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,276,<S2SV_ModStart> ; if ( ptr_hbe_txposer -> noise_sensitivity > INT_MAX / ptr_hbe_txposer -> noise_sensitivity ) { ptr_hbe_txposer -> noise_sensitivity = INT_MAX ; ptr_hbe_txposer -> noise_sensitivity = ptr_hbe_txposer -> noise_sensitivity ; } else if ( ptr_hbe_txposer -> noise_sensitivity > INT_MAX / ptr_hbe_txposer -> noise_sensitivity ) { ptr_hbe_txposer -> noise_sensitivity = ptr_hbe_txposer -> noise_sensitivity ; } else if ( ptr_hbe_txposer -> noise_sensitivity > INT_MAX / ptr_hbe_txposer -> noise_sensitivity ) { ptr_hbe_txposer -> noise_sensitivity = ptr_hbe_txposer -> noise_sensitivity ; },0
290,CWE-787,"CWE-787 static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }
","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z,290,"<S2SV_ModStart> + x > ( size_t ) <S2SV_ModStart> + x > ( size_t ) <S2SV_ModStart> NULL ; } if ( diffPtr + x > diffBlock + diffBlockLength || extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } if ( extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } if ( extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError, ""corrupt <S2SV_blank> patch <S2SV_blank> (overflow)"" ) ; return NULL ; } memcpy ( newData + newpos, extraPtr, y ) ;",0
406,CWE-787,"CWE-787 <S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> { <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> if ( context -> ChromaSubsamplingLevel ) { <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> , rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if ( ! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,406,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> UINT32 rowstride ) { if (! context ) return FALSE ; if (! bmpdata ||! rowstride ) return FALSE ; <S2SV_ModStart>, rowstride ) ; return TRUE ; } <S2SV_ModEnd> if ( context <S2SV_ModStart> ChromaSubsamplingLevel ) { if (! <S2SV_ModStart> ( context ) ) return FALSE ; return TRUE ;",0
415,CWE-787,"CWE-787 <S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> ExceptionInfo * exception ) { <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> Quantum index ; index = 0 ; <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> break ; } case 2 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( Image <S2SV_ModStart> image , ssize_t bpp <S2SV_ModEnd> , unsigned char <S2SV_ModStart> exception ) { int bit ; Quantum index <S2SV_ModEnd> ; register Quantum <S2SV_ModStart> ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> ; switch ( bpp <S2SV_ModEnd> ) { case <S2SV_ModStart> 1 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> bit < ( ssize_t ) ( <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ++ ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 2 : { for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> * p >> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ( * p ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> ( image ) <S2SV_ModEnd> ; } if <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> image ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 8 : { for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x <S2SV_ModStart> ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> , exception ) <S2SV_ModStart> , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",ImageMagick@ImageMagick/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,CVE-2018-16642,https://github.com/ImageMagick/ImageMagick/commit/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,2018-09-06T22:29Z,415,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static Quantum * QueueAuthenticPixels <S2SV_ModEnd> ( Image * <S2SV_ModStart> image, ssize_t columns, <S2SV_ModStart> exception ) { <S2SV_ModEnd> register Quantum * <S2SV_ModStart> register Quantum * q <S2SV_ModEnd> ; index = <S2SV_ModStart> index = 0 <S2SV_ModEnd> ; switch ( <S2SV_ModStart> : { q = QueueAuthenticPixels <S2SV_ModEnd> ( image, <S2SV_ModStart>, y, columns, 1, exception ) ; if ( q == ( Quantum * ) NULL ) return ( Quantum * ) NULL ; <S2SV_ModStart> : { q = QueueAuthenticPixels <S2SV_ModEnd> ( image, <S2SV_ModStart>, y, columns, 1, exception ) ; if ( q == ( Quantum * ) NULL ) return ( Quantum * ) NULL ; <S2SV_ModStart> bit ++ ) { index = ConstrainColormapIndex ( image, ( * p >> 6 ) & 0x3, exception ) ; SetPixelIndex ( image, index, q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> % 2 ) { index = ConstrainColormapIndex ( image, ( * p >> 4 ) & 0x3, exception ) ; SetPixelIndex ( image, index, q ) ;",0
518,CWE-787,"CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
","<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,518,<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if (! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if (! rc ) return FALSE ; },1
562,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; } <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> out += len ; left -= len ; } else { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out , UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; } <S2SV_null>
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,562,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out, UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } return TRUE <S2SV_ModEnd> ; } <S2SV_null>",0
595,CWE-787,"CWE-787 static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
",ImageMagick@ImageMagick/b6ae2f9e0ab13343c0281732d479757a8e8979c7,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7,2017-04-20T18:59Z,595,"<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index <S2SV_ModStart> index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 4 )!= 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 4 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; } if ( ( <S2SV_ModStart> % 4 )!= 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 4 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit )? 0x01 : 0x00 ) ; SetPixelRGBO ( q, image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( ssize_t ) ( p ) & ( 0x80 >> bit )!= 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 4 ) ; bit ++ ) { index = ( ( * p",0
713,CWE-787,"CWE-787 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; <S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
",ImageMagick@ImageMagick/998c687fb83993c13fa711d75f59a95b38ceab77,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77,2017-04-20T18:59Z,713,"<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError, ""InvalidColormapIndex"" ) ; if ( WPG_Palette. StartIndex > WPG_Palette. NumOfEntries",0
751,CWE-787,"CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ; break ; <S2SV_ModEnd> } } if <S2SV_ModStart> 1 ; } }
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,751,<S2SV_ModStart> ; if ( sfb >= ptr_hbe_txposer -> max_sfb ) { ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> max_sfb ; ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> min_sfb ; ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> max_sfb ; } else { if ( sfb >= ptr_hbe_txposer -> max_sfb ) { ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> max_sfb ; ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> min_sfb ; ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> max_sfb ; } else { if ( sfb >= ptr_hbe_txposer -> max_sfb ) { ptr_hbe_txposer -> max_sfb = ptr_hbe_txposer -> max_sfb ; ptr_hbe_txposer,0
752,CWE-787,"CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
","<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
",uclouvain@openjpeg/2cd30c2b06ce332dede81cccad8b334cde997281,CVE-2017-14040,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2017-08-30T22:29Z,752,<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga,0
774,CWE-787,"CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
",dbry@WavPack/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,CVE-2018-10540,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,2018-04-29T15:29Z,774,"<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s <S2SV_blank> is <S2SV_blank> not <S2SV_blank> a <S2SV_blank> valid <S2SV_blank>.DFF <S2SV_blank> file!"", infilename ) ; return WAVPACK_SOFT_ERROR ; } buff",1
786,CWE-787,"CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
","<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z,786,<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->,1
789,CWE-787,"CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>"" ""This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n"" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
","<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,789,<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t,1
801,CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,801,"<S2SV_ModStart> name ) { size_t max_name_len = strlen ( name ) * 2 + 16 ; if ( max_name_len > max_name_len ) { ERR ( ""Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> (%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", max_name_len, ( int ) ( max_name_len / 2 ) ) ; dst_name = malloc ( max_name_len / 2 ) ; if (! dst_name ) { ERR ( ""Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> (%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", max_name_len, ( int ) ( max_name_len / 2 ) ) ; } dst_name = malloc ( max_name_len * 2 + 16 ) ; if (! ( dst_name ) ) dst_name = malloc ( max_name_len / 2 ) ; if (! dst_name ) { ERR ( ""Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> (%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", max_name_len, ( int ) ( max_name_",0
803,CWE-787,"CWE-787 static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; } <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }
","<S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> , __func__ )
",libimobiledevice@libplist/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,CVE-2017-6439,https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,2017-03-15T14:59Z,803,"<S2SV_ModStart> object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> size <S2SV_blank> node <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> for <S2SV_blank> node <S2SV_blank> type <S2SV_blank> 0x%02x <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__, type ) ; return NULL ; } size = UINT_TO_HOST ( * object, size ) ; ( * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> size <S2SV_blank> node <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> for <S2SV_blank> node <S2SV_blank> type <S2SV_blank> 0x%02x <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__, type ) ; return NULL ; } size = UINT_TO_HOST ( * object, size ) ; ( * object + size ) ; if ( * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s: <S2SV_blank> size <S2SV_blank> node <S2SV_blank> data <S2SV_blank> bytes <S2SV_blank> for <S2SV_blank> node <S2SV_blank> type <S2SV_blank> 0x%02x <S2SV_blank> point <S2SV_blank> outside <S2SV_blank> of <S2SV_blank> valid <S2SV_blank> range\\n"", __func__, type ) ; return NULL ; }",0
863,CWE-787,"CWE-787 static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%d<S2SV_blank>PKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; <S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> r = sc_transmit_apdu ( card , & apdu ) ; LOG_TEST_RET ( card -> ctx , r , ""APDU<S2SV_blank>transmit<S2SV_blank>failed"" ) ; if ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) { size_t len = ( apdu . resplen > outlen ) ? outlen : apdu . resplen ; unsigned int offset = 0 ; if ( tcos3 && ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) && apdu . resp [ 0 ] == 0 && apdu . resp [ 1 ] == 2 ) { offset = 2 ; while ( offset < len && apdu . resp [ offset ] != 0 ) ++ offset ; offset = ( offset < len - 1 ) ? offset + 1 : 0 ; } memcpy ( out , apdu . resp + offset , len - offset ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , len - offset ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ) ; }
","<S2SV_ModStart> 0x02 ) ; if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;
",OpenSC@OpenSC/9d294de90d1cc66956389856e60b6944b27b4817,CVE-2020-26572,https://github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817,2020-10-06T02:15Z,863,"<S2SV_ModStart> 0x02 ) ; if ( crgram_len > 0 && crgram_len < sizeof ( sbuf ) - 1 ) { <S2SV_ModStart>, crgram, crgram_len - 1",0
864,CWE-787,"CWE-787 static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , ""mcs_recv_connect_response(),<S2SV_blank>result=%d"" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
","<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,864,"<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if (! s_check_rem ( s, length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(), <S2SV_blank> consume <S2SV_blank> connect <S2SV_blank> id <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; }",1
870,CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; } } return - 1 ;
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,870,"<S2SV_ModStart> ; } } if ( strtok ( g -> data, "";"" ) ) { eprintf ( ""action: <S2SV_blank> %s\\n"", action ) ; switch ( action [ 0 ] ) { case 'i' : if ( cmd_cb ( core_ptr, ""ic"", NULL, 0 ) < 0 ) { send_msg ( g, ""E01"" ) ; return - 1 ; } return send_msg ( g, ""E01"" ) ; } switch ( action [ 0 ] ) { case 'u' : if ( cmd_cb ( core_ptr, ""ic"", NULL, 0 ) < 0 ) { send_msg ( g, ""E01"" ) ; return - 1 ; } return send_msg ( g, ""E01"" ) ; } if ( strtok ( NULL, "";"" ) ) { eprintf ( ""action: <S2SV_blank> %s\\n"", action ) ; switch ( action [ 0 ] ) { case's' : if ( cmd_cb ( core_ptr, ""ds"", NULL, 0 ) < 0 ) { send_msg ( g, ""E01"" ) ; return - 1 ; } return send_msg ( g, ""E01",0
916,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,916,<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if (! context ) return FALSE ; <S2SV_ModStart> planeSize ; } return TRUE ;,0
958,CWE-787,"CWE-787 VOID ixheaacd_esbr_radix4bfly ( const WORD32 * w , WORD32 * x , WORD32 index1 , WORD32 index ) { int i ; WORD32 l1 , l2 , h2 , fft_jmp ; <S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; WORD32 x_h2_0 , x_h2_1 ; WORD32 si10 , si20 , si30 , co10 , co20 , co30 ; WORD64 mul_1 , mul_2 , mul_3 , mul_4 , mul_5 , mul_6 ; WORD64 mul_7 , mul_8 , mul_9 , mul_10 , mul_11 , mul_12 ; WORD32 * x_l1 ; WORD32 * x_l2 ; WORD32 * x_h2 ; const WORD32 * w_ptr = w ; WORD32 i1 ; h2 = index << 1 ; l1 = index << 2 ; l2 = ( index << 2 ) + ( index << 1 ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; fft_jmp = 6 * ( index ) ; for ( i1 = 0 ; i1 < index1 ; i1 ++ ) { for ( i = 0 ; i < index ; i ++ ) { si10 = ( * w_ptr ++ ) ; co10 = ( * w_ptr ++ ) ; si20 = ( * w_ptr ++ ) ; co20 = ( * w_ptr ++ ) ; si30 = ( * w_ptr ++ ) ; co30 = ( * w_ptr ++ ) ; x_0 = x [ 0 ] ; x_h2_0 = x [ h2 ] ; x_l1_0 = x [ l1 ] ; x_l2_0 = x [ l2 ] ; <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> x_1 = x [ 1 ] ; x_h2_1 = x [ h2 + 1 ] ; x_l1_1 = x [ l1 + 1 ] ; x_l2_1 = x [ l2 + 1 ] ; <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ; mul_3 = ixheaacd_mult64 ( yt2_0 , si30 ) ; x [ l2 ] = ( WORD32 ) ( ( mul_3 + mul_11 ) >> 32 ) << RADIXSHIFT ; mul_5 = ixheaacd_mult64 ( xt2_0 , si30 ) ; mul_9 = ixheaacd_mult64 ( yt2_0 , co30 ) ; x [ l2 + 1 ] = ( WORD32 ) ( ( mul_9 - mul_5 ) >> 32 ) << RADIXSHIFT ; mul_12 = ixheaacd_mult64 ( xt0_0 , co20 ) ; mul_2 = ixheaacd_mult64 ( yt0_0 , si20 ) ; x [ l1 ] = ( WORD32 ) ( ( mul_2 + mul_12 ) >> 32 ) << RADIXSHIFT ; mul_6 = ixheaacd_mult64 ( xt0_0 , si20 ) ; mul_8 = ixheaacd_mult64 ( yt0_0 , co20 ) ; x [ l1 + 1 ] = ( WORD32 ) ( ( mul_8 - mul_6 ) >> 32 ) << RADIXSHIFT ; mul_4 = ixheaacd_mult64 ( xt1_0 , co10 ) ; mul_1 = ixheaacd_mult64 ( yt1_0 , si10 ) ; x [ h2 ] = ( WORD32 ) ( ( mul_1 + mul_4 ) >> 32 ) << RADIXSHIFT ; mul_10 = ixheaacd_mult64 ( xt1_0 , si10 ) ; mul_7 = ixheaacd_mult64 ( yt1_0 , co10 ) ; x [ h2 + 1 ] = ( WORD32 ) ( ( mul_7 - mul_10 ) >> 32 ) << RADIXSHIFT ; x += 2 ; } x += fft_jmp ; w_ptr = w_ptr - fft_jmp ; } }
","<S2SV_ModStart> , fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , yt0_0 <S2SV_ModStart> , yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , xh1_0 <S2SV_ModStart> ; xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xl0_0 <S2SV_ModStart> ; xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xh20_0 <S2SV_ModStart> ; xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; xl20_0 <S2SV_ModStart> ; xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; x <S2SV_ModStart> 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> ; xt0_0 = <S2SV_ModStart> ; xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> xh20_0 ; x_1 <S2SV_ModStart> ; xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xl1_0 <S2SV_ModStart> ; xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xh21_0 <S2SV_ModStart> ; xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; xl21_0 <S2SV_ModStart> ; xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; x <S2SV_ModStart> 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> ; yt0_0 = <S2SV_ModStart> ; yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> xh21_0 ; xt1_0 <S2SV_ModStart> ; xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> xl21_0 ; xt2_0 <S2SV_ModStart> ; xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> xl21_0 ; yt2_0 <S2SV_ModStart> ; yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> xl20_0 ; yt1_0 <S2SV_ModStart> ; yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> xl20_0 ; mul_11
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,958,"<S2SV_ModStart>, h2, fft_jmp ; WORD32 xt0_0, yt1_0, yt2_0 ; WORD32 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0 ; WORD32 x_0, x_1, x_l1_0, x_l1_1 ; x_l2_0, x_l2_1 ; x_h2_0 = x [ h2 ] ; x_h2_0 = x [ h2 ] ; x_h2_1 = x [ h2 ] ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_l1 = & ( x [ l1 ] ) ; x_l1 = & ( x [ l1 ] ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; x_h2 =",0
975,CWE-787,"CWE-787 opj_image_t * pgxtoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f = NULL ; int w , h , prec ; int i , numcomps , max ; OPJ_COLOR_SPACE color_space ; opj_image_cmptparm_t cmptparm ; opj_image_t * image = NULL ; int adjustS , ushift , dshift , force8 ; char endian1 , endian2 , sign ; char signtmp [ 32 ] ; char temp [ 32 ] ; int bigendian ; opj_image_comp_t * comp = NULL ; numcomps = 1 ; color_space = OPJ_CLRSPC_GRAY ; memset ( & cmptparm , 0 , sizeof ( opj_image_cmptparm_t ) ) ; max = 0 ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!\\n"" , filename ) ; return NULL ; } fseek ( f , 0 , SEEK_SET ) ; <S2SV_StartBug> if ( fscanf ( f , ""PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d"" , temp , & endian1 , <S2SV_EndBug> & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose ( f ) ; fprintf ( stderr , ""ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>right<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>from<S2SV_blank>the<S2SV_blank>fscanf()<S2SV_blank>function!\\n"" ) ; return NULL ; } i = 0 ; sign = '+' ; while ( signtmp [ i ] != '\\0' ) { if ( signtmp [ i ] == '-' ) { sign = '-' ; } i ++ ; } fgetc ( f ) ; if ( endian1 == 'M' && endian2 == 'L' ) { bigendian = 1 ; } else if ( endian2 == 'M' && endian1 == 'L' ) { bigendian = 0 ; } else { fclose ( f ) ; fprintf ( stderr , ""Bad<S2SV_blank>pgx<S2SV_blank>header,<S2SV_blank>please<S2SV_blank>check<S2SV_blank>input<S2SV_blank>file\\n"" ) ; return NULL ; } cmptparm . x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; cmptparm . y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; cmptparm . w = ! cmptparm . x0 ? ( OPJ_UINT32 ) ( ( w - 1 ) * parameters -> subsampling_dx + 1 ) : cmptparm . x0 + ( OPJ_UINT32 ) ( w - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1 ; cmptparm . h = ! cmptparm . y0 ? ( OPJ_UINT32 ) ( ( h - 1 ) * parameters -> subsampling_dy + 1 ) : cmptparm . y0 + ( OPJ_UINT32 ) ( h - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1 ; if ( sign == '-' ) { cmptparm . sgnd = 1 ; } else { cmptparm . sgnd = 0 ; } if ( prec < 8 ) { force8 = 1 ; ushift = 8 - prec ; dshift = prec - ushift ; if ( cmptparm . sgnd ) { adjustS = ( 1 << ( prec - 1 ) ) ; } else { adjustS = 0 ; } cmptparm . sgnd = 0 ; prec = 8 ; } else { ushift = dshift = force8 = adjustS = 0 ; } cmptparm . prec = ( OPJ_UINT32 ) prec ; cmptparm . bpp = ( OPJ_UINT32 ) prec ; cmptparm . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = cmptparm . x0 ; image -> y0 = cmptparm . x0 ; image -> x1 = cmptparm . w ; image -> y1 = cmptparm . h ; comp = & image -> comps [ 0 ] ; for ( i = 0 ; i < w * h ; i ++ ) { int v ; if ( force8 ) { v = readuchar ( f ) + adjustS ; v = ( v << ushift ) + ( v >> dshift ) ; comp -> data [ i ] = ( unsigned char ) v ; if ( v > max ) { max = v ; } continue ; } if ( comp -> prec == 8 ) { if ( ! comp -> sgnd ) { v = readuchar ( f ) ; } else { v = ( char ) readuchar ( f ) ; } } else if ( comp -> prec <= 16 ) { if ( ! comp -> sgnd ) { v = readushort ( f , bigendian ) ; } else { v = ( short ) readushort ( f , bigendian ) ; } } else { if ( ! comp -> sgnd ) { v = ( int ) readuint ( f , bigendian ) ; } else { v = ( int ) readuint ( f , bigendian ) ; } } if ( v > max ) { max = v ; } comp -> data [ i ] = v ; } fclose ( f ) ; comp -> bpp = ( OPJ_UINT32 ) int_floorlog2 ( max ) + 1 ; return image ; }
","<S2SV_ModStart> ( f , ""PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d"" <S2SV_ModEnd> , temp ,
",uclouvain@openjpeg/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,CVE-2017-14041,https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,2017-08-30T22:29Z,975,"<S2SV_ModStart>, ""PG%[ <S2SV_blank> \\t]%c%c%[ <S2SV_blank> \\t+-]%d%[ <S2SV_blank> \\t]%d%[ <S2SV_blank> \\t]%d%[ <S2SV_blank> \\t]%d"", temp, & prec, temp, & w, temp, & h )!= 9 ) { fclose ( f ) ; fprintf ( stderr, ""ERROR: <S2SV_blank> Failed <S2SV_blank> to <S2SV_blank> read <S2SV_blank> the <S2SV_blank> right <S2SV_blank> number <S2SV_blank> of <S2SV_blank> element <S2SV_blank> from <S2SV_blank> the <S2SV_blank> fscanf() <S2SV_blank> function!\\n"" ) ; return NULL ; } if ( fscanf ( f, ""PG%[ <S2SV_blank> \\t]%c%c%[ <S2SV_blank> \\t+-]%d%[ <S2SV_blank> \\t]%d"", temp, & prec, temp, & w, temp, & h )!= 9 ) { fclose ( f ) ; fprintf ( stderr, ""ERROR: <S2SV_blank> Failed <S2SV_blank> to <S2SV_blank> read <S2SV_blank> the <S2SV_blank> right <S2SV_blank> number <S2SV_blank> of <S2SV_blank> element <S2SV_blank> from <S2SV_blank> the <S2SV_blank> fscanf() <S2SV_blank> function!\\n"" ) ; return NULL ; } if ( fscanf ( f, ""PG%[ <S2SV_blank> \\t]%c%c%[ <S2SV_blank> \\t+-]%",0
976,CWE-787,"CWE-787 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; <S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
",coreutils@gnulib/278b4175c9d7dd47c1a3071554aac02add3b3c35,CVE-2018-17942,https://github.com/coreutils/gnulib/commit/278b4175c9d7dd47c1a3071554aac02add3b3c35,2018-10-03T08:29Z,976,"<S2SV_ModStart> < 6 ) ASSERT ( result!= NULL <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf, ""DEADBEEF"", 8 ) ; length = size ; result = my_asnprintf ( buf, & length, ""%d"", 12345 ) ; ASSERT ( result!= NULL ) ; ASSERT ( strcmp ( result, ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; if ( size < 8 ) ASSERT ( result!= buf ) ; ASSERT ( memcmp ( buf + size, & ""DEADBEEF"" [ size ], 8 - size ) == 0 ) ; if ( result!= buf ) free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf, ""DEADBEEF"", 8 ) ; length = size ; result = my_asnprintf ( buf, & length, ""%d"", 12345 ) ; ASSERT ( result!= NULL ) ; ASSERT ( strcmp ( result, ""12345"" ) == 0 ) ; ASSERT (",0
994,CWE-787,"CWE-787 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; <S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> } }
","<S2SV_ModStart> = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
",external@libmpeg2/bef16671c891e16f25a7b174bc528eea109357be,CVE-2018-9497,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be,2018-10-02T19:29Z,994,<S2SV_ModStart> = 0 ; ps_op -> s_ivd_video_decode_op_t. u4_ip_num_bytes = ps_ip -> s_ivd_video_decode_ip_t. u4_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_pic_num_bytes = ps_ip -> s_ivd_video_decode_ip_t. u4_pic_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_pic_num_bytes = ps_ip -> s_ivd_video_decode_ip_t. u4_pic_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_pic_num_bytes = ps_ip -> s_ivd_video_decode_ip_t. u4_pic_num_Bytes ; ps_op -> s_ivd_video_decode_op_t. u4_pic_num_bytes = ps_ip -> s_ivd_video_decode_ip_t. u,0
1006,CWE-787,"CWE-787 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { # ifndef _MSC_VER char buf [ EXT2_BLOCK_SIZE ( data ) ] ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return fileblock + start ; } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; return - 1 ; } } <S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> < INDIRECT_BLOCKS ) { <S2SV_ModStart> ] ) ; }
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,1006,"<S2SV_ModStart> ] ) ; if ( fileblock < grub_le_to_cpu32 ( leaf -> entries ) ) { grub_error ( GRUB_ERR_BAD_FS, ""file <S2SV_blank> out <S2SV_blank> of <S2SV_blank> range"" ) ; return - 1 ; }",0
1010,CWE-787,"CWE-787 <S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , ""?[%d]"" , token ) ; }
","<S2SV_ModStart> len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""UNFINISHED<S2SV_blank>COMMENT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str
",espruino@Espruino/bed844f109b6c222816740555068de2e101e8018,CVE-2018-11593,https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018,2018-05-31T16:29Z,1010,"<S2SV_ModStart> len ) { assert ( len > 0 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""EOF"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""ID"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""INT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""FLOAT"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""UNFINISHED <S2SV_blank> STRING"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""UNFINISHED <S2SV_blank> TEMPLATE <S2SV_blank> LITERAL"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""UNFINISHED <S2SV_blank> REGEX"" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str, <S2SV_ModStart> str, ""UN",0
1053,CWE-787,"CWE-787 static int l2cap_build_conf_req ( struct sock * sk , void * data ) { struct l2cap_pinfo * pi = l2cap_pi ( sk ) ; struct l2cap_conf_req * req = data ; <S2SV_StartBug> struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; <S2SV_EndBug> void * ptr = req -> data ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; <S2SV_StartBug> switch ( pi -> mode ) { <S2SV_EndBug> case L2CAP_MODE_BASIC : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ; break ; case L2CAP_MODE_ERTM : rfc . mode = L2CAP_MODE_ERTM ; <S2SV_StartBug> rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; <S2SV_EndBug> rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ; <S2SV_StartBug> rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; <S2SV_EndBug> <S2SV_StartBug> rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; <S2SV_EndBug> rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; } req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> flags = cpu_to_le16 ( 0 ) ; return ptr - data ; }
","<S2SV_ModStart> . mode = L2CAP_MODE_ERTM <S2SV_ModEnd> } ; void <S2SV_ModStart> sk ) ; if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> . txwin_size = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . retrans_timeout = 0 <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . monitor_timeout = 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ; rfc .
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z,1053,"<S2SV_ModStart> ; struct l2cap_conf_rfc rfc = { } <S2SV_ModStart> sk ) ; BT_DBG ( ""sk <S2SV_blank> %p"", sk ) ; <S2SV_ModStart> = L2CAP_MODE_ERTM ; rfc. txwin_size = L2CAP_DEFAULT_TX_WINDOW ; rfc. max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ; rfc. retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; rfc. monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; rfc. max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; rfc.",0
1086,CWE-787,"CWE-787 VOID ixheaacd_esbr_postradixcompute2 ( WORD32 * ptr_y , WORD32 * ptr_x , const WORD32 * pdig_rev_tbl , WORD32 npoints ) { WORD32 i , k ; WORD32 h2 ; WORD32 x_0 , x_1 , x_2 , x_3 ; WORD32 x_4 , x_5 , x_6 , x_7 ; <S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ; WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ; WORD32 n0 , j0 ; WORD32 * x2 , * x0 ; WORD32 * y0 , * y1 , * y2 , * y3 ; y0 = ptr_y ; y2 = ptr_y + ( WORD32 ) npoints ; x0 = ptr_x ; x2 = ptr_x + ( WORD32 ) ( npoints >> 1 ) ; y1 = y0 + ( WORD32 ) ( npoints >> 2 ) ; y3 = y2 + ( WORD32 ) ( npoints >> 2 ) ; j0 = 8 ; n0 = npoints >> 1 ; for ( k = 0 ; k < 2 ; k ++ ) { for ( i = 0 ; i < npoints >> 1 ; i += 8 ) { h2 = * pdig_rev_tbl ++ >> 2 ; x_0 = * x0 ++ ; x_1 = * x0 ++ ; x_2 = * x0 ++ ; x_3 = * x0 ++ ; x_4 = * x0 ++ ; x_5 = * x0 ++ ; x_6 = * x0 ++ ; x_7 = * x0 ++ ; <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> n01 = x_1 + x_3 ; n20 = x_0 - x_2 ; n21 = x_1 - x_3 ; n10 = x_4 + x_6 ; n11 = x_5 + x_7 ; n30 = x_4 - x_6 ; n31 = x_5 - x_7 ; y0 [ h2 ] = n00 ; y0 [ h2 + 1 ] = n01 ; <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> y2 [ h2 ] = n20 ; y2 [ h2 + 1 ] = n21 ; <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; n02 = x_8 + x_a ; n03 = x_9 + x_b ; n22 = x_8 - x_a ; n23 = x_9 - x_b ; n12 = x_c + x_e ; n13 = x_d + x_f ; n32 = x_c - x_e ; n33 = x_d - x_f ; y0 [ h2 + 2 ] = n02 ; y0 [ h2 + 3 ] = n03 ; y1 [ h2 + 2 ] = n12 ; y1 [ h2 + 3 ] = n13 ; y2 [ h2 + 2 ] = n22 ; y2 [ h2 + 3 ] = n23 ; y3 [ h2 + 2 ] = n32 ; y3 [ h2 + 3 ] = n33 ; } x0 += ( WORD32 ) npoints >> 1 ; x2 += ( WORD32 ) npoints >> 1 ; } }
","<S2SV_ModStart> x_e , x_f <S2SV_ModEnd> ; WORD32 n0 <S2SV_ModStart> x0 ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; } x0
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z,1086,"<S2SV_ModStart>, x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f ; WORD32 n00, n10, n11, n21, n31, n01, n12, n13, n23, n33 ; WORD32 n00, n10, n20, n01, n12, n22, n32, n03, n13, n23, n33 ; n00 = x_0 + x_2 ; n01 = x_1 + x_3 ; n11 = x_1 - x_2 ; n12 = x_0 + x_3 ; n22 = x_1 - x_3 ; n03 = x_4 + x_6 ; n13 = x_5 + x_7 ; n13 = x_4 + x_6 ; n23 = x_5 + x_7 ; n23 = x_1 - x_3 ; n30 = x_0 - x_2 ; n02 = x_1 + x_3 ; n12 = x_2 + x_4 ; n13 = x_1 - x_3",0
1136,CWE-787,"CWE-787 static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>"" ""beginning<S2SV_blank>of<S2SV_blank>image.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>SOI<S2SV_blank>marker<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>first<S2SV_blank>"" ""marker<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>SOI.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""no<S2SV_blank>image<S2SV_blank>content<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i + 1 < frag -> data_size ; i ++ ) { if ( frag -> data [ i ] != 0xff ) continue ; end = i ; for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { if ( frag -> data [ i ] == 0x00 ) continue ; next_marker = frag -> data [ i ] ; next_start = i + 1 ; } break ; } } else { i = start ; if ( i + 2 > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } length = AV_RB16 ( frag -> data + i ) ; if ( i + length > frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>JPEG<S2SV_blank>image:<S2SV_blank>"" ""truncated<S2SV_blank>at<S2SV_blank>%02x<S2SV_blank>marker<S2SV_blank>segment.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } end = start + length ; i = end ; if ( frag -> data [ i ] != 0xff ) { next_marker = - 1 ; } else { for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { next_marker = - 1 ; } else { next_marker = frag -> data [ i ] ; next_start = i + 1 ; } } } if ( marker == JPEG_MARKER_SOS ) { length = AV_RB16 ( frag -> data + start ) ; <S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! data ) return AVERROR ( ENOMEM ) ; memcpy ( data , frag -> data + start , length ) ; for ( i = start + length , j = length ; i < end ; i ++ , j ++ ) { if ( frag -> data [ i ] == 0xff ) { while ( frag -> data [ i ] == 0xff ) ++ i ; data [ j ] = 0xff ; } else { data [ j ] = frag -> data [ i ] ; } } data_size = j ; memset ( data + data_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; } else { data = frag -> data + start ; data_size = end - start ; data_ref = frag -> data_ref ; } err = ff_cbs_insert_unit_data ( ctx , frag , unit , marker , data , data_size , data_ref ) ; if ( err < 0 ) return err ; if ( next_marker == - 1 ) break ; marker = next_marker ; start = next_start ; } return 0 ; }
","<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z,1136,"<S2SV_ModStart> + 1 ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> no <S2SV_blank> SOI <S2SV_blank> marker <S2SV_blank> found.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> first <S2SV_blank> "" <S2SV_ModStart> + 1 ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> marker <S2SV_blank> is <S2SV_blank> %02x, <S2SV_blank> should <S2SV_blank> be <S2SV_blank> SOS.\\n"", marker ) ; return AVERROR_INVALIDDATA ; } if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx, AV_LOG_ERROR, ""Invalid <S2SV_blank> JPEG <S2SV_blank> image: <S2SV_blank> first <S2SV_blank> "" ""marker <S2SV_blank> is <S2SV_blank> %02x, <S2SV_blank> should <S2SV_blank> be <S2SV_blank> SOI.\\n"", marker ) ; return AVERROR_INVALIDDATA ; }",0
1167,CWE-787,"CWE-787 static int gtStripSeparate ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileSeparateRoutine put = img -> put . separate ; unsigned char * buf = NULL ; unsigned char * p0 = NULL , * p1 = NULL , * p2 = NULL , * pa = NULL ; uint32 row , y , nrow , rowstoread ; tmsize_t pos ; tmsize_t scanline ; uint32 rowsperstrip , offset_row ; uint32 imagewidth = img -> width ; tmsize_t stripsize ; tmsize_t bufsize ; int32 fromskew , toskew ; int alpha = img -> alpha ; int ret = 1 , flip ; uint16 colorchannels ; stripsize = TIFFStripSize ( tif ) ; bufsize = _TIFFMultiplySSize ( tif , alpha ? 4 : 3 , stripsize , ""gtStripSeparate"" ) ; if ( bufsize == 0 ) { return ( 0 ) ; } flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } switch ( img -> photometric ) { case PHOTOMETRIC_MINISWHITE : case PHOTOMETRIC_MINISBLACK : case PHOTOMETRIC_PALETTE : colorchannels = 1 ; break ; default : colorchannels = 3 ; break ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) { <S2SV_StartBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; <S2SV_EndBug> nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; offset_row = row + img -> row_offset ; <S2SV_StartBug> if ( buf == NULL ) <S2SV_EndBug> { if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , ( void * * ) & buf , bufsize , <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && ( buf == NULL || img -> stoponerr ) ) { ret = 0 ; break ; } p0 = buf ; if ( colorchannels == 1 ) { p2 = p1 = p0 ; pa = ( alpha ? ( p0 + 3 * stripsize ) : NULL ) ; } else { p1 = p0 + stripsize ; p2 = p1 + stripsize ; pa = ( alpha ? ( p2 + stripsize ) : NULL ) ; } } else if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , <S2SV_StartBug> p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 1 ) , <S2SV_StartBug> p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 2 ) , <S2SV_StartBug> p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } if ( alpha ) { if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , <S2SV_StartBug> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> && img -> stoponerr ) { ret = 0 ; break ; } } pos = ( ( row + img -> row_offset ) % rowsperstrip ) * scanline + ( ( tmsize_t ) img -> col_offset * img -> samplesperpixel ) ; ( * put ) ( img , raster + y * w , 0 , y , w , nrow , fromskew , toskew , p0 + pos , p1 + pos , p2 + pos , ( alpha ? ( pa + pos ) : NULL ) ) ; y += ( ( flip & FLIP_VERTICALLY ) ? - ( int32 ) nrow : ( int32 ) nrow ) ; } if ( flip & FLIP_HORIZONTALLY ) { uint32 line ; for ( line = 0 ; line < h ; line ++ ) { uint32 * left = raster + ( line * w ) ; uint32 * right = left + w - 1 ; while ( left < right ) { uint32 temp = * left ; * left = * right ; * right = temp ; left ++ ; right -- ; } } } _TIFFfree ( buf ) ; return ( ret ) ; }
","<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ; return 0 ; } <S2SV_ModStart> , bufsize , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p0 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p1 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p2 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , pa , temp <S2SV_ModEnd> * scanline )
",OSGeo@gdal/21674033ee246f698887604c7af7ba1962a40ddf,CVE-2019-17546,https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf,2019-10-14T02:15Z,1167,"<S2SV_ModStart> nrow ) { if ( _TIFFGetFieldDefaulted ( tif, TIFFTAG_ROWSPERSTRIP, & rowsperstrip ) < 0 ) { TIFFErrorExt ( tif, ""gtStripSeparate"", ""%s"", ""(row+img->row_offset) <S2SV_blank> is <S2SV_blank> out <S2SV_blank> of <S2SV_blank> bounds"" ) ; return ( 0 ) ; } rowstoread = ( row + img -> row_offset ) % rowsperstrip ; nrow = ( row + rowstoread > h? h - row : rowstoread ) ; buf = ( unsigned char * ) _TIFFReadEncodedStripAndAllocBuffer ( tif, bufsize, ""gtStripSeparate"" ) ; if ( buf == NULL ) { TIFFErrorExt ( tif, ""gtStripSeparate"", ""%s"", ""(row+img->row_offset) <S2SV_blank> is <S2SV_blank> out <S2SV_blank> of <S2SV_blank> bounds"" ) ; return ( 0 ) ; }",0
1188,CWE-787,"CWE-787 void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = AF_INET ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } FD_ZERO ( & read_fd ) ; FD_SET ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , NULL , NULL , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?WATCH={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } while ( G . do_exit == 0 ) { usleep ( 500000 ) ; memset ( G . gps_loc , 0 , sizeof ( float ) * 5 ) ; if ( is_json ) { if ( pos == sizeof ( line ) ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } <S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug> return ; temp = strstr ( line , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { continue ; } if ( strchr ( temp , '}' ) == NULL ) { pos = strlen ( temp ) ; if ( temp != line ) { memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } temp = strstr ( temp , ""\\""lat\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 0 ] ) ; temp = strstr ( temp , ""\\""lon\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 1 ] ) ; temp = strstr ( temp , ""\\""alt\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 4 ] ) ; temp = strstr ( temp , ""\\""speed\\"":"" ) ; if ( temp == NULL ) { continue ; } ret = sscanf ( temp + 6 , ""%f"" , & G . gps_loc [ 2 ] ) ; temp = strstr ( temp , ""{\\""class\\"":\\""TPV\\"""" ) ; if ( temp == NULL ) { memset ( line , 0 , sizeof ( line ) ) ; pos = 0 ; } else { pos = strlen ( temp ) ; memmove ( line , temp , pos ) ; memset ( line + pos , 0 , sizeof ( line ) - pos ) ; } } else { memset ( line , 0 , sizeof ( line ) ) ; snprintf ( line , sizeof ( line ) - 1 , ""PVTAD\\r\\n"" ) ; if ( send ( gpsd_sock , line , 7 , 0 ) != 7 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( memcmp ( line , ""GPSD,P="" , 7 ) != 0 ) continue ; if ( line [ 7 ] == '?' ) continue ; ret = sscanf ( line + 7 , ""%f<S2SV_blank>%f"" , & G . gps_loc [ 0 ] , & G . gps_loc [ 1 ] ) ; if ( ( temp = strstr ( line , ""V="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 2 ] ) ; if ( ( temp = strstr ( line , ""T="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 3 ] ) ; if ( ( temp = strstr ( line , ""A="" ) ) == NULL ) continue ; ret = sscanf ( temp + 2 , ""%f"" , & G . gps_loc [ 4 ] ) ; } if ( G . record_data ) fputs ( line , G . f_gps ) ; G . save_gps = 1 ; if ( G . do_exit == 0 ) { unused = write ( G . gc_pipe [ 1 ] , G . gps_loc , sizeof ( float ) * 5 ) ; kill ( getppid ( ) , SIGUSR2 ) ; } } }
","<S2SV_ModStart> line ) - pos -
",aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z,1188,"<S2SV_ModStart> } if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } if ( strncmp ( line, ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"", 32 ) == 0 ) { close ( gpsd_sock ) ; return ; }",0
1232,CWE-787,"CWE-787 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; <S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
","<S2SV_ModStart> = act_code ; if ( npix > 0 ) <S2SV_ModStart> = casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - stackp <S2SV_ModStart> - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= (
",miniupnp@ngiflib/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,CVE-2018-10717,https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,2018-05-03T17:29Z,1232,"<S2SV_ModStart> ; # endif if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log, ""*** <S2SV_blank> WARNING <S2SV_blank> *** <S2SV_blank> Adjusting <S2SV_blank> X <S2SV_blank> position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log, ""*** <S2SV_blank> WARNING <S2SV_blank> *** <S2SV_blank> Adjusting <S2SV_blank> Y <S2SV_blank> position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log, ""*** <S2SV_blank> WARNING <S2SV_blank> *** <S2SV_blank> Adjusting <S2SV_blank> X <S2SV_blank> position\\n"" ) ; # endif i -> posX =",0
1239,CWE-787,"CWE-787 <S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }
","<S2SV_ModStart> UINT32 nsc_rle_encode ( const
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,1239,<S2SV_ModStart> UINT32 nsc_rle_encode ( const,1
1311,CWE-787,"CWE-787 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
","<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false
",radare@radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf,CVE-2018-20460,https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,2018-12-25T19:29Z,1311,"<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too <S2SV_blank> many <S2SV_blank> operands\\n"" ) ; return false",1
1313,CWE-787,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z,1313,"<S2SV_ModStart> name ) { size_t max_name_len = strlen ( name ) * 2 + 16 ; if ( max_name_len > max_name_len ) { ERR ( ""Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> (%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", max_name_len, ( int ) ( max_name_len / 2 ) ) ; dst_name = malloc ( max_name_len / 2 ) ; if (! dst_name ) { ERR ( ""Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> (%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", max_name_len, ( int ) ( max_name_len / 2 ) ) ; } dst_name = malloc ( max_name_len * 2 + 16 ) ; if (! ( dst_name ) ) dst_name = malloc ( max_name_len / 2 ) ; if (! dst_name ) { ERR ( ""Maximum <S2SV_blank> number <S2SV_blank> of <S2SV_blank> components <S2SV_blank> (%d) <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", max_name_len, ( int ) ( max_name_",0
1354,CWE-787,"CWE-787 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
","<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,1354,"<S2SV_ModStart> int tagval, uint32 <S2SV_ModEnd> * length )",1
1426,CWE-787,"CWE-787 static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) { <S2SV_StartBug> int v , i ; <S2SV_EndBug> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || <S2SV_StartBug> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }
","<S2SV_ModStart> , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> != 6 ) || s -> bit_depth == 1
",FFmpeg@FFmpeg/e477f09d0b3619f3d29173b2cd593e17e2d1978e,CVE-2017-7863,https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e,2017-04-14T04:59Z,1426,"<S2SV_ModStart>, i ; if (! ( s -> state & PNG_IHDR ) ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> before <S2SV_blank> IHDR"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> before <S2SV_blank> IDAT"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> after <S2SV_blank> IDAT"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> before <S2SV_blank> IDAT"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx, AV_LOG_ERROR, ""trns <S2SV_blank> after <S2SV_blank> IDAT"" ) ; return AVERROR_INVALIDDATA ; }",0
1437,CWE-787,"CWE-787 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
",ImageMagick@ImageMagick/19651f3db63fa1511ed83a348c4c82fa553f8d01,CVE-2019-13308,https://github.com/ImageMagick/ImageMagick/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01,2019-07-05T01:15Z,1437,<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> MaxGIFBits ) ; \\\n} <S2SV_ModEnd> # define IndexPacket,0
1444,CWE-787,"CWE-787 static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; <S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }
","<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev )
",torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z,1444,"<S2SV_ModStart> ; if (! nl ) { struct dm_dev_info * dev_info ; <S2SV_ModStart> needed ) ; dev_info = dm_disk_dev ( disk ) ; dm_device_info_init ( & dev_info -> dev, dev_info -> bdev -> bd_dev ) ; if ( dev_info -> bdev -> bd_dev_info [ dev_info -> bd_dev_info [ dev_info -> bd_dev_info [ 0 ] -> bd_dev_info [ dev_info -> bdev_info [ dev_info -> bd_dev_info [ dev_info -> bd_dev_info [ 0 ] -> bd_dev ], dev_info -> bdev_info [ dev_info -> bdev -> bd_dev ] ) ; if ( dev_info -> bd_dev_info [ dev_info -> bd_dev_info [ dev_info -> bd_dev_info [ 0 ] -> bd_dev_info [ 0 ] -> bd_dev_info [ dev_info -> bd_dev_info [ dev_info -> bd_dev_info [ 0 ] -> bd_dev_info [ 0 ] -> bd_dev_info [",0
1461,CWE-787,"CWE-787 MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; <S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }
","<S2SV_ModStart> = NULL ; reader . recursive_counter = 0 ;
",hoene@libmysofa/2e6fac6ab6156dae8e8c6f417741388084b70d6f,CVE-2019-20016,https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f,2019-12-27T02:15Z,1461,<S2SV_ModStart> = NULL ; if ( reader. superblock == NULL ) { reader. superblock = & mysofa_superblock ; } else { reader. superblock = mysofa_superblockCreate ( <S2SV_ModEnd> reader. gcol <S2SV_ModStart> gcol ) ; },0
1512,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,1512,<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> BYTE a_val ; if (! context ) return FALSE <S2SV_ModStart> ; } } return TRUE ;,0
1537,CWE-787,"CWE-787 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
","<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,1537,"<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s ; struct stream packet = * s ; if (! s_check_rem ( s, length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(), <S2SV_blank> consume <S2SV_blank> domain <S2SV_blank> params <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } <S2SV_ModStart> length ) ; if (! s_check_rem ( s, length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(), <S2SV_blank> consume <S2SV_blank> domain <S2SV_blank> params <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; }",0
1547,CWE-787,"CWE-787 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
",miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a,CVE-2019-16347,https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a,2019-09-16T13:15Z,1547,<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; },1
1561,CWE-787,"CWE-787 PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rdd"" , & IM , & input , & output ) == FAILURE ) { return ; } <S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }
","<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; }
",php@php-src/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae,CVE-2016-7127,https://github.com/php/php-src/commit/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae?w=1,2016-09-12T01:59Z,1561,"<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC, E_WARNING, ""Gamma <S2SV_blank> values <S2SV_blank> should <S2SV_blank> be <S2SV_blank> positive"" ) ; RETURN_FALSE ; }",1
1611,CWE-787,"CWE-787 void process_bitmap_updates ( STREAM s ) { <S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),<S2SV_blank>[%d,%d,%d,%d],<S2SV_blank>[%d,%d],<S2SV_blank>bpp=%d,<S2SV_blank>compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_uint8s ( s , 4 ) ; } in_uint8p ( s , data , size ) ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; if ( bitmap_decompress ( bmpdata , width , height , data , size , Bpp ) ) { ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; } else { logger ( Graphics , Warning , ""process_bitmap_updates(),<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>bitmap"" ) ; } xfree ( bmpdata ) ; } }
","<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z,1611,"<S2SV_ModStart> { uint16 num_updates = 0 <S2SV_ModStart> int i ; struct stream packet = * s ; struct stream packet2 ; <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 * sizeof ( packet ) ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> of <S2SV_blank> bitmap <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; } <S2SV_ModStart> ++ ) { if (! s_check_rem ( s, 2 * sizeof ( packet ) ) ) { rdp_protocol_error ( ""process_bitmap_updates(), <S2SV_blank> consume <S2SV_blank> of <S2SV_blank> bitmap <S2SV_blank> from <S2SV_blank> stream <S2SV_blank> would <S2SV_blank> overrun"", & packet ) ; }",0
1627,CWE-787,"CWE-787 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z,1627,"<S2SV_ModStart> 4 ) ; if ( idx + 4 > len ) return NULL ; <S2SV_ModStart> ]. len ) ; CHECKINT16 ( idx, len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx, len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID, 1 ) ; copy_guid_from_buf ( a -> guid, buf + idx, len ) ; idx += sizeof ( GUID ) ; } } else { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData, a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx, len ) ; a -> names [ i ]. data = CHECKED_XMALLOC ( unsigned char, a -> names [ i ]. len ) ; for ( j = 0 ; j < a -> names [ i ]. len ; j ++ ) a -> names [ i ]. data [ j ] =",0
1664,CWE-787,"CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:<S2SV_blank>%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; } } return - 1 ;
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z,1664,"<S2SV_ModStart> ; } } if ( strtok ( g -> data, "";"" ) ) { eprintf ( ""action: <S2SV_blank> %s\\n"", action ) ; switch ( action [ 0 ] ) { case 'i' : if ( cmd_cb ( core_ptr, ""ic"", NULL, 0 ) < 0 ) { send_msg ( g, ""E01"" ) ; return - 1 ; } return send_msg ( g, ""E01"" ) ; } switch ( action [ 0 ] ) { case 'u' : if ( cmd_cb ( core_ptr, ""ic"", NULL, 0 ) < 0 ) { send_msg ( g, ""E01"" ) ; return - 1 ; } return send_msg ( g, ""E01"" ) ; } if ( strtok ( NULL, "";"" ) ) { eprintf ( ""action: <S2SV_blank> %s\\n"", action ) ; switch ( action [ 0 ] ) { case's' : if ( cmd_cb ( core_ptr, ""ds"", NULL, 0 ) < 0 ) { send_msg ( g, ""E01"" ) ; return - 1 ; } return send_msg ( g, ""E01",0
1685,CWE-787,"CWE-787 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( t2p -> tiff_dataoffset != 0 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( t2p -> pdf_ojpegiflength == 0 ) { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; t2pReadFile ( input , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } else { inputoffset = t2pSeekFile ( input , 0 , SEEK_CUR ) ; t2pSeekFile ( input , t2p -> tiff_dataoffset , SEEK_SET ) ; bufferoffset = t2pReadFile ( input , ( tdata_t ) buffer , t2p -> pdf_ojpegiflength ) ; t2p -> pdf_ojpegiflength = 0 ; t2pSeekFile ( input , inputoffset , SEEK_SET ) ; TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & h_samp , & v_samp ) ; buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xdd ; buffer [ bufferoffset ++ ] = 0x00 ; buffer [ bufferoffset ++ ] = 0x04 ; h_samp *= 8 ; v_samp *= 8 ; ri = ( t2p -> tiff_width + h_samp - 1 ) / h_samp ; TIFFGetField ( input , TIFFTAG_ROWSPERSTRIP , & rows ) ; ri *= ( rows + v_samp - 1 ) / v_samp ; buffer [ bufferoffset ++ ] = ( ri >> 8 ) & 0xff ; buffer [ bufferoffset ++ ] = ri & 0xff ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } } else { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; bufferoffset = t2p -> pdf_ojpegdatalength ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( i != 0 ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = ( 0xd0 | ( ( i - 1 ) % 8 ) ) ; } bufferoffset += TIFFReadRawStrip ( input , i , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; } if ( ! ( ( buffer [ bufferoffset - 1 ] == 0xd9 ) && ( buffer [ bufferoffset - 2 ] == 0xff ) ) ) { buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; # if 0 TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>JPEG<S2SV_blank>File<S2SV_blank>Interchange<S2SV_blank>offset"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; # endif } } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { if ( count > 4 ) { _TIFFmemcpy ( buffer , jpt , count ) ; bufferoffset += count - 2 ; } } stripcount = TIFFNumberOfStrips ( input ) ; TIFFGetField ( input , TIFFTAG_STRIPBYTECOUNTS , & sbc ) ; for ( i = 0 ; i < stripcount ; i ++ ) { if ( sbc [ i ] > max_striplength ) max_striplength = sbc [ i ] ; } stripbuffer = ( unsigned char * ) _TIFFmalloc ( max_striplength ) ; if ( stripbuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , max_striplength , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { striplength = TIFFReadRawStrip ( input , i , ( tdata_t ) stripbuffer , - 1 ) ; if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , <S2SV_StartBug> & bufferoffset , <S2SV_EndBug> i , t2p -> tiff_length ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>process<S2SV_blank>JPEG<S2SV_blank>data<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } buffer [ bufferoffset ++ ] = 0xff ; buffer [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( stripbuffer ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } } else { if ( t2p -> pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { sepstripsize = TIFFStripSize ( input ) ; sepstripcount = TIFFNumberOfStrips ( input ) ; stripsize = sepstripsize * t2p -> tiff_samplesperpixel ; stripcount = sepstripcount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; samplebuffer = ( unsigned char * ) _TIFFmalloc ( stripsize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } for ( i = 0 ; i < stripcount ; i ++ ) { samplebufferoffset = 0 ; for ( j = 0 ; j < t2p -> tiff_samplesperpixel ; j ++ ) { read = TIFFReadEncodedStrip ( input , i + j * stripcount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , TIFFmin ( sepstripsize , stripsize - samplebufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i + j * stripcount , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; } _TIFFfree ( samplebuffer ) ; goto dataready ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } memset ( buffer , 0 , t2p -> tiff_datasize ) ; stripsize = TIFFStripSize ( input ) ; stripcount = TIFFNumberOfStrips ( input ) ; for ( i = 0 ; i < stripcount ; i ++ ) { read = TIFFReadEncodedStrip ( input , i , ( tdata_t ) & buffer [ bufferoffset ] , TIFFmin ( stripsize , t2p -> tiff_datasize - bufferoffset ) ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>strip<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , i , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += read ; } if ( t2p -> pdf_sample & T2P_SAMPLE_REALIZE_PALETTE ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_datasize * t2p -> tiff_samplesperpixel ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; t2p -> tiff_datasize *= t2p -> tiff_samplesperpixel ; } t2p_sample_realize_palette ( t2p , buffer ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { samplebuffer = ( unsigned char * ) _TIFFrealloc ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length * 4 ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; _TIFFfree ( buffer ) ; return ( 0 ) ; } else { buffer = samplebuffer ; } if ( ! TIFFReadRGBAImageOriented ( input , t2p -> tiff_width , t2p -> tiff_length , ( uint32 * ) buffer , ORIENTATION_TOPLEFT , 0 ) ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>use<S2SV_blank>TIFFReadRGBAImageOriented<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>RGB<S2SV_blank>image<S2SV_blank>from<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } t2p -> tiff_datasize = t2p_sample_abgr_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_width * t2p -> tiff_length ) ; } } dataready : t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_width ) ; TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_length ) ; TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } if ( TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) == 0 ) { TIFFError ( TIFF2PDF_MODULE , ""Unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>JPEG<S2SV_blank>compression<S2SV_blank>for<S2SV_blank>input<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>output<S2SV_blank>%s"" , TIFFFileName ( input ) , TIFFFileName ( output ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; # ifdef JPEG_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_JPEG && t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , stripsize * stripcount ) ; } else # endif { bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , t2p -> tiff_datasize ) ; } if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == ( tsize_t ) - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>strip<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z,1685,"<S2SV_ModStart> if ( striplength > max_striplength ) { TIFFError ( TIFF2PDF_MODULE, ""Can\'t <S2SV_blank> allocate <S2SV_blank> %lu <S2SV_blank> bytes <S2SV_blank> of <S2SV_blank> memory <S2SV_blank> for <S2SV_blank> "" ""t2p_readwrite_pdf_image, <S2SV_blank> max_striplength <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", striplength, ( int ) t2p -> tiff_datasize ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } <S2SV_ModStart> if ( striplength > max_striplength ) { TIFFError ( TIFF2PDF_MODULE, ""Can\'t <S2SV_blank> allocate <S2SV_blank> %lu <S2SV_blank> bytes <S2SV_blank> of <S2SV_blank> "" ""t2p_readwrite_pdf_image, <S2SV_blank> max_striplength <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)"", ( int ) t2p -> tiff_datasize ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; }",0
1687,CWE-787,"CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z,1687,<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> BYTE a_val ; if (! context ) return FALSE <S2SV_ModStart> ; } } return TRUE ;,0
