Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0.1,raw_predictions,correctly_predicted
98,CWE-22,"CWE-22 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
",yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z,98,<S2SV_ModStart> ) ) { char * filename = r ; <S2SV_ModStart> == '\\0' ) { <S2SV_ModStart> ) ) ; } else { <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { <S2SV_ModStart> NULL ) ; },0
119,CWE-22,"CWE-22 static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z,119,"<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive, ARCHIVE_ERRNO_MISC, ""Path <S2SV_blank> is <S2SV_blank> absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;",1
345,CWE-22,"CWE-22 <S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { <S2SV_StartBug> fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ; <S2SV_EndBug> return NULL ; } * name = '\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , ""/"" ) ; } <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do { <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) { <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> x |= * fname ++ & 0x3F ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= * fname ++ & 0x3F ; } else x = '?' ; } if ( x == sep ) x = '/' ; else if ( x == slash ) x = '\\\\' ; else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ; if ( x < 0x80 ) { * p ++ = ( unsigned char ) x ; } else if ( x < 0x800 ) { * p ++ = 0xC0 | ( x >> 6 ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } else { * p ++ = 0xE0 | ( x >> 12 ) ; * p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> } else { do { c = * fname ++ ; if ( c == sep ) c = '/' ; else if ( c == slash ) c = '\\\\' ; else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ; } while ( ( * p ++ = c ) ) ; } return ( char * ) name ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * create_output_name <S2SV_ModStart> * create_output_name ( <S2SV_ModEnd> char * fname <S2SV_ModStart> char * fname ) { char * out , * p <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> while ( * <S2SV_ModStart> * fname == '/' || * fname == '\\\\' <S2SV_ModEnd> ) fname ++ <S2SV_ModStart> fname ++ ; strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } } return out <S2SV_ModEnd> ; } <S2SV_null>
",kyz@libmspack/7cadd489698be117c47efcadd742651594429e6d,CVE-2018-18586,https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d,2018-10-23T02:29Z,345,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * create_output_output_name <S2SV_ModStart> * fname = ( <S2SV_ModEnd> char * fname <S2SV_ModStart> char * fname ) { char * out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( * fname == '/' || * fname == '\\\\' && * fname == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( p [ 0 ] == '/' || * fname == '\\\\' || * p [ 1 ] == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { strcpy ( out, out, '\\\\' <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; } } } return out <S2SV_ModEnd> ; } <S2SV_null>",0
672,CWE-22,"CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , ""w"" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , ""%u"" , val ) ; fclose ( fp ) ; return 0 ; }
","<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/'
",reubenhwk@radvd/92e22ca23e52066da2258df8c76a2dca8a428bcc,CVE-2011-3602,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,2014-04-27T21:55Z,672,"<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name, "".."" ) || strchr ( name, '/'",1
674,CWE-22,"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z,674,"<S2SV_ModStart> -> bcache, cache_id ( <S2SV_ModStart> ] -> data )",1
979,CWE-22,"CWE-22 local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""name<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , ""<S2SV_blank>too<S2SV_blank>large<S2SV_blank>--<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>large<S2SV_blank>file<S2SV_blank>support"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>special<S2SV_blank>file<S2SV_blank>or<S2SV_blank>device<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { complain ( ""%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>directory<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { char * roll , * item , * cut , * base , * bigger ; size_t len , hold ; DIR * here ; struct dirent * next ; here = opendir ( g . inf ) ; if ( here == NULL ) return ; hold = 512 ; roll = MALLOC ( hold ) ; if ( roll == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; * roll = 0 ; item = roll ; while ( ( next = readdir ( here ) ) != NULL ) { if ( next -> d_name [ 0 ] == 0 || ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) continue ; len = strlen ( next -> d_name ) + 1 ; if ( item + len + 1 > roll + hold ) { do { hold <<= 1 ; } while ( item + len + 1 > roll + hold ) ; bigger = REALLOC ( roll , hold ) ; if ( bigger == NULL ) { FREE ( roll ) ; bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; } item = bigger + ( item - roll ) ; roll = bigger ; } strcpy ( item , next -> d_name ) ; item += len ; * item = 0 ; } closedir ( here ) ; cut = base = g . inf + strlen ( g . inf ) ; if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) bail ( ""path<S2SV_blank>too<S2SV_blank>long"" , g . inf ) ; * base ++ = '/' ; } item = roll ; while ( * item ) { strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , ""..."" ) ; bail ( ""path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>"" , g . inf ) ; } process ( g . inf ) ; item += strlen ( item ) + 1 ; } * cut = 0 ; FREE ( roll ) ; return ; } if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { complain ( ""%s<S2SV_blank>ends<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>skipping"" , g . inf , g . sufx ) ; return ; } if ( g . decode == 1 && ! g . pipeout && ! g . list ) { int suf = compressed_suffix ( g . inf ) ; if ( suf == 0 ) { complain ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>compressed<S2SV_blank>suffix<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } len -= suf ; } g . ind = open ( g . inf , O_RDONLY , 0 ) ; if ( g . ind < 0 ) bail ( ""read<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . inf ) ; g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; g . mtime = g . headis & 2 ? st . st_mtime : 0 ; } SET_BINARY_MODE ( g . ind ) ; g . hname = NULL ; if ( g . decode ) { in_init ( ) ; method = get_header ( 1 ) ; if ( method != 8 && method != 257 && ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && ! g . list ) ) { RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; if ( method != - 1 ) complain ( method < 0 ? ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>compressed<S2SV_blank>--<S2SV_blank>skipping"" : ""%s<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>--<S2SV_blank>skipping"" , g . inf ) ; return ; } if ( g . decode == 2 ) { if ( method == 8 ) infchk ( ) ; else { unlzw ( ) ; if ( g . list ) { g . in_tot -= 3 ; show_info ( method , 0 , g . out_tot , 0 ) ; } } RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } } if ( g . list ) { list_info ( ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( path == NULL || g . pipeout ) { g . outf = MALLOC ( strlen ( ""<stdout>"" ) + 1 ) ; if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; strcpy ( g . outf , ""<stdout>"" ) ; g . outd = 1 ; if ( ! g . decode && ! g . force && isatty ( g . outd ) ) bail ( ""trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>data<S2SV_blank>to<S2SV_blank>a<S2SV_blank>terminal"" , ""<S2SV_blank>(use<S2SV_blank>-f<S2SV_blank>to<S2SV_blank>force)"" ) ; } else { <S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> to = g . inf ; <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> } <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ; <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ; if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { int ch , reply ; fprintf ( stderr , ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>overwrite<S2SV_blank>(y/n)?<S2SV_blank>"" , g . outf ) ; fflush ( stderr ) ; reply = - 1 ; do { ch = getchar ( ) ; if ( reply < 0 && ch != '<S2SV_blank>' && ch != '\\t' ) reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; if ( reply == 1 ) g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , 0600 ) ; } if ( g . outd < 0 && errno == EEXIST ) { complain ( ""%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>skipping"" , g . outf ) ; RELEASE ( g . outf ) ; RELEASE ( g . hname ) ; if ( g . ind != 0 ) close ( g . ind ) ; return ; } if ( g . outd < 0 ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; } SET_BINARY_MODE ( g . outd ) ; RELEASE ( g . hname ) ; if ( g . verbosity > 1 ) fprintf ( stderr , ""%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , g . inf , g . outf ) ; if ( g . decode ) { if ( method == 8 ) infchk ( ) ; else if ( method == 257 ) unlzw ( ) ; else cat ( ) ; } # ifndef NOTHREAD else if ( g . procs > 1 ) parallel_compress ( ) ; # endif else single_compress ( 0 ) ; if ( g . verbosity > 1 ) { putc ( '\\n' , stderr ) ; fflush ( stderr ) ; } if ( g . ind != 0 ) close ( g . ind ) ; if ( g . outd != 1 ) { if ( close ( g . outd ) ) bail ( ""write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>"" , g . outf ) ; g . outd = - 1 ; if ( g . ind != 0 ) { copymeta ( g . inf , g . outf ) ; if ( ! g . keep ) unlink ( g . inf ) ; } if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) touch ( g . outf , g . stamp ) ; } RELEASE ( g . outf ) ; }
","<S2SV_ModStart> char * to = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> g . decode ) { if ( <S2SV_ModEnd> ( g . <S2SV_ModStart> NULL ) { pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> g . hname <S2SV_ModStart> g . hname ) <S2SV_ModStart> = strlen ( to ) ; } else if ( <S2SV_ModEnd> strcmp ( to <S2SV_ModStart> , "".tgz"" ) == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> g . outf <S2SV_ModStart> = MALLOC ( pre + len + strlen ( sufx ) <S2SV_ModEnd> + 1 ) <S2SV_ModStart> . outf , g . inf , pre ) ; memcpy <S2SV_ModEnd> ( g . <S2SV_ModStart> . outf + pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> sufx ) ;
",madler@pigz/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,CVE-2015-1191,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,2015-01-21T18:59Z,979,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> g. inf, * strlen ( sufx ) - 1 ) ; if ( <S2SV_ModEnd> strlen ( strlen <S2SV_ModStart> g. inf, to ) == 0 ) { sufx = strlen ( char * ) ; memcpy ( g. inf, 0, len ) ; } else sufx = strlen ( char ) ; memcpy ( to, 0, len ) ; <S2SV_ModEnd> } else sufx <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else sufx =",0
1039,CWE-22,"CWE-22 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
",yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z,1039,<S2SV_ModStart> ) ) { char * filename = r ; <S2SV_ModStart> == '\\0' ) { <S2SV_ModStart> ) ) ; } else { <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { <S2SV_ModStart> NULL ) ; },0
1142,CWE-22,"CWE-22 static void xcopy_pt_undepend_remotedev ( struct xcopy_op * xop ) { <S2SV_StartBug> struct se_device * remote_dev ; <S2SV_EndBug> if ( xop -> op_origin == XCOL_SOURCE_RECV_OP ) <S2SV_StartBug> remote_dev = xop -> dst_dev ; <S2SV_EndBug> else <S2SV_StartBug> remote_dev = xop -> src_dev ; <S2SV_EndBug> pr_debug ( ""Calling<S2SV_blank>configfs_undepend_item<S2SV_blank>for"" ""<S2SV_blank>remote_dev:<S2SV_blank>%p<S2SV_blank>remote_dev->dev_group:<S2SV_blank>%p\\n"" , remote_dev , & remote_dev -> dev_group . cg_item ) ; target_undepend_item ( & remote_dev -> dev_group . cg_item ) ; }
","<S2SV_ModStart> xop ) { <S2SV_ModEnd> if ( xop <S2SV_ModStart> == XCOL_SOURCE_RECV_OP ) pr_debug ( ""putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> dst_dev <S2SV_ModStart> xop -> dst_dev ) ; else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> xop -> src_dev <S2SV_ModStart> xop -> src_dev ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> ) ; }
",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z,1142,<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> gp_dev_opts_opts_dev ( struct <S2SV_ModStart> common_dev ) { if (! xop -> remote_dev ) { return - EPERM ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> xop = xop ->,0
