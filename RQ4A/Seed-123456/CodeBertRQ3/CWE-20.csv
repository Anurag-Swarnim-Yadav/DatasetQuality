Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0.1,raw_predictions,correctly_predicted
25,CWE-20,"CWE-20 error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }
","<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,12,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
84,CWE-20,"CWE-20 bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , ""LinkKeyType"" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , ""PinLength"" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , ""LinkKey"" , link_key , sizeof ( LINK_KEY ) ) ; <S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }
","<S2SV_ModStart> ) ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ; }
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,31,,0
96,CWE-20,"CWE-20 error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> enc28j60WriteBuffer ( interface , buffer , offset ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,37,"<S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd>, interface, ENC28J60_ECON1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON1 <S2SV_ModEnd>, interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ) ; interface <S2SV_ModStart> ( interface, ENC28J60_ECON2 <S2SV_ModEnd> ) ; interface, ENC28",0
115,CWE-20,"CWE-20 static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) <S2SV_StartBug> { <S2SV_EndBug> errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) { <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }
","<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
",vim@vim/d0b5138ba4bccff8a744c99836041ef6322ed39a,CVE-2016-1248,https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a,2016-11-23T15:59Z,46,,0
148,CWE-20,"CWE-20 static int parse_exports_table ( long long * table_start ) { int res ; <S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>export<S2SV_blank>index<S2SV_blank>table\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
","<S2SV_ModStart> = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> ; long long * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> ; res = <S2SV_ModStart> . lookup_table_start , length , <S2SV_ModEnd> export_index_table ) ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z,55,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
183,CWE-20,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } <S2SV_StartBug> colormap = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( number_colormaps != 0 ) { <S2SV_StartBug> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , <S2SV_EndBug> 3 * map_length * sizeof ( * colormap ) ) ; <S2SV_StartBug> if ( colormap == ( unsigned char * ) NULL ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , * p & mask , & index , exception ) ; <S2SV_EndBug> * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> colormap = ( <S2SV_ModStart> char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> ( unsigned char <S2SV_ModEnd> ) ScaleQuantumToChar ( <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( Quantum )
",ImageMagick@ImageMagick/f6240ee77847787f6d7618b669d3a2040a2d6d40,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/f6240ee77847787f6d7618b669d3a2040a2d6d40,2017-05-22T14:29Z,67,"<S2SV_ModStart> -> rows * MagickMax ( number_planes_filled, 4 ) * number_planes_filled <S2SV_ModEnd> ; pixels =",0
240,CWE-20,"CWE-20 void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( ""refs/heads/git_tilde1"" <S2SV_ModStart> "".git/foobar"" ) ; test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",libgit2@libgit2/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,CVE-2020-12279,https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,2020-04-27T17:15Z,84,<S2SV_ModStart> ) ) { <S2SV_ModEnd> if (!,0
248,CWE-20,"CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,86,<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0,0
315,CWE-20,"CWE-20 struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { <S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> err_code = sctp_process_asconf_param ( asoc , asconf , <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> if ( SCTP_ERROR_NO_ERROR != err_code ) <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
","<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
",torvalds@linux/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,CVE-2014-3673,https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,2014-11-10T11:55Z,112,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> S2SV_t * sctp_chunk_asconf_addip_chunk_t * sctp_chunk_t * sctp_hdr <S2SV_ModEnd> ; sctp_addip_chunk_t addip_hdr <S2SV_ModStart> -> sctp_chunk_hdr ; if ( sctp_addip_hdr. addip_hdr. addip_hdr. addip_hdr. p -> sctp_chunk_hdr. addip_hdr. addip_hdr. addip_hdr. addip_hdr ( sctp_hdr. p -> sctp_hdr. addip_hdr. addip_hdr. p ) { sctp_hdr = SCTP_PARAM_PARAM_ADDRESS ; sctp_hdr = SCTP_ADDRESS ; sctp_hdr ( err_hdr. p -> sctp_hdr. p -> sctp,0
317,CWE-20,"CWE-20 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
","<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,113,<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;,0
324,CWE-20,"CWE-20 int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { <S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
","<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,115,,0
375,CWE-20,"CWE-20 error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ; tja1100WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,131,,0
381,CWE-20,"CWE-20 static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
","<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z,133,,0
385,CWE-20,"CWE-20 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
","<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,136,<S2SV_ModStart> goto out ; msg -> msg_namelen = 0 ;,0
396,CWE-20,"CWE-20 error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { connection -> request . version = HTTP_VERSION_1_1 ; connection -> request . keepAlive = TRUE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }
","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,143,<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->,0
451,CWE-20,"CWE-20 void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; <S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,161,"<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( line,",0
482,CWE-20,"CWE-20 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }
","<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z,172,<S2SV_ModStart> ; if (! EXT4_SB ( inode -> i_sb ),0
485,CWE-20,"CWE-20 void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,173,"<S2SV_ModStart> y3 ) { sprintf ( outputbuffer <S2SV_ModEnd>, ""\\n"" ) ;",0
515,CWE-20,"CWE-20 static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; <S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; <S2SV_StartBug> } else <S2SV_EndBug> err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }
","<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,180,"<S2SV_ModStart> -> msg_name ; if ( msg_sys -> msg_name, msg_sys -> msg_namelen ) <S2SV_ModStart> -> msg_namelen = msg_namelen <S2SV_ModEnd> ; if (",0
528,CWE-20,"CWE-20 bool_t ksz8851IrqHandler ( NetInterface * interface ) { bool_t flag ; size_t n ; uint16_t ier ; uint16_t isr ; flag = FALSE ; <S2SV_StartBug> ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> if ( ( isr & ISR_LCIS ) != 0 ) { <S2SV_StartBug> ier &= ~ IER_LCIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( isr & ISR_TXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } } <S2SV_StartBug> if ( ( isr & ISR_RXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ier &= ~ IER_RXIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ; <S2SV_EndBug> return flag ; }
","<S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> ) ; ksz8851WriteReg <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_LCIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( isr & KSZ8851_ISR_TXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( isr & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_RXIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , ier )
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,188,"<S2SV_ModStart> ( interface, KSZ8851_ISR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( interface, KSZ8851_ISR <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_ISR, KSZ8851_IR <S2SV_ModEnd> )!= 0 <S2SV_ModStart> ( interface, KSZ8851_R, KSZ8851_IR <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface, KSZ8851_ISR, KSZ8851_ISRXS2SV_null> <S2SV_null>",0
543,CWE-20,"CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;
",git@git/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,CVE-2018-17456,https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,2018-10-06T14:29Z,194,,0
581,CWE-20,"CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
",torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z,210,"<S2SV_ModStart> ), & _dh <S2SV_ModEnd> ) ; if",0
587,CWE-20,"CWE-20 static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; <S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
","<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
",torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z,212,<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;,1
593,CWE-20,"CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed"" ""<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device."" , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> * findalldevs_if ; uint32 replylen ; <S2SV_ModStart> 0 ; } replylen = 0 ; <S2SV_ModStart> -> description ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> -> name ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> name ) ; replylen <S2SV_ModEnd> += sizeof ( <S2SV_ModStart> : # endif replylen <S2SV_ModEnd> += ( sizeof <S2SV_ModStart> , nif , replylen <S2SV_ModEnd> ) ; for
",the-tcpdump-group@libpcap/617b12c0339db4891d117b661982126c495439ea,CVE-2019-15161,https://github.com/the-tcpdump-group/libpcap/commit/617b12c0339db4891d117b661982126c495439ea,2019-10-03T19:15Z,215,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> sockaddr ; struct <S2SV_ModStart> err ; if ( addr_len < 0 ) { if ( rdp_hdrlen < 0 ) { err = - ENOMEM ; goto error ; } <S2SV_ModStart> - ENOMEM ; if (! daddr ) { if ( err ) { err = - ENOMEM ; goto error ; } <S2SV_ModStart> NULL ; } if ( err ) { if (! daddr ) { if ( err ) { err = - ENOMEM ; goto error ; } <S2SV_ModStart> - ENOMEM ; if ( daddr ) { if (! daddr ) { if ( err ) { err = - ENOMEM ) { err = - ENOMEM ; goto error ; },0
633,CWE-20,"CWE-20 static inline void VectorClamp3 ( DDSVector3 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,240,"<S2SV_ModStart> ( 1.0f, MagickMax <S2SV_ModEnd> ( 1.0f,",0
657,CWE-20,"CWE-20 int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z,251,<S2SV_ModStart> i ) ; mutex_lock ( & timer -> timer_list ) ;,0
671,CWE-20,"CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,257,<S2SV_ModStart> ; msg -> msg_namelen = 0,0
710,CWE-20,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
","<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
",torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e,CVE-2017-17805,https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e,2017-12-20T23:29Z,278,,0
776,CWE-20,"CWE-20 int serverCron ( struct aeEventLoop * eventLoop , long long id , void * clientData ) { int j , loops = server . cronloops ++ ; REDIS_NOTUSED ( eventLoop ) ; REDIS_NOTUSED ( id ) ; REDIS_NOTUSED ( clientData ) ; server . unixtime = time ( NULL ) ; updateLRUClock ( ) ; if ( server . shutdown_asap ) { if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ; redisLog ( REDIS_WARNING , ""SIGTERM<S2SV_blank>received<S2SV_blank>but<S2SV_blank>errors<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>shut<S2SV_blank>down<S2SV_blank>the<S2SV_blank>server,<S2SV_blank>check<S2SV_blank>the<S2SV_blank>logs<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information"" ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long size , used , vkeys ; size = dictSlots ( server . db [ j ] . dict ) ; used = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( ! ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE , ""DB<S2SV_blank>%d:<S2SV_blank>%lld<S2SV_blank>keys<S2SV_blank>(%lld<S2SV_blank>volatile)<S2SV_blank>in<S2SV_blank>%lld<S2SV_blank>slots<S2SV_blank>HT."" , j , used , vkeys , size ) ; } } if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) { if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ; if ( server . activerehashing ) incrementallyRehash ( ) ; } if ( ! ( loops % 50 ) ) { redisLog ( REDIS_VERBOSE , ""%d<S2SV_blank>clients<S2SV_blank>connected<S2SV_blank>(%d<S2SV_blank>slaves),<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>use"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ; } if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ; if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) { int statloc ; pid_t pid ; if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) != 0 ) { if ( pid == server . bgsavechildpid ) { backgroundSaveDoneHandler ( statloc ) ; } else { backgroundRewriteDoneHandler ( statloc ) ; } updateDictResizePolicy ( ) ; } } else { time_t now = time ( NULL ) ; for ( j = 0 ; j < server . saveparamslen ; j ++ ) { struct saveparam * sp = server . saveparams + j ; if ( server . dirty >= sp -> changes && now - server . lastsave > sp -> seconds ) { redisLog ( REDIS_NOTICE , ""%d<S2SV_blank>changes<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>seconds.<S2SV_blank>Saving..."" , sp -> changes , sp -> seconds ) ; rdbSaveBackground ( server . dbfilename ) ; break ; } } } if ( server . masterhost == NULL ) activeExpireCycle ( ) ; <S2SV_StartBug> if ( vmCanSwapOut ( ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( server . vm_enabled && zmalloc_used_memory ( ) > <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory ) <S2SV_EndBug> { int retval = ( server . vm_max_threads == 0 ) ? vmSwapOneObjectBlocking ( ) : vmSwapOneObjectThreaded ( ) ; if ( retval == REDIS_ERR && ! ( loops % 300 ) && zmalloc_used_memory ( ) > ( server . vm_max_memory + server . vm_max_memory / 10 ) ) { redisLog ( REDIS_WARNING , ""WARNING:<S2SV_blank>vm-max-memory<S2SV_blank>limit<S2SV_blank>exceeded<S2SV_blank>by<S2SV_blank>more<S2SV_blank>than<S2SV_blank>10%%<S2SV_blank>but<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>swap<S2SV_blank>more<S2SV_blank>objects<S2SV_blank>out!"" ) ; } if ( retval == REDIS_ERR || server . vm_max_threads > 0 ) break ; } } if ( ! ( loops % 10 ) ) replicationCron ( ) ; return 100 ; }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> while ( server <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && zmalloc_used_memory ( <S2SV_ModStart> > server . cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> } if (
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z,297,<S2SV_ModStart> ( server. ds_enabled <S2SV_ModEnd> ) ; },0
781,CWE-20,"CWE-20 void BezierCircle ( double r , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - r , - r , r * BzK , - r * BzK , r , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , r * BzK , r , r , r * BzK , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , r , - r * BzK , r * BzK , - r , - r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - r * BzK , - r , - r , - r * BzK , - r , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,300,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
804,CWE-20,"CWE-20 error_t ksz8851Init ( NetInterface * interface ) { Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; TRACE_INFO ( ""Initializing<S2SV_blank>KSZ8851<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; # if ( KSZ8851_SPI_SUPPORT == ENABLED ) interface -> spiDriver -> init ( ) ; # endif interface -> extIntDriver -> init ( ) ; <S2SV_StartBug> TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1ILR ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1IHR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID ) <S2SV_EndBug> { return ERROR_WRONG_IDENTIFIER ; } ksz8851DumpReg ( interface ) ; context -> frameId = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> txBuffer == NULL || context -> rxBuffer == NULL ) { memPoolFree ( context -> txBuffer ) ; memPoolFree ( context -> rxBuffer ) ; return ERROR_OUT_OF_MEMORY ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ; <S2SV_EndBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXFDPR , TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXPAFMA | RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXME | RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR2 , RXCR2_SRDBL2 | RXCR2_IUFFP | RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXQCR , RXQCR_RXFCTE | RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFCTR , 1 ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS | <S2SV_EndBug> ISR_RXIS | ISR_RXOIS | ISR_TXPSIS | ISR_RXPSIS | ISR_TXSAIS | ISR_RXWFDIS | ISR_RXMPDIS | ISR_LDIS | ISR_EDIS | ISR_SPIBEIS ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ; <S2SV_EndBug> osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_CIDER <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1ILR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1IHR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , KSZ8851_MARH <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARM <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARL <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> ) ; osSetEvent
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,310,,0
843,CWE-20,"CWE-20 static int check_symlinks ( struct archive_write_disk * a ) { <S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; <S2SV_StartBug> } <S2SV_EndBug> a -> pst = NULL ; <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>remove<S2SV_blank>intervening<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> ( a -> <S2SV_ModStart> name , & error_number , & error_string , a -> flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string ) ; <S2SV_ModStart> = NULL ; return rc ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9,CVE-2016-5418,https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9,2016-09-21T14:25Z,328,"<S2SV_ModStart> ; if ( r == NULL ) { archive_set_error ( & error_number, & error_t ) ; if ( r!= ARCHIVE_MAX ) { archive_set_error ( & error_error, & error_snprintf ( & error_t ) ; } if ( r!= ARCHIVE_FAILURE ) { archive_error ( & error_set_error ( & error_error, & error_number, & error_number, & error_number, & error_t ) ; if ( r < 0 ) { archive_error ( & error_copy ) ; return error_error ( & error_snprintf ( & error_t ) ; } if ( r < 0 ) { error_error ( & error_copy ) { error_error ( & error_error ( & error_t ) ; return error_snprintf ( & error, & error_t ) ; } if ( r!= 0 ) { error_error ( & error_copy ) { error_error ( & error_error ( & error_copy, & error, & error_copy ) ; } if ( error_error ( & error_copy ) { archive_error ( & error_",0
869,CWE-20,"CWE-20 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
",torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z,342,,0
884,CWE-20,"CWE-20 void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; <S2SV_StartBug> struct stat stb ; <S2SV_EndBug> enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; <S2SV_StartBug> int setimes , targisdir , wrerrno = 0 ; <S2SV_EndBug> char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; if ( src != NULL && ! iamrecursive && ! Tflag ) { if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>expand<S2SV_blank>pattern"" , __func__ ) ; } for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; goto done ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; size = ( off_t ) ull ; if ( * cp == '\\0' || strchr ( cp , '/' ) != NULL || strcmp ( cp , ""."" ) == 0 || strcmp ( cp , "".."" ) == 0 ) { run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( npatterns > 0 ) { for ( n = 0 ; n < npatterns ; n ++ ) { if ( fnmatch ( patterns [ n ] , cp , 0 ) == 0 ) break ; } if ( n >= npatterns ) SCREWUP ( ""filename<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>request"" ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) == - 1 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect , src ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) == - 1 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) == - 1 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; <S2SV_StartBug> wrerr = NO ; <S2SV_EndBug> statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( ""%s"" , j != EPIPE ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { <S2SV_StartBug> if ( wrerr == NO ) { <S2SV_EndBug> if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; <S2SV_StartBug> if ( count != 0 && wrerr == NO && <S2SV_EndBug> atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && <S2SV_StartBug> ftruncate ( ofd , size ) != 0 ) { <S2SV_EndBug> run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> wrerr = DISPLAYED ; } } <S2SV_StartBug> if ( close ( ofd ) == - 1 ) { <S2SV_EndBug> wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; <S2SV_StartBug> if ( setimes && wrerr == NO ) { <S2SV_EndBug> setimes = 0 ; if ( utimes ( np , tv ) == - 1 ) { <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_EndBug> np , strerror ( errno ) ) ; <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case DISPLAYED : break ; } } done : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; return ; screwup : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> struct stat stb <S2SV_ModEnd> ; BUF * <S2SV_ModStart> , targisdir , wrerr <S2SV_ModEnd> ; char ch <S2SV_ModStart> ; wrerr = 0 <S2SV_ModEnd> ; statbytes = <S2SV_ModStart> { if ( ! wrerr <S2SV_ModEnd> ) { if <S2SV_ModStart> count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> != 0 && ! wrerr <S2SV_ModEnd> && atomicio ( <S2SV_ModStart> count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr <S2SV_ModEnd> && ( ! <S2SV_ModStart> != 0 ) note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( pflag <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> - 1 ) note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( setimes && ! wrerr <S2SV_ModEnd> ) { setimes <S2SV_ModStart> 1 ) { note_err <S2SV_ModEnd> ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_ModStart> ) ) ; } } if ( note_err ( NULL ) == 0 ) <S2SV_ModEnd> ( void ) <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> } done :
",openssh@openssh-portable/aad87b88fc2536b1ea023213729aaf4eaabe1894,CVE-2020-12062,https://github.com/openssh/openssh-portable/commit/aad87b88fc2536b1ea023213729aaf4eaabe1894,2020-06-01T16:15Z,348,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,0
903,CWE-20,"CWE-20 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;
",external@libavc/d4841f1161bdb5e13cb19e81af42437a634dd6ef,CVE-2016-3755,https://android.googlesource.com/platform/external/libavc/+/d4841f1161bdb5e13cb19e81af42437a634dd6ef,2016-07-11T01:59Z,353,<S2SV_ModStart> -> u4_first_slice_in_pic = 0,0
945,CWE-20,"CWE-20 __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_arch_events_quirk ) ; switch ( boot_cpu_data . x86_model ) { case 14 : pr_cont ( ""Core<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 15 : x86_add_quirk ( intel_clovertown_quirk ) ; case 22 : case 23 : case 29 : memcpy ( hw_cache_event_ids , core2_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_core ( ) ; x86_pmu . event_constraints = intel_core2_event_constraints ; x86_pmu . pebs_constraints = intel_core2_pebs_event_constraints ; pr_cont ( ""Core2<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 26 : case 30 : case 46 : memcpy ( hw_cache_event_ids , nehalem_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_nehalem_event_constraints ; x86_pmu . pebs_constraints = intel_nehalem_pebs_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . extra_regs = intel_nehalem_extra_regs ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; x86_add_quirk ( intel_nehalem_quirk ) ; pr_cont ( ""Nehalem<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 28 : case 38 : case 39 : case 53 : case 54 : memcpy ( hw_cache_event_ids , atom_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; intel_pmu_lbr_init_atom ( ) ; x86_pmu . event_constraints = intel_gen_event_constraints ; x86_pmu . pebs_constraints = intel_atom_pebs_event_constraints ; pr_cont ( ""Atom<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 37 : case 44 : case 47 : memcpy ( hw_cache_event_ids , westmere_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , nehalem_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_nhm ( ) ; x86_pmu . event_constraints = intel_westmere_event_constraints ; x86_pmu . enable_all = intel_pmu_nhm_enable_all ; x86_pmu . pebs_constraints = intel_westmere_pebs_event_constraints ; x86_pmu . extra_regs = intel_westmere_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x3f , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""Westmere<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 42 : case 45 : x86_add_quirk ( intel_sandybridge_quirk ) ; memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_snb_event_constraints ; x86_pmu . pebs_constraints = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_BACKEND ] = X86_CONFIG ( . event = 0xb1 , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""SandyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; case 58 : case 62 : memcpy ( hw_cache_event_ids , snb_hw_cache_event_ids , sizeof ( hw_cache_event_ids ) ) ; memcpy ( hw_cache_extra_regs , snb_hw_cache_extra_regs , sizeof ( hw_cache_extra_regs ) ) ; intel_pmu_lbr_init_snb ( ) ; x86_pmu . event_constraints = intel_ivb_event_constraints ; x86_pmu . pebs_constraints = intel_ivb_pebs_event_constraints ; <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> x86_pmu . extra_regs = intel_snb_extra_regs ; x86_pmu . er_flags |= ERF_HAS_RSP_1 ; x86_pmu . er_flags |= ERF_NO_HT_SHARING ; intel_perfmon_event_map [ PERF_COUNT_HW_STALLED_CYCLES_FRONTEND ] = X86_CONFIG ( . event = 0x0e , . umask = 0x01 , . inv = 1 , . cmask = 1 ) ; pr_cont ( ""IvyBridge<S2SV_blank>events,<S2SV_blank>"" ) ; break ; default : switch ( x86_pmu . version ) { case 1 : x86_pmu . event_constraints = intel_v1_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon<S2SV_blank>v1,<S2SV_blank>"" ) ; break ; default : x86_pmu . event_constraints = intel_gen_event_constraints ; pr_cont ( ""generic<S2SV_blank>architected<S2SV_blank>perfmon,<S2SV_blank>"" ) ; break ; } } if ( x86_pmu . num_counters > INTEL_PMC_MAX_GENERIC ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters , INTEL_PMC_MAX_GENERIC ) ; x86_pmu . num_counters = INTEL_PMC_MAX_GENERIC ; } x86_pmu . intel_ctrl = ( 1 << x86_pmu . num_counters ) - 1 ; if ( x86_pmu . num_counters_fixed > INTEL_PMC_MAX_FIXED ) { WARN ( 1 , KERN_ERR ""hw<S2SV_blank>perf<S2SV_blank>events<S2SV_blank>fixed<S2SV_blank>%d<S2SV_blank>><S2SV_blank>max(%d),<S2SV_blank>clipping!"" , x86_pmu . num_counters_fixed , INTEL_PMC_MAX_FIXED ) ; x86_pmu . num_counters_fixed = INTEL_PMC_MAX_FIXED ; } x86_pmu . intel_ctrl |= ( ( 1LL << x86_pmu . num_counters_fixed ) - 1 ) << INTEL_PMC_IDX_FIXED ; if ( x86_pmu . event_constraints ) { for_each_event_constraint ( c , x86_pmu . event_constraints ) { if ( c -> cmask != X86_RAW_EVENT_MASK || c -> idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES ) { continue ; } c -> idxmsk64 |= ( 1ULL << x86_pmu . num_counters ) - 1 ; c -> weight += x86_pmu . num_counters ; } } return 0 ; }
","<S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
",torvalds@linux/f1923820c447e986a9da0fc6bf60c1dccdf0408e,CVE-2013-2146,https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e,2013-06-07T14:03Z,371,<S2SV_ModStart> return 0 ; <S2SV_ModEnd> return 0 ;,0
1081,CWE-20,"CWE-20 error_t ksz8851SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t n ; size_t length ; Ksz8851TxHeader header ; Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; length = netBufferGetLength ( buffer ) - offset ; if ( length > ETH_MAX_FRAME_SIZE ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n < ( length + 8 ) ) { return ERROR_FAILURE ; } netBufferRead ( context -> txBuffer , buffer , offset , length ) ; <S2SV_StartBug> header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; <S2SV_EndBug> header . byteCount = htole16 ( length ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851WriteFifo ( interface , ( uint8_t * ) & header , sizeof ( Ksz8851TxHeader ) ) ; ksz8851WriteFifo ( interface , context -> txBuffer , length ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { osSetEvent ( & interface -> nicTxEvent ) ; } return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> = htole16 ( KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> | ( context <S2SV_ModStart> frameId ++ & KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851WriteFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,436,"<S2SV_ModStart> ( interface, KSZ8851_ISRXS2SV_null> <S2SV_null> <S2SV_null>",0
1084,CWE-20,"CWE-20 static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings . logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE ; settings . logger_buf_size = LOGGER_BUF_SIZE ; settings . drop_privileges = true ; # ifdef MEMCACHED_DEBUG settings . relaxed_privileges = false ; # endif }
","<S2SV_ModStart> . udpport = 0 <S2SV_ModEnd> ; settings .
",memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z,438,<S2SV_ModStart>. udpport = 0 <S2SV_ModEnd> ; settings.,1
1109,CWE-20,"CWE-20 void enc28j60WritePhyReg ( NetInterface * interface , uint16_t address , uint16_t data ) { <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> { } }
","<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MIWRL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_MIWRH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,451,"<S2SV_ModStart> ( interface, ENC28J60_MIREGADR <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC28J60_MICMD <S2SV_ModEnd>, interface,",0
1118,CWE-20,"CWE-20 error_t webSocketParseAuthenticateField ( WebSocket * webSocket , char_t * value ) { # if ( WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) size_t n ; char_t * p ; char_t * token ; char_t * separator ; char_t * name ; WebSocketAuthContext * authContext ; authContext = & webSocket -> authContext ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcasecmp ( token , ""Basic"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_BASIC ; } else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_DIGEST ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""realm"" ) ) { strSafeCopy ( authContext -> realm , value , WEB_SOCKET_REALM_MAX_LEN ) ; } # if ( WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { strSafeCopy ( authContext -> nonce , value , WEB_SOCKET_NONCE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { strSafeCopy ( authContext -> opaque , value , WEB_SOCKET_OPAQUE_MAX_LEN + 1 ) ; } else if ( ! osStrcasecmp ( name , ""stale"" ) ) { if ( ! osStrcasecmp ( value , ""true"" ) ) authContext -> stale = TRUE ; else authContext -> stale = FALSE ; } # endif token = osStrtok_r ( NULL , "","" , & p ) ; } } # endif return NO_ERROR ; }
","<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,455,<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( context ->,0
1123,CWE-20,"CWE-20 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z,456,<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key ),1
1140,CWE-20,"CWE-20 int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z,468,,0
1141,CWE-20,"CWE-20 error_t rawSocketReceiveIpPacket ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } rawSocketUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }
","<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,469,<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->,1
1159,CWE-20,"CWE-20 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { <S2SV_StartBug> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; <S2SV_EndBug> ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
","<S2SV_ModStart> -> ps_cur_slice -> <S2SV_ModEnd> u1_slice_type = P_SLICE
",external@libavc/cc676ebd95247646e67907ccab150fb77a847335,CVE-2016-3741,https://android.googlesource.com/platform/external/libavc/+/cc676ebd95247646e67907ccab150fb77a847335,2016-07-11T01:59Z,477,<S2SV_ModStart> -> u4_first_slice_in_pic = 0,0
1217,CWE-20,"CWE-20 static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
","<S2SV_ModStart> bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,508,,0
1245,CWE-20,"CWE-20 static void test_headers_bad ( Test * test , gconstpointer data ) { GHashTable * headers ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=1;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=2;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; <S2SV_StartBug> g_hash_table_destroy ( headers ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;
",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z,522,,0
1273,CWE-20,"CWE-20 MonoReflectionMethod * mono_reflection_bind_generic_method_parameters ( MonoReflectionMethod * rmethod , MonoArray * types ) { MonoClass * klass ; MonoMethod * method , * inflated ; MonoMethodInflated * imethod ; MonoGenericContext tmp_context ; MonoGenericInst * ginst ; MonoType * * type_argv ; int count , i ; MONO_ARCH_SAVE_REGS ; if ( ! strcmp ( rmethod -> object . vtable -> klass -> name , ""MethodBuilder"" ) ) { # ifndef DISABLE_REFLECTION_EMIT MonoReflectionMethodBuilder * mb = NULL ; MonoReflectionTypeBuilder * tb ; MonoClass * klass ; mb = ( MonoReflectionMethodBuilder * ) rmethod ; tb = ( MonoReflectionTypeBuilder * ) mb -> type ; klass = mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) tb ) ) ; method = methodbuilder_to_mono_method ( klass , mb ) ; # else g_assert_not_reached ( ) ; method = NULL ; # endif } else { method = rmethod -> method ; } klass = method -> klass ; if ( method -> is_inflated ) method = ( ( MonoMethodInflated * ) method ) -> declaring ; count = mono_method_signature ( method ) -> generic_param_count ; if ( count != mono_array_length ( types ) ) return NULL ; type_argv = g_new0 ( MonoType * , count ) ; for ( i = 0 ; i < count ; i ++ ) { MonoReflectionType * garg = mono_array_get ( types , gpointer , i ) ; type_argv [ i ] = mono_reflection_type_get_handle ( garg ) ; } ginst = mono_metadata_get_generic_inst ( count , type_argv ) ; g_free ( type_argv ) ; tmp_context . class_inst = klass -> generic_class ? klass -> generic_class -> context . class_inst : NULL ; tmp_context . method_inst = ginst ; inflated = mono_class_inflate_generic_method ( method , & tmp_context ) ; imethod = ( MonoMethodInflated * ) inflated ; if ( method -> klass -> image -> dynamic ) { MonoDynamicImage * image = ( MonoDynamicImage * ) method -> klass -> image ; mono_loader_lock ( ) ; mono_g_hash_table_insert ( image -> generic_def_objects , imethod , rmethod ) ; mono_loader_unlock ( ) ; } <S2SV_StartBug> return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ;
",mono@mono/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,CVE-2010-4254,https://github.com/mono/mono/commit/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,2010-12-06T13:44Z,538,,0
1302,CWE-20,"CWE-20 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
",ImageMagick@ImageMagick/8a370f9ab120faf182aa160900ba692ba8e2bcf0,CVE-2016-10069,https://github.com/ImageMagick/ImageMagick/commit/8a370f9ab120faf182aa160900ba692ba8e2bcf0,2017-03-02T21:59Z,560,,0
1315,CWE-20,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) <S2SV_StartBug> * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( image -> matte != MagickFalse ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> matte == MagickFalse ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; operand ++ ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> matte == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> MagickFalse ) break ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> colormap = ( <S2SV_ModStart> x ++ ) { <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t )
",ImageMagick@ImageMagick/7fdf9ea808caa3c81a0eb42656e5fafc59084198,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/7fdf9ea808caa3c81a0eb42656e5fafc59084198,2017-05-22T14:29Z,570,"<S2SV_ModStart> -> rows * MagickMax ( number_planes_filled, 4 ) * number_planes_filled <S2SV_ModEnd> ; pixels =",0
1344,CWE-20,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if (
",ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7,2018-09-06T22:29Z,584,"<S2SV_ModStart>, message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [",0
1346,CWE-20,"CWE-20 error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,586,"<S2SV_ModStart> ( interface, ENC28J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC28J600_EHT3 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC28J600_EHT3 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd>, hashTable [ <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J60_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface, ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; } <S2SV_ModStart> ( interface, ENC624J600_EHT2, ENC6",0
1357,CWE-20,"CWE-20 void Rectangle ( double x , double y , double w , double h ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> h ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , <S2SV_ModStart> h ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,593,"<S2SV_ModStart> y3 ) { sprintf ( outputbuffer <S2SV_ModEnd>, ""\\n"" )",0
1359,CWE-20,"CWE-20 <S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> { struct io_context * ioc ; <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
","<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
",torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z,594,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct task <S2SV_ModEnd> struct <S2SV_ModStart> struct io_context ) { task_lock_irqrestore ( task <S2SV_ModEnd> ) ; task <S2SV_ModStart> ; if ( task ) { task_unlock ( task, task <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; } task <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",0
1396,CWE-20,"CWE-20 error_t tja1101Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1101...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1101_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1101WritePhyReg ( interface , TJA1101_BASIC_CTRL , TJA1101_BASIC_CTRL_RESET ) ; while ( tja1101ReadPhyReg ( interface , TJA1101_BASIC_CTRL ) & TJA1101_BASIC_CTRL_RESET ) { } tja1101DumpPhyReg ( interface ) ; value = tja1101ReadPhyReg ( interface , TJA1101_EXTENDED_CTRL ) ; value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ; tja1101WritePhyReg ( interface , TJA1101_EXTENDED_CTRL , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_CONFIG1 ) ; value &= ~ TJA1101_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_COMM_CTRL ) ; value |= TJA1101_COMM_CTRL_AUTO_OP ; tja1101WritePhyReg ( interface , TJA1101_COMM_CTRL , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> ; tja1101WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,612,,0
1411,CWE-20,"CWE-20 error_t httpClientSetQueryString ( HttpClientContext * context , const char_t * queryString ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || queryString == NULL ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { <S2SV_StartBug> q = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; } else { q = p ; m = 0 ; } n = osStrlen ( queryString ) ; if ( n == 0 ) { osMemmove ( p , p + m , context -> buffer + context -> bufferLen + 1 - q ) ; } else { n ++ ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; p [ 0 ] = '?' ; osStrncpy ( p + 1 , queryString , n - 1 ) ; } context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { q = osStrchr <S2SV_ModEnd> ( p +
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,622,<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->,0
1414,CWE-20,"CWE-20 error_t enc624j600ReceivePacket ( NetInterface * interface ) { error_t error ; <S2SV_StartBug> uint16_t n ; <S2SV_EndBug> uint32_t status ; <S2SV_StartBug> Enc624j600Context * context ; <S2SV_EndBug> context = ( Enc624j600Context * ) interface -> nicContext ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ; <S2SV_EndBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , <S2SV_StartBug> ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> context -> nextPacket = letoh16 ( context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ; <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ; <S2SV_EndBug> error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC624J600_RX_BUFFER_START ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ; <S2SV_EndBug> } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> } return error ; }
","<S2SV_ModStart> error ; uint16_t length <S2SV_ModEnd> ; uint32_t status <S2SV_ModStart> uint32_t status ; uint8_t header [ 8 ] ; <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> ) { enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_ERXRDPT <S2SV_ModEnd> , context -> <S2SV_ModStart> , ENC624J600_CMD_RRXDATA , header <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> 0 ) { length <S2SV_ModEnd> = MIN ( <S2SV_ModStart> = MIN ( length <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> ) ; error <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> ENC624J600_RX_BUFFER_STOP ) ; <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> context -> nextPacket <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> , & ancillary
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,625,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ( interface, ENC624J600_ECON2SV_null> <S2SV_null> <S2SV_ModEnd> ( interface, ENC624J600_ECON2SV_null>",0
1429,CWE-20,"CWE-20 error_t ksz8851ReceivePacket ( NetInterface * interface ) { size_t n ; uint16_t status ; Ksz8851Context * context ; NetRxAncillary ancillary ; context = ( Ksz8851Context * ) interface -> nicContext ; <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RXFHSR_RXFV ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ; <S2SV_EndBug> if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; return NO_ERROR ; } } } <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ; <S2SV_EndBug> return ERROR_INVALID_PACKET ; }
","<S2SV_ModStart> ( interface , KSZ8851_RXFHSR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> ) != 0 <S2SV_ModStart> status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> ) ) == <S2SV_ModStart> ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851ReadFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ancillary <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,636,"<S2SV_ModStart> ( interface, KSZ8851_ISRXRXRXRXRXRXRXR_PTR <S2SV_ModEnd> ) ; KSZ8851_PTR <S2SV_ModEnd> ( interface, KSZ8851_PTR <S2SV_ModStart> ( interface, KSZ8851_ISRXR, KSZ8851_PTR <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface, KSZ8851_RXRXRXS2SV_null> <S2SV_null>",0
1441,CWE-20,"CWE-20 int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n"" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n"" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n"" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n"" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = ""\\x1b[0m"" ; static const char * GREEN = ""\\x1b[0;32m"" ; static const char * RED = ""\\x1b[0;31m"" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = """" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( ""\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n"" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> if ( test_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( ""\\n"" ) ; if ( fail ) { printf ( ""%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n"" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( ""All<S2SV_blank>tests<S2SV_blank>passed!\\n"" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }
","<S2SV_ModStart> -> enable ( false
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z,641,<S2SV_ModStart> ) ; } <S2SV_ModEnd> if (!,0
1452,CWE-20,"CWE-20 static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_upper ( old ) -> d_inode == ovl_dentry_upper ( new ) -> d_inode ) goto out ; } } else { if ( ovl_dentry_is_opaque ( new ) ) new_type = __OVL_PATH_UPPER ; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE ; } err = ovl_want_write ( old ) ; if ( err ) goto out ; err = ovl_copy_up ( old ) ; if ( err ) goto out_drop_write ; err = ovl_copy_up ( new -> d_parent ) ; if ( err ) goto out_drop_write ; if ( ! overwrite ) { err = ovl_copy_up ( new ) ; if ( err ) goto out_drop_write ; } old_opaque = ! OVL_TYPE_PURE_UPPER ( old_type ) ; new_opaque = ! OVL_TYPE_PURE_UPPER ( new_type ) ; if ( old_opaque || new_opaque ) { err = - ENOMEM ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) goto out_drop_write ; cap_raise ( override_cred -> cap_effective , CAP_SYS_ADMIN ) ; cap_raise ( override_cred -> cap_effective , CAP_DAC_OVERRIDE ) ; cap_raise ( override_cred -> cap_effective , CAP_FOWNER ) ; cap_raise ( override_cred -> cap_effective , CAP_FSETID ) ; cap_raise ( override_cred -> cap_effective , CAP_CHOWN ) ; old_cred = override_creds ( override_cred ) ; } if ( overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { opaquedir = ovl_check_empty_and_clear ( new ) ; err = PTR_ERR ( opaquedir ) ; if ( IS_ERR ( opaquedir ) ) { opaquedir = NULL ; goto out_revert_creds ; } } if ( overwrite ) { if ( old_opaque ) { if ( new -> d_inode || ! new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } else if ( is_dir && ! new -> d_inode && new_opaque ) { flags |= RENAME_EXCHANGE ; cleanup_whiteout = true ; } } old_upperdir = ovl_dentry_upper ( old -> d_parent ) ; new_upperdir = ovl_dentry_upper ( new -> d_parent ) ; trap = lock_rename ( new_upperdir , old_upperdir ) ; <S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> newdentry = ovl_dentry_upper ( new ) ; if ( newdentry ) { if ( opaquedir ) { newdentry = opaquedir ; opaquedir = NULL ; } else { dget ( newdentry ) ; } } else { new_create = true ; <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> new -> d_name . len ) ; <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> goto out_unlock ; <S2SV_StartBug> } <S2SV_EndBug> err = - ESTALE ; <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> goto out_dput ; <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir && ! old_opaque && new_opaque ) { err = ovl_set_opaque ( olddentry ) ; if ( err ) goto out_dput ; } if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) { err = ovl_set_opaque ( newdentry ) ; if ( err ) goto out_dput ; } if ( old_opaque || new_opaque ) { err = ovl_do_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , flags ) ; } else { BUG_ON ( flags & ~ RENAME_EXCHANGE ) ; err = vfs_rename ( old_upperdir -> d_inode , olddentry , new_upperdir -> d_inode , newdentry , NULL , flags ) ; } if ( err ) { if ( is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( newdentry ) ; goto out_dput ; } if ( is_dir && old_opaque && ! new_opaque ) ovl_remove_opaque ( olddentry ) ; if ( ! overwrite && new_is_dir && ! old_opaque && new_opaque ) ovl_remove_opaque ( newdentry ) ; if ( old_opaque != new_opaque ) { ovl_dentry_set_opaque ( old , new_opaque ) ; if ( ! overwrite ) ovl_dentry_set_opaque ( new , old_opaque ) ; } if ( cleanup_whiteout ) ovl_cleanup ( old_upperdir -> d_inode , newdentry ) ; ovl_dentry_version_inc ( old -> d_parent ) ; ovl_dentry_version_inc ( new -> d_parent ) ; out_dput : dput ( newdentry ) ; <S2SV_StartBug> out_unlock : <S2SV_EndBug> unlock_rename ( new_upperdir , old_upperdir ) ; out_revert_creds : if ( old_opaque || new_opaque ) { revert_creds ( old_cred ) ; put_cred ( override_cred ) ; } out_drop_write : ovl_drop_write ( old ) ; out : dput ( opaquedir ) ; return err ; }
","<S2SV_ModStart> ; olddentry = lookup_one_len ( old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> . name , old_upperdir , old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> = PTR_ERR ( olddentry <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( IS_ERR ( olddentry <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto out_unlock ; <S2SV_ModEnd> err = - <S2SV_ModStart> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> newdentry ) ; out_dput_old : dput ( olddentry ) ;
",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z,647,,0
1486,CWE-20,"CWE-20 error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( ""Initializing<S2SV_blank>ENC624J600<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <S2SV_EndBug> if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) { <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <S2SV_EndBug> interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ; <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <S2SV_EndBug> interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ; <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <S2SV_EndBug> interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <S2SV_EndBug> temp = htole16 ( interface -> macAddr . w [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <S2SV_EndBug> temp = htole16 ( interface -> macAddr . w [ 2 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN | <S2SV_EndBug> ERXFCON_CRCEN | ERXFCON_RUNTEN | ERXFCON_UCEN | ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , 0x0000 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , <S2SV_EndBug> MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_MAMXFL , ETH_MAX_FRAME_SIZE ) ; <S2SV_StartBug> enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 | <S2SV_EndBug> PHANA_AD100FD | PHANA_AD100 | PHANA_AD10FD | PHANA_AD10 | PHANA_ADIEEE0 ) ; enc624j600WriteReg ( interface , ENC624J600_REG_EIR , 0x0000 ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE | <S2SV_EndBug> EIE_LINKIE | EIE_PKTIE | EIE_TXIE | EIE_TXABTIE ) ; <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> enc624j600DumpReg ( interface ) ; enc624j600DumpPhyReg ( interface ) ; osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_ERXST <S2SV_ModEnd> , ENC624J600_RX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL <S2SV_ModEnd> , ENC624J600_RX_BUFFER_STOP ) <S2SV_ModStart> ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <S2SV_ModEnd> ) ; enc624j600DumpReg
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,666,"<S2SV_ModStart> ( interface, ENC624J600_EIR <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON1, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON1, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON2, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON2, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface, ENC624J600_ECON2, ENC624J600_ECON2 <S2SV_ModEnd> ( interface,",0
1510,CWE-20,"CWE-20 static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ; <S2SV_StartBug> struct ieee_802_11_phdr phdr ; <S2SV_EndBug> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , ""PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes"" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti = proto_tree_add_item ( ppi_tree , hf_ppi_head_flags , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; ppi_flags_tree = proto_item_add_subtree ( ti , ett_ppi_flags ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_alignment , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_reserved , tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_len , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_dlt , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; } tot_len -= PPI_V0_HEADER_LEN ; offset += 8 ; memset ( & phdr , 0 , sizeof ( phdr ) ) ; phdr . fcs_len = - 1 ; phdr . decrypted = FALSE ; phdr . datapad = FALSE ; phdr . phy = PHDR_802_11_PHY_UNKNOWN ; phdr . presence_flags = 0 ; while ( tot_len > 0 ) { data_type = tvb_get_letohs ( tvb , offset ) ; data_len = tvb_get_letohs ( tvb , offset + 2 ) + 4 ; tot_len -= data_len ; switch ( data_type ) { case PPI_80211_COMMON : dissect_80211_common ( tvb , pinfo , ppi_tree , offset , data_len , & phdr ) ; break ; case PPI_80211N_MAC : dissect_80211n_mac ( tvb , pinfo , ppi_tree , offset , data_len , TRUE , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_80211N_MAC_PHY : dissect_80211n_mac_phy ( tvb , pinfo , ppi_tree , offset , data_len , & n_ext_flags , & ampdu_id , & phdr ) ; break ; case PPI_SPECTRUM_MAP : ADD_BASIC_TAG ( hf_spectrum_map ) ; break ; case PPI_PROCESS_INFO : ADD_BASIC_TAG ( hf_process_info ) ; break ; case PPI_CAPTURE_INFO : ADD_BASIC_TAG ( hf_capture_info ) ; break ; case PPI_AGGREGATION_EXTENSION : dissect_aggregation_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_8023_EXTENSION : dissect_8023_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; break ; case PPI_GPS_INFO : if ( ppi_gps_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_gps , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ; } break ; case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) { proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ; } else { next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ; } break ; default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ; } offset += data_len ; if ( IS_PPI_FLAG_ALIGN ( flags ) ) { offset += PADDING4 ( offset ) ; } } if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) { len_remain = tvb_captured_length_remaining ( tvb , offset ) ; # if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { pad_len = PADDING4 ( len_remain ) ; } # endif pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; while ( fd_head ) { ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ; fd_head = fd_head -> next ; } if ( ampdu_len > AGGREGATE_MAX ) { if ( tree ) { proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ; THROW ( ReportedBoundsError ) ; } else { return ; } } fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ; pinfo -> fragmented = TRUE ; fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; if ( fd_head && tree ) { ft_fdh = fd_head ; seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; while ( ft_fdh ) { if ( ft_fdh -> tvb_data && ft_fdh -> len ) { last_frame = ft_fdh -> frame ; if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ; first_mpdu = FALSE ; proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ; proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ; } ft_fdh = ft_fdh -> next ; } if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ; } if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ; agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ; } while ( fd_head ) { if ( fd_head -> tvb_data && fd_head -> len ) { mpdu_count ++ ; mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ; next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ; add_new_data_source ( pinfo , next_tvb , mpdu_str ) ; ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ; call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ; } fd_head = fd_head -> next ; } proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ; pinfo -> fragmented = FALSE ; } else { next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ; col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ; call_dissector ( data_handle , next_tvb , pinfo , tree ) ; } return ; } next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; if ( dlt == 105 ) { call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; } else { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> ( wtap_encap_dissector_table , wtap_encap <S2SV_ModEnd> , next_tvb , <S2SV_ModStart> pinfo , tree , TRUE , phdrp
",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z,681,,0
1541,CWE-20,"CWE-20 int read_filesystem_tables_4 ( ) { <S2SV_StartBug> long long directory_table_end , table_start ; <S2SV_EndBug> if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( read_uids_guids ( & table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( parse_exports_table ( & table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <S2SV_EndBug> return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) <S2SV_StartBug> return FALSE ; <S2SV_EndBug> if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> { long long table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_xattrs_from_disk <S2SV_ModStart> == 0 ) goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_id_table <S2SV_ModEnd> ( & table_start <S2SV_ModStart> == FALSE ) goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( parse_exports_table <S2SV_ModStart> == FALSE ) goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_fragment_table <S2SV_ModStart> read_fragment_table ( & table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_inode_table <S2SV_ModStart> == FALSE ) goto corrupted <S2SV_ModEnd> ; if ( <S2SV_ModStart> return TRUE ; corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\n"" ) ; return FALSE ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z,703,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> S2SV_null> <S2SV_null>,0
1552,CWE-20,"CWE-20 int DoOneObject ( char * cinput ) { <S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ; <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> return ( 0 ) ; } else { fprintf ( stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" , axohelp , nameobject ) ; <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) { <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>no<S2SV_blank>extra<S2SV_blank>numbers<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject , ""Curve"" ) == 0 ) { Curve ( argbuf , num1 ) ; } else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) { Polygon ( argbuf , num1 , 0 ) ; } else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) { Polygon ( argbuf , num1 , 1 ) ; } free ( argbuf ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) { <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> if ( num2 != 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>two<S2SV_blank>numbers<S2SV_blank>after<S2SV_blank>the<S2SV_blank>coordinates\\n<S2SV_blank><S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; DashCurve ( argbuf , num1 ) ; free ( argbuf ) ; <S2SV_StartBug> } <S2SV_EndBug> } else { <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < sizeof ( commands ) / sizeof ( KEYWORD ) ; i ++ ) { if ( strcmp ( nameobject , commands [ i ] . name ) == 0 ) { if ( num == commands [ i ] . numargs + 1 ) { axolinewidth = argbuf [ num - 1 ] ; SetLineWidth ( axolinewidth ) ; ( * ( commands [ i ] . func ) ) ( argbuf ) ; free ( argbuf ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>should<S2SV_blank>have<S2SV_blank>%d(+1)<S2SV_blank>arguments<S2SV_blank>in<S2SV_blank>%s.\\n"" , axohelp , nameobject , commands [ i ] . numargs , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } } if ( i >= sizeof ( commands ) / sizeof ( KEYWORD ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Command<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s.\\n"" , axohelp , nameobject , inname ) ; <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> return ( - 1 ) ; } } outpos += sprintf ( outpos , ""}\\n"" ) ; CleanupOutput ( StartClean ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; }
","<S2SV_ModStart> num1 , num2 , retcode <S2SV_ModStart> , * t <S2SV_ModEnd> ; double * <S2SV_ModStart> argbuf = 0 ; retcode = - 1 <S2SV_ModStart> t ++ ; fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> = outputbuffer ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ] == 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> = 1 ; fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> , VERSION , <S2SV_ModStart> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> stderr , ""%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n"" <S2SV_ModStart> nameobject ) ; goto EXIT ; } } <S2SV_ModEnd> if ( ( <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; for ( <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } } <S2SV_ModStart> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> argbuf ) ; } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> ) ; }
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,711,<S2SV_ModStart> <S2SV_null> <S2SV_null> static,0
1587,CWE-20,"CWE-20 error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '=' ) { separatorFound = TRUE ; param -> nameLen = p + i - param -> name ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { } else { error = ERROR_INVALID_SYNTAX ; } } else if ( ! separatorFound ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == '=' ) { separatorFound = TRUE ; } else if ( c == \'\\""\' ) { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { i = param -> name + param -> nameLen - p ; error = NO_ERROR ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> value == NULL ) { if ( c == '\\0' || c == ',' || c == ';' ) { error = NO_ERROR ; } else if ( c == '<S2SV_blank>' || c == '\\t' ) { } else if ( c == \'\\""\' ) { param -> value = p + i ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { param -> value = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( param -> value [ 0 ] == \'\\""\' ) { if ( c == '\\0' ) { error = ERROR_INVALID_SYNTAX ; } else if ( escapeFlag ) { escapeFlag = FALSE ; } else if ( c == '\\\\' ) { escapeFlag = TRUE ; } else if ( c == \'\\""\' ) { i ++ ; param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } else if ( isprint ( c ) || c == '\\t' || c >= 128 ) { } else { error = ERROR_INVALID_SYNTAX ; } } else { if ( c == '\\0' || c == '<S2SV_blank>' || c == '\\t' || c == ',' || c == ';' ) { param -> valueLen = p + i - param -> value ; error = NO_ERROR ; } <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> { } else { error = ERROR_INVALID_SYNTAX ; } } } if ( error == ERROR_IN_PROGRESS ) i ++ ; } if ( param -> valueLen >= 2 && param -> value [ 0 ] == \'\\""\' ) { param -> value ++ ; param -> valueLen -= 2 ; } * pos = p + i ; return error ; }
","<S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( ""!#$%&\'*+-.^_`|~"" ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,733,,0
1589,CWE-20,"CWE-20 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> out : return ERR_PTR ( error ) ; }
","<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return
",torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z,735,<S2SV_ModStart> ; if (! fmode <S2SV_ModEnd> ) return error,0
1591,CWE-20,"CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> return MagickTrue ; }
","<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z,737,<S2SV_ModStart> <S2SV_null> <S2SV_null> static,0
1595,CWE-20,"CWE-20 void BezierOval ( double w , double h , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , w , - h * BzK , w * BzK , - h , - h ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - w * BzK , - h , - w , - h * BzK , - w , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,740,"<S2SV_ModStart> y3 ) { sprintf ( outputbuffer <S2SV_ModEnd>, ""\\n <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f <S2SV_blank> %12.3f\\n"", outputbuffer ) ; sendClean ( outputbuffer ) ;",0
1599,CWE-20,"CWE-20 void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z,742,,0
1639,CWE-20,"CWE-20 void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; <S2SV_StartBug> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <S2SV_EndBug> ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec -> ps_dec_err_status -> u1_err_flag = ACCEPT_ALL_PICS ; ps_dec -> ps_dec_err_status -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; ps_dec -> ps_dec_err_status -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; ps_dec -> ps_dec_err_status -> u4_cur_frm = INIT_FRAME ; ps_dec -> ps_dec_err_status -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; ps_dec -> u1_pr_sl_type = 0xFF ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_prev_poc = & ps_dec -> s_prev_pic_poc ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb = 0 ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] = 0 ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_top_field_order_count = ps_cur_poc -> i4_top_field_order_count = 0 ; ps_prev_poc -> i4_bottom_field_order_count = ps_cur_poc -> i4_bottom_field_order_count = 0 ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field = 0 ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_poc -> u1_mmco_equalto5 = 0 ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst = 0 ; ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = 0 ; ps_dec -> i4_max_poc = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> u1_recon_mb_grp = 4 ; ps_dec -> u1_second_field = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; ps_dec -> u2_crop_offset_y = 0 ; ps_dec -> u2_crop_offset_uv = 0 ; ps_dec -> i4_vui_frame_rate = - 1 ; ps_dec -> i4_pic_type = - 1 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u1_res_changed = 0 ; ps_dec -> u1_frame_decoded_flag = 0 ; ps_dec -> u4_skip_frm_mask = SKIP_NONE ; ps_dec -> pf_cavlc_4x4res_block [ 0 ] = ih264d_cavlc_4x4res_block_totalcoeff_1 ; ps_dec -> pf_cavlc_4x4res_block [ 1 ] = ih264d_cavlc_4x4res_block_totalcoeff_2to10 ; ps_dec -> pf_cavlc_4x4res_block [ 2 ] = ih264d_cavlc_4x4res_block_totalcoeff_11to16 ; ps_dec -> pf_cavlc_parse4x4coeff [ 0 ] = ih264d_cavlc_parse4x4coeff_n0to7 ; ps_dec -> pf_cavlc_parse4x4coeff [ 1 ] = ih264d_cavlc_parse4x4coeff_n8 ; ps_dec -> pf_cavlc_parse_8x8block [ 0 ] = ih264d_cavlc_parse_8x8block_none_available ; ps_dec -> pf_cavlc_parse_8x8block [ 1 ] = ih264d_cavlc_parse_8x8block_left_available ; ps_dec -> pf_cavlc_parse_8x8block [ 2 ] = ih264d_cavlc_parse_8x8block_top_available ; ps_dec -> pf_cavlc_parse_8x8block [ 3 ] = ih264d_cavlc_parse_8x8block_both_available ; ps_dec -> pf_fill_bs1 [ 0 ] [ 0 ] = ih264d_fill_bs1_16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 0 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_pslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 0 ] = ih264d_fill_bs1_16x16mb_bslice ; ps_dec -> pf_fill_bs1 [ 1 ] [ 1 ] = ih264d_fill_bs1_non16x16mb_bslice ; ps_dec -> pf_fill_bs_xtra_left_edge [ 0 ] = ih264d_fill_bs_xtra_left_edge_cur_frm ; ps_dec -> pf_fill_bs_xtra_left_edge [ 1 ] = ih264d_fill_bs_xtra_left_edge_cur_fld ; ih264d_init_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_dec -> u2_prv_frame_num = 0 ; ps_dec -> u1_top_bottom_decoded = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> s_cab_dec_env . cabac_table = gau4_ih264d_cabac_table ; ps_dec -> pu1_left_mv_ctxt_inc = ps_dec -> u1_left_mv_ctxt_inc_arr [ 0 ] ; ps_dec -> pi1_left_ref_idx_ctxt_inc = & ps_dec -> i1_left_ref_idx_ctx_inc_arr [ 0 ] [ 0 ] ; ps_dec -> pu1_left_yuv_dc_csbp = & ps_dec -> u1_yuv_dc_csbp_topmb ; ps_dec -> u1_flushfrm = 0 ; { ps_dec -> s_cab_dec_env . pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_bitstrm -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_cur_slice -> pv_codec_handle = ( void * ) ps_dec ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ( void * ) ps_dec ; } memset ( ps_dec -> disp_bufs , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( disp_buf_t ) ) ; memset ( ps_dec -> u4_disp_buf_mapping , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; memset ( ps_dec -> u4_disp_buf_to_be_freed , 0 , ( MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; ih264d_init_arch ( ps_dec ) ; ih264d_init_function_ptr ( ps_dec ) ; ps_dec -> e_frm_out_mode = IVD_DISPLAY_FRAME_OUT ; ps_dec -> init_done = 1 ; }
","<S2SV_ModStart> , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )
",external@libavc/ecf6c7ce6d5a22d52160698aab44fc234c63291a,CVE-2016-3743,https://android.googlesource.com/platform/external/libavc/+/ecf6c7ce6d5a22d52160698aab44fc234c63291a,2016-07-11T01:59Z,768,,0
1669,CWE-20,"CWE-20 static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; <S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug> str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }
","<S2SV_ModStart> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> , & error <S2SV_ModStart> if ( ret > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> , error ) <S2SV_ModStart> 1 ; } <S2SV_ModEnd> else if (
",dovecot@core/000030feb7a30f193197f1aab8a7b04a26b42735,CVE-2017-2669,https://github.com/dovecot/core/commit/000030feb7a30f193197f1aab8a7b04a26b42735,2018-06-21T13:29Z,790,"<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key, <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> if (!",0
1672,CWE-20,"CWE-20 void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send ( <S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }
","<S2SV_ModStart> ; stbbr_send ( ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>""
",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z,793,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null>,0
1684,CWE-20,"CWE-20 uint16_t dm9000ReadPhyReg ( uint8_t address ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> usleep ( 5 ) ; <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z,805,"<S2SV_ModStart> ; dm9000WriteReg ( DM9000_ISR_ERR <S2SV_ModEnd>, MSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_ISR_ERR, DM9000_ERR ) ; dm9000WriteReg ( DM9000_EPCR, DM9000_ERR ) ; dm9000WriteReg ( DM9000_EPOS ) ; dm9000WriteReg ( DM9000_ERR, DM9000_EPOS ) ; dm9000WriteReg ( DM9000_EPCR ) ; dm9000WriteReg ( DM9000_EPOS ) ; dm9000WriteReg ( DM9000_EPOS ) ; dm9000WriteReg ( DM9000_ERR_EPOS ) ; dm9000WriteReg ( DM9000_EPOS ) ; dm9000WriteReg ( DM9000_EPOS ) ; dm9000WriteReg ( DM9000_ERR_ERR, DM9000_EPOS ) ; dm9000WriteReg ( DM9000WriteReg ( DM9000_EPCR, DM9000_",0
1692,CWE-20,"CWE-20 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; <S2SV_StartBug> msg . msg_name = ( struct sockaddr * ) & address ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_namelen = sizeof ( address ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> . msg_name = addr ? <S2SV_ModStart> ) & address : NULL <S2SV_ModStart> . msg_namelen = 0 <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z,809,<S2SV_ModStart> ; size = INT_MAX <S2SV_ModEnd> ; if (,0
