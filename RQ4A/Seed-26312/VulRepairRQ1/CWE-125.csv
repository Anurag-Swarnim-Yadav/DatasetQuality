Unnamed: 0,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time,Unnamed: 0.1,raw_predictions,correctly_predicted
1,CWE-125,"CWE-125 void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : <S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) { <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_FAST : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }
","<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , ""unknown"" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
",the-tcpdump-group@tcpdump/985122081165753c7442bd7824c473eb9ff56308,CVE-2017-13015,https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308,2017-09-14T06:29Z,1,"<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 2 ) ; <S2SV_ModStart> ( ndo, ""\\n\\t\\t <S2SV_blank> Type <S2SV_blank> %u <S2SV_blank> (%u)"", <S2SV_ModEnd> tok2str ( eap_type_values <S2SV_ModStart>, ""unknown"", subtype ), subtype <S2SV_ModEnd> ) ) ;",0
28,CWE-125,"CWE-125 static void l2tp_ppp_discon_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , <S2SV_StartBug> ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 5 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) dat ; if ( length < 5 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , ""Direction-#%u"" , EXTRACT_8BITS ( ptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; ptr ++ ; length -- ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,28,"<S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ptr ++ ; length -= 2 ; if ( length < 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart>, ""Direction-#%u"", * ( ( const u_char * ) ptr ++ ) ) ) ; length -= 2 ; if ( length < 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ptr, length <S2SV_ModEnd> ) ; }",0
29,CWE-125,"CWE-125 static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { <S2SV_StartBug> int alt ; <S2SV_EndBug> alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> return alt ; return usb_set_interface ( udev , <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
",torvalds@linux/786de92b3cb26012d3d0f00ee37adf14527f35c4,CVE-2017-16530,https://github.com/torvalds/linux/commit/786de92b3cb26012d3d0f00ee37adf14527f35c4,2017-11-04T01:29Z,29,"<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if (! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev, alt -> <S2SV_ModEnd> desc. bInterfaceNumber <S2SV_ModStart> bInterfaceNumber, alt -> desc. bAlternateSetting",1
51,CWE-125,"CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%s<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%u<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z,51,"<S2SV_ModStart>, cp, ep2, map, nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo, "" <S2SV_blank> #%u <S2SV_blank> attrmap=%u <S2SV_blank> "", tcount, map, nmap ) ) ; cp = ikev2_attr_print ( ndo, cp, ep2 ) ; } else if ( cp == NULL ) { ND_PRINT ( ( ndo, "" <S2SV_blank> #%u <S2SV_blank> attrmap=%u <S2SV_blank> "", tcount, cp, ep2 ) ) ; } if ( cp == NULL ) { ND_PRINT ( ( ndo, "" <S2SV_blank> #%u <S2SV_blank> attrmap=%u <S2SV_blank> "", tcount, map, nmap ) ) ; cp = ikev2_attr_print ( ndo, cp, ep2 ) ; } else if ( cp == NULL ) { ND_PRINT ( ( ndo, "" <S2SV_blank> #%u <S2SV_blank> attrmap=%u <S2SV_blank> "", tcount, cp, ep2 ) ) ; } if ( cp == NULL ) { ND_PRINT ( ( ndo, "" <S2SV_blank> #%u <S2SV_blank> attrmap=%u <S2SV_blank> "", tcount, map, nmap ) ) ;",0
60,CWE-125,"CWE-125 static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) { <S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ; <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE : <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Path<S2SV_blank>Cost:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Prio:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>V:<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>SPSource-ID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>No<S2SV_blank>of<S2SV_blank>Trees:<S2SV_blank>%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> { <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>SPVID:<S2SV_blank>%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ; <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI : <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>VID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T:<S2SV_blank>%d,<S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>ISID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; } <S2SV_StartBug> } <S2SV_EndBug> return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }
","<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
",the-tcpdump-group@tcpdump/b20e1639dbac84b3fcb393858521c13ad47a9d70,CVE-2017-13026,https://github.com/the-tcpdump-group/tcpdump/commit/b20e1639dbac84b3fcb393858521c13ad47a9d70,2017-09-14T06:29Z,60,"<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr, 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len + ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; stlv_len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = st",0
63,CWE-125,"CWE-125 static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""<S2SV_blank>csum"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }
","<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
",the-tcpdump-group@tcpdump/4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c,CVE-2017-13040,https://github.com/the-tcpdump-group/tcpdump/commit/4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c,2017-09-14T06:29Z,63,<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN ),1
65,CWE-125,"CWE-125 static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; <S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , ""invalid<S2SV_blank>packet<S2SV_blank>line"" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
","<S2SV_ModStart> = GIT_PKT_NG ; if ( len < 3 ) goto out_err ; <S2SV_ModStart> += 3 ; len -= 3 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '<S2SV_blank>' , len <S2SV_ModStart> = '\\0' ; if ( len < 1 ) goto out_err ; <S2SV_ModStart> + 1 ; len -= 1 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '\\n' , len
",libgit2@libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,CVE-2018-15501,https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,2018-08-18T02:29Z,65,"<S2SV_ModStart> = GIT_PKT_NG ; if ( strlen ( line ) < 3 ) { giterr_set ( GITERR_NET, ""invalid <S2SV_blank> packet <S2SV_blank> line"" ) ; return - 1 ; } <S2SV_ModStart> = '\\0' ; if ( strlen ( line ) < 3 ) { giterr_set ( GITERR_NET, ""invalid <S2SV_blank> packet <S2SV_blank> line"" ) ; return - 1 ; } <S2SV_ModStart> = ptr + len <S2SV_ModEnd> ; if ( <S2SV_ModStart> if (! ( ptr <S2SV_ModEnd> = strchr ( <S2SV_ModStart> '\\n' ) ) ) { giterr_set ( GITERR_NET, ""invalid <S2SV_blank> packet <S2SV_blank> line"" ) ; return - 1 ; } len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen, len, 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg, line, len ) ; pkt -> msg [ len ] = '\\0' ; if ( strlen ( line ) < 2 ) { giterr_set ( GITERR_NET, ""invalid <S2SV_blank> packet <S2SV_blank> line"" ) ; return - 1",0
72,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; <S2SV_StartBug> UINT16 length ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> RequestedProtocols ) ; WLog_DBG ( TAG , ""RDP_NEG_REQ:<S2SV_blank>RequestedProtocol:<S2SV_blank>0x%08"" PRIX32 """" , nego -> RequestedProtocols ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> ; UINT16 length ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,72,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ; UINT16 length <S2SV_ModEnd> ; Stream_Read_UINT32 ( <S2SV_ModStart> = NEGO_STATE_FINAL ; return ;,0
76,CWE-125,"CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }
","<S2SV_ModStart> av_log ( mxf -> fc
",FFmpeg@FFmpeg/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,CVE-2018-1999014,https://github.com/FFmpeg/FFmpeg/commit/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,2018-07-23T15:29Z,76,"<S2SV_ModStart> av_log ( mxf -> fc <S2SV_ModEnd>, AV_LOG_ERROR, <S2SV_ModStart> AV_LOG_ERROR, ""material <S2SV_blank> track <S2SV_blank> not <S2SV_blank> found\\n"" ) ; break <S2SV_ModEnd> ; } if <S2SV_ModStart> av_log ( mxf -> fc <S2SV_ModEnd>, AV_LOG_ERROR, <S2SV_ModStart> AV_LOG_ERROR, ""material <S2SV_blank> track <S2SV_blank> not <S2SV_blank> found\\n"" ) ; break <S2SV_ModEnd> ; } if <S2SV_ModStart> av_log ( mxf -> fc <S2SV_ModEnd>, AV_LOG_ERROR,",0
79,CWE-125,"CWE-125 static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; ND_TCHECK ( p [ 0 ] ) ; while ( lp -> s != NULL ) { if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; <S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
",the-tcpdump-group@tcpdump/42073d54c53a496be40ae84152bbfe2c923ac7bc,CVE-2017-13004,https://github.com/the-tcpdump-group/tcpdump/commit/42073d54c53a496be40ae84152bbfe2c923ac7bc,2017-09-14T06:29Z,79,"<S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ], 2 ) ;",0
97,CWE-125,"CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> value = ast2obj_int ( o -> lineno ) ; <S2SV_EndBug> if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value =
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,97,"<S2SV_ModStart> value ) ; value = ast2obj_int ( o -> lineno ) ; if (! value ) goto failed ; if ( _PyObject_SetAttrId ( result, & PyId_lineno, value ) < 0 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_int ( o -> col_offset ) ; if (! value ) goto failed ; if ( _PyObject_SetAttrId ( result, & PyId_col_offset, value ) < 0 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> o -> end_lineno <S2SV_ModEnd> ) ; if",0
100,CWE-125,"CWE-125 static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)"" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u"" "",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u"" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_compproto_subopt_values , ""Unknown"" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ipcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z,100,<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; compproto,0
111,CWE-125,"CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,111,"<S2SV_ModStart> ( ndo, ""%s"", rpl_tstr <S2SV_ModEnd> ) ) ;",1
112,CWE-125,"CWE-125 <S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ; <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> hexdump = FALSE ; ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Serial:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_IPV6_PREFIX_PDU : { const rpki_rtr_pdu_ipv6_prefix * pdu ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_ERROR_REPORT_PDU : { const rpki_rtr_pdu_error_report * pdu ; u_int encapsulated_pdu_length , text_length , tlen , error_code ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> tlen = pdu_len ; error_code = EXTRACT_16BITS ( pdu -> pdu_header . u . error_code ) ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>code:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Encapsulated<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , tok2str ( rpki_rtr_error_codes , ""Unknown"" , error_code ) , error_code , encapsulated_pdu_length ) ) ; <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> tlen -= sizeof ( * pdu ) ; <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> ( encapsulated_pdu_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%s-----encapsulated<S2SV_blank>PDU-----"" , indent_string ( indent + 4 ) ) ) ; <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> goto trunc ; } tptr += encapsulated_pdu_length ; <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> if ( tlen > 4 ) { <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> } <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> if ( text_length && ( text_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : hexdump = TRUE ; } if ( ndo -> ndo_vflag > 1 || ( ndo -> ndo_vflag && hexdump ) ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , pdu_len ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> trunc : <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> length ) ; <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> encapsulated_pdu_length ) ; tlen += 4 <S2SV_ModEnd> ; error_code = <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( encapsulated_pdu_length <S2SV_ModStart> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ndo , tptr + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> + 2 ) ; } tlen <S2SV_ModEnd> += encapsulated_pdu_length ; <S2SV_ModStart> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> ; text_length = <S2SV_ModStart> ; text_length = <S2SV_ModEnd> EXTRACT_32BITS ( tptr <S2SV_ModStart> EXTRACT_32BITS ( tptr + tlen ) ; tlen <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> ND_TCHECK2 ( * <S2SV_ModStart> * tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = TRUE <S2SV_ModStart> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> ; trunc : <S2SV_ModStart> ; trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> ; } <S2SV_null>
",the-tcpdump-group@tcpdump/83c64fce3a5226b080e535f5131a8a318f30e79b,CVE-2017-13050,https://github.com/the-tcpdump-group/tcpdump/commit/83c64fce3a5226b080e535f5131a8a318f30e79b,2017-09-14T06:29Z,112,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr!= 0 ) { ND_PRINT ( ( ndo, ""%sRPKI-RTRv%u, <S2SV_blank> %s <S2SV_blank> PDU <S2SV_blank> (%u), <S2SV_blank> length: <S2SV_blank> %u"", indent_string ( 8 ), * tptr, * tptr ) ) ; return 0 ; } ND_TCHECK2 ( * tptr, sizeof ( rpki_rtr_pdu ), pdu_len ) ) ; <S2SV_ModStart> case RPKI_RTR_END_OF_DATA_PDU : ND_PRINT ( ( ndo, ""%sSession <S2SV_blank> ID: <S2SV_blank> 0x%04x, <S2SV_blank> Serial: <S2SV_blank> %u"", indent_string ( indent + 2 ), EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : break",0
118,CWE-125,"CWE-125 u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO : <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,118,"<S2SV_ModStart> p, length <S2SV_ModEnd> ) ; break",1
131,CWE-125,"CWE-125 void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; <S2SV_StartBug> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <S2SV_EndBug> readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ; <S2SV_StartBug> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <S2SV_EndBug> if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }
","<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z,131,"<S2SV_ModStart> + MIDQ_DATA_BUFF ; mutex_lock <S2SV_ModEnd> ( & mpu <S2SV_ModStart> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail )!= readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp ; if (! test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, & mpu -> mode",0
137,CWE-125,"CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,137,<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;,1
138,CWE-125,"CWE-125 GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; <S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }
","<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
",gpac@gpac/bceb03fd2be95097a7b409ea59914f332fb6bc86,CVE-2018-13006,https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86,2018-06-29T14:29Z,138,<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart>!= 0 ) <S2SV_ModEnd> ) { i,1
146,CWE-125,"CWE-125 void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; } <S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ; <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT : <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
",the-tcpdump-group@tcpdump/de981e6070d168b58ec1bb0713ded77ed4ad87f4,CVE-2017-12901,https://github.com/the-tcpdump-group/tcpdump/commit/de981e6070d168b58ec1bb0713ded77ed4ad87f4,2017-09-14T06:29Z,146,"<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo, ""EIGRP <S2SV_blank> %s, <S2SV_blank> length: <S2SV_blank> %u <S2SV_blank> (too <S2SV_blank> short, <S2SV_blank> < <S2SV_blank> %u)"", tok2str ( eigrp_opcode_values, ""unknown <S2SV_blank> (%u)"", eigrp_com_header -> opcode ), len, ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> (too <S2SV_blank> short, <S2SV_blank> < <S2SV_blank> %u)"", ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( tlv_tlen < sizeof ( * tlv_ptr. eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> (too <S2SV_blank> short, <S2SV_blank> < <S2SV_blank> %u)"", ( u_int ) sizeof ( * tlv",0
182,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
",ImageMagick@ImageMagick/6b4aff0f117b978502ee5bcd6e753c17aec5a961,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/6b4aff0f117b978502ee5bcd6e753c17aec5a961,2017-04-20T18:59Z,182,"<S2SV_ModStart> ""UnableToReadImageData"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ;",0
198,CWE-125,"CWE-125 static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) { <S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> spacep = strchr ( temp , '<S2SV_blank>' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }
","<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> , sfsname , stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'
",the-tcpdump-group@tcpdump/7a923447fd49a069a0fd3b6c3547438ab5ee2123,CVE-2017-13001,https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123,2017-09-14T06:29Z,198,"<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int len2 ; temp [ NFSX_V3FHMAX + 1 ] = '\\0' ; len2 = strnlen ( sfsname, NFSX_V3FHMAX ) ; if ( len2 > sizeof ( temp ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> fh <S2SV_blank> [%u]/"", temp ) ) ; goto trunc ; } <S2SV_ModStart>, sfsname, len2 <S2SV_ModEnd> ) ; temp <S2SV_ModStart> = '\\0' ; spacep = strchr ( temp,'<S2SV_blank>') ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo, "" <S2SV_blank> fh <S2SV_blank> %s/"", temp ) ) ; } else { ND_PRINT ( ( ndo, "" <S2SV_blank> fh <S2SV_blank> %d,%d/"", fsid. Fsid_dev ) ) ; } if ( ino > NFSX_V3FHMAX ) { ND_PRINT ( ( ndo, "" <S2SV_blank> fh <S2SV_blank> [%u]/"", temp ) ) ; } if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo,",0
211,CWE-125,"CWE-125 static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ; <S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> if ( len >= 0 ) len += tested ; } return ( len ) ; }
","<S2SV_ModStart> ( * b + len , * avail - len <S2SV_ModEnd> , nl )
",libarchive@libarchive/eec077f52bfa2d3f7103b4b74d52572ba8a15aca,CVE-2016-8688,https://github.com/libarchive/libarchive/commit/eec077f52bfa2d3f7103b4b74d52572ba8a15aca,2017-02-15T19:59Z,211,"<S2SV_ModStart> ( * b + len, * avail - len <S2SV_ModEnd>, nl )",1
212,CWE-125,"CWE-125 static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { <S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> int kind ; void * data ; PyCompilerFlags cf ; <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> char * str ; <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
","<S2SV_ModStart> n ) { <S2SV_ModEnd> PyCompilerFlags cf ; <S2SV_ModStart> PyCompilerFlags cf ; node * mod_n ; <S2SV_ModStart> * str ; Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ':' ) ; for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> expr_end - expr_start <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; str = <S2SV_ModStart> == NULL ) { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> str [ 0 <S2SV_ModStart> = PyCF_ONLY_AST ; mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> PyMem_RawFree ( str ) ; Ta3Node_Free ( mod_n
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,212,"<S2SV_ModStart> n ) { assert ( expr_start < expr_end ) ; <S2SV_ModStart> * o, * fstring_name <S2SV_ModEnd> ; Py_ssize_t len <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; assert ( <S2SV_ModStart> == ':' ) ) { Py_DECREF ( o ) ; str = PyMem_RawMalloc ( 3 ) ; if ( str == NULL ) return NULL ; all_whitespace = 1 ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if (! PyUnicode_ISSPACE ( PyUnicode_READ ( PyUnicode_KIND ( kind, data, i ) ) ) { Py_DECREF ( o ) ; str [ 0 ] = '(' ; memcpy ( str + 1, expr_start, len ) ; } } if ( all_whitespace ) { ast_error ( c, n, ""f-string: <S2SV_blank> empty <S2SV_blank> expression <S2SV_blank> not <S2SV_blank> allowed"" ) ; return NULL ; } len = expr_end - expr_start ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; Py_DECREF ( fstring",0
213,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> { WLog_DBG ( TAG , ""%s<S2SV_blank>(Len:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>MaxLen:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>BufferOffset:<S2SV_blank>%"" PRIu32 "")"" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,213,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
223,CWE-125,"CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,CVE-2018-11377,https://github.com/radare/radare2/commit/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,2018-05-22T19:29Z,223,<S2SV_ModStart> ; RAnalOp next_op = { 0 },1
228,CWE-125,"CWE-125 static VarLenData * * get_html_data ( MAPI_Attr * a ) { VarLenData * * body = XCALLOC ( VarLenData * , a -> num_values + 1 ) ; int j ; for ( j = 0 ; j < a -> num_values ; j ++ ) <S2SV_StartBug> { <S2SV_EndBug> body [ j ] = XMALLOC ( VarLenData , 1 ) ; body [ j ] -> len = a -> values [ j ] . len ; body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; } <S2SV_StartBug> return body ; <S2SV_EndBug> }
","<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } }
",verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z,228,<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } },1
230,CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,230,"<S2SV_ModStart> u_char * dat, u_int length <S2SV_ModStart>, val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; val_l = <S2SV_ModStart> ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return",0
237,CWE-125,"CWE-125 static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>"" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>"" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { <S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z,237,"<S2SV_ModStart> ( cp, ep2, map, nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; } if <S2SV_ModStart> ( cp, ep2, map, nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; } if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; } if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; } } if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; } if ( cp == NULL ) { ND_PRINT ( ( ndo, ""\\n"" ) ) ; goto trunc ; }",0
249,CWE-125,"CWE-125 void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ; <S2SV_StartBug> register u_int amt ; <S2SV_EndBug> register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> if ( j == 1 <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>dump"" ) ) ; break ; } <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RIP6_RESPONSE : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d:"" , j ) ) ; <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , ni -> rip6_metric ) ; } <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-%d<S2SV_blank>??<S2SV_blank>%u"" , rp -> rip6_cmd , length ) ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ;
",the-tcpdump-group@tcpdump/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,CVE-2017-12992,https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,2017-09-14T06:29Z,249,"<S2SV_ModStart> * ni ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; register <S2SV_ModStart> case RIP6_REQUEST : ND_TCHECK2 ( rp -> rip6_nets ) ; <S2SV_ModStart> j == 1 ) goto trunc ; ND_TCHECK2 ( rp -> rip6_nets ) ; <S2SV_ModStart> j == 1 ) goto trunc <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } ND_TCHECK2 ( rp -> rip6_nets ) ; if ( j * sizeof ( * ni )!= length - 4 ) ND_PRINT ( ( ndo, "" <S2SV_blank> ripng-req <S2SV_blank> %u[%u]:"", j, length ) ) ; else ND_PRINT ( ( ndo, "" <S2SV_blank> ripng-req <S2SV_blank> %u:"", j ) ) ; for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; i -= sizeof ( * ni ), ++ ni ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo, ""\\n\\t"" ) ) ; rip6_entry_print ( ndo, ni, 0 ) ; } break ; case RIP6_",0
253,CWE-125,"CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
","<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
",libgd@libgd/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,CVE-2013-7456,https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,2016-08-07T10:59Z,253,<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ]. Left = iLeft ; res -> ContribRow [ u ]. Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ].,1
259,CWE-125,"CWE-125 static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; <S2SV_StartBug> int is_async = 0 ; <S2SV_EndBug> REQ ( n , comp_for ) ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> is_async = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async<S2SV_blank>comprehensions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.6<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } <S2SV_StartBug> for_ch = CHILD ( n , 1 + is_async ) ; <S2SV_EndBug> t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; <S2SV_StartBug> expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; <S2SV_EndBug> if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> int j , n_ifs ; asdl_seq * ifs ; <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
","<S2SV_ModStart> * for_ch ; node * sync_n ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 <S2SV_ModEnd> ) { is_async <S2SV_ModStart> = 1 ; REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> if ( is_async <S2SV_ModStart> = CHILD ( sync_n , 1 <S2SV_ModEnd> ) ; t <S2SV_ModStart> , CHILD ( sync_n , 3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( NCH ( sync_n ) == 5 <S2SV_ModEnd> ) { int <S2SV_ModStart> = CHILD ( sync_n , 4 <S2SV_ModEnd> ) ; n_ifs
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,259,<S2SV_ModStart> * for_ch ; bool is_async ; int is_ <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug> <S2SV_StartBug>,0
268,CWE-125,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z,268,<S2SV_ModStart> < sizeof ( struct pgstate <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ) ; } ND_TCHECK_32BITS ( & prep -> pp_n ) ;,0
274,CWE-125,"CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
","<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->
",radare@radare2/1f37c04f2a762500222dda2459e6a04646feeedf,CVE-2018-11376,https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf,2018-05-22T19:29Z,274,<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->,1
275,CWE-125,"CWE-125 static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( isis_ext_is_reach_subtlv_values , ""unknown"" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if ( subl >= 32 ) { for ( te_class = 0 ; te_class < 8 ; te_class ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TE-Class<S2SV_blank>%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ; tptr ++ ; for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) { <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Bandwidth<S2SV_blank>constraint<S2SV_blank>CT%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC : if ( subl >= 3 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE : if ( subl == 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]<S2SV_blank>(0x%04x)"" , bittok2str ( isis_subtlv_link_attribute_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) ) , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE : if ( subl >= 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , bittok2str ( gmpls_link_prot_values , ""none"" , * tptr ) , * ( tptr + 1 ) ) ) ; } break ; case ISIS_SUBTLV_SPB_METRIC : if ( subl >= 6 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>LM:<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; tptr = tptr + 3 ; ND_PRINT ( ( ndo , "",<S2SV_blank>P:<S2SV_blank>%u"" , * ( tptr ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>P-ID:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR : if ( subl >= 36 ) { gmpls_switch_cap = * tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>Switching<S2SV_blank>Capability:%s"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , gmpls_switch_cap ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>LSP<S2SV_blank>Encoding:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( tptr + 1 ) ) ) ) ; tptr += 4 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Max<S2SV_blank>LSP<S2SV_blank>Bandwidth:"" , ident ) ) ; for ( priority_level = 0 ; priority_level < 8 ; priority_level ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>priority<S2SV_blank>level<S2SV_blank>%d:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , priority_level , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } subl -= 36 ; switch ( gmpls_switch_cap ) { case GMPLS_PSC1 : case GMPLS_PSC2 : case GMPLS_PSC3 : case GMPLS_PSC4 : ND_TCHECK2 ( * tptr , 6 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>MTU:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case GMPLS_TSC : ND_TCHECK2 ( * tptr , 8 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Indication<S2SV_blank>%s"" , ident , tok2str ( gmpls_switch_cap_tsc_indication_values , ""Unknown<S2SV_blank>(%u)"" , * ( tptr + 4 ) ) ) ) ; break ; default : if ( subl > 0 ) { if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; } } } break ; default : if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; break ; } return ( 1 ) ; trunc : return ( 0 ) ; }
","<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> bw . i
",the-tcpdump-group@tcpdump/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,CVE-2017-13055,https://github.com/the-tcpdump-group/tcpdump/commit/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,2017-09-14T06:29Z,275,"<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_WIDTH : if ( subl == 0 ) break ; <S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_HEIGHT : if ( subl == 8 ) ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; else ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; <S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_HEIGHT : if ( subl == 8 ) ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr + 4 ) ) ) ; else if ( subl == 0 ) ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ; else ND_PRINT ( ( ndo, "", <S2SV_blank> 0x%08x"", ipaddr_string ( ndo, tptr ) ) ) ;",0
277,CWE-125,"CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
",kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z,277,"<S2SV_ModStart> < q ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> low ) ; } <S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> low ) ; } <S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> low ) ; }",0
297,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,297,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
308,CWE-125,"CWE-125 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> offset ) ; } return offset ; }
","<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z,308,<S2SV_ModStart> nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>,0
322,CWE-125,"CWE-125 void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) { sycc420_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc422_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc444_to_rgb ( img ) ; } else { fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> }
","<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z,322,<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>,1
348,CWE-125,"CWE-125 GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }
","<S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; tmp_str =
",gpac@gpac/8e05648d6b4459facbc783025c5c42d301fef5c3,CVE-2020-23928,https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3,2021-04-21T18:15Z,348,<S2SV_ModStart> return GF_ISOM_INVALID_FILE ; if ( ( <S2SV_ModStart> ) ptr -> size % sizeof ( GF_AdobeBootstrapInfoBox )!= 0 ) return GF_ISOM_INVALID_FILE ; if ( ( ( u32 ) ptr -> size / sizeof ( GF_AdobeBootstrapInfoBox ) )!= 0 ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> - 8 ; if ( ( ( u32 ) ptr -> size % sizeof ( GF_AdobeBootstrapInfoBox ) )!= 0 ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> -> size - sizeof ( GF_AdobeBootstrapInfoBox ) ) return GF_ISOM_INVALID_FILE ; if ( ( ( u32 ) ptr -> size % sizeof ( GF_AdobeBootstrapInfoBox ) )!= 0 ) return GF_ISOM_INVALID_FILE ; if ( ( ( u32 ) ptr -> size % sizeof ( GF_AdobeBootstrapInfoBox ) )!= 0 ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> -> size - sizeof ( GF_AdobeBootstrapInfoBox ) ) return GF_ISOM,0
353,CWE-125,"CWE-125 static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z,353,"<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw, maxh <S2SV_ModStart> maxh, max, offx, loopmaxw <S2SV_ModStart>, upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; for ( i = 0U ; i < maxw ; ++ i ) { sycc_to_rgb ( offset, upb, * y, * cb, * cr, r, g, b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> ( offset, upb, * y, * cb, * cr, r, g, b ) ; ++ y ; ++ r ; ++ g ; ++ cb ; ++ cr ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>",0
364,CWE-125,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,364,"<S2SV_ModStart> ) ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, "" <S2SV_blank> [|osi]"" ) ) ; <S2SV_ModStart> 1 ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, "" <S2SV_blank> "" ) ) ; atalk_print ( ndo, p, length ) ; return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo, p, length, src, dst ) ; return ( 1 ) ; case ETHERTYPE_PPPOED1 : case ETHERTYPE_PPPOED1 : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, ""et1 <S2SV_blank> "" ) ) ; atalk_print ( ndo, p, length ) ; return ( 1 ) ; case ETHERTYPE_PPPOES1 : case ETHERTYPE_PPPOES2 : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, ""et1 <S2SV_blank> "" ) ) ; atalk_print ( ndo, p, length ) ; return ( 1",0
377,CWE-125,"CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z,377,<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT,1
388,CWE-125,"CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,388,"<S2SV_ModStart> bp, len ) ; break ; case ETHERTYPE_TEB : ND_TCHECK_16BITS ( * bp, 2 ) ; <S2SV_ModStart> ndo_vflag ) ND_PRINT ( ( ndo, "", <S2SV_blank> sum <S2SV_blank> 0x%x"", EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; if ( flags & GRE_KP ) { <S2SV_ModStart> ndo_vflag ) ND_PRINT ( ( ndo, "", <S2SV_blank> key=0x%x"", EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { <S2SV_ModStart> ndo_vflag ) ND_PRINT ( ( ndo, "", <S2SV_blank> seq <S2SV_blank> %u"", EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_CP ) { ND_TCHECK_16BITS ( * bp, 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, "", <S2SV_blank> key=0x%x"", EXTRACT_",0
394,CWE-125,"CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
","<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
",radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z,394,<S2SV_ModStart> : case 0x16 : case 0x17 : case 0x18 : case 0x19 : case 0x0a : case 0x0b : case 0x0c : case 0x0f : case <S2SV_ModStart> : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x6a : case 0x6b : case 0x6e : case 0x6f : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x8a : case 0x8b : case 0x8f : case 0x9a : case 0x9f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x17 : case 0x18 : case 0x19 : case 0x18 : case 0x19 : case 0x18 : case 0x19 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x8a : case 0x,0
397,CWE-125,"CWE-125 int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL ) <S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , ""Can\'t<S2SV_blank>create<S2SV_blank>file<S2SV_blank>%s"" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , ""<S2SV_blank>Writing<S2SV_blank>output<S2SV_blank>to<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; fprintf ( stdout , ""<S2SV_blank>-><S2SV_blank>Script<S2SV_blank>encoded<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>instructions.\\n\\n"" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }
","<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
",LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z,397,<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID,1
398,CWE-125,"CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/e01c9bf76740802025c9328901b55ee4a0c49ed6,CVE-2018-14880,https://github.com/the-tcpdump-group/tcpdump/commit/e01c9bf76740802025c9328901b55ee4a0c49ed6,2019-10-03T16:15Z,398,<S2SV_ModStart> goto trunc ; if ( lshp -> ls_length < 2 ) goto trunc ;,0
400,CWE-125,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> offset += tim . length - 3 ; <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> , p + offset + 3 , <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ) ; offset += <S2SV_ModEnd> tim . length <S2SV_ModStart> length - 3 ; length -= <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ; <S2SV_ModEnd> if ( !
",the-tcpdump-group@tcpdump/99798bd9a41bd3d03fdc1e949810a38967f20ed3,CVE-2017-12987,https://github.com/the-tcpdump-group/tcpdump/commit/99798bd9a41bd3d03fdc1e949810a38967f20ed3,2017-09-14T06:29Z,400,"<S2SV_ModStart> tim. length + 1 ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 4 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 5 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 6 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 4 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 5 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 6 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 5 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 4 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 5 ), 4 ) ) return 0 ; if (! ND_TTEST2 ( * ( p + offset + 6 ),",0
409,CWE-125,"CWE-125 static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
","<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
",ImageMagick@ImageMagick/5f16640725b1225e6337c62526e6577f0f88edb8,CVE-2016-7525,https://github.com/ImageMagick/ImageMagick/commit/5f16640725b1225e6337c62526e6577f0f88edb8,2017-04-20T18:59Z,409,<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image ),1
413,CWE-125,"CWE-125 static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
","<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,413,"<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t, 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t, 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t, 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t, 1 ) <S2SV_ModEnd> << rpy )",1
416,CWE-125,"CWE-125 static int cfm_network_addr_print ( netdissect_options * ndo , <S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> { u_int network_addr_type ; <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> network_addr_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown"" , network_addr_type ) , network_addr_type ) ) ; switch ( network_addr_type ) { case AFNUM_INET : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; case AFNUM_INET6 : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }
","<S2SV_ModStart> u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; }
",the-tcpdump-group@tcpdump/5d340a5ca6e420a70297cdbdf777333f18bfdab7,CVE-2017-13052,https://github.com/the-tcpdump-group/tcpdump/commit/5d340a5ca6e420a70297cdbdf777333f18bfdab7,2017-09-14T06:29Z,416,"<S2SV_ModStart> u_char * tptr, const u_int length <S2SV_ModStart> u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> case AFNUM_INET : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv4 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv6 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv6 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length < 2 ) { ND_PRINT ( ( ndo, ""(invalid <S2SV_blank> IPv6 <S2SV_blank> address <S2SV_blank> length)"" ) ) ; hexdump = TRUE ; break ; }",0
423,CWE-125,"CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = ""?"" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp"" : ""tcp"" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , ""]"" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp6"" : ""tcp6"" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = ""unix"" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , ""<AF<S2SV_blank>%d>"" , af ) ; } if ( port ) { sprintf ( addr , ""%s:%s:%u"" , protoname , addr_text , port ) ; } else { sprintf ( addr , ""%s:%s"" , protoname , addr_text ) ; } }
","<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'
",memcached@memcached/554b56687a19300a75ec24184746b5512580c819,CVE-2019-15026,https://github.com/memcached/memcached/commit/554b56687a19300a75ec24184746b5512580c819,2019-08-30T15:15Z,423,"<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( pathlen > MAXPATHLEN ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text, ( ( struct sockaddr_un * ) sock_addr ) -> sun_path, pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'",0
442,CWE-125,"CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>attr:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>EOF"" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>from:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>to:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>file<S2SV_blank>POST:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>dir:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z,442,"<S2SV_ModStart> ( er ) { ND_TCHECK ( <S2SV_ModEnd> dp ) ; <S2SV_ModStart> ( er ) { ND_TCHECK ( <S2SV_ModEnd> dp ) ; <S2SV_ModStart> ( er ) { ND_TCHECK ( <S2SV_ModEnd> dp ) ; <S2SV_ModStart> ( er ) { ND_TCHECK ( <S2SV_ModEnd> dp ) ; <S2SV_ModStart> ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> post <S2SV_blank> dattr:"" ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> post <S2SV_blank> dattr:"" ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> post <S2SV_blank> dattr:"" ) ) ; } } } else { ND_PRINT ( ( ndo, "" <S2SV_blank> dattr:"" ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> post <S2SV_blank> dattr:"" ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> post <S2SV_blank> dattr:"" ) ) ; if (",0
455,CWE-125,"CWE-125 mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }
","<S2SV_ModStart> asdl_seq * body , asdl_seq * type_ignores <S2SV_ModStart> = body ; p -> v . Module . type_ignores = type_ignores ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,455,"<S2SV_ModStart> asdl_seq * body, asdl_arena * arena <S2SV_ModStart> = body ; p -> v. Module. arena = arena ;",0
465,CWE-125,"CWE-125 int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> hlen += 1 ; hlen += 1 ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( - 1 ) ; }
","<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> & 0xf0 ) { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( mh -> <S2SV_ModStart> [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ;
",the-tcpdump-group@tcpdump/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,CVE-2017-13009,https://github.com/the-tcpdump-group/tcpdump/commit/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,2017-09-14T06:29Z,465,<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ) ) ; },0
467,CWE-125,"CWE-125 struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ; <S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ; <S2SV_StartBug> } * note ; <S2SV_EndBug> UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ; <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ; <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> hmi_data += 4 ; hmi_track_offset [ i ] += 4 ; <S2SV_StartBug> } <S2SV_EndBug> hmi_data += 4 ; hmi_track_offset [ i ] += 4 ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ; <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ; <S2SV_StartBug> } <S2SV_EndBug> } if ( * hmi_data > 0x7f ) { do { <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> } while ( * hmi_data > 0x7F ) ; } <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }
","<S2SV_ModStart> = hmi_data ; uint32_t data_siz ; <S2SV_ModStart> } * note <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> += hmi_tmp ; hmi_tmp += 4 ; <S2SV_ModStart> += 4 ; hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> hmi_mdi , hmi_data , data_siz <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; <S2SV_ModStart> ; if ( data_siz && <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> > 0x7F ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> * hmi_data > <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; hmi_data ++ ; data_siz --
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z,467,"<S2SV_ModStart> = hmi_data ; uint32_t data_siz ; <S2SV_ModStart> } * note <S2SV_ModEnd> ; if ( <S2SV_ModStart> += hmi_tmp ; data_siz = hmi_tmp ; <S2SV_ModStart> += hmi_tmp ; if ( data_siz < hmi_tmp ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> in <S2SV_blank> hmi"", 0 ) ; return NULL ; } <S2SV_ModStart> += hmi_tmp ; data_siz -= hmi_tmp ; <S2SV_ModStart> += hmi_tmp ; if ( data_siz < hmi_tmp ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> in <S2SV_blank> hmi"", 0 ) ; return NULL ; } <S2SV_ModStart> += hmi_tmp ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_HMI, ""Not <S2SV_blank> enough <S2SV_blank> data <S2SV_blank> in <S2SV_blank> hmi"",",0
484,CWE-125,"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\n\\t%s<S2SV_blank>(%u)"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type:<S2SV_blank>%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; <S2SV_StartBug> if ( netal == 0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ; <S2SV_EndBug> else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>opts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(bad<S2SV_blank>length)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; pptr += opli ; } trunc : return ; }
","<S2SV_ModStart> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> 0 ) ND_PRINT <S2SV_ModStart> ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , <S2SV_ModEnd> isonsap_string ( ndo
",the-tcpdump-group@tcpdump/c177cb3800a9a68d79b2812f0ffcb9479abd6eb8,CVE-2017-13016,https://github.com/the-tcpdump-group/tcpdump/commit/c177cb3800a9a68d79b2812f0ffcb9479abd6eb8,2017-09-14T06:29Z,484,"<S2SV_ModStart> return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> indicator <S2SV_blank> %u <S2SV_blank> < <S2SV_blank> min <S2SV_blank> PDU <S2SV_blank> size:"", li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo, ""%02X"", * pptr ++ ) ) ; if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> %u <S2SV_blank> < <S2SV_blank> min <S2SV_blank> PDU <S2SV_blank> size:"", li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo, ""%02X"", * pptr ++ ) ; if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> indicator <S2SV_blank> %u <S2SV_blank> < <S2SV_blank> min <S2SV_blank> PDU <S2SV_blank> size:"", li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> indicator <S2SV_blank> %u <S2SV_blank> <",0
488,CWE-125,"CWE-125 static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
","<S2SV_ModStart> self ) { PyObject_GC_UnTrack ( self ) ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,488,<S2SV_ModStart> self ) { if ( self -> dict ) Py_CLEAR ( self -> dict ) ;,0
500,CWE-125,"CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
","<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z,500,<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size ),1
504,CWE-125,"CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> type_ignore_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( type_ignores , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( argtypes , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; <S2SV_EndBug> return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; <S2SV_EndBug> return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { type_ignore_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,504,"<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_body, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""body\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } if ( lookup_attr_id ( obj, & PyId_type_ignores, & tmp ) < 0 ) { return 1 ; } if ( tmp == Py_None ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""type_ignores\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } if ( tmp == Py_None ) { PyErr_SetString ( PyExc_TypeError, ""required <S2SV_blank> field <S2SV_blank> \\""type_ignores\\"" <S2SV_blank> missing <S2SV_blank> from <S2SV_blank> Module"" ) ; return 1 ; } if ( lookup_attr_id ( obj, & PyId_type_ignores, & tmp ) < 0 ) { return 1 ; } if ( tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_ignores = & PyId_type_ignores <S2SV_ModEnd> ; if ( <S2SV_ModStart>",0
537,CWE-125,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z,537,"<S2SV_ModStart> ) ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, "" <S2SV_blank> [|osi]"" ) ) ; <S2SV_ModStart> 1 ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, "" <S2SV_blank> "" ) ) ; atalk_print ( ndo, p, length ) ; return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo, p, length, src, dst ) ; return ( 1 ) ; case ETHERTYPE_PPPOED1 : case ETHERTYPE_PPPOED1 : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, ""et1 <S2SV_blank> "" ) ) ; atalk_print ( ndo, p, length ) ; return ( 1 ) ; case ETHERTYPE_PPPOES1 : case ETHERTYPE_PPPOES2 : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo, ""et1 <S2SV_blank> "" ) ) ; atalk_print ( ndo, p, length ) ; return ( 1",0
538,CWE-125,"CWE-125 int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; <S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) { <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> if ( buf ) <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> space_rem , buf_size ) ; <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }
","<S2SV_ModStart> controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus
",stoth68000@media-tree/354dd3924a2e43806774953de536257548b5002c,CVE-2017-8831,https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c,2017-05-08T06:29Z,538,"<S2SV_ModStart> peekonly ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ), buf_size ) ; } else { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ), space_rem - sizeof ( * msg ) ) ; } else { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ), space_rem - sizeof ( * msg ) ) ; } } else { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ), bus -> m_pdwGetRing, buf_size - sizeof ( * msg ) ) ; } else { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ), space_rem - sizeof ( * msg ) ) ; } else { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd>, bus -> <S2SV_ModStart> -> m",0
564,CWE-125,"CWE-125 static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { <S2SV_StartBug> const char * literal_start = * str ; <S2SV_EndBug> const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; <S2SV_StartBug> for ( ; * str < end ; ( * str ) ++ ) { <S2SV_EndBug> char ch = * * str ; <S2SV_StartBug> if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && <S2SV_EndBug> * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { <S2SV_StartBug> in_named_escape = 0 ; <S2SV_EndBug> } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { <S2SV_StartBug> if ( * str + 1 < end && * ( * str + 1 ) == ch ) { <S2SV_EndBug> literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { <S2SV_StartBug> ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ; <S2SV_EndBug> return - 1 ; } } <S2SV_StartBug> break ; <S2SV_EndBug> } } <S2SV_StartBug> literal_end = * str ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str <= end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str == end || * * str == '{' || * * str == '}' ) ; <S2SV_EndBug> done : <S2SV_StartBug> if ( literal_start != literal_end ) { <S2SV_EndBug> if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , <S2SV_StartBug> literal_end - literal_start , <S2SV_EndBug> NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , <S2SV_StartBug> literal_end - literal_start ) ; <S2SV_EndBug> if ( ! * literal ) return - 1 ; } return result ; }
","<S2SV_ModStart> const char * s = * str ; const char * literal_start = s <S2SV_ModEnd> ; int result <S2SV_ModStart> NULL ) ; while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> '}' ) { <S2SV_ModStart> '}' ) { } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> if ( ch <S2SV_ModStart> { if ( s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> ; result = <S2SV_ModStart> '}' ) { * str = s - 1 ; <S2SV_ModStart> ; } } s -- ; <S2SV_ModStart> ; } } * str = s <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> <= end ) <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> == end || <S2SV_ModStart> end || * s <S2SV_ModEnd> == '{' || <S2SV_ModStart> '{' || * s <S2SV_ModEnd> == '}' ) <S2SV_ModStart> ( literal_start != s <S2SV_ModEnd> ) { if <S2SV_ModStart> ( literal_start , s <S2SV_ModEnd> - literal_start , <S2SV_ModStart> , literal_start , s <S2SV_ModEnd> - literal_start )
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,564,"<S2SV_ModStart> n ) { int literal_start = 0 ; int in_named_escape = 0 ; int result = 0 ; assert ( * str <= end ) ; assert ( <S2SV_ModEnd> * literal == <S2SV_ModStart> NULL ) ; for ( ; * str < end ; ( * str ) ++ ) { char ch = * * str ; if (! in_named_escape && * ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 0 ; } else if ( <S2SV_ModEnd> ch == '{' <S2SV_ModStart> '}' ) { <S2SV_ModEnd> if ( recurse_lvl <S2SV_ModStart> 0 ) { if ( * str + 1 < end ) { ast_error ( c, n, ""f-string: <S2SV_blank> single <S2SV_blank> \'}\' <S2SV_blank> is <S2SV_blank> not <S2SV_blank> allowed"" ) ; return - 1 ; } literal_start = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; *",0
570,CWE-125,"CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; ( void ) count ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if (
",ImageMagick@ImageMagick/7afcf9f71043df15508e46f079387bd4689a738d,CVE-2016-7101,https://github.com/ImageMagick/ImageMagick/commit/7afcf9f71043df15508e46f079387bd4689a738d,2017-01-18T17:59Z,570,"<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info. name ) ; if ( count!= sizeof ( iris_info. name ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" <S2SV_ModStart> filler ) ; if ( count!= sizeof ( iris_info. filler ) ) ThrowReaderException ( CorruptImageError, ""ImproperImageHeader"" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->",0
572,CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z,572,"<S2SV_ModStart> u_char * dat, u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo, ""AVP <S2SV_blank> too <S2SV_blank> short"" ) ) ; return ; }",1
576,CWE-125,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> ) ) ; }
",uclouvain@openjpeg/c16bc057ba3f125051c9966cf1f5b68a05681de4,CVE-2016-7163,https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4,2016-09-21T14:25Z,576,<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l,0
597,CWE-125,"CWE-125 static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> int tstype ) <S2SV_EndBug> { struct sock_exterr_skb * serr ; <S2SV_StartBug> int err ; <S2SV_EndBug> serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
","<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,597,"<S2SV_ModStart>, int tstype, bool opt_id <S2SV_ModStart> ; int err ; serr = SKB_EXT_ERR ( skb ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_id = opt_id <S2SV_ModStart> ee_info = tstype <S2SV_ModEnd> ; if (",0
599,CWE-125,"CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u,<S2SV_blank>%s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "",<S2SV_blank>(ttl<S2SV_blank>%u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>authtype<S2SV_blank>%s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>auth<S2SV_blank>\\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
","<S2SV_ModStart> 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> ) ) ; }
",the-tcpdump-group@tcpdump/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,CVE-2018-14463,https://github.com/the-tcpdump-group/tcpdump/commit/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,2019-10-03T16:15Z,599,<S2SV_ModStart> = len ; bp += 4 ; len -= 4 ; <S2SV_ModStart> = len ; bp += 4 ; <S2SV_ModStart> = len ; len -= 4 ;,0
619,CWE-125,"CWE-125 size_t compile_tree ( struct filter_op * * fop ) { int i = 1 ; struct filter_op * array = NULL ; struct unfold_elm * ue ; <S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ; fflush ( stdout ) ; unfold_blk ( & tree_root ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; labels_to_offsets ( ) ; TAILQ_FOREACH ( ue , & unfolded_tree , next ) { if ( ue -> label == 0 ) { SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ; i ++ ; } } SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; array [ i - 1 ] . opcode = FOP_EXIT ; * fop = array ; return ( i ) ; }
","<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0
",LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z,619,<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0,1
622,CWE-125,"CWE-125 void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { <S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ( dp [ 4 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) ) )
",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z,622,"<S2SV_ModStart> ( dp [ 3 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ndoerr ) { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_sattr_str, ""access-%u"", access_flags ) ) ) ; goto trunc ; } ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_sattr_str, ""type-%u"", type ) ) ) ; if ( v3 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_sattr_str, ""access-%u"", access_flags ) ) ) ; } else { ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_sattr_str, ""access-%u"", access_flags ) ) ) ; ND_PRINT ( ( ndo, "" <S2SV_blank> %s"", tok2str ( nfsv3_sattr_str, ""access-%u"", access_flags ) ) ) ; }",0
623,CWE-125,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; <S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> while ( len > 0 ) { <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> return ; } <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z,623,<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_8BITS ( tptr ) ;,0
626,CWE-125,"CWE-125 void rpki_rtr_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { <S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> const u_char * tptr ; const rpki_rtr_pdu * pdu_header ; tptr = pptr ; tlen = len ; if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>RPKI-RTR"" ) ) ; return ; } <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; pdu_header = ( const rpki_rtr_pdu * ) tptr ; pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; ND_TCHECK2 ( * tptr , pdu_len ) ; if ( ! pdu_type || ! pdu_len ) { break ; } if ( tlen < pdu_len ) { goto trunc ; } <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> goto trunc ; tlen -= pdu_len ; <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> } <S2SV_StartBug> return ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; }
","<S2SV_ModStart> len ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo , pptr , len , 1 <S2SV_ModEnd> , 8 ) <S2SV_ModStart> , 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",the-tcpdump-group@tcpdump/83c64fce3a5226b080e535f5131a8a318f30e79b,CVE-2017-13050,https://github.com/the-tcpdump-group/tcpdump/commit/83c64fce3a5226b080e535f5131a8a318f30e79b,2017-09-14T06:29Z,626,"<S2SV_ModStart> len ) { <S2SV_ModEnd> if (! <S2SV_ModStart> ) ) { ND_PRINT ( ( ndo, ""\\n\\t%s"", tstr ) ) ; return ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo, ""\\n\\t%s"", tstr ) ) ; return ; } ND_TCHECK2 ( * tptr, sizeof ( rpki_rtr_pdu ) ) ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; if (! pdu_len ) { ND_PRINT ( ( ndo, ""\\n\\t%s"", tstr ) ) ; return ; } tptr += sizeof ( rpki_rtr_pdu ) <S2SV_ModEnd> ; } <S2SV_null>",0
638,CWE-125,"CWE-125 int frag6_print ( netdissect_options * ndo , register const u_char * bp , register const u_char * bp2 ) { register const struct ip6_frag * dp ; register const struct ip6_hdr * ip6 ; dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ; <S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(0x%08x:%d|%ld)"" , EXTRACT_32BITS ( & dp -> ip6f_ident ) , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } else { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(%d|%ld)"" , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } if ( ( EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK ) != 0 ) return - 1 ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; return sizeof ( struct ip6_frag ) ; } trunc : ND_PRINT ( ( ndo , ""[|frag]"" ) ) ; return - 1 ; }
","<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if
",the-tcpdump-group@tcpdump/2d669862df7cd17f539129049f6fb70d17174125,CVE-2017-13031,https://github.com/the-tcpdump-group/tcpdump/commit/2d669862df7cd17f539129049f6fb70d17174125,2017-09-14T06:29Z,638,<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if,1
639,CWE-125,"CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
","<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
",the-tcpdump-group@tcpdump/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,CVE-2017-13023,https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,2017-09-14T06:29Z,639,<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;,1
656,CWE-125,"CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
",ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z,656,"<S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; }",0
658,CWE-125,"CWE-125 static int print_ccp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case CCPOPT_BSDCOMP : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ; case CCPOPT_MVRCA : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ; break ; case CCPOPT_DEFLATE : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ; break ; # if 0 case CCPOPT_OUI : case CCPOPT_PRED1 : case CCPOPT_PRED2 : case CCPOPT_PJUMP : case CCPOPT_HPPPC : case CCPOPT_STACLZS : case CCPOPT_MPPC : case CCPOPT_GFZA : case CCPOPT_V42BIS : case CCPOPT_LZSDCP : case CCPOPT_DEC : case CCPOPT_RESV : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ccp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z,658,<S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len,0
708,CWE-125,"CWE-125 static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,708,"<S2SV_ModStart>, end_col_offset ; string type_comment ; <S2SV_ModStart> += 2 ; type_comment = NEW_TYPE_COMMENT ( CHILD ( n, name_i ) ) ; if (! type_comment ) return NULL <S2SV_ModStart>, body ) ; if (! type_comment ) return NULL <S2SV_ModStart> is_async ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n, name_i ) ) ; if (! type_comment ) return NULL ; } <S2SV_ModStart>, body, type_comment,",0
719,CWE-125,"CWE-125 struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ; <S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> uint8_t * * tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 4 ; if ( tmp_val != 6 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , NULL , 0 ) ; return ( NULL ) ; } tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val > 2 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } midi_type = tmp_val ; tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val < 1 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(no<S2SV_blank>tracks)"" , 0 ) ; return ( NULL ) ; } no_tracks = tmp_val ; if ( ( midi_type == 0 ) && ( no_tracks > 1 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , ""(expected<S2SV_blank>1<S2SV_blank>track<S2SV_blank>for<S2SV_blank>type<S2SV_blank>0<S2SV_blank>midi<S2SV_blank>file,<S2SV_blank>found<S2SV_blank>more)"" , 0 ) ; return ( NULL ) ; } divisions = * midi_data ++ << 8 ; divisions |= * midi_data ++ ; midi_size -= 2 ; if ( divisions & 0x00008000 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mdi , divisions ) ; tracks = malloc ( sizeof ( uint8_t * ) * no_tracks ) ; <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ; running_event = malloc ( sizeof ( uint8_t ) * no_tracks ) ; smallest_delta = 0xffffffff ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( midi_size < 8 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ; goto _end ; } midi_data += 4 ; midi_size -= 4 ; <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> midi_size -= 4 ; <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ; goto _end ; } tracks [ i ] = midi_data ; <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> track_end [ i ] = 0 ; running_event [ i ] = 0 ; track_delta [ i ] = 0 ; while ( * tracks [ i ] > 0x7F ) { track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; tracks [ i ] ++ ; <S2SV_StartBug> } <S2SV_EndBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> if ( midi_type == 1 ) { if ( track_delta [ i ] < smallest_delta ) { smallest_delta = track_delta [ i ] ; } } else { if ( i == 0 ) smallest_delta = track_delta [ i ] ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; if ( midi_type == 1 ) { while ( end_of_tracks != no_tracks ) { smallest_delta = 0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( track_end [ i ] ) continue ; if ( track_delta [ i ] ) { track_delta [ i ] -= subtract_delta ; if ( track_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } continue ; } } do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { end_of_tracks ++ ; track_end [ i ] = 1 ; tracks [ i ] += 3 ; <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> } while ( ! track_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } NEXT_TRACK : continue ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; } } else { if ( midi_type == 2 ) { mdi -> is_type2 = 1 ; } sample_remainder = 0.0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { track_end [ i ] = 1 ; goto NEXT_TRACK2 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> if ( * tracks [ i ] > 0x7f ) { do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; NEXT_TRACK2 : smallest_delta = track_delta [ i ] ; UNUSED ( smallest_delta ) ; } while ( track_end [ i ] == 0 ) ; } } if ( ( mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _end ; } mdi -> extra_info . current_sample = 0 ; mdi -> current_event = & mdi -> events [ 0 ] ; mdi -> samples_to_mix = 0 ; mdi -> note = NULL ; _WM_ResetToStart ( mdi ) ; _end : free ( sysex_store ) ; free ( track_end ) ; free ( track_delta ) ; free ( running_event ) ; free ( tracks ) ; <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> _WM_freeMDI ( mdi ) ; return ( NULL ) ; }
","<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z,719,<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ++ ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 0 ; tmp_val <S2SV_ModEnd> |= * midi_data,0
723,CWE-125,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z,723,"<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ), func <S2SV_ModEnd>, line, <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]: <S2SV_blank> %pV"", func <S2SV_ModEnd>, line,",1
728,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , <S2SV_StartBug> height , <S2SV_EndBug> length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> extent , height <S2SV_ModEnd> ; ssize_t count <S2SV_ModStart> PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> image -> columns <S2SV_ModStart> % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> * p ++ <S2SV_ModStart> * p ++ ) <S2SV_ModStart> q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart> if ( ( <S2SV_ModEnd> ( bytes_per_pixel *
",ImageMagick@ImageMagick/8ea44b48a182dd46d018f4b4f09a5e2ee9638105,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/8ea44b48a182dd46d018f4b4f09a5e2ee9638105,2017-04-20T18:59Z,728,"<S2SV_ModStart> extent, height, <S2SV_ModStart> ""UnableToReadImageData"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; height = sun_info. height ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( width > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; if ( height > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; if ( width > GetBlobSize",0
733,CWE-125,"CWE-125 static void ip_cmsg_recv_checksum ( struct msghdr * msg , struct sk_buff * skb , int tlen , int offset ) { __wsum csum = skb -> csum ; if ( skb -> ip_summed != CHECKSUM_COMPLETE ) return ; <S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> csum = csum_sub ( csum , <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; }
","<S2SV_ModStart> != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum , skb_checksum ( skb , tend_off , <S2SV_ModEnd> offset , 0 <S2SV_ModStart> ) ) ; }
",torvalds@linux/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32,CVE-2017-6347,https://github.com/torvalds/linux/commit/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32,2017-03-01T20:59Z,733,"<S2SV_ModStart>!= 0 ) { int tstart = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum, skb_checksum ( skb, tstart, <S2SV_ModEnd> offset, 0 <S2SV_ModStart> ( csum, skb_checksum ( skb, tstart <S2SV_ModEnd>, offset,",0
737,CWE-125,"CWE-125 static inline unsigned int ReadPropertyUnsignedLong ( const EndianType endian , const unsigned char * buffer ) { unsigned int value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] ; return <S2SV_ModEnd> ( value & <S2SV_ModStart> & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null>
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,737,<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] ; return <S2SV_ModEnd> ( value & <S2SV_ModStart> & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null>,1
744,CWE-125,"CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else <S2SV_StartBug> { <S2SV_EndBug> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : { <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }
","<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z,744,"<S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { goto trunc ; } <S2SV_ModStart> struct olsr_msg6 ) ) { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x], <S2SV_blank> msg6[0x%04x]"", msgptr. v4 -> msg_type, msgptr. v6 -> msg_type, msgptr. v6 -> msg_len ) ) ; } else { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x]"", msgptr. v4 -> msg_type, msgptr. v4 -> msg_len ) ) ; if ( msg_len_valid == 0 ) { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x]"", msgptr. v4 -> msg_type, msgptr. v4 -> msg_len ) ) ; } else { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x]"", msgptr. v4 ->",0
755,CWE-125,"CWE-125 uint32 TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; <S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> if ( td -> td_nstrips ) return td -> td_nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , ""TIFFNumberOfStrips"" ) ; return ( nstrips ) ; }
","<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =
",vadz@libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018,CVE-2016-10270,https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018,2017-03-24T19:59Z,755,<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =,1
807,CWE-125,"CWE-125 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; <S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> } snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , ""%d<S2SV_blank>"" ,
",radare@radare2/52b1526443c1f433087928291d1c3d37a5600515,CVE-2017-15368,https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515,2017-10-16T01:29Z,807,<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> goto beach ; <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ),0
819,CWE-125,"CWE-125 PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Suite_kind : result = PyType_GenericNew ( Suite_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,819,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,1
833,CWE-125,"CWE-125 int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { uint8_t * ip ; uint8_t * input ; uint8_t mask ; uint8_t value ; RE_FIBER_LIST fibers ; RE_THREAD_STORAGE * storage ; RE_FIBER * fiber ; RE_FIBER * next_fiber ; int error ; int bytes_matched ; int max_bytes_matched ; int match ; int character_size ; int input_incr ; int kill ; int action ; int result = - 1 ; # define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ; if ( flags & RE_FLAGS_WIDE ) character_size = 2 ; else character_size = 1 ; input = input_data ; input_incr = character_size ; if ( flags & RE_FLAGS_BACKWARDS ) { <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> input_incr = - input_incr ; } <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; bytes_matched = 0 ; error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; fibers . head = fiber ; fibers . tail = fiber ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; while ( fibers . head != NULL ) { fiber = fibers . head ; while ( fiber != NULL ) { ip = fiber -> ip ; action = ACTION_NONE ; switch ( * ip ) { case RE_OPCODE_ANY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_GREEDY : case RE_OPCODE_REPEAT_ANY_UNGREEDY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; break ; case RE_OPCODE_LITERAL : prolog ; if ( flags & RE_FLAGS_NO_CASE ) match = yr_lowercase [ * input ] == yr_lowercase [ * ( ip + 1 ) ] ; else match = ( * input == * ( ip + 1 ) ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 2 ; break ; case RE_OPCODE_MASKED_LITERAL : prolog ; value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; match = ( ( * input & mask ) == value ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 3 ; break ; case RE_OPCODE_CLASS : prolog ; match = CHAR_IN_CLASS ( * input , ip + 1 ) ; if ( ! match && ( flags & RE_FLAGS_NO_CASE ) ) match = CHAR_IN_CLASS ( yr_altercase [ * input ] , ip + 1 ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 33 ; break ; case RE_OPCODE_WORD_CHAR : prolog ; <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_WORD_CHAR : prolog ; <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_SPACE : case RE_OPCODE_NON_SPACE : prolog ; switch ( * input ) { case '<S2SV_blank>' : case '\\t' : case '\\r' : case '\\n' : case '\\v' : case '\\f' : match = TRUE ; break ; default : match = FALSE ; } if ( * ip == RE_OPCODE_NON_SPACE ) match = ! match ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_DIGIT : prolog ; match = isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_DIGIT : prolog ; match = ! isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> ! ( flags & RE_FLAGS_BACKWARDS ) ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> else if ( bytes_matched >= max_bytes_matched ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> match = TRUE ; else match = FALSE ; if ( * ip == RE_OPCODE_NON_WORD_BOUNDARY ) match = ! match ; action = match ? ACTION_CONTINUE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> else <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH : result = bytes_matched ; if ( flags & RE_FLAGS_EXHAUSTIVE ) { if ( callback != NULL ) { int cb_result ; if ( flags & RE_FLAGS_BACKWARDS ) cb_result = callback ( input + character_size , bytes_matched , flags , callback_args ) ; else cb_result = callback ( input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } } action = ACTION_KILL ; } else { action = ACTION_KILL_TAIL ; } break ; default : assert ( FALSE ) ; } switch ( action ) { case ACTION_KILL : fiber = _yr_re_fiber_kill ( & fibers , & storage -> fiber_pool , fiber ) ; break ; case ACTION_KILL_TAIL : _yr_re_fiber_kill_tail ( & fibers , & storage -> fiber_pool , fiber ) ; fiber = NULL ; break ; case ACTION_CONTINUE : error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; break ; default : next_fiber = fiber -> next ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; fiber = next_fiber ; } <S2SV_StartBug> } <S2SV_EndBug> if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) { _yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ; } input += input_incr ; bytes_matched += character_size ; if ( flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched ) { error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; _yr_re_fiber_append ( & fibers , fiber ) ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; } } return result ; }
","<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> ( bytes_matched >= <S2SV_ModStart> >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ( e ) { <S2SV_ModStart> 4 ; } } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } else { <S2SV_ModStart> ) yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT ) <S2SV_ModStart> RE_SCAN_LIMIT ) ; } <S2SV_ModStart> ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> == 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = TRUE <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> >= max_bytes_matched ) { <S2SV_ModStart> = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input - <S2SV_ModStart> input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched <S2SV_ModStart> & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> next_fiber ; } <S2SV_ModEnd> } input +=
",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z,833,"<S2SV_ModStart> input_data, size_t input_forwards_size, size_t input_backwards_size <S2SV_ModEnd>, int flags <S2SV_ModStart> # define prolog ( e ) <S2SV_ModStart> { action = ACTION_KILL_TAIL ; break ; } <S2SV_ModEnd> # define fail_if_error <S2SV_ModStart> ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { input = ( uint8_t ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } max_bytes_matched = ( int ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { input = ( uint8_t ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { input = ( uint8_t ) yr_min ( input_backwards_size, RE_SCAN_LIMIT ) ;",0
855,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,855,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
878,CWE-125,"CWE-125 static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { <S2SV_StartBug> PyObject * u ; <S2SV_EndBug> char * buf ; char * p ; <S2SV_StartBug> const char * end ; <S2SV_EndBug> if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; <S2SV_StartBug> if ( * s & 0x80 ) { <S2SV_EndBug> strcpy ( p , ""u005c"" ) ; <S2SV_StartBug> p += 5 ; <S2SV_EndBug> } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } <S2SV_StartBug> assert ( p - buf <= Py_SIZE ( u ) ) ; <S2SV_EndBug> Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; <S2SV_StartBug> return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { PyObject * v , * <S2SV_ModStart> char * end ; const char * first_invalid_escape <S2SV_ModStart> ; if ( s >= end || <S2SV_ModStart> p += 5 ; if ( s >= end ) break <S2SV_ModStart> - buf <= PyBytes_GET_SIZE <S2SV_ModEnd> ( u ) <S2SV_ModStart> = buf ; v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ; if ( v != NULL && first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_XDECREF ( u ) ; Py_DECREF ( v ) ; return NULL ; } } Py_XDECREF ( u ) ; return v <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,878,"<S2SV_ModStart> len ) { PyObject <S2SV_ModEnd> * u ; <S2SV_ModStart> char * p <S2SV_ModEnd> ; const char <S2SV_ModStart> * end ; Py_DECREF ( w ) ; p = buf = PyBytes_FromStringAndSize ( ( char * ) NULL, len * 6 ) ; if ( p == buf ) { Py_DECREF ( u ) ; return NULL ; } if ( p - buf <= Py_SIZE ( u ) ) ; assert ( p - buf <= Py_SIZE ( u ) ) ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t i ; w = decode_utf8 ( c, & s, end ) ; if ( w == NULL ) { Py_DECREF ( w ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind, data, i ) ; sprintf (",0
879,CWE-125,"CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = ""libevt_record_values_read_event"" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>values."" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data."" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , ""%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>exceeds<S2SV_blank>maximum."" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ; byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ; # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>size\\t\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size ) ; libcnotify_printf ( ""%s:<S2SV_blank>signature\\t\\t\\t\\t:<S2SV_blank>%c%c%c%c\\n"" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ; libcnotify_printf ( ""%s:<S2SV_blank>record<S2SV_blank>number\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> number ) ; if ( libevt_debug_print_posix_time_value ( function , ""creation<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libevt_debug_print_posix_time_value ( function , ""written<S2SV_blank>time\\t\\t\\t\\t"" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier\\t\\t\\t:<S2SV_blank>0x%08"" PRIx32 ""\\n"" , function , record_values -> event_identifier ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>code\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , record_values -> event_identifier & 0x0000ffffUL ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>facility\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>reserved\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>customer<S2SV_blank>flags\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>severity\\t\\t:<S2SV_blank>%"" PRIu32 ""<S2SV_blank>("" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ; libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ; libcnotify_printf ( "")\\n"" ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>type\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>("" , function , record_values -> event_type ) ; libevt_debug_print_event_type ( record_values -> event_type ) ; libcnotify_printf ( "")\\n"" ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>strings\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>category\\t\\t\\t\\t:<S2SV_blank>%"" PRIu16 ""\\n"" , function , record_values -> event_category ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>event<S2SV_blank>flags\\t\\t\\t\\t:<S2SV_blank>0x%04"" PRIx16 ""\\n"" , function , value_16bit ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>closing<S2SV_blank>record<S2SV_blank>values<S2SV_blank>number\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , value_32bit ) ; libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , strings_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>size\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>offset\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , user_sid_offset ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>size\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_size ) ; libcnotify_printf ( ""%s:<S2SV_blank>data<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , data_offset ) ; } # endif record_data_offset = sizeof ( evt_record_event_header_t ) ; if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>or<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_offset != 0 ) { if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( user_sid_size != 0 ) { if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } } if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) { if ( data_size != 0 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } data_offset = ( uint32_t ) record_data_size - 4 ; } if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( strings_offset != 0 ) { if ( strings_offset < record_data_offset ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( user_sid_offset != 0 ) { members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ; } else if ( strings_offset != 0 ) { members_data_size = strings_offset - ( uint32_t ) record_data_offset ; } if ( strings_offset != 0 ) { strings_size = data_offset - strings_offset ; } if ( data_size != 0 ) { if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } } if ( members_data_size != 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>source<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>computer<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( members_data_size > 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>members<S2SV_blank>trailing<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif record_data_offset += members_data_size ; } } if ( user_sid_size != 0 ) { <S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)\\t\\t:<S2SV_blank>"" , function ) ; if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value."" , function ) ; goto on_error ; } libcnotify_printf ( ""\\n"" ) ; } # endif record_data_offset += user_sid_size ; } if ( strings_size != 0 ) <S2SV_StartBug> { <S2SV_EndBug> # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>strings<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( size_copy == 0 ) { strings_data_offset = strings_offset + strings_size - 2 ; while ( strings_data_offset > strings_offset ) { if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) { strings_size += 2 ; break ; } strings_data_offset -= 2 ; strings_size -= 2 ; } } if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>strings<S2SV_blank>value."" , function ) ; goto on_error ; } record_data_offset += strings_size ; } if ( data_size != 0 ) { <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> if ( libcnotify_verbose != 0 ) { libcnotify_printf ( ""%s:<S2SV_blank>data:\\n"" , function ) ; libcnotify_print_data ( <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , ""%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>data<S2SV_blank>value."" , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ; # endif } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { if ( record_data_offset < ( record_data_size - 4 ) ) { libcnotify_printf ( ""%s:<S2SV_blank>padding:\\n"" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } libcnotify_printf ( ""%s:<S2SV_blank>size<S2SV_blank>copy\\t\\t\\t\\t:<S2SV_blank>%"" PRIu32 ""\\n"" , function , size_copy ) ; libcnotify_printf ( ""\\n"" ) ; } # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) { size_copy = size ; } if ( size != size_copy ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size<S2SV_blank>copy."" , function ) ; goto on_error ; } if ( record_data_size != ( size_t ) size ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , ""%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>record_values<S2SV_blank>data<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size."" , function ) ; goto on_error ; } return ( 1 ) ; on_error : if ( record_values -> data != NULL ) { libfvalue_value_free ( & ( record_values -> data ) , NULL ) ; } if ( record_values -> strings != NULL ) { libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ; } if ( record_values -> user_security_identifier != NULL ) { libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ; } if ( record_values -> computer_name != NULL ) { libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ; } if ( record_values -> source_name != NULL ) { libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - record_data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> ( record_data [ record_data_offset <S2SV_ModEnd> ] ) ,
",libyal@libevt/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e,CVE-2018-8754,https://github.com/libyal/libevt/commit/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e,2018-03-18T03:29Z,879,"<S2SV_ModStart> 0 ) { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS, ""%s: <S2SV_blank> user <S2SV_blank> SID <S2SV_blank> data <S2SV_blank> size <S2SV_blank> value <S2SV_blank> out <S2SV_blank> of <S2SV_blank> bounds."", function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS, ""%s: <S2SV_blank> strings <S2SV_blank> size <S2SV_blank> value <S2SV_blank> out <S2SV_blank> of <S2SV_blank> bounds."", function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR",0
882,CWE-125,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; <S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> while ( len > 0 ) { <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> return ; } <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z,882,<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_8BITS ( tptr ) ;,0
896,CWE-125,"CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>who-are-you<S2SV_blank>request"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" ) ) ; break ; default : ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>len"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , "",<S2SV_blank>subject=DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>subject"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , ""[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]"" ) ) ; break ; } needcomma = 0 ; <S2SV_StartBug> ni6 = ( const struct icmp6_nodeinfo * ) dp ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""success"" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , ""refused"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , ""unknown"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""noop"" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; <S2SV_StartBug> cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; <S2SV_EndBug> if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[TTL=%u]"" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""(%d)"" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? ""T"" : """" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }
","<S2SV_ModStart> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ) + 4 ; ND_TCHECK ( cp [ 0 ] )
",the-tcpdump-group@tcpdump/f4b9e24c7384d882a7f434cc7413925bf871d63e,CVE-2017-13041,https://github.com/the-tcpdump-group/tcpdump/commit/f4b9e24c7384d882a7f434cc7413925bf871d63e,2017-09-14T06:29Z,896,"<S2SV_ModStart> ( ndo, ""%s"", icmp6_tstr <S2SV_ModEnd> ) ) ;",0
912,CWE-125,"CWE-125 static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) { const size_t base_len = strlen ( base_name ) ; <S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> for ( dom = state -> head ; dom ; dom = dom -> next ) { if ( ! n -- ) { const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ; const int postfix_len = dom -> len ; char * const newname = ( char * ) mm_malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ; if ( ! newname ) return NULL ; memcpy ( newname , base_name , base_len ) ; if ( need_to_append_dot ) newname [ base_len ] = '.' ; memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ; newname [ base_len + need_to_append_dot + postfix_len ] = 0 ; return newname ; } } EVUTIL_ASSERT ( 0 ) ; return NULL ; }
","<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom
",libevent@libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,CVE-2016-10197,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,2017-03-15T15:59Z,912,<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if (! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom,1
925,CWE-125,"CWE-125 static PyObject * ast_type_reduce ( PyObject * self , PyObject * unused ) { <S2SV_StartBug> PyObject * res ; <S2SV_EndBug> _Py_IDENTIFIER ( __dict__ ) ; <S2SV_StartBug> PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ ) ; <S2SV_EndBug> if ( dict == NULL ) { if ( PyErr_ExceptionMatches ( PyExc_AttributeError ) ) PyErr_Clear ( ) ; else return NULL ; } if ( dict ) { <S2SV_StartBug> res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ; <S2SV_EndBug> Py_DECREF ( dict ) ; return res ; } return Py_BuildValue ( ""O()"" , Py_TYPE ( self ) ) ; }
","<S2SV_ModStart> unused ) { <S2SV_ModEnd> _Py_IDENTIFIER ( __dict__ <S2SV_ModStart> PyObject * dict ; if ( lookup_attr_id <S2SV_ModEnd> ( self , <S2SV_ModStart> , & PyId___dict__ , & dict ) < 0 ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> dict ) { return Py_BuildValue ( ""O()N"" <S2SV_ModEnd> , Py_TYPE ( <S2SV_ModStart> , dict ) <S2SV_ModEnd> ; } return
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,925,"<S2SV_ModStart> unused ) { <S2SV_ModEnd> _Py_IDENTIFIER ( __dict__ <S2SV_ModStart> * dict = _PyObject_GetAttrId <S2SV_ModEnd> ( self, <S2SV_ModStart> ( self, & PyId___dict__ ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> { res = _PyObject_BuildValue <S2SV_ModEnd> ( ""O()O"", <S2SV_ModStart> ( dict ) <S2SV_ModEnd> ; Py_DECREF (",0
936,CWE-125,"CWE-125 u_int chdlc_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , register const u_char * p ) { <S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> register u_int caplen = h -> caplen ; if ( caplen < CHDLC_HDRLEN ) { ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ( caplen ) ; } <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> p ) { return <S2SV_ModEnd> chdlc_print ( ndo <S2SV_ModStart> , p , h -> len <S2SV_ModEnd> ) ; }
",the-tcpdump-group@tcpdump/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d,CVE-2017-13687,https://github.com/the-tcpdump-group/tcpdump/commit/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d,2017-09-14T06:29Z,936,"<S2SV_ModStart> p ) { return <S2SV_ModEnd> chdlc_print ( ndo <S2SV_ModStart>, p, h -> len <S2SV_ModEnd> ) ; }",1
938,CWE-125,"CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && <S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }
","<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z,938,<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (,1
952,CWE-125,"CWE-125 static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; <S2SV_StartBug> int ret , n ; <S2SV_EndBug> quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""class<S2SV_blank>descriptor<S2SV_blank>not<S2SV_blank>present\\n"" ) ; return - ENODEV ; } <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weird<S2SV_blank>size<S2SV_blank>of<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>(%u)\\n"" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( ""reading<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n"" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( ""parsing<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n"" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
","<S2SV_ModStart> ret , n ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> hdesc -> bCountryCode ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> ; n < num_descriptors <S2SV_ModEnd> ; n ++
",torvalds@linux/f043bfc98c193c284e2cd768fefabe18ac2fed9b,CVE-2017-16533,https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b,2017-11-04T01:29Z,952,"<S2SV_ModStart> ret, n ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor, desc ) <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid <S2SV_blank> descriptor <S2SV_blank> is <S2SV_blank> too <S2SV_blank> short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> hdesc -> bCountryCode ; num_descriptors = min_t ( int, hdesc -> bNumDescriptors, ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> ; n < num_descriptors <S2SV_ModEnd> ; n ++",1
953,CWE-125,"CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z,953,"<S2SV_ModStart> struct ikev2_id id <S2SV_ModEnd> ; int id_len <S2SV_ModStart> * typedata ; ND_TCHECK_16BIT ( * ext ) ; UNALIGNED_MEMCPY ( & id, ext, sizeof ( id ) )",0
963,CWE-125,"CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }
","<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&
",torvalds@linux/50220dead1650609206efe91f0cc116132d59b3f,CVE-2016-7915,https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f,2016-11-16T05:59Z,963,<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage &&,0
969,CWE-125,"CWE-125 int dbd_st_prepare ( SV * sth , imp_sth_t * imp_sth , char * statement , SV * attribs ) { int i ; SV * * svp ; dTHX ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION char * str_ptr , * str_last_ptr ; # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION int limit_flag = 0 ; # endif # endif <S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> MYSQL_BIND * bind , * bind_end ; imp_sth_phb_t * fbind ; # endif D_imp_xxh ( sth ) ; D_imp_dbh_from_sth ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_prepare<S2SV_blank>MYSQL_VERSION_ID<S2SV_blank>%d,<S2SV_blank>SQL<S2SV_blank>statement:<S2SV_blank>%s\\n"" , MYSQL_VERSION_ID , statement ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_sth -> use_server_side_prepare = imp_dbh -> use_server_side_prepare ; if ( attribs ) { svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_server_prepare"" , 20 ) ; imp_sth -> use_server_side_prepare = ( svp ) ? SvTRUE ( * svp ) : imp_dbh -> use_server_side_prepare ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""async"" , 5 ) ; if ( svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth , 2000 , ""Async<S2SV_blank>support<S2SV_blank>was<S2SV_blank>not<S2SV_blank>built<S2SV_blank>into<S2SV_blank>this<S2SV_blank>version<S2SV_blank>of<S2SV_blank>DBD::mysql"" , ""HY000"" ) ; return 0 ; # endif } } imp_sth -> fetch_done = 0 ; # endif imp_sth -> done_desc = 0 ; imp_sth -> result = NULL ; imp_sth -> currow = 0 ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_use_result"" , 16 ) ; imp_sth -> use_mysql_use_result = svp ? SvTRUE ( * svp ) : imp_dbh -> use_mysql_use_result ; for ( i = 0 ; i < AV_ATTRIB_LAST ; i ++ ) imp_sth -> av_attr [ i ] = Nullav ; mysql_st_free_result_sets ( sth , imp_sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set,<S2SV_blank>check<S2SV_blank>restrictions\\n"" ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>LIMIT<S2SV_blank>&<S2SV_blank>CALL\\n"" ) ; # else ""\\t\\tneed<S2SV_blank>to<S2SV_blank>test<S2SV_blank>for<S2SV_blank>restrictions\\n"" ) ; # endif str_last_ptr = statement + strlen ( statement ) ; for ( str_ptr = statement ; str_ptr < str_last_ptr ; str_ptr ++ ) { # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION if ( limit_flag ) { if ( * str_ptr == '?' ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tLIMIT<S2SV_blank>and<S2SV_blank>?<S2SV_blank>found,<S2SV_blank>set<S2SV_blank>to<S2SV_blank>use_server_side_prepare=0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } else if ( str_ptr < str_last_ptr - 6 && isspace ( * ( str_ptr + 0 ) ) && tolower ( * ( str_ptr + 1 ) ) == 'l' && tolower ( * ( str_ptr + 2 ) ) == 'i' && tolower ( * ( str_ptr + 3 ) ) == 'm' && tolower ( * ( str_ptr + 4 ) ) == 'i' && tolower ( * ( str_ptr + 5 ) ) == 't' && isspace ( * ( str_ptr + 6 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""LIMIT<S2SV_blank>set<S2SV_blank>limit<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>1\\n"" ) ; limit_flag = 1 ; } # endif if ( str_ptr < str_last_ptr - 4 && tolower ( * ( str_ptr + 0 ) ) == 'c' && tolower ( * ( str_ptr + 1 ) ) == 'a' && tolower ( * ( str_ptr + 2 ) ) == 'l' && tolower ( * ( str_ptr + 3 ) ) == 'l' && isspace ( * ( str_ptr + 4 ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""Disable<S2SV_blank>PS<S2SV_blank>mode<S2SV_blank>for<S2SV_blank>CALL()\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; break ; } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tuse_server_side_prepare<S2SV_blank>set\\n"" ) ; if ( imp_sth -> stmt ) fprintf ( stderr , <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ; if ( ! imp_sth -> stmt ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) ) ; } prepare_retval = mysql_stmt_prepare ( imp_sth -> stmt , statement , strlen ( statement ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>returned<S2SV_blank>%d\\n"" , prepare_retval ) ; if ( prepare_retval ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_stmt_prepare<S2SV_blank>%d<S2SV_blank>%s\\n"" , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) ) ; if ( mysql_stmt_errno ( imp_sth -> stmt ) == ER_UNSUPPORTED_PS ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tSETTING<S2SV_blank>imp_sth->use_server_side_prepare<S2SV_blank>to<S2SV_blank>0\\n"" ) ; imp_sth -> use_server_side_prepare = 0 ; } else { do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; mysql_stmt_close ( imp_sth -> stmt ) ; imp_sth -> stmt = NULL ; return FALSE ; } } else { DBIc_NUM_PARAMS ( imp_sth ) = mysql_stmt_param_count ( imp_sth -> stmt ) ; if ( DBIc_NUM_PARAMS ( imp_sth ) > 0 ) { <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> imp_sth -> bind = alloc_bind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> fbind = alloc_fbind ( DBIc_NUM_PARAMS ( imp_sth ) ) ; imp_sth -> has_been_bound = 0 ; for ( i = 0 , bind = imp_sth -> bind , fbind = imp_sth -> fbind , bind_end = bind + DBIc_NUM_PARAMS ( imp_sth ) ; bind < bind_end ; bind ++ , fbind ++ , i ++ ) { <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug> imp_sth -> stmt -> fields [ i ] . type : MYSQL_TYPE_STRING ) ; bind -> buffer_type = mysql_to_perl_type ( col_type ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tmysql_to_perl_type<S2SV_blank>returned<S2SV_blank>%d\\n"" , col_type ) ; bind -> buffer = NULL ; bind -> length = & ( fbind -> length ) ; bind -> is_null = ( char * ) & ( fbind -> is_null ) ; fbind -> is_null = 1 ; fbind -> length = 0 ; } } } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare == 0 ) DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # else DBIc_NUM_PARAMS ( imp_sth ) = count_params ( ( imp_xxh_t * ) imp_dbh , aTHX_ statement , imp_dbh -> bind_comment_placeholders ) ; # endif imp_sth -> params = alloc_param ( DBIc_NUM_PARAMS ( imp_sth ) ) ; DBIc_IMPSET_on ( imp_sth ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_prepare\\n"" ) ; return 1 ; }
","<S2SV_ModStart> # endif int <S2SV_ModEnd> prepare_retval ; MYSQL_BIND <S2SV_ModStart> ( stderr , ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> ) ; imp_sth <S2SV_ModStart> imp_xxh ) , ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> , mysql_errno ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> imp_sth -> bind <S2SV_ModStart> ++ ) { bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ; bind ->
",perl5-dbi@DBD-mysql/793b72b1a0baa5070adacaac0e12fd995a6fbabe,CVE-2016-1249,https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe,2017-02-17T02:59Z,969,"<S2SV_ModStart> endif # endif int <S2SV_ModEnd> col_type, prepare_retval <S2SV_ModStart>, prepare_retval ; # if MYSQL_VERSION_ID < SERVER_PREPARE_VERSION imp_sth -> use_server_side_prepare = ( attribs )? SvTRUE ( attribs -> mysql_server_prepare ) : imp_dbh -> use_server_side_prepare ; if ( svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth, 2000, ""Async <S2SV_blank> support <S2SV_blank> was <S2SV_blank> not <S2SV_blank> built <S2SV_blank> into <S2SV_blank> this <S2SV_blank> version <S2SV_blank> of <S2SV_blank> DBD::mysql"", ""HY000"" ) ; return 0 ; # endif <S2SV_ModStart> } # endif <S2SV_ModEnd> # if MYSQL_VERSION_ID <S2SV_ModStart> < SERVER_PREPARE_VERSION && svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth, 2000, ""Async <S2SV_blank> support <S2SV_blank> was <S2SV_blank> not <S2SV_blank> built <S2SV_blank> into",0
986,CWE-125,"CWE-125 int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }
","<S2SV_ModStart> s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> , s2 , len + 1 <S2SV_ModEnd> ) ; }
",jedisct1@pure-ftpd/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,CVE-2020-9365,https://github.com/jedisct1/pure-ftpd/commit/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,2020-02-24T16:15Z,986,"<S2SV_ModStart> s2 ) { const size_t len = strlen ( s1 ) + 1U ; return memcmp <S2SV_ModEnd> ( s1,",0
992,CWE-125,"CWE-125 PyObject * ast2obj_excepthandler ( void * _o ) { excepthandler_ty o = ( excepthandler_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case ExceptHandler_kind : result = PyType_GenericNew ( ExceptHandler_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . ExceptHandler . type ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> v . ExceptHandler . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ExceptHandler . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,992,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch,1
993,CWE-125,"CWE-125 void process_packet_tail ( struct msg_digest * md ) { struct state * st = md -> st ; enum state_kind from_state = md -> v1_from_state ; const struct state_v1_microcode * smc = md -> smc ; bool new_iv_set = md -> new_iv_set ; bool self_delete = FALSE ; if ( md -> hdr . isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION ) { endpoint_buf b ; dbg ( ""received<S2SV_blank>encrypted<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>%s"" , str_endpoint ( & md -> sender , & b ) ) ; if ( st == NULL ) { libreswan_log ( ""discarding<S2SV_blank>encrypted<S2SV_blank>message<S2SV_blank>for<S2SV_blank>an<S2SV_blank>unknown<S2SV_blank>ISAKMP<S2SV_blank>SA"" ) ; return ; } if ( st -> st_skeyid_e_nss == NULL ) { loglog ( RC_LOG_SERIOUS , ""discarding<S2SV_blank>encrypted<S2SV_blank>message<S2SV_blank>because<S2SV_blank>we<S2SV_blank>haven\'t<S2SV_blank>yet<S2SV_blank>negotiated<S2SV_blank>keying<S2SV_blank>material"" ) ; return ; } md -> encrypted = TRUE ; const struct encrypt_desc * e = st -> st_oakley . ta_encrypt ; if ( pbs_left ( & md -> message_pbs ) % e -> enc_blocksize != 0 ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>message:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>encryption<S2SV_blank>blocksize"" ) ; return ; } md -> raw_packet = clone_bytes_as_chunk ( md -> packet_pbs . start , pbs_room ( & md -> packet_pbs ) , ""raw<S2SV_blank>packet"" ) ; if ( ! new_iv_set ) { if ( st -> st_v1_iv . len == 0 ) { init_phase2_iv ( st , & md -> hdr . isa_msgid ) ; } else { restore_new_iv ( st , st -> st_v1_iv ) ; } } passert ( st -> st_v1_new_iv . len >= e -> enc_blocksize ) ; st -> st_v1_new_iv . len = e -> enc_blocksize ; if ( DBGP ( DBG_CRYPT ) ) { DBG_log ( ""decrypting<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>using<S2SV_blank>algorithm<S2SV_blank>%s"" , ( unsigned ) pbs_left ( & md -> message_pbs ) , st -> st_oakley . ta_encrypt -> common . fqn ) ; DBG_dump_hunk ( ""IV<S2SV_blank>before:"" , st -> st_v1_new_iv ) ; } e -> encrypt_ops -> do_crypt ( e , md -> message_pbs . cur , pbs_left ( & md -> message_pbs ) , st -> st_enc_key_nss , st -> st_v1_new_iv . ptr , FALSE ) ; if ( DBGP ( DBG_CRYPT ) ) { DBG_dump_hunk ( ""IV<S2SV_blank>after:"" , st -> st_v1_new_iv ) ; DBG_log ( ""decrypted<S2SV_blank>payload<S2SV_blank>(starts<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%td):"" , md -> message_pbs . cur - md -> message_pbs . roof ) ; DBG_dump ( NULL , md -> message_pbs . start , md -> message_pbs . roof - md -> message_pbs . start ) ; } } else { if ( smc -> flags & SMF_INPUT_ENCRYPTED ) { loglog ( RC_LOG_SERIOUS , ""packet<S2SV_blank>rejected:<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>encrypted"" ) ; SEND_NOTIFICATION ( INVALID_FLAGS ) ; return ; } } { enum next_payload_types_ikev1 np = md -> hdr . isa_np ; lset_t needed = smc -> req_payloads ; const char * excuse = LIN ( SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT , smc -> flags ) ? ""probable<S2SV_blank>authentication<S2SV_blank>failure<S2SV_blank>(mismatch<S2SV_blank>of<S2SV_blank>preshared<S2SV_blank>secrets?):<S2SV_blank>"" : """" ; while ( np != ISAKMP_NEXT_NONE ) { struct_desc * sd = v1_payload_desc ( np ) ; if ( md -> digest_roof >= elemsof ( md -> digest ) ) { loglog ( RC_LOG_SERIOUS , ""more<S2SV_blank>than<S2SV_blank>%zu<S2SV_blank>payloads<S2SV_blank>in<S2SV_blank>message;<S2SV_blank>ignored"" , elemsof ( md -> digest ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } struct payload_digest * const pd = md -> digest + md -> digest_roof ; if ( st != NULL && st -> st_connection != NULL && ( st -> st_connection -> policy & POLICY_AGGRESSIVE ) == LEMPTY ) { switch ( np ) { case ISAKMP_NEXT_NATD_RFC : case ISAKMP_NEXT_NATOA_RFC : if ( ( st -> hidden_variables . st_nat_traversal & NAT_T_WITH_RFC_VALUES ) == LEMPTY ) { DBG ( DBG_NATT , DBG_log ( ""st_nat_traversal<S2SV_blank>was:<S2SV_blank>%s"" , bitnamesof ( natt_bit_names , st -> hidden_variables . st_nat_traversal ) ) ) ; sd = NULL ; } break ; default : break ; } } if ( sd == NULL ) { switch ( np ) { case ISAKMP_NEXT_ID : sd = ( IS_PHASE1 ( from_state ) || IS_PHASE15 ( from_state ) ) ? & isakmp_identification_desc : & isakmp_ipsec_identification_desc ; break ; case ISAKMP_NEXT_NATD_DRAFTS : np = ISAKMP_NEXT_NATD_RFC ; sd = & isakmp_nat_d_drafts ; break ; case ISAKMP_NEXT_NATOA_DRAFTS : np = ISAKMP_NEXT_NATOA_RFC ; sd = & isakmp_nat_oa_drafts ; break ; case ISAKMP_NEXT_SAK : loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>with<S2SV_blank>unsupported<S2SV_blank>payload<S2SV_blank>ISAKMP_NEXT_SAK<S2SV_blank>(or<S2SV_blank>ISAKMP_NEXT_NATD_BADDRAFTS)<S2SV_blank>ignored"" , excuse ) ; if ( ! in_struct ( & pd -> payload , & isakmp_ignore_desc , & md -> message_pbs , & pd -> pbs ) ) { loglog ( RC_LOG_SERIOUS , ""%smalformed<S2SV_blank>payload<S2SV_blank>in<S2SV_blank>packet"" , excuse ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } np = pd -> payload . generic . isag_np ; continue ; default : loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unknown<S2SV_blank>or<S2SV_blank>unexpected<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>at<S2SV_blank>the<S2SV_blank>outermost<S2SV_blank>level"" , excuse , enum_show ( & ikev1_payload_names , np ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( INVALID_PAYLOAD_TYPE ) ; } return ; } passert ( sd != NULL ) ; } passert ( np < LELEM_ROOF ) ; { lset_t s = LELEM ( np ) ; if ( LDISJOINT ( s , needed | smc -> opt_payloads | LELEM ( ISAKMP_NEXT_VID ) | LELEM ( ISAKMP_NEXT_N ) | LELEM ( ISAKMP_NEXT_D ) | LELEM ( ISAKMP_NEXT_CR ) | LELEM ( ISAKMP_NEXT_CERT ) ) ) { loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>unexpected<S2SV_blank>by<S2SV_blank>state<S2SV_blank>%s"" , excuse , enum_show ( & ikev1_payload_names , np ) , <S2SV_StartBug> st -> st_state -> name ) ; <S2SV_EndBug> if ( ! md -> encrypted ) { SEND_NOTIFICATION ( INVALID_PAYLOAD_TYPE ) ; } return ; } DBG ( DBG_PARSING , DBG_log ( ""got<S2SV_blank>payload<S2SV_blank>0x%"" PRIxLSET ""<S2SV_blank><S2SV_blank>(%s)<S2SV_blank>needed:<S2SV_blank>0x%"" PRIxLSET ""<S2SV_blank>opt:<S2SV_blank>0x%"" PRIxLSET , s , enum_show ( & ikev1_payload_names , np ) , needed , smc -> opt_payloads ) ) ; needed &= ~ s ; } pd -> payload_type = np ; if ( ! in_struct ( & pd -> payload , sd , & md -> message_pbs , & pd -> pbs ) ) { loglog ( RC_LOG_SERIOUS , ""%smalformed<S2SV_blank>payload<S2SV_blank>in<S2SV_blank>packet"" , excuse ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } switch ( np ) { case ISAKMP_NEXT_ID : case ISAKMP_NEXT_NATOA_RFC : DBG ( DBG_PARSING , DBG_dump ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>obj:<S2SV_blank>"" , pd -> pbs . cur , pbs_left ( & pd -> pbs ) ) ) ; break ; default : break ; } { passert ( np < elemsof ( md -> chain ) ) ; struct payload_digest * * p = & md -> chain [ np ] ; while ( * p != NULL ) p = & ( * p ) -> next ; * p = pd ; pd -> next = NULL ; } np = pd -> payload . generic . isag_np ; md -> digest_roof ++ ; excuse = """" ; } DBG ( DBG_PARSING , { if ( pbs_left ( & md -> message_pbs ) != 0 ) DBG_log ( ""removing<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>padding"" , ( int ) pbs_left ( & md -> message_pbs ) ) ; } ) ; md -> message_pbs . roof = md -> message_pbs . cur ; if ( needed != 0 ) { loglog ( RC_LOG_SERIOUS , ""message<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>missing<S2SV_blank>payloads<S2SV_blank>%s"" , finite_states [ from_state ] -> name , bitnamesof ( payload_name_ikev1 , needed ) ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } } if ( ! check_v1_HASH ( smc -> hash_type , smc -> message , st , md ) ) { return ; } if ( IS_PHASE1 ( from_state ) || IS_PHASE15 ( from_state ) ) { if ( md -> chain [ ISAKMP_NEXT_SA ] != NULL && md -> hdr . isa_np != ISAKMP_NEXT_SA ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Phase<S2SV_blank>1<S2SV_blank>message:<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>an<S2SV_blank>SA<S2SV_blank>payload"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } } else if ( IS_QUICK ( from_state ) ) { if ( md -> hdr . isa_np != ISAKMP_NEXT_HASH ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>HASH<S2SV_blank>payload"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } { struct payload_digest * p ; int i ; p = md -> chain [ ISAKMP_NEXT_SA ] ; i = 1 ; while ( p != NULL ) { if ( p != & md -> digest [ i ] ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>SA<S2SV_blank>payload<S2SV_blank>is<S2SV_blank>in<S2SV_blank>wrong<S2SV_blank>position"" ) ; if ( ! md -> encrypted ) { SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; } return ; } p = p -> next ; i ++ ; } } { struct payload_digest * id = md -> chain [ ISAKMP_NEXT_ID ] ; if ( id != NULL ) { if ( id -> next == NULL || id -> next -> next != NULL ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>if<S2SV_blank>any<S2SV_blank>ID<S2SV_blank>payload<S2SV_blank>is<S2SV_blank>present,<S2SV_blank>there<S2SV_blank>must<S2SV_blank>be<S2SV_blank>exactly<S2SV_blank>two"" ) ; SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; return ; } if ( id + 1 != id -> next ) { loglog ( RC_LOG_SERIOUS , ""malformed<S2SV_blank>Quick<S2SV_blank>Mode<S2SV_blank>message:<S2SV_blank>the<S2SV_blank>ID<S2SV_blank>payloads<S2SV_blank>are<S2SV_blank>not<S2SV_blank>adjacent"" ) ; SEND_NOTIFICATION ( PAYLOAD_MALFORMED ) ; return ; } } } } { struct payload_digest * p = md -> chain [ ISAKMP_NEXT_N ] ; while ( p != NULL ) { switch ( p -> payload . notification . isan_type ) { case R_U_THERE : case R_U_THERE_ACK : case ISAKMP_N_CISCO_LOAD_BALANCE : case PAYLOAD_MALFORMED : case INVALID_MESSAGE_ID : case IPSEC_RESPONDER_LIFETIME : if ( md -> hdr . isa_xchg == ISAKMP_XCHG_INFO ) { break ; } default : if ( st == NULL ) { DBG ( DBG_CONTROL , DBG_log ( ""ignoring<S2SV_blank>informational<S2SV_blank>payload<S2SV_blank>%s,<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>state"" , enum_show ( & ikev1_notify_names , p -> payload . notification . isan_type ) ) ) ; } else { loglog ( RC_LOG_SERIOUS , ""ignoring<S2SV_blank>informational<S2SV_blank>payload<S2SV_blank>%s,<S2SV_blank>msgid=%08"" PRIx32 "",<S2SV_blank>length=%d"" , enum_show ( & ikev1_notify_names , p -> payload . notification . isan_type ) , st -> st_v1_msgid . id , p -> payload . notification . isan_length ) ; DBG_dump_pbs ( & p -> pbs ) ; } } if ( DBGP ( DBG_BASE ) ) { DBG_dump ( ""info:"" , p -> pbs . cur , pbs_left ( & p -> pbs ) ) ; } p = p -> next ; } p = md -> chain [ ISAKMP_NEXT_D ] ; while ( p != NULL ) { self_delete |= accept_delete ( md , p ) ; if ( DBGP ( DBG_BASE ) ) { DBG_dump ( ""del:"" , p -> pbs . cur , pbs_left ( & p -> pbs ) ) ; } if ( md -> st != st ) { pexpect ( md -> st == NULL ) ; dbg ( ""zapping<S2SV_blank>ST<S2SV_blank>as<S2SV_blank>accept_delete()<S2SV_blank>zapped<S2SV_blank>MD.ST"" ) ; st = md -> st ; } p = p -> next ; } p = md -> chain [ ISAKMP_NEXT_VID ] ; while ( p != NULL ) { handle_vendorid ( md , ( char * ) p -> pbs . cur , pbs_left ( & p -> pbs ) , FALSE ) ; p = p -> next ; } } if ( self_delete ) { accept_self_delete ( md ) ; st = md -> st ; } pexpect ( st == md -> st ) ; statetime_t start = statetime_start ( md -> st ) ; complete_v1_state_transition ( md , smc -> processor ( st , md ) ) ; statetime_stop ( & start , ""%s()"" , __func__ ) ; }
","<S2SV_ModStart> np ) , finite_states [ smc -> state ] <S2SV_ModEnd> -> name )
",libreswan@libreswan/471a3e41a449d7c753bc4edbba4239501bb62ba8,CVE-2020-1763,https://github.com/libreswan/libreswan/commit/471a3e41a449d7c753bc4edbba4239501bb62ba8,2020-05-12T14:15Z,993,"<S2SV_ModStart> md -> hdr. isa_msgid <S2SV_ModEnd> ) ; strncpy <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> hdr. isa_msgid, sizeof ( md -> hdr. isa_msgid ) <S2SV_ModEnd> ) ; strncpy <S2SV_ModEnd> ( md -> <S2SV_ModStart> md -> hdr",0
996,CWE-125,"CWE-125 <S2SV_StartBug> static void <S2SV_EndBug> ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } if ( ( length + 1 ) & 3 ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_EndBug> ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>ptr<S2SV_blank>%u]"" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <S2SV_EndBug> if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> , length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;
",the-tcpdump-group@tcpdump/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,CVE-2017-13022,https://github.com/the-tcpdump-group/tcpdump/commit/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,2017-09-14T06:29Z,996,"<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> 3 ) { ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> 4 ) { ND_TCHECK2 ( cp [ len ], 4 ) ; <S2SV_ModStart> ) ) ; } return ( 0 ) ;",0
1009,CWE-125,"CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { <S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> if ( bytes_matched + i >= max_bytes_matched ) <S2SV_StartBug> break ; <S2SV_EndBug> if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z,1009,"<S2SV_ModStart> ++ ) { if ( bytes_matched >= max_bytes_matched ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS? input + 1 : input_data, bytes_matched, flags, callback_args ) ) ; break ; } <S2SV_ModStart> ++ ) { if ( bytes_matched >= max_bytes_matched ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS? input + 1 : input_data, bytes_matched, flags, callback_args ) ) ; break ; }",0
1013,CWE-125,"CWE-125 int jpc_dec_decodepkts ( jpc_dec_t * dec , jas_stream_t * pkthdrstream , jas_stream_t * in ) { jpc_dec_tile_t * tile ; jpc_pi_t * pi ; int ret ; tile = dec -> curtile ; pi = tile -> pi ; for ( ; ; ) { if ( ! tile -> pkthdrstream || jas_stream_peekc ( tile -> pkthdrstream ) == EOF ) { switch ( jpc_dec_lookahead ( in ) ) { case JPC_MS_EOC : case JPC_MS_SOT : return 0 ; break ; case JPC_MS_SOP : case JPC_MS_EPH : case 0 : break ; default : return - 1 ; break ; } } if ( ( ret = jpc_pi_next ( pi ) ) ) { return ret ; } if ( dec -> maxpkts >= 0 && dec -> numpkts >= dec -> maxpkts ) { jas_eprintf ( ""warning:<S2SV_blank>stopping<S2SV_blank>decode<S2SV_blank>prematurely<S2SV_blank>as<S2SV_blank>requested\\n"" ) ; return 0 ; } if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""packet<S2SV_blank>offset=%08ld<S2SV_blank>prg=%d<S2SV_blank>cmptno=%02d<S2SV_blank>"" ""rlvlno=%02d<S2SV_blank>prcno=%03d<S2SV_blank>lyrno=%02d\\n"" , ( long ) jas_stream_getrwcount ( in ) , jpc_pi_prg ( pi ) , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ; } if ( jpc_dec_decodepkt ( dec , pkthdrstream , in , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ) { return - 1 ; } ++ dec -> numpkts ; } return 0 ; }
","
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,1013,,1
1021,CWE-125,"CWE-125 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO ""0x%02x"" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO "",<S2SV_blank>"" ) ; } printk ( "")<S2SV_blank>toneburst=%d\\n"" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( ""%s<S2SV_blank>burst=%d\\n"" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }
","<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i
",torvalds@linux/1fa2337a315a2448c5434f41e00d56b01a22283c,CVE-2015-9289,https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c,2019-07-27T22:15Z,1021,<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i,1
1023,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
",ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z,1023,"<S2SV_ModStart> ""UnableToReadImageData"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ;",0
1046,CWE-125,"CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
","<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
",the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94,CVE-2018-14466,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,2019-10-03T16:15Z,1046,<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh,1
1052,CWE-125,"CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
",kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z,1052,"<S2SV_ModStart> < q ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> low ) ; } <S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> low ) ; } <S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, str, * low ) ; } else { <S2SV_ModStart> low ) ; }",0
1061,CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z,1061,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static,1
1070,CWE-125,"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\n\\t%s<S2SV_blank>(%u)"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type:<S2SV_blank>%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>opts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(bad<S2SV_blank>length)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { <S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; pptr += opli ; } trunc : <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> ND_TCHECK ( * tptr <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> } trunc : ND_PRINT ( ( ndo , ""[|esis]"" ) ) <S2SV_ModEnd> ; } <S2SV_null>
",the-tcpdump-group@tcpdump/331530a4076c69bbd2e3214db6ccbe834fb75640,CVE-2017-13047,https://github.com/the-tcpdump-group/tcpdump/commit/331530a4076c69bbd2e3214db6ccbe834fb75640,2017-09-14T06:29Z,1070,"<S2SV_ModStart> return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> indicator <S2SV_blank> %u <S2SV_blank> < <S2SV_blank> min <S2SV_blank> PDU <S2SV_blank> size:"", li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo, ""%02X"", * pptr ++ ) ) ; if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> %u <S2SV_blank> < <S2SV_blank> min <S2SV_blank> PDU <S2SV_blank> size:"", li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo, ""%02X"", * pptr ++ ) ; if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> indicator <S2SV_blank> %u <S2SV_blank> < <S2SV_blank> min <S2SV_blank> PDU <S2SV_blank> size:"", li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo, "" <S2SV_blank> length <S2SV_blank> indicator <S2SV_blank> %u <S2SV_blank> <",0
1090,CWE-125,"CWE-125 static void core_anal_bytes ( RCore * core , const ut8 * buf , int len , int nops , int fmt ) { int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; bool iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; bool romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; bool stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; bool be = core -> print -> big_endian ; bool use_color = core -> print -> flags & R_PRINT_FLAGS_COLOR ; core -> parser -> relsub = r_config_get_i ( core -> config , ""asm.relsub"" ) ; int ret , i , j , idx , size ; const char * color = """" ; const char * esilstr ; const char * opexstr ; RAnalHint * hint ; RAnalEsil * esil = NULL ; RAsmOp asmop ; RAnalOp op = { 0 } ; ut64 addr ; bool isFirst = true ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; int totalsize = 0 ; if ( use_color ) { color = core -> cons -> pal . label ; } switch ( fmt ) { case 'j' : r_cons_printf ( ""["" ) ; break ; case 'r' : esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; if ( ! esil ) { return ; } r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; break ; } for ( i = idx = ret = 0 ; idx < len && ( ! nops || ( nops && i < nops ) ) ; i ++ , idx += ret ) { addr = core -> offset + idx ; hint = r_anal_hint_get ( core -> anal , addr ) ; r_asm_set_pc ( core -> assembler , addr ) ; ( void ) r_asm_disassemble ( core -> assembler , & asmop , buf + idx , len - idx ) ; ret = r_anal_op ( core -> anal , & op , core -> offset + idx , buf + idx , len - idx , R_ANAL_OP_MASK_ESIL ) ; esilstr = R_STRBUF_SAFEGET ( & op . esil ) ; opexstr = R_STRBUF_SAFEGET ( & op . opex ) ; char * mnem = strdup ( r_asm_op_get_asm ( & asmop ) ) ; char * sp = strchr ( mnem , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; if ( op . prefix ) { char * arg = strdup ( sp + 1 ) ; char * sp = strchr ( arg , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; } free ( mnem ) ; mnem = arg ; } } if ( ret < 1 && fmt != 'd' ) { eprintf ( ""Oops<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""<S2SV_blank>("" , core -> offset + idx ) ; for ( i = idx , j = 0 ; i < core -> blocksize && j < 3 ; ++ i , ++ j ) { eprintf ( ""%02x<S2SV_blank>"" , buf [ i ] ) ; } eprintf ( ""...)\\n"" ) ; free ( mnem ) ; break ; } size = ( hint && hint -> size ) ? hint -> size : op . size ; if ( fmt == 'd' ) { char * opname = strdup ( r_asm_op_get_asm ( & asmop ) ) ; if ( opname ) { r_str_split ( opname , '<S2SV_blank>' ) ; char * d = r_asm_describe ( core -> assembler , opname ) ; if ( d && * d ) { r_cons_printf ( ""%s:<S2SV_blank>%s\\n"" , opname , d ) ; free ( d ) ; } else { eprintf ( ""Unknown<S2SV_blank>opcode\\n"" ) ; } free ( opname ) ; } } else if ( fmt == 'e' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( ""%s0x%"" PFMT64x Color_RESET ""<S2SV_blank>%s\\n"" , color , core -> offset + idx , esilstr ) ; } else { r_cons_printf ( ""0x%"" PFMT64x ""<S2SV_blank>%s\\n"" , core -> offset + idx , esilstr ) ; } } } else if ( fmt == 's' ) { totalsize += op . size ; } else if ( fmt == 'r' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( ""%s0x%"" PFMT64x Color_RESET ""\\n"" , color , core -> offset + idx ) ; } else { r_cons_printf ( ""0x%"" PFMT64x ""\\n"" , core -> offset + idx ) ; } r_anal_esil_parse ( esil , esilstr ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; } } else if ( fmt == 'j' ) { if ( isFirst ) { isFirst = false ; } else { r_cons_print ( "","" ) ; } r_cons_printf ( ""{\\""opcode\\"":\\""%s\\"","" , r_asm_op_get_asm ( & asmop ) ) ; { char strsub [ 128 ] = { 0 } ; r_parse_varsub ( core -> parser , NULL , core -> offset + idx , asmop . size , r_asm_op_get_asm ( & asmop ) , strsub , sizeof ( strsub ) ) ; { ut64 killme = UT64_MAX ; if ( r_io_read_i ( core -> io , op . ptr , & killme , op . refptr , be ) ) { core -> parser -> relsub_addr = killme ; } } char * p = strdup ( strsub ) ; if ( p ) { r_parse_filter ( core -> parser , addr , core -> flags , p , strsub , sizeof ( strsub ) , be ) ; free ( p ) ; } r_cons_printf ( ""\\""disasm\\"":\\""%s\\"","" , strsub ) ; } r_cons_printf ( ""\\""mnemonic\\"":\\""%s\\"","" , mnem ) ; if ( hint && hint -> opcode ) { r_cons_printf ( ""\\""ophint\\"":\\""%s\\"","" , hint -> opcode ) ; } r_cons_printf ( ""\\""sign\\"":%s,"" , r_str_bool ( op . sign ) ) ; r_cons_printf ( ""\\""prefix\\"":%"" PFMT64u "","" , op . prefix ) ; r_cons_printf ( ""\\""id\\"":%d,"" , op . id ) ; if ( opexstr && * opexstr ) { r_cons_printf ( ""\\""opex\\"":%s,"" , opexstr ) ; } r_cons_printf ( ""\\""addr\\"":%"" PFMT64u "","" , core -> offset + idx ) ; r_cons_printf ( ""\\""bytes\\"":\\"""" ) ; for ( j = 0 ; j < size ; j ++ ) { r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; } r_cons_printf ( ""\\"","" ) ; if ( op . val != UT64_MAX ) { r_cons_printf ( ""\\""val\\"":<S2SV_blank>%"" PFMT64u "","" , op . val ) ; } if ( op . ptr != UT64_MAX ) { r_cons_printf ( ""\\""ptr\\"":<S2SV_blank>%"" PFMT64u "","" , op . ptr ) ; } r_cons_printf ( ""\\""size\\"":<S2SV_blank>%d,"" , size ) ; r_cons_printf ( ""\\""type\\"":<S2SV_blank>\\""%s\\"","" , r_anal_optype_to_string ( op . type ) ) ; if ( op . reg ) { r_cons_printf ( ""\\""reg\\"":<S2SV_blank>\\""%s\\"","" , op . reg ) ; } if ( op . ireg ) { r_cons_printf ( ""\\""ireg\\"":<S2SV_blank>\\""%s\\"","" , op . ireg ) ; } if ( op . scale ) { r_cons_printf ( ""\\""scale\\"":%d,"" , op . scale ) ; } if ( hint && hint -> esil ) { r_cons_printf ( ""\\""esil\\"":<S2SV_blank>\\""%s\\"","" , hint -> esil ) ; } else if ( * esilstr ) { r_cons_printf ( ""\\""esil\\"":<S2SV_blank>\\""%s\\"","" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { r_cons_printf ( ""\\""jump\\"":%"" PFMT64u "","" , op . jump ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . refptr != - 1 ) { r_cons_printf ( ""\\""refptr\\"":%d,"" , op . refptr ) ; } if ( op . fail != UT64_MAX ) { r_cons_printf ( ""\\""fail\\"":%"" PFMT64u "","" , op . fail ) ; } r_cons_printf ( ""\\""cycles\\"":%d,"" , op . cycles ) ; if ( op . failcycles ) { r_cons_printf ( ""\\""failcycles\\"":%d,"" , op . failcycles ) ; } r_cons_printf ( ""\\""delay\\"":%d,"" , op . delay ) ; { const char * p = r_anal_stackop_tostring ( op . stackop ) ; if ( p && * p && strcmp ( p , ""null"" ) ) r_cons_printf ( ""\\""stack\\"":\\""%s\\"","" , p ) ; } if ( op . stackptr ) { r_cons_printf ( ""\\""stackptr\\"":%d,"" , op . stackptr ) ; } { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { r_cons_printf ( ""\\""cond\\"":\\""%s\\"","" , arg ) ; } } r_cons_printf ( ""\\""family\\"":\\""%s\\""}"" , r_anal_op_family_to_string ( op . family ) ) ; } else { # define printline ( k , fmt , arg ) { if ( use_color ) r_cons_printf ( ""%s%s:<S2SV_blank>"" Color_RESET , color , k ) ; else r_cons_printf ( ""%s:<S2SV_blank>"" , k ) ; if ( fmt ) r_cons_printf ( fmt , arg ) ; } printline ( ""address"" , ""0x%"" PFMT64x ""\\n"" , core -> offset + idx ) ; printline ( ""opcode"" , ""%s\\n"" , r_asm_op_get_asm ( & asmop ) ) ; printline ( ""mnemonic"" , ""%s\\n"" , mnem ) ; if ( hint ) { if ( hint -> opcode ) { printline ( ""ophint"" , ""%s\\n"" , hint -> opcode ) ; } # if 0 if ( hint -> addr != UT64_MAX ) { printline ( ""addr"" , ""0x%08"" PFMT64x ""\\n"" , ( hint -> addr + idx ) ) ; } # endif } printline ( ""prefix"" , ""%"" PFMT64u ""\\n"" , op . prefix ) ; printline ( ""id"" , ""%d\\n"" , op . id ) ; # if 0 if ( opexstr && * opexstr ) { printline ( ""opex"" , ""%s\\n"" , opexstr ) ; } # endif printline ( ""bytes"" , NULL , 0 ) ; <S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> } r_cons_newline ( ) ; <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> printline ( ""val"" , ""0x%08"" PFMT64x ""\\n"" , op . val ) ; <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug> printline ( ""size"" , ""%d\\n"" , size ) ; printline ( ""sign"" , ""%s\\n"" , r_str_bool ( op . sign ) ) ; printline ( ""type"" , ""%s\\n"" , r_anal_optype_to_string ( op . type ) ) ; printline ( ""cycles"" , ""%d\\n"" , op . cycles ) ; if ( op . failcycles ) { printline ( ""failcycles"" , ""%d\\n"" , op . failcycles ) ; } { const char * t2 = r_anal_optype_to_string ( op . type2 ) ; if ( t2 && strcmp ( t2 , ""null"" ) ) { printline ( ""type2"" , ""%s\\n"" , t2 ) ; } } if ( op . reg ) { printline ( ""reg"" , ""%s\\n"" , op . reg ) ; } if ( op . ireg ) { printline ( ""ireg"" , ""%s\\n"" , op . ireg ) ; } if ( op . scale ) { printline ( ""scale"" , ""%d\\n"" , op . scale ) ; } if ( hint && hint -> esil ) { printline ( ""esil"" , ""%s\\n"" , hint -> esil ) ; } else if ( * esilstr ) { printline ( ""esil"" , ""%s\\n"" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { printline ( ""jump"" , ""0x%08"" PFMT64x ""\\n"" , op . jump ) ; } if ( op . direction != 0 ) { const char * dir = op . direction == 1 ? ""read"" : op . direction == 2 ? ""write"" : op . direction == 4 ? ""exec"" : op . direction == 8 ? ""ref"" : ""none"" ; printline ( ""direction"" , ""%s\\n"" , dir ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . fail != UT64_MAX ) { printline ( ""fail"" , ""0x%08"" PFMT64x ""\\n"" , op . fail ) ; } if ( op . delay ) { printline ( ""delay"" , ""%d\\n"" , op . delay ) ; } printline ( ""stack"" , ""%s\\n"" , r_anal_stackop_tostring ( op . stackop ) ) ; { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { printline ( ""cond"" , ""%s\\n"" , arg ) ; } } printline ( ""family"" , ""%s\\n"" , r_anal_op_family_to_string ( op . family ) ) ; printline ( ""stackop"" , ""%s\\n"" , r_anal_stackop_tostring ( op . stackop ) ) ; if ( op . stackptr ) { printline ( ""stackptr"" , ""%"" PFMT64u ""\\n"" , op . stackptr ) ; } } free ( mnem ) ; r_anal_hint_free ( hint ) ; r_anal_op_fini ( & op ) ; } r_anal_op_fini ( & op ) ; if ( fmt == 'j' ) { r_cons_printf ( ""]"" ) ; r_cons_newline ( ) ; } else if ( fmt == 's' ) { r_cons_printf ( ""%d\\n"" , totalsize ) ; } r_anal_esil_free ( esil ) ; }
","<S2SV_ModStart> 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> ; j < minsz <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> buf [ j <S2SV_ModStart> + idx ] ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> val ) ; } <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> ptr ) ; } <S2SV_ModStart> - 1 ) { <S2SV_ModStart> refptr ) ; }
",radare@radare2/a1bc65c3db593530775823d6d7506a457ed95267,CVE-2018-20461,https://github.com/radare/radare2/commit/a1bc65c3db593530775823d6d7506a457ed95267,2018-12-25T19:29Z,1090,"<S2SV_ModStart> 0 ) ; if ( idx + size > len ) { r_cons_printf ( ""bytes <S2SV_blank> would <S2SV_blank> overrun <S2SV_blank> esil[%d]\\n"", idx + len ) ; break ; } <S2SV_ModStart> 0 ) ; if ( idx + size > len ) { r_cons_printf ( ""bytes <S2SV_blank> would <S2SV_blank> overrun <S2SV_blank> esil[%d]\\n"", idx + len ) ; break ; } <S2SV_ModStart> 1 ) ; if ( idx + size > len ) { r_cons_printf ( ""bytes <S2SV_blank> would <S2SV_blank> overrun <S2SV_blank> esil[%d]\\n"", len ) ; break ; } <S2SV_ModStart> 0 ) { r_cons_printf ( ""bytes <S2SV_blank> would <S2SV_blank> overrun <S2SV_blank> esil[%d]\\n"", idx + size ) ; break ; } <S2SV_ModStart> 0 ) { r_cons_printf ( ""bytes <S2SV_blank> would <S2SV_blank> overrun <S2SV_blank> esil[%d]\\n"", idx + size <S2SV_ModEnd> ) ; }",0
1092,CWE-125,"CWE-125 static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ; <S2SV_StartBug> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <S2SV_EndBug> u16 wTmp ; snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ; <S2SV_StartBug> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <S2SV_EndBug> writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ; <S2SV_StartBug> } <S2SV_EndBug> inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }
","<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z,1092,"<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head, tail, size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head!= tail ) { snd_msnd_eval_dsp_msg ( chip, readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd>, chip -> <S2SV_ModStart> ) ; } out :",1
1093,CWE-125,"CWE-125 static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { <S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , ""1,$"" ) ; return NULL ; }
","<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; }
",radare@radare2/b35530fa0681b27eba084de5527037ebfb397422,CVE-2018-11377,https://github.com/radare/radare2/commit/b35530fa0681b27eba084de5527037ebfb397422,2018-05-22T19:29Z,1093,<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; },1
1097,CWE-125,"CWE-125 static int add_attributes ( PyTypeObject * type , char * * attrs , int num_fields ) { <S2SV_StartBug> int i , result ; <S2SV_EndBug> _Py_IDENTIFIER ( _attributes ) ; PyObject * s , * l = PyTuple_New ( num_fields ) ; if ( ! l ) return 0 ; for ( i = 0 ; i < num_fields ; i ++ ) { s = PyUnicode_FromString ( attrs [ i ] ) ; if ( ! s ) { Py_DECREF ( l ) ; return 0 ; } PyTuple_SET_ITEM ( l , i , s ) ; } result = _PyObject_SetAttrId ( ( PyObject * ) type , & PyId__attributes , l ) >= 0 ; Py_DECREF ( l ) ; return result ; }
","<S2SV_ModStart> i , result <S2SV_ModEnd> ; PyObject *
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1097,"<S2SV_ModStart>, result ; _Py_IDENTIFIER ( _attributes ) ; PyUnicodeObject * s ; if (! num_fields ) { Py_DECREF ( l ) ; return 0 ; } for ( i = 0 ; i < num_fields ; i ++ ) { s = PyUnicode_FromString ( attrs [ i ] ) ; if (! s ) { Py_DECREF ( l ) ; return 0 ; } PyTuple_SET_ITEM ( l, i, s ) ; } result = _PyObject_SetAttrId ( ( PyObject * ) type, & PyId__attributes, l ) >= 0 ; Py_DECREF ( l ) ;",0
1106,CWE-125,"CWE-125 int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor<S2SV_blank>set\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; <S2SV_StartBug> length = cap -> bLength ; <S2SV_EndBug> if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptor<S2SV_blank>type<S2SV_blank>invalid,<S2SV_blank>skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
","<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=
",torvalds@linux/1c0edc3633b56000e18d82fc241e3995ca18a69e,CVE-2017-16535,https://github.com/torvalds/linux/commit/1c0edc3633b56000e18d82fc241e3995ca18a69e,2017-11-04T01:29Z,1106,<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=,1
1119,CWE-125,"CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; <S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length ) return - 1 ; if ( ++ ptr_count > length ) return - 1 ; continue ; } if ( label_len > 63 ) return - 1 ; if ( cp != name_out ) { if ( cp + 1 >= end ) return - 1 ; * cp ++ = '.' ; } if ( cp + label_len >= end ) return - 1 ; <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> cp += label_len ; j += label_len ; } if ( cp >= end ) return - 1 ; * cp = '\\0' ; if ( name_end < 0 ) * idx = j ; else * idx = name_end ; return 0 ; err : return - 1 ; }
","<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;
",libevent@libevent/96f64a022014a208105ead6c8a7066018449d86d,CVE-2016-10195,https://github.com/libevent/libevent/commit/96f64a022014a208105ead6c8a7066018449d86d,2017-03-15T15:59Z,1119,<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;,1
1128,CWE-125,"CWE-125 void ip6_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { register const struct ip6_hdr * ip6 ; register int advance ; u_int len ; const u_char * ipend ; register const u_char * cp ; register u_int payload_len ; int nh ; int fragmented = 0 ; u_int flow ; ip6 = ( const struct ip6_hdr * ) bp ; ND_TCHECK ( * ip6 ) ; if ( length < sizeof ( struct ip6_hdr ) ) { ND_PRINT ( ( ndo , ""truncated-ip6<S2SV_blank>%u"" , length ) ) ; return ; } if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IP6<S2SV_blank>"" ) ) ; if ( IP6_VERSION ( ip6 ) != 6 ) { ND_PRINT ( ( ndo , ""version<S2SV_blank>error:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>6"" , IP6_VERSION ( ip6 ) ) ) ; return ; } payload_len = EXTRACT_16BITS ( & ip6 -> ip6_plen ) ; len = payload_len + sizeof ( struct ip6_hdr ) ; if ( length < len ) ND_PRINT ( ( ndo , ""truncated-ip6<S2SV_blank>-<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>missing!"" , len - length ) ) ; if ( ndo -> ndo_vflag ) { flow = EXTRACT_32BITS ( & ip6 -> ip6_flow ) ; ND_PRINT ( ( ndo , ""("" ) ) ; # if 0 if ( flow & 0x0f000000 ) ND_PRINT ( ( ndo , ""pri<S2SV_blank>0x%02x,<S2SV_blank>"" , ( flow & 0x0f000000 ) >> 24 ) ) ; if ( flow & 0x00ffffff ) ND_PRINT ( ( ndo , ""flowlabel<S2SV_blank>0x%06x,<S2SV_blank>"" , flow & 0x00ffffff ) ) ; # else if ( flow & 0x0ff00000 ) ND_PRINT ( ( ndo , ""class<S2SV_blank>0x%02x,<S2SV_blank>"" , ( flow & 0x0ff00000 ) >> 20 ) ) ; if ( flow & 0x000fffff ) ND_PRINT ( ( ndo , ""flowlabel<S2SV_blank>0x%05x,<S2SV_blank>"" , flow & 0x000fffff ) ) ; # endif ND_PRINT ( ( ndo , ""hlim<S2SV_blank>%u,<S2SV_blank>next-header<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>payload<S2SV_blank>length:<S2SV_blank>%u)<S2SV_blank>"" , ip6 -> ip6_hlim , tok2str ( ipproto_values , ""unknown"" , ip6 -> ip6_nxt ) , ip6 -> ip6_nxt , payload_len ) ) ; } ipend = bp + len ; if ( ipend < ndo -> ndo_snapend ) ndo -> ndo_snapend = ipend ; cp = ( const u_char * ) ip6 ; advance = sizeof ( struct ip6_hdr ) ; nh = ip6 -> ip6_nxt ; while ( cp < ndo -> ndo_snapend && advance > 0 ) { <S2SV_StartBug> cp += advance ; <S2SV_EndBug> len -= advance ; if ( cp == ( const u_char * ) ( ip6 + 1 ) && nh != IPPROTO_TCP && nh != IPPROTO_UDP && nh != IPPROTO_DCCP && nh != IPPROTO_SCTP ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; } switch ( nh ) { case IPPROTO_HOPOPTS : advance = hbhopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_DSTOPTS : advance = dstopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_FRAGMENT : advance = frag6_print ( ndo , cp , ( const u_char * ) ip6 ) ; if ( advance < 0 || ndo -> ndo_snapend <= cp + advance ) return ; nh = * cp ; fragmented = 1 ; break ; case IPPROTO_MOBILITY_OLD : case IPPROTO_MOBILITY : advance = mobility_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> return ; case IPPROTO_ROUTING : <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> break ; case IPPROTO_SCTP : sctp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_DCCP : dccp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_TCP : tcp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_UDP : udp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_ICMPV6 : icmp6_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_AH : <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> nh = * cp ; break ; case IPPROTO_ESP : { int enh , padlen ; advance = esp_print ( ndo , cp , len , ( const u_char * ) ip6 , & enh , & padlen ) ; <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> len -= padlen ; break ; } case IPPROTO_IPCOMP : { ipcomp_print ( ndo , cp ) ; advance = - 1 ; break ; } case IPPROTO_PIM : pim_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_OSPF : ospf6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV6 : ip6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV4 : ip_print ( ndo , cp , len ) ; return ; case IPPROTO_PGM : pgm_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_GRE : gre_print ( ndo , cp , len ) ; return ; case IPPROTO_RSVP : rsvp_print ( ndo , cp , len ) ; return ; case IPPROTO_NONE : ND_PRINT ( ( ndo , ""no<S2SV_blank>next<S2SV_blank>header"" ) ) ; return ; default : ND_PRINT ( ( ndo , ""ip-proto-%d<S2SV_blank>%d"" , nh , len ) ) ; return ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|ip6]"" ) ) ; }
","<S2SV_ModStart> 0 ) { if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> , cp ) ; if ( advance < 0 ) return <S2SV_ModStart> padlen ) ; if ( advance < 0 ) return ;
",the-tcpdump-group@tcpdump/66df248b49095c261138b5a5e34d341a6bf9ac7f,CVE-2017-12985,https://github.com/the-tcpdump-group/tcpdump/commit/66df248b49095c261138b5a5e34d341a6bf9ac7f,2017-09-14T06:29Z,1128,"<S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated-ip6 <S2SV_blank> - <S2SV_blank> %u <S2SV_blank> bytes <S2SV_blank> missing!"", advance ) ) ; goto trunc ; } <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) { ND_PRINT ( ( ndo, ""truncated",0
1129,CWE-125,"CWE-125 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z,1129,<S2SV_ModStart> 4 ) ; if ( idx + 4 > len ) return NULL ; <S2SV_ModStart> ]. len + idx,0
1137,CWE-125,"CWE-125 static stmt_ty ast_for_expr_stmt ( struct compiling * c , const node * n ) { REQ ( n , expr_stmt ) ; <S2SV_StartBug> if ( NCH ( n ) == 1 ) { <S2SV_EndBug> expr_ty e = ast_for_testlist ( c , CHILD ( n , 0 ) ) ; if ( ! e ) return NULL ; return Expr ( e , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == augassign ) { expr_ty expr1 , expr2 ; operator_ty newoperator ; node * ch = CHILD ( n , 0 ) ; expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) return NULL ; if ( ! set_context ( c , expr1 , Store , ch ) ) return NULL ; switch ( expr1 -> kind ) { case Name_kind : case Attribute_kind : case Subscript_kind : break ; default : ast_error ( c , ch , ""illegal<S2SV_blank>expression<S2SV_blank>for<S2SV_blank>augmented<S2SV_blank>assignment"" ) ; return NULL ; } ch = CHILD ( n , 2 ) ; if ( TYPE ( ch ) == testlist ) expr2 = ast_for_testlist ( c , ch ) ; else expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) return NULL ; newoperator = ast_for_augassign ( c , CHILD ( n , 1 ) ) ; if ( ! newoperator ) return NULL ; return AugAssign ( expr1 , newoperator , expr2 , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == annassign ) { expr_ty expr1 , expr2 , expr3 ; node * ch = CHILD ( n , 0 ) ; node * deep , * ann = CHILD ( n , 1 ) ; int simple = 1 ; deep = ch ; while ( NCH ( deep ) == 1 ) { deep = CHILD ( deep , 0 ) ; } if ( NCH ( deep ) > 0 && TYPE ( CHILD ( deep , 0 ) ) == LPAR ) { simple = 0 ; } expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) { return NULL ; } switch ( expr1 -> kind ) { case Name_kind : if ( forbidden_name ( c , expr1 -> v . Name . id , n , 0 ) ) { return NULL ; } expr1 -> v . Name . ctx = Store ; break ; case Attribute_kind : if ( forbidden_name ( c , expr1 -> v . Attribute . attr , n , 1 ) ) { return NULL ; } expr1 -> v . Attribute . ctx = Store ; break ; case Subscript_kind : expr1 -> v . Subscript . ctx = Store ; break ; case List_kind : ast_error ( c , ch , ""only<S2SV_blank>single<S2SV_blank>target<S2SV_blank>(not<S2SV_blank>list)<S2SV_blank>can<S2SV_blank>be<S2SV_blank>annotated"" ) ; return NULL ; case Tuple_kind : ast_error ( c , ch , ""only<S2SV_blank>single<S2SV_blank>target<S2SV_blank>(not<S2SV_blank>tuple)<S2SV_blank>can<S2SV_blank>be<S2SV_blank>annotated"" ) ; return NULL ; default : ast_error ( c , ch , ""illegal<S2SV_blank>target<S2SV_blank>for<S2SV_blank>annotation"" ) ; return NULL ; } if ( expr1 -> kind != Name_kind ) { simple = 0 ; } ch = CHILD ( ann , 1 ) ; expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) { return NULL ; } if ( NCH ( ann ) == 2 ) { return AnnAssign ( expr1 , expr2 , NULL , simple , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else { ch = CHILD ( ann , 3 ) ; if ( TYPE ( ch ) == testlist ) { expr3 = ast_for_testlist ( c , ch ) ; } else { expr3 = ast_for_expr ( c , ch ) ; } if ( ! expr3 ) { return NULL ; } return AnnAssign ( expr1 , expr2 , expr3 , simple , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } } else { <S2SV_StartBug> int i ; <S2SV_EndBug> asdl_seq * targets ; node * value ; expr_ty expression ; <S2SV_StartBug> REQ ( CHILD ( n , 1 ) , EQUAL ) ; <S2SV_EndBug> <S2SV_StartBug> targets = _Py_asdl_seq_new ( NCH ( n ) / 2 , c -> c_arena ) ; <S2SV_EndBug> if ( ! targets ) return NULL ; <S2SV_StartBug> for ( i = 0 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> expr_ty e ; node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == yield_expr ) { ast_error ( c , ch , ""assignment<S2SV_blank>to<S2SV_blank>yield<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>possible"" ) ; return NULL ; } e = ast_for_testlist ( c , ch ) ; if ( ! e ) return NULL ; if ( ! set_context ( c , e , Store , CHILD ( n , i ) ) ) return NULL ; asdl_seq_SET ( targets , i / 2 , e ) ; } <S2SV_StartBug> value = CHILD ( n , NCH ( n ) - 1 ) ; <S2SV_EndBug> if ( TYPE ( value ) == testlist_star_expr ) expression = ast_for_testlist ( c , value ) ; else expression = ast_for_expr ( c , value ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> return Assign ( targets , expression , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } }
","<S2SV_ModStart> expr_stmt ) ; int num = <S2SV_ModEnd> NCH ( n <S2SV_ModStart> ( n ) ; if ( num <S2SV_ModStart> { int i , nch_minus_type , has_type_comment <S2SV_ModStart> expr_ty expression ; string type_comment ; <S2SV_ModStart> EQUAL ) ; has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ; nch_minus_type = num - has_type_comment ; <S2SV_ModStart> = _Py_asdl_seq_new ( nch_minus_type <S2SV_ModEnd> / 2 , <S2SV_ModStart> ; i < nch_minus_type <S2SV_ModEnd> - 2 ; <S2SV_ModStart> ( n , nch_minus_type <S2SV_ModEnd> - 1 ) <S2SV_ModStart> return NULL ; if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; <S2SV_ModStart> , expression , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,1137,"<S2SV_ModStart> ; if ( TYPE ( CHILD ( n, 0 ) ) == type_comment ) { node * ch = CHILD ( n, 0 ) ; if (! ch ) return NULL ; if (! set_context ( c, expr1, Store, ch ) ) return NULL ; switch ( TYPE ( CHILD ( n, 2 ) ) { case Name_kind : case Attribute_kind : break ; default : ast_error ( c, ch, ""illegal <S2SV_blank> expression <S2SV_blank> for <S2SV_blank> augmented <S2SV_blank> assignment"" ) ; return NULL ; } ch = CHILD ( n, 3 ) ; if (! set_context ( c, expr1, Store, ch ) ) return NULL ; switch ( TYPE ( CHILD ( n, 3 ) ) ) { case Name_kind : case Subscript_kind : break ; default : ast_error ( c, ch, ""illegal <S2SV_blank> expression <S2SV_blank> for <S2SV_blank> augmented <S2SV_blank> assignment"" ) ; return NULL ; } ch = CHILD ( n, 4 ) ; if (! set_context ( c, expr1, Store, ch ) ) return NULL ; } <S2SV_ModStart>, LINENO ( n ), n -> n_col_offset, n -> n_end",0
1152,CWE-125,"CWE-125 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
","<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
",torvalds@linux/cef31d9af908243421258f1df35a4a644604efbe,CVE-2017-18344,https://github.com/torvalds/linux/commit/cef31d9af908243421258f1df35a4a644604efbe,2018-07-26T19:29Z,1152,<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;,1
1168,CWE-125,"CWE-125 static int num_stmts ( const node * n ) { int i , l ; node * ch ; switch ( TYPE ( n ) ) { case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) return 0 ; else return num_stmts ( CHILD ( n , 0 ) ) ; case file_input : l = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == stmt ) l += num_stmts ( ch ) ; } return l ; case stmt : return num_stmts ( CHILD ( n , 0 ) ) ; case compound_stmt : return 1 ; case simple_stmt : return NCH ( n ) / 2 ; case suite : if ( NCH ( n ) == 1 ) return num_stmts ( CHILD ( n , 0 ) ) ; else { i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 1 ) ; i ++ ) l += num_stmts ( CHILD ( n , i ) ) ; return l ; } default : { char buf [ 128 ] ; sprintf ( buf , ""Non-statement<S2SV_blank>found:<S2SV_blank>%d<S2SV_blank>%d"" , TYPE ( n ) , NCH ( n ) ) ; Py_FatalError ( buf ) ; } } <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ; } } abort ( ) <S2SV_ModEnd> ; } <S2SV_null>
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1168,"<S2SV_ModStart> ; } } if ( NCH ( n ) == 1 ) { type_comment ( CHILD ( n, 1 ) ) ; if ( TYPE ( CHILD ( n, 2 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < NCH ( n ) - 2 ; i ++ ) if ( TYPE ( CHILD ( n, 3 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 1 ) ; i ++ ) if ( TYPE ( CHILD ( n, 4 ) ) { type_comment ( CHILD ( n, 5 ) ) ; if ( TYPE ( CHILD ( n, 5 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 2 ) ; i ++ ) if ( TYPE ( CHILD ( n, 3 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 3 ) ; i ++ ) if ( TYPE ( CHILD ( n, 4 ) ) == TYPE_COMMENT ) i += 2 ; if ( TYPE ( CHILD ( n, 5 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i",0
1176,CWE-125,"CWE-125 static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) { EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; switch ( type ) { case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( actx == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; return 0 ; } actx -> len . aad = 0 ; actx -> len . text = 0 ; actx -> aad = 0 ; actx -> mac_inited = 0 ; actx -> tag_len = 0 ; actx -> nonce_len = 12 ; actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; return 1 ; case EVP_CTRL_COPY : if ( actx ) { EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( dst -> cipher_data == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; return 0 ; } } return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ; actx -> nonce_len = arg ; return 1 ; case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ; actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ; if ( ptr != NULL ) { memcpy ( actx -> tag , ptr , arg ) ; actx -> tag_len = arg ; } return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ; memcpy ( ptr , actx -> tag , arg ) ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; { unsigned int len ; unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ; len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ; if ( ! ctx -> encrypt ) { <S2SV_StartBug> len -= POLY1305_BLOCK_SIZE ; <S2SV_EndBug> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ; aad = temp ; temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ; temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ; } actx -> tls_payload_length = len ; actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ; actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ; actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ; actx -> mac_inited = 0 ; chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ; return POLY1305_BLOCK_SIZE ; } case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ; default : return - 1 ; } }
","<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
",openssl@openssl/00d965474b22b54e4275232bc71ee0c699c5cd21,CVE-2017-3731,https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21,2017-05-04T19:29Z,1176,<S2SV_ModStart> case EVP_CTRL_AEAD_SET_IV_LEN_FIXED : if ( arg < 0 || arg > EVP_CTR_SIZE ) return 0 ; actx -> nonce [ 0 ] = actx -> key. counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 1 ] = actx -> key. counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 2 ] = actx -> key. counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 5 ) ; actx -> nonce [ 3 ] = actx -> key. counter [ 0 ] = actx -> key. counter [ 1 ] = actx -> key. counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 6 ) ; actx -> nonce [ 4 ] = actx -> key. counter [ 3 ] = actx -> key. counter [ 4 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr +,0
1192,CWE-125,"CWE-125 static int forbidden_name ( struct compiling * c , identifier name , const node * n , int full_checks ) { assert ( PyUnicode_Check ( name ) ) ; <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 ) { <S2SV_EndBug> ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ; return 1 ; } if ( full_checks ) { const char * const * p ; for ( p = FORBIDDEN ; * p ; p ++ ) { <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , * p ) == 0 ) { <S2SV_EndBug> ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ; return 1 ; } } } return 0 ; }
","<S2SV_ModStart> ; if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> , ""__debug__"" ) <S2SV_ModEnd> ) { ast_error <S2SV_ModStart> { if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> * p ) <S2SV_ModEnd> ) { ast_error
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1192,"<S2SV_ModStart> if ( PyUnicode_CompareWithASCIIString <S2SV_ModEnd> ( name, <S2SV_ModStart> { if ( PyUnicode_CompareWithASCIIString <S2SV_ModEnd> ( name,",0
1197,CWE-125,"CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
","<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
",devnexen@radare2/88a8adf080a9f8ed5a4250a2507752e133ba54dd,CVE-2018-20459,https://github.com/devnexen/radare2/commit/88a8adf080a9f8ed5a4250a2507752e133ba54dd,2018-12-25T19:29Z,1197,<S2SV_ModStart> [ i ] && j < sizeof ( buf ),0
1202,CWE-125,"CWE-125 static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
","
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z,1202,,1
1231,CWE-125,"CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ; <S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; } <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , ""Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n"" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , ""all"" ) == 0 ) { all_flag = 1 ; body_pref = ""rht"" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }
","<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&
",verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z,1231,<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&,1
1244,CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b,CVE-2019-19275,https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b,2019-11-26T15:15Z,1244,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1252,CWE-125,"CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_StartBug> int hexdump ; <S2SV_EndBug> u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> ; int hexdump , ret <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
",the-tcpdump-group@tcpdump/d97e94223720684c6aa740ff219e0d19426c2220,CVE-2018-14464,https://github.com/the-tcpdump-group/tcpdump/commit/d97e94223720684c6aa740ff219e0d19426c2220,2019-10-03T16:15Z,1252,"<S2SV_ModStart>, obj_tlen ; u_int <S2SV_ModEnd> offset ; u_int <S2SV_ModStart> ) ) ; if ( tlen < sizeof ( struct lmp_common_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> (too <S2SV_blank> short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo, "" <S2SV_blank> (too <S2SV_blank> short)"" ) ) ; tlen = len ; } <S2SV_ModStart> ) ) ; if ( tlen < sizeof ( struct lmp_object_header ) ) { ND_PRINT ( ( ndo, "" <S2SV_blank> (too <S2SV_blank> short)"" ) ) ; return ; }",0
1291,CWE-125,"CWE-125 stmt_ty <S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>target<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>iter<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ; <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,1291,"<S2SV_ModStart> expr_ty iter, string type_comment, <S2SV_ModStart> orelse = orelse ; p -> v. AsyncFor. type_comment = type_comment",0
1296,CWE-125,"CWE-125 static UINT rdpei_recv_pdu ( RDPEI_CHANNEL_CALLBACK * callback , wStream * s ) { UINT16 eventId ; UINT32 pduLength ; UINT error ; <S2SV_StartBug> Stream_Read_UINT16 ( s , eventId ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , pduLength ) ; # ifdef WITH_DEBUG_RDPEI WLog_DBG ( TAG , ""rdpei_recv_pdu:<S2SV_blank>eventId:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>(%s)<S2SV_blank>length:<S2SV_blank>%"" PRIu32 """" , eventId , rdpei_eventid_string ( eventId ) , pduLength ) ; # endif switch ( eventId ) { case EVENTID_SC_READY : if ( ( error = rdpei_recv_sc_ready_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_sc_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } if ( ( error = rdpei_send_cs_ready_pdu ( callback ) ) ) { WLog_ERR ( TAG , ""rdpei_send_cs_ready_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_SUSPEND_TOUCH : if ( ( error = rdpei_recv_suspend_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_suspend_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_RESUME_TOUCH : if ( ( error = rdpei_recv_resume_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_resume_touch_pdu<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } break ; default : break ; } return CHANNEL_RC_OK ; }
","<S2SV_ModStart> UINT error ; if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1296,"<S2SV_ModStart> UINT error ; if (! Stream_SafeSeek <S2SV_ModEnd> ( s,",0
1303,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; UINT16 length ; UINT32 failureCode ; <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> , ""RDP_NEG_FAILURE"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FAIL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1303,"<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> rdpNego * <S2SV_ModStart> UINT32 failureCode ; if (! s ) return NULL ; WLog_DBG ( TAG, ""RDP_NEG_FAILURE"" ) ; <S2SV_ModStart> = NEGO_STATE_FAIL ; return NULL ;",0
1306,CWE-125,"CWE-125 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif break ; case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) { r1 . o = function -> return_obj ; push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , <S2SV_StartBug> r2 . re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> NULL , NULL ) >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } yr_modules_unload_all ( context ) ; yr_free ( stack ) ; return result ; }
","<S2SV_ModStart> -> length , 0 ,
",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z,1306,"<S2SV_ModStart> { YR_OBJECT * obj_ptr = ( YR_OBJECT * * ) yr_calloc ( 1, sizeof ( YR_OBJECT * ) ) ; if ( obj_ptr == NULL ) return ERROR_INSUFFICIENT_MEMORY ; <S2SV_ModStart> ++ ) { obj_ptr = ( YR_OBJECT * * ) yr_calloc ( 1, sizeof ( YR_OBJECT * ) ) ; if ( obj_ptr == NULL ) return ERROR_INSUFFICIENT_MEMORY ; } <S2SV_ModStart> ++ ) { obj_ptr = ( YR_OBJECT * * ) yr_calloc ( 1, sizeof ( YR_OBJECT * ) ) ; if ( obj_ptr == NULL ) return ERROR_INSUFFICIENT_MEMORY ; } <S2SV_ModStart> ++ ) { obj_ptr = ( YR_OBJECT * * ) yr_calloc ( 1, sizeof ( YR_OBJECT * ) ) ; if ( obj_ptr == NULL ) return ERROR_INSUFFICIENT_MEMORY ; } <S2SV_ModStart> ++ ) { obj_ptr = ( YR_OBJECT * * ) yr_calloc ( 1, sizeof ( YR_OBJECT * ) ) ; if ( obj",0
1331,CWE-125,"CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
",ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z,1331,"<S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; } <S2SV_ModStart> j ] & 0xFF ; if ( j % 8 == 0 ) { ALOGE ( ""b/26366256"" ) ; return ( - 1 ) ; }",0
1335,CWE-125,"CWE-125 static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z,1335,"<S2SV_ModStart> ; if ( exif_check_overflow ( buf + o, buf_size ) ) { exif_log ( en -> log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataFuji"", ""Short <S2SV_blank> MakerNote"" ) ; break ; } if ( <S2SV_ModStart> ; if ( exif_check_overflow ( buf + o, buf_size ) ) { exif_log ( en -> log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataFuji"", ""Short <S2SV_blank> MakerNote"" ) ; break ; } n -> entries [ tcount ]. tag = exif_get_short ( buf + o + 2, EXIF_BYTE_ORDER_INTEL ) ; n -> entries [ tcount ]. order = n -> order ; n -> entries [ tcount ]. entries = exif_mem_alloc ( en -> mem, sizeof ( MnoteFujiEntry ) * c ) ; if (! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log, ""ExifMnoteDataFuji"", sizeof ( MnoteFujiEntry ) * c ) ;",0
1337,CWE-125,"CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; <S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }
","<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
",the-tcpdump-group@tcpdump/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,CVE-2017-13012,https://github.com/the-tcpdump-group/tcpdump/commit/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,2017-09-14T06:29Z,1337,"<S2SV_ModStart> ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res, plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res, hlen ) ) { <S2SV_ModStart> ) ) ; }",0
1342,CWE-125,"CWE-125 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p )
",miniupnp@miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47,CVE-2016-3178,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,2017-03-24T15:59Z,1342,<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ),1
1347,CWE-125,"CWE-125 static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MagickPathExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MagickPathExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
",ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z,1347,"<S2SV_ModStart> 0x0004 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> 0x0008 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> 0x0008 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; break ; } <S2SV_ModStart> 0x0008 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> 0x0008 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> 0x0008 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; break ; } <S2SV_ModStart> 0x0008 : { if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, ""UnexpectedEndOfFile"" ) ; break ; } <S2SV_ModStart>",0
1353,CWE-125,"CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z,1353,"<S2SV_ModStart> struct ikev2_id id <S2SV_ModEnd> ; int id_len <S2SV_ModStart> * typedata ; ND_TCHECK_16BIT ( * ext ) ; UNALIGNED_MEMCPY ( & id, ext, sizeof ( id ) )",0
1356,CWE-125,"CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; <S2SV_StartBug> size_t <S2SV_EndBug> value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
","<S2SV_ModStart> 4 ] ; unsigned int <S2SV_ModEnd> value ; if <S2SV_ModStart> value = ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z,1356,<S2SV_ModStart> 4 ] ; unsigned int <S2SV_ModEnd> value ; if <S2SV_ModStart> value = ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart>. unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (,1
1371,CWE-125,"CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,1371,"<S2SV_ModStart> ( ndo, ""%s"", rpl_tstr <S2SV_ModEnd> ) ) ;",1
1379,CWE-125,"CWE-125 PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; <S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }
","<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1
",DanBloomberg@leptonica/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,CVE-2020-36281,https://github.com/DanBloomberg/leptonica/commit/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,2021-03-12T01:15Z,1379,"<S2SV_ModStart> * lined ; const PIX * pixc, * pixm, * pixg, * pixd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if (! pixc || pixGetDepth ( pixc )!= 8 ) return ( PIX * ) ERROR_PTR ( ""pixs <S2SV_blank> undefined <S2SV_blank> or <S2SV_blank> not <S2SV_blank> 8 <S2SV_blank> bpp"", procName, NULL ) ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs, level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too <S2SV_blank> many <S2SV_blank> colors"", procName, NULL ) ; if ( <S2SV_ModStart> NULL ) return ( PIX * ) ERROR_PTR ( ""too <S2SV_blank> many <S2SV_blank> colors"", procName, NULL ) ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs, level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too <S2SV_blank> many <S2SV_blank> colors"", procName, NULL ) ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs, level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too",0
1391,CWE-125,"CWE-125 static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( ""Invalid<S2SV_blank>strings<S2SV_blank>size\\n"" ) ; return false ; } if ( bin -> classes ) { ut64 amount = sizeof ( int ) * bin -> header . method_size ; if ( amount > UT32_MAX || amount < bin -> header . method_size ) { return false ; } methods = calloc ( 1 , amount + 1 ) ; for ( i = 0 ; i < bin -> header . class_size ; i ++ ) { char * super_name , * class_name ; struct dex_class_t * c = & bin -> classes [ i ] ; class_name = dex_class_name ( bin , c ) ; super_name = dex_class_super_name ( bin , c ) ; if ( dexdump ) { rbin -> cb_printf ( ""Class<S2SV_blank>#%d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-\\n"" , i ) ; } parse_class ( arch , bin , c , i , methods , & sym_count ) ; free ( class_name ) ; free ( super_name ) ; } } if ( methods ) { int import_count = 0 ; int sym_count = bin -> methods_list -> length ; for ( i = 0 ; i < bin -> header . method_size ; i ++ ) { int len = 0 ; if ( methods [ i ] ) { continue ; } <S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> continue ; } if ( is_class_idx_in_code_classes ( bin , bin -> methods [ i ] . class_id ) ) { continue ; } char * class_name = getstr ( bin , bin -> types [ bin -> methods [ i ] . class_id ] . descriptor_id ) ; if ( ! class_name ) { free ( class_name ) ; continue ; } len = strlen ( class_name ) ; if ( len < 1 ) { continue ; } class_name [ len - 1 ] = 0 ; char * method_name = dex_method_name ( bin , i ) ; char * signature = dex_method_signature ( bin , i ) ; if ( method_name && * method_name ) { RBinImport * imp = R_NEW0 ( RBinImport ) ; imp -> name = r_str_newf ( ""%s.method.%s%s"" , class_name , method_name , signature ) ; imp -> type = r_str_const ( ""FUNC"" ) ; imp -> bind = r_str_const ( ""NONE"" ) ; imp -> ordinal = import_count ++ ; r_list_append ( bin -> imports_list , imp ) ; RBinSymbol * sym = R_NEW0 ( RBinSymbol ) ; sym -> name = r_str_newf ( ""imp.%s"" , imp -> name ) ; sym -> type = r_str_const ( ""FUNC"" ) ; sym -> bind = r_str_const ( ""NONE"" ) ; sym -> paddr = sym -> vaddr = bin -> b -> base + bin -> header . method_offset + ( sizeof ( struct dex_method_t ) * i ) ; sym -> ordinal = sym_count ++ ; r_list_append ( bin -> methods_list , sym ) ; sdb_num_set ( mdb , sdb_fmt ( 0 , ""method.%d"" , i ) , sym -> paddr , 0 ) ; } free ( method_name ) ; free ( signature ) ; free ( class_name ) ; } free ( methods ) ; } return true ; }
","<S2SV_ModStart> header . types_size <S2SV_ModEnd> ) { continue
",radare@radare2/ead645853a63bf83d8386702cad0cf23b31d7eeb,CVE-2017-6387,https://github.com/radare/radare2/commit/ead645853a63bf83d8386702cad0cf23b31d7eeb,2017-03-02T01:59Z,1391,"<S2SV_ModStart> header. class_size == 0 || bin -> header. class_size <S2SV_ModStart> header. strings_size == 0 ) { eprintf ( ""Invalid <S2SV_blank> strings <S2SV_blank> size\\n"" ) ; return false ; } if ( bin -> header. methods_size > UT64_MAX || <S2SV_ModStart> header. methods_size == 0 ) { eprintf ( ""Invalid <S2SV_blank> methods <S2SV_blank> size\\n"" ) ; return false ; } if ( bin -> header. imports_size == 0 ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; r_list_free ( bin -> classes_list ) ; return false ; } <S2SV_ModStart> header. strings_size == 0 ) { eprintf ( ""Invalid <S2SV_blank> strings <S2SV_blank> size\\n"" ) ; return false ; } if ( bin -> header. classes_size == 0 ) { eprintf ( ""Invalid <S2SV_blank> classes <S2SV_blank> size\\n"" ) ; return false ; }",0
1394,CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { UINT16 length ; WLog_DBG ( TAG , ""RDP_NEG_RSP"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) { WLog_ERR ( TAG , ""Invalid<S2SV_blank>RDP_NEG_RSP"" ) ; nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> return ; <S2SV_EndBug> } Stream_Read_UINT8 ( s , nego -> flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> SelectedProtocol ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_response ( rdpNego <S2SV_ModStart> NEGO_STATE_FAIL ; return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1394,<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = NEGO_STATE_FAIL ; return ;,0
1398,CWE-125,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z,1398,<S2SV_ModStart> < sizeof ( struct pgstate <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ) ; } ND_TCHECK_32BITS ( & prep -> pp_n ) ;,0
1401,CWE-125,"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z,1401,"<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ) == COMMA || TYPE ( CHILD ( n, j ) ) == TYPE_COMMENT ) <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD",0
1412,CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z,1412,<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD,0
1430,CWE-125,"CWE-125 static stmt_ty <S2SV_StartBug> ast_for_funcdef_impl ( struct compiling * c , const node * n , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * decorator_seq , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>functions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_StartBug> type_comment , LINENO ( n ) , <S2SV_EndBug> n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> const node * n0 <S2SV_ModEnd> , asdl_seq * <S2SV_ModStart> * decorator_seq , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1430,"<S2SV_ModStart> const node * n0, asdl_seq * decorator_seq, bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async? CHILD ( n0, 1 ) : n0 ; <S2SV_ModStart>, LINENO ( n0 ), n0 <S2SV_ModEnd> -> n_col_offset, <S2SV_ModStart>, LINENO ( n0 ), n0 <S2SV_ModEnd> -> n_col_offset, <S2SV_ModStart>, type_comment, LINENO ( n0 ), n0 <S2SV_ModEnd> -> n_col_offset,",0
1435,CWE-125,"CWE-125 struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XDIRINFO"" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_size -- ; xmi_tmpdata -= 13 ; xmi_data += xmi_tmpdata ; xmi_size -= xmi_tmpdata ; if ( memcmp ( xmi_data , ""CAT<S2SV_blank>"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_catlen = * xmi_data ++ << 24 ; xmi_catlen |= * xmi_data ++ << 16 ; xmi_catlen |= * xmi_data ++ << 8 ; xmi_catlen |= * xmi_data ++ ; xmi_size -= 4 ; UNUSED ( xmi_catlen ) ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( xmi_mdi , xmi_divisions ) ; _WM_midi_setup_tempo ( xmi_mdi , xmi_tempo ) ; xmi_samples_per_delta_f = _WM_GetSamplesPerTick ( xmi_divisions , xmi_tempo ) ; xmi_notelen = malloc ( sizeof ( uint32_t ) * 16 * 128 ) ; memset ( xmi_notelen , 0 , ( sizeof ( uint32_t ) * 16 * 128 ) ) ; for ( i = 0 ; i < xmi_formcnt ; i ++ ) { if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen = * xmi_data ++ << 24 ; xmi_subformlen |= * xmi_data ++ << 16 ; xmi_subformlen |= * xmi_data ++ << 8 ; xmi_subformlen |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen -= 4 ; do { if ( ! memcmp ( xmi_data , ""TIMB"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""RBRN"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""EVNT"" , 4 ) ) { xmi_data += 4 ; xmi_evnt_cnt ++ ; xmi_evntlen = * xmi_data ++ << 24 ; xmi_evntlen |= * xmi_data ++ << 16 ; xmi_evntlen |= * xmi_data ++ << 8 ; xmi_evntlen |= * xmi_data ++ ; xmi_size -= 8 ; xmi_subformlen -= 8 ; do { if ( * xmi_data < 0x80 ) { xmi_delta = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; do { if ( ( xmi_lowestdelta != 0 ) && ( xmi_lowestdelta <= xmi_delta ) ) { xmi_tmpdata = xmi_lowestdelta ; } else { xmi_tmpdata = xmi_delta ; } xmi_sample_count_f = ( ( ( float ) xmi_tmpdata * xmi_samples_per_delta_f ) + xmi_sample_remainder ) ; xmi_sample_count = ( uint32_t ) xmi_sample_count_f ; xmi_sample_remainder = xmi_sample_count_f - ( float ) xmi_sample_count ; xmi_mdi -> events [ xmi_mdi -> event_count - 1 ] . samples_to_next += xmi_sample_count ; xmi_mdi -> extra_info . approx_total_samples += xmi_sample_count ; xmi_lowestdelta = 0 ; for ( j = 0 ; j < ( 16 * 128 ) ; j ++ ) { if ( xmi_notelen [ j ] == 0 ) continue ; xmi_notelen [ j ] -= xmi_tmpdata ; if ( xmi_notelen [ j ] == 0 ) { xmi_ch = j / 128 ; xmi_note = j - ( xmi_ch * 128 ) ; _WM_midi_setup_noteoff ( xmi_mdi , xmi_ch , xmi_note , 0 ) ; } else { if ( ( xmi_lowestdelta == 0 ) || ( xmi_lowestdelta > xmi_notelen [ j ] ) ) { xmi_lowestdelta = xmi_notelen [ j ] ; } } } xmi_delta -= xmi_tmpdata ; } while ( xmi_delta ) ; } else { if ( ( xmi_data [ 0 ] == 0xff ) && ( xmi_data [ 1 ] == 0x51 ) && ( xmi_data [ 2 ] == 0x03 ) ) { setup_ret = 6 ; goto _XMI_Next_Event ; } <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <S2SV_EndBug> goto _xmi_end ; } if ( ( * xmi_data & 0xf0 ) == 0x90 ) { xmi_ch = * xmi_data & 0x0f ; xmi_note = xmi_data [ 1 ] ; xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; xmi_tmpdata = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; xmi_notelen [ 128 * xmi_ch + xmi_note ] = xmi_tmpdata ; if ( ( xmi_tmpdata > 0 ) && ( ( xmi_lowestdelta == 0 ) || ( xmi_tmpdata < xmi_lowestdelta ) ) ) { xmi_lowestdelta = xmi_tmpdata ; } } else { _XMI_Next_Event : xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; } } } while ( xmi_evntlen ) ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } } while ( xmi_subformlen ) ; } if ( ( xmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _xmi_end ; } xmi_mdi -> extra_info . current_sample = 0 ; xmi_mdi -> current_event = & xmi_mdi -> events [ 0 ] ; xmi_mdi -> samples_to_mix = 0 ; xmi_mdi -> note = NULL ; if ( xmi_evnt_cnt > 1 ) { xmi_mdi -> is_type2 = 1 ; } _WM_ResetToStart ( xmi_mdi ) ; _xmi_end : if ( xmi_notelen != NULL ) free ( xmi_notelen ) ; if ( xmi_mdi -> reverb ) return ( xmi_mdi ) ; _WM_freeMDI ( xmi_mdi ) ; return NULL ; }
","<S2SV_ModStart> , xmi_data , xmi_size ,
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z,1435,"<S2SV_ModStart> += 4 ; if ( xmi_size < 4 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, ""xmi"" ) ; return NULL ; } <S2SV_ModStart> += 4 ; if ( xmi_size < 4 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, ""xmi"" ) ; return NULL ; } <S2SV_ModStart> += 4 ; if ( xmi_size < 4 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, ""xmi"" ) ; return NULL ; } <S2SV_ModStart> += 4 ; if ( xmi_size < 4 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, ""xmi"" ) ; return NULL ; } <S2SV_ModStart> += 4 ; if ( xmi_size < 4 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, ""xmi"" ) ; return NULL ; } <S2SV_ModStart> += 4",0
1445,CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
",ImageMagick@ImageMagick/b173a352397877775c51c9a0e9d59eb6ce24c455,CVE-2016-10070,https://github.com/ImageMagick/ImageMagick/commit/b173a352397877775c51c9a0e9d59eb6ce24c455,2017-03-03T18:59Z,1445,"<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;",0
1451,CWE-125,"CWE-125 static int update_prepare_order_info ( rdpContext * context , ORDER_INFO * orderInfo , UINT32 orderType ) { int length = 1 ; orderInfo -> fieldFlags = 0 ; orderInfo -> orderType = orderType ; orderInfo -> controlFlags = ORDER_STANDARD ; orderInfo -> controlFlags |= ORDER_TYPE_CHANGE ; length += 1 ; <S2SV_StartBug> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; <S2SV_EndBug> length += update_prepare_bounds ( context , orderInfo ) ; return length ; }
","<S2SV_ModStart> ; length += get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ; length +=
",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z,1451,"<S2SV_ModStart> ; length += <S2SV_ModEnd> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo <S2SV_ModStart> orderInfo -> orderType ] ; length += update_prepare_bounds ( context, orderInfo )",0
1453,CWE-125,"CWE-125 static int match_at ( regex_t * reg , const UChar * str , const UChar * end , # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE const UChar * right_range , # endif const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) { static UChar FinishCode [ ] = { OP_FINISH } ; int i , n , num_mem , best_len , pop_level ; LengthType tlen , tlen2 ; MemNumType mem ; RelAddrType addr ; UChar * s , * q , * sbegin ; int is_alloca ; char * alloc_base ; OnigStackType * stk_base , * stk , * stk_end ; OnigStackType * stkp ; OnigStackIndex si ; OnigStackIndex * repeat_stk ; OnigStackIndex * mem_start_stk , * mem_end_stk ; # ifdef USE_COMBINATION_EXPLOSION_CHECK int scv ; unsigned char * state_check_buff = msa -> state_check_buff ; int num_comb_exp_check = reg -> num_comb_exp_check ; # endif UChar * p = reg -> p ; OnigOptionType option = reg -> options ; OnigEncoding encode = reg -> enc ; OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; pop_level = reg -> stack_pop_level ; num_mem = reg -> num_mem ; STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; UPDATE_FOR_STACK_REALLOC ; for ( i = 1 ; i <= num_mem ; i ++ ) { mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; } # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""match_at:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>start:<S2SV_blank>%d,<S2SV_blank>sprev:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; fprintf ( stderr , ""size:<S2SV_blank>%d,<S2SV_blank>start<S2SV_blank>offset:<S2SV_blank>%d\\n"" , ( int ) ( end - str ) , ( int ) ( sstart - str ) ) ; # endif STACK_PUSH_ENSURED ( STK_ALT , FinishCode ) ; best_len = ONIG_MISMATCH ; s = ( UChar * ) sstart ; while ( 1 ) { # ifdef ONIG_DEBUG_MATCH { UChar * q , * bp , buf [ 50 ] ; int len ; fprintf ( stderr , ""%4d><S2SV_blank>\\"""" , ( int ) ( s - str ) ) ; bp = buf ; for ( i = 0 , q = s ; i < 7 && q < end ; i ++ ) { len = enclen ( encode , q ) ; while ( len -- > 0 ) * bp ++ = * q ++ ; } if ( q < end ) { xmemcpy ( bp , ""...\\"""" , 4 ) ; bp += 4 ; } else { xmemcpy ( bp , ""\\"""" , 1 ) ; bp += 1 ; } * bp = 0 ; fputs ( ( char * ) buf , stderr ) ; for ( i = 0 ; i < 20 - ( bp - buf ) ; i ++ ) fputc ( '<S2SV_blank>' , stderr ) ; onig_print_compiled_byte_code ( stderr , p , NULL , encode ) ; fprintf ( stderr , ""\\n"" ) ; } # endif sbegin = s ; switch ( * p ++ ) { case OP_END : MOP_IN ( OP_END ) ; n = s - sstart ; if ( n > best_len ) { OnigRegion * region ; # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE if ( IS_FIND_LONGEST ( option ) ) { if ( n > msa -> best_len ) { msa -> best_len = n ; msa -> best_s = ( UChar * ) sstart ; } else goto end_best_len ; } # endif best_len = n ; region = msa -> region ; if ( region ) { # ifdef USE_POSIX_API_REGION_OPTION if ( IS_POSIX_REGION ( msa -> options ) ) { posix_regmatch_t * rmt = ( posix_regmatch_t * ) region ; rmt [ 0 ] . rm_so = sstart - str ; rmt [ 0 ] . rm_eo = s - str ; for ( i = 1 ; i <= num_mem ; i ++ ) { if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) rmt [ i ] . rm_so = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; else rmt [ i ] . rm_so = ( UChar * ) ( ( void * ) ( mem_start_stk [ i ] ) ) - str ; rmt [ i ] . rm_eo = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; } else { rmt [ i ] . rm_so = rmt [ i ] . rm_eo = ONIG_REGION_NOTPOS ; } } } else { # endif region -> beg [ 0 ] = sstart - str ; region -> end [ 0 ] = s - str ; for ( i = 1 ; i <= num_mem ; i ++ ) { if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) region -> beg [ i ] = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; else region -> beg [ i ] = ( UChar * ) ( ( void * ) mem_start_stk [ i ] ) - str ; region -> end [ i ] = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; } else { region -> beg [ i ] = region -> end [ i ] = ONIG_REGION_NOTPOS ; } } # ifdef USE_CAPTURE_HISTORY if ( reg -> capture_history != 0 ) { int r ; OnigCaptureTreeNode * node ; if ( IS_NULL ( region -> history_root ) ) { region -> history_root = node = history_node_new ( ) ; CHECK_NULL_RETURN_MEMERR ( node ) ; } else { node = region -> history_root ; history_tree_clear ( node ) ; } node -> group = 0 ; node -> beg = sstart - str ; node -> end = s - str ; stkp = stk_base ; r = make_capture_history_tree ( region -> history_root , & stkp , stk , ( UChar * ) str , reg ) ; if ( r < 0 ) { best_len = r ; goto finish ; } } # endif # ifdef USE_POSIX_API_REGION_OPTION } # endif } } # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE end_best_len : # endif MOP_OUT ; if ( IS_FIND_CONDITION ( option ) ) { if ( IS_FIND_NOT_EMPTY ( option ) && s == sstart ) { best_len = ONIG_MISMATCH ; goto fail ; } if ( IS_FIND_LONGEST ( option ) && DATA_ENSURE_CHECK1 ) { goto fail ; } } goto finish ; break ; case OP_EXACT1 : MOP_IN ( OP_EXACT1 ) ; <S2SV_StartBug> # if 0 <S2SV_EndBug> DATA_ENSURE ( 1 ) ; if ( * p != * s ) goto fail ; <S2SV_StartBug> p ++ ; s ++ ; <S2SV_EndBug> # endif if ( * p != * s ++ ) goto fail ; DATA_ENSURE ( 0 ) ; p ++ ; MOP_OUT ; break ; case OP_EXACT1_IC : MOP_IN ( OP_EXACT1_IC ) ; { int len ; UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; DATA_ENSURE ( 1 ) ; len = ONIGENC_MBC_CASE_FOLD ( encode , case_fold_flag , & s , end , lowbuf ) ; DATA_ENSURE ( 0 ) ; q = lowbuf ; while ( len -- > 0 ) { if ( * p != * q ) { goto fail ; } p ++ ; q ++ ; } } MOP_OUT ; break ; case OP_EXACT2 : MOP_IN ( OP_EXACT2 ) ; DATA_ENSURE ( 2 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT3 : MOP_IN ( OP_EXACT3 ) ; DATA_ENSURE ( 3 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT4 : MOP_IN ( OP_EXACT4 ) ; DATA_ENSURE ( 4 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACT5 : MOP_IN ( OP_EXACT5 ) ; DATA_ENSURE ( 5 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; sprev = s ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTN : MOP_IN ( OP_EXACTN ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen ) ; while ( tlen -- > 0 ) { if ( * p ++ != * s ++ ) goto fail ; } sprev = s - 1 ; MOP_OUT ; continue ; break ; case OP_EXACTN_IC : MOP_IN ( OP_EXACTN_IC ) ; { int len ; UChar * q , * endp , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; GET_LENGTH_INC ( tlen , p ) ; endp = p + tlen ; while ( p < endp ) { sprev = s ; DATA_ENSURE ( 1 ) ; len = ONIGENC_MBC_CASE_FOLD ( encode , case_fold_flag , & s , end , lowbuf ) ; DATA_ENSURE ( 0 ) ; q = lowbuf ; while ( len -- > 0 ) { if ( * p != * q ) goto fail ; p ++ ; q ++ ; } } } MOP_OUT ; continue ; break ; case OP_EXACTMB2N1 : MOP_IN ( OP_EXACTMB2N1 ) ; DATA_ENSURE ( 2 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; break ; case OP_EXACTMB2N2 : MOP_IN ( OP_EXACTMB2N2 ) ; DATA_ENSURE ( 4 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; sprev = s ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTMB2N3 : MOP_IN ( OP_EXACTMB2N3 ) ; DATA_ENSURE ( 6 ) ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; sprev = s ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; MOP_OUT ; continue ; break ; case OP_EXACTMB2N : MOP_IN ( OP_EXACTMB2N ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen * 2 ) ; while ( tlen -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - 2 ; MOP_OUT ; continue ; break ; case OP_EXACTMB3N : MOP_IN ( OP_EXACTMB3N ) ; GET_LENGTH_INC ( tlen , p ) ; DATA_ENSURE ( tlen * 3 ) ; while ( tlen -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - 3 ; MOP_OUT ; continue ; break ; case OP_EXACTMBN : MOP_IN ( OP_EXACTMBN ) ; GET_LENGTH_INC ( tlen , p ) ; GET_LENGTH_INC ( tlen2 , p ) ; tlen2 *= tlen ; DATA_ENSURE ( tlen2 ) ; while ( tlen2 -- > 0 ) { if ( * p != * s ) goto fail ; p ++ ; s ++ ; } sprev = s - tlen ; MOP_OUT ; continue ; break ; case OP_CCLASS : MOP_IN ( OP_CCLASS ) ; DATA_ENSURE ( 1 ) ; if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; p += SIZE_BITSET ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_CCLASS_MB : MOP_IN ( OP_CCLASS_MB ) ; if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) goto fail ; cclass_mb : GET_LENGTH_INC ( tlen , p ) ; { OnigCodePoint code ; UChar * ss ; int mb_len ; DATA_ENSURE ( 1 ) ; mb_len = enclen ( encode , s ) ; DATA_ENSURE ( mb_len ) ; ss = s ; s += mb_len ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; # ifdef PLATFORM_UNALIGNED_WORD_ACCESS if ( ! onig_is_in_code_range ( p , code ) ) goto fail ; # else q = p ; ALIGNMENT_RIGHT ( q ) ; if ( ! onig_is_in_code_range ( q , code ) ) goto fail ; # endif } p += tlen ; MOP_OUT ; break ; case OP_CCLASS_MIX : MOP_IN ( OP_CCLASS_MIX ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { p += SIZE_BITSET ; goto cclass_mb ; } else { if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; p += SIZE_BITSET ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; s ++ ; } MOP_OUT ; break ; case OP_CCLASS_NOT : MOP_IN ( OP_CCLASS_NOT ) ; DATA_ENSURE ( 1 ) ; if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; p += SIZE_BITSET ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_CCLASS_MB_NOT : MOP_IN ( OP_CCLASS_MB_NOT ) ; DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) { s ++ ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; goto cc_mb_not_success ; } cclass_mb_not : GET_LENGTH_INC ( tlen , p ) ; { OnigCodePoint code ; UChar * ss ; int mb_len = enclen ( encode , s ) ; if ( ! DATA_ENSURE_CHECK ( mb_len ) ) { DATA_ENSURE ( 1 ) ; s = ( UChar * ) end ; p += tlen ; goto cc_mb_not_success ; } ss = s ; s += mb_len ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; # ifdef PLATFORM_UNALIGNED_WORD_ACCESS if ( onig_is_in_code_range ( p , code ) ) goto fail ; # else q = p ; ALIGNMENT_RIGHT ( q ) ; if ( onig_is_in_code_range ( q , code ) ) goto fail ; # endif } p += tlen ; cc_mb_not_success : MOP_OUT ; break ; case OP_CCLASS_MIX_NOT : MOP_IN ( OP_CCLASS_MIX_NOT ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { p += SIZE_BITSET ; goto cclass_mb_not ; } else { if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; p += SIZE_BITSET ; GET_LENGTH_INC ( tlen , p ) ; p += tlen ; s ++ ; } MOP_OUT ; break ; case OP_CCLASS_NODE : MOP_IN ( OP_CCLASS_NODE ) ; { OnigCodePoint code ; void * node ; int mb_len ; UChar * ss ; DATA_ENSURE ( 1 ) ; GET_POINTER_INC ( node , p ) ; mb_len = enclen ( encode , s ) ; ss = s ; s += mb_len ; DATA_ENSURE ( 0 ) ; code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; if ( onig_is_code_in_cc_len ( mb_len , code , node ) == 0 ) goto fail ; } MOP_OUT ; break ; case OP_ANYCHAR : MOP_IN ( OP_ANYCHAR ) ; DATA_ENSURE ( 1 ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; s += n ; MOP_OUT ; break ; case OP_ANYCHAR_ML : MOP_IN ( OP_ANYCHAR_ML ) ; DATA_ENSURE ( 1 ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; s += n ; MOP_OUT ; break ; case OP_ANYCHAR_STAR : MOP_IN ( OP_ANYCHAR_STAR ) ; while ( DATA_ENSURE_CHECK1 ) { STACK_PUSH_ALT ( p , s , sprev ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } MOP_OUT ; break ; case OP_ANYCHAR_ML_STAR : MOP_IN ( OP_ANYCHAR_ML_STAR ) ; while ( DATA_ENSURE_CHECK1 ) { STACK_PUSH_ALT ( p , s , sprev ) ; n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } MOP_OUT ; break ; case OP_ANYCHAR_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_STAR_PEEK_NEXT ) ; while ( DATA_ENSURE_CHECK1 ) { if ( * p == * s ) { STACK_PUSH_ALT ( p + 1 , s , sprev ) ; } n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } p ++ ; MOP_OUT ; break ; case OP_ANYCHAR_ML_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_ML_STAR_PEEK_NEXT ) ; while ( DATA_ENSURE_CHECK1 ) { if ( * p == * s ) { STACK_PUSH_ALT ( p + 1 , s , sprev ) ; } n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } p ++ ; MOP_OUT ; break ; # ifdef USE_COMBINATION_EXPLOSION_CHECK case OP_STATE_CHECK_ANYCHAR_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_STAR ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; while ( DATA_ENSURE_CHECK1 ) { STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; n = enclen ( encode , s ) ; DATA_ENSURE ( n ) ; if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; sprev = s ; s += n ; } MOP_OUT ; break ; case OP_STATE_CHECK_ANYCHAR_ML_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_ML_STAR ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; while ( DATA_ENSURE_CHECK1 ) { STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; n = enclen ( encode , s ) ; if ( n > 1 ) { DATA_ENSURE ( n ) ; sprev = s ; s += n ; } else { sprev = s ; s ++ ; } } MOP_OUT ; break ; # endif case OP_WORD : MOP_IN ( OP_WORD ) ; DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_NOT_WORD : MOP_IN ( OP_NOT_WORD ) ; DATA_ENSURE ( 1 ) ; if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; s += enclen ( encode , s ) ; MOP_OUT ; break ; case OP_WORD_BOUND : MOP_IN ( OP_WORD_BOUND ) ; if ( ON_STR_BEGIN ( s ) ) { DATA_ENSURE ( 1 ) ; if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; } else if ( ON_STR_END ( s ) ) { if ( ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } else { if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) == ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } MOP_OUT ; continue ; break ; case OP_NOT_WORD_BOUND : MOP_IN ( OP_NOT_WORD_BOUND ) ; if ( ON_STR_BEGIN ( s ) ) { if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) goto fail ; } else if ( ON_STR_END ( s ) ) { if ( ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } else { if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) != ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) goto fail ; } MOP_OUT ; continue ; break ; # ifdef USE_WORD_BEGIN_END case OP_WORD_BEGIN : MOP_IN ( OP_WORD_BEGIN ) ; if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { if ( ON_STR_BEGIN ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { MOP_OUT ; continue ; } } goto fail ; break ; case OP_WORD_END : MOP_IN ( OP_WORD_END ) ; if ( ! ON_STR_BEGIN ( s ) && ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { if ( ON_STR_END ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { MOP_OUT ; continue ; } } goto fail ; break ; # endif case OP_BEGIN_BUF : MOP_IN ( OP_BEGIN_BUF ) ; if ( ! ON_STR_BEGIN ( s ) ) goto fail ; MOP_OUT ; continue ; break ; case OP_END_BUF : MOP_IN ( OP_END_BUF ) ; if ( ! ON_STR_END ( s ) ) goto fail ; MOP_OUT ; continue ; break ; case OP_BEGIN_LINE : MOP_IN ( OP_BEGIN_LINE ) ; if ( ON_STR_BEGIN ( s ) ) { if ( IS_NOTBOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) && ! ON_STR_END ( s ) ) { MOP_OUT ; continue ; } goto fail ; break ; case OP_END_LINE : MOP_IN ( OP_END_LINE ) ; if ( ON_STR_END ( s ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { # endif if ( IS_NOTEOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE } # endif } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) { MOP_OUT ; continue ; } # ifdef USE_CRNL_AS_LINE_TERMINATOR else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { MOP_OUT ; continue ; } # endif goto fail ; break ; case OP_SEMI_END_BUF : MOP_IN ( OP_SEMI_END_BUF ) ; if ( ON_STR_END ( s ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { # endif if ( IS_NOTEOL ( msa -> options ) ) goto fail ; MOP_OUT ; continue ; # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE } # endif } else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) && ON_STR_END ( s + enclen ( encode , s ) ) ) { MOP_OUT ; continue ; } # ifdef USE_CRNL_AS_LINE_TERMINATOR else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { UChar * ss = s + enclen ( encode , s ) ; ss += enclen ( encode , ss ) ; if ( ON_STR_END ( ss ) ) { MOP_OUT ; continue ; } } # endif goto fail ; break ; case OP_BEGIN_POSITION : MOP_IN ( OP_BEGIN_POSITION ) ; if ( s != msa -> start ) goto fail ; MOP_OUT ; continue ; break ; case OP_MEMORY_START_PUSH : MOP_IN ( OP_MEMORY_START_PUSH ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_MEM_START ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_START : MOP_IN ( OP_MEMORY_START ) ; GET_MEMNUM_INC ( mem , p ) ; mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END_PUSH : MOP_IN ( OP_MEMORY_END_PUSH ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_MEM_END ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END : MOP_IN ( OP_MEMORY_END ) ; GET_MEMNUM_INC ( mem , p ) ; mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; MOP_OUT ; continue ; break ; # ifdef USE_SUBEXP_CALL case OP_MEMORY_END_PUSH_REC : MOP_IN ( OP_MEMORY_END_PUSH_REC ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_MEM_START ( mem , stkp ) ; STACK_PUSH_MEM_END ( mem , s ) ; mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; MOP_OUT ; continue ; break ; case OP_MEMORY_END_REC : MOP_IN ( OP_MEMORY_END_REC ) ; GET_MEMNUM_INC ( mem , p ) ; mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; STACK_GET_MEM_START ( mem , stkp ) ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; else mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) stkp -> u . mem . pstr ) ; STACK_PUSH_MEM_END_MARK ( mem ) ; MOP_OUT ; continue ; break ; # endif case OP_BACKREF1 : MOP_IN ( OP_BACKREF1 ) ; mem = 1 ; goto backref ; break ; case OP_BACKREF2 : MOP_IN ( OP_BACKREF2 ) ; mem = 2 ; goto backref ; break ; case OP_BACKREFN : MOP_IN ( OP_BACKREFN ) ; GET_MEMNUM_INC ( mem , p ) ; backref : { int len ; UChar * pstart , * pend ; if ( mem > num_mem ) goto fail ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; STRING_CMP ( pstart , s , n ) ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; MOP_OUT ; continue ; } break ; case OP_BACKREFN_IC : MOP_IN ( OP_BACKREFN_IC ) ; GET_MEMNUM_INC ( mem , p ) ; { int len ; UChar * pstart , * pend ; if ( mem > num_mem ) goto fail ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; STRING_CMP_IC ( case_fold_flag , pstart , & s , n ) ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; MOP_OUT ; continue ; } break ; case OP_BACKREF_MULTI : MOP_IN ( OP_BACKREF_MULTI ) ; { int len , is_fail ; UChar * pstart , * pend , * swork ; GET_LENGTH_INC ( tlen , p ) ; for ( i = 0 ; i < tlen ; i ++ ) { GET_MEMNUM_INC ( mem , p ) ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; swork = s ; STRING_CMP_VALUE ( pstart , swork , n , is_fail ) ; if ( is_fail ) continue ; s = swork ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; break ; } if ( i == tlen ) goto fail ; MOP_OUT ; continue ; } break ; case OP_BACKREF_MULTI_IC : MOP_IN ( OP_BACKREF_MULTI_IC ) ; { int len , is_fail ; UChar * pstart , * pend , * swork ; GET_LENGTH_INC ( tlen , p ) ; for ( i = 0 ; i < tlen ; i ++ ) { GET_MEMNUM_INC ( mem , p ) ; if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; else pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; n = pend - pstart ; DATA_ENSURE ( n ) ; sprev = s ; swork = s ; STRING_CMP_VALUE_IC ( case_fold_flag , pstart , & swork , n , is_fail ) ; if ( is_fail ) continue ; s = swork ; while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; break ; } if ( i == tlen ) goto fail ; MOP_OUT ; continue ; } break ; # ifdef USE_BACKREF_WITH_LEVEL case OP_BACKREF_WITH_LEVEL : { int len ; OnigOptionType ic ; LengthType level ; GET_OPTION_INC ( ic , p ) ; GET_LENGTH_INC ( level , p ) ; GET_LENGTH_INC ( tlen , p ) ; sprev = s ; if ( backref_match_at_nested_level ( reg , stk , stk_base , ic , case_fold_flag , ( int ) level , ( int ) tlen , p , & s , end ) ) { while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) sprev += len ; p += ( SIZE_MEMNUM * tlen ) ; } else goto fail ; MOP_OUT ; continue ; } break ; # endif # if 0 case OP_SET_OPTION_PUSH : MOP_IN ( OP_SET_OPTION_PUSH ) ; GET_OPTION_INC ( option , p ) ; STACK_PUSH_ALT ( p , s , sprev ) ; p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL ; MOP_OUT ; continue ; break ; case OP_SET_OPTION : MOP_IN ( OP_SET_OPTION ) ; GET_OPTION_INC ( option , p ) ; MOP_OUT ; continue ; break ; # endif case OP_NULL_CHECK_START : MOP_IN ( OP_NULL_CHECK_START ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_PUSH_NULL_CHECK_START ( mem , s ) ; MOP_OUT ; continue ; break ; case OP_NULL_CHECK_END : MOP_IN ( OP_NULL_CHECK_END ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; STACK_NULL_CHECK ( isnull , mem , s ) ; if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif null_check_found : switch ( * p ++ ) { case OP_JUMP : case OP_PUSH : p += SIZE_RELADDR ; break ; case OP_REPEAT_INC : case OP_REPEAT_INC_NG : case OP_REPEAT_INC_SG : case OP_REPEAT_INC_NG_SG : p += SIZE_MEMNUM ; break ; default : goto unexpected_bytecode_error ; break ; } } } MOP_OUT ; continue ; break ; # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT case OP_NULL_CHECK_END_MEMST : MOP_IN ( OP_NULL_CHECK_END_MEMST ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; STACK_NULL_CHECK_MEMST ( isnull , mem , s , reg ) ; if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END_MEMST:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif if ( isnull == - 1 ) goto fail ; goto null_check_found ; } } MOP_OUT ; continue ; break ; # endif # ifdef USE_SUBEXP_CALL case OP_NULL_CHECK_END_MEMST_PUSH : MOP_IN ( OP_NULL_CHECK_END_MEMST_PUSH ) ; { int isnull ; GET_MEMNUM_INC ( mem , p ) ; # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT STACK_NULL_CHECK_MEMST_REC ( isnull , mem , s , reg ) ; # else STACK_NULL_CHECK_REC ( isnull , mem , s ) ; # endif if ( isnull ) { # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""NULL_CHECK_END_MEMST_PUSH:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n"" , ( int ) mem , ( int ) s ) ; # endif if ( isnull == - 1 ) goto fail ; goto null_check_found ; } else { STACK_PUSH_NULL_CHECK_END ( mem ) ; } } MOP_OUT ; continue ; break ; # endif case OP_JUMP : MOP_IN ( OP_JUMP ) ; GET_RELADDR_INC ( addr , p ) ; p += addr ; MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_PUSH : MOP_IN ( OP_PUSH ) ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; break ; # ifdef USE_COMBINATION_EXPLOSION_CHECK case OP_STATE_CHECK_PUSH : MOP_IN ( OP_STATE_CHECK_PUSH ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; MOP_OUT ; continue ; break ; case OP_STATE_CHECK_PUSH_OR_JUMP : MOP_IN ( OP_STATE_CHECK_PUSH_OR_JUMP ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) { p += addr ; } else { STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; } MOP_OUT ; continue ; break ; case OP_STATE_CHECK : MOP_IN ( OP_STATE_CHECK ) ; GET_STATE_CHECK_NUM_INC ( mem , p ) ; STATE_CHECK_VAL ( scv , mem ) ; if ( scv ) goto fail ; STACK_PUSH_STATE_CHECK ( s , mem ) ; MOP_OUT ; continue ; break ; # endif case OP_POP : MOP_IN ( OP_POP ) ; STACK_POP_ONE ; MOP_OUT ; continue ; break ; case OP_PUSH_OR_JUMP_EXACT1 : MOP_IN ( OP_PUSH_OR_JUMP_EXACT1 ) ; GET_RELADDR_INC ( addr , p ) ; if ( * p == * s && DATA_ENSURE_CHECK1 ) { p ++ ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; } p += ( addr + 1 ) ; MOP_OUT ; continue ; break ; case OP_PUSH_IF_PEEK_NEXT : MOP_IN ( OP_PUSH_IF_PEEK_NEXT ) ; GET_RELADDR_INC ( addr , p ) ; if ( * p == * s ) { p ++ ; STACK_PUSH_ALT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; } p ++ ; MOP_OUT ; continue ; break ; case OP_REPEAT : MOP_IN ( OP_REPEAT ) ; { GET_MEMNUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STACK_ENSURE ( 1 ) ; repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; STACK_PUSH_REPEAT ( mem , p ) ; if ( reg -> repeat_range [ mem ] . lower == 0 ) { STACK_PUSH_ALT ( p + addr , s , sprev ) ; } } MOP_OUT ; continue ; break ; case OP_REPEAT_NG : MOP_IN ( OP_REPEAT_NG ) ; { GET_MEMNUM_INC ( mem , p ) ; GET_RELADDR_INC ( addr , p ) ; STACK_ENSURE ( 1 ) ; repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; STACK_PUSH_REPEAT ( mem , p ) ; if ( reg -> repeat_range [ mem ] . lower == 0 ) { STACK_PUSH_ALT ( p , s , sprev ) ; p += addr ; } } MOP_OUT ; continue ; break ; case OP_REPEAT_INC : MOP_IN ( OP_REPEAT_INC ) ; GET_MEMNUM_INC ( mem , p ) ; si = repeat_stk [ mem ] ; stkp = STACK_AT ( si ) ; repeat_inc : stkp -> u . repeat . count ++ ; if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . upper ) { } else if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { STACK_PUSH_ALT ( p , s , sprev ) ; p = STACK_AT ( si ) -> u . repeat . pcode ; } else { p = stkp -> u . repeat . pcode ; } STACK_PUSH_REPEAT_INC ( si ) ; MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_REPEAT_INC_SG : MOP_IN ( OP_REPEAT_INC_SG ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_REPEAT ( mem , stkp ) ; si = GET_STACK_INDEX ( stkp ) ; goto repeat_inc ; break ; case OP_REPEAT_INC_NG : MOP_IN ( OP_REPEAT_INC_NG ) ; GET_MEMNUM_INC ( mem , p ) ; si = repeat_stk [ mem ] ; stkp = STACK_AT ( si ) ; repeat_inc_ng : stkp -> u . repeat . count ++ ; if ( stkp -> u . repeat . count < reg -> repeat_range [ mem ] . upper ) { if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { UChar * pcode = stkp -> u . repeat . pcode ; STACK_PUSH_REPEAT_INC ( si ) ; STACK_PUSH_ALT ( pcode , s , sprev ) ; } else { p = stkp -> u . repeat . pcode ; STACK_PUSH_REPEAT_INC ( si ) ; } } else if ( stkp -> u . repeat . count == reg -> repeat_range [ mem ] . upper ) { STACK_PUSH_REPEAT_INC ( si ) ; } MOP_OUT ; CHECK_INTERRUPT_IN_MATCH_AT ; continue ; break ; case OP_REPEAT_INC_NG_SG : MOP_IN ( OP_REPEAT_INC_NG_SG ) ; GET_MEMNUM_INC ( mem , p ) ; STACK_GET_REPEAT ( mem , stkp ) ; si = GET_STACK_INDEX ( stkp ) ; goto repeat_inc_ng ; break ; case OP_PUSH_POS : MOP_IN ( OP_PUSH_POS ) ; STACK_PUSH_POS ( s , sprev ) ; MOP_OUT ; continue ; break ; case OP_POP_POS : MOP_IN ( OP_POP_POS ) ; { STACK_POS_END ( stkp ) ; s = stkp -> u . state . pstr ; sprev = stkp -> u . state . pstr_prev ; } MOP_OUT ; continue ; break ; case OP_PUSH_POS_NOT : MOP_IN ( OP_PUSH_POS_NOT ) ; GET_RELADDR_INC ( addr , p ) ; STACK_PUSH_POS_NOT ( p + addr , s , sprev ) ; MOP_OUT ; continue ; break ; case OP_FAIL_POS : MOP_IN ( OP_FAIL_POS ) ; STACK_POP_TIL_POS_NOT ; goto fail ; break ; case OP_PUSH_STOP_BT : MOP_IN ( OP_PUSH_STOP_BT ) ; STACK_PUSH_STOP_BT ; MOP_OUT ; continue ; break ; case OP_POP_STOP_BT : MOP_IN ( OP_POP_STOP_BT ) ; STACK_STOP_BT_END ; MOP_OUT ; continue ; break ; case OP_LOOK_BEHIND : MOP_IN ( OP_LOOK_BEHIND ) ; GET_LENGTH_INC ( tlen , p ) ; s = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; if ( IS_NULL ( s ) ) goto fail ; sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; MOP_OUT ; continue ; break ; case OP_PUSH_LOOK_BEHIND_NOT : MOP_IN ( OP_PUSH_LOOK_BEHIND_NOT ) ; GET_RELADDR_INC ( addr , p ) ; GET_LENGTH_INC ( tlen , p ) ; q = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; if ( IS_NULL ( q ) ) { p += addr ; } else { STACK_PUSH_LOOK_BEHIND_NOT ( p + addr , s , sprev ) ; s = q ; sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; } MOP_OUT ; continue ; break ; case OP_FAIL_LOOK_BEHIND_NOT : MOP_IN ( OP_FAIL_LOOK_BEHIND_NOT ) ; STACK_POP_TIL_LOOK_BEHIND_NOT ; goto fail ; break ; # ifdef USE_SUBEXP_CALL case OP_CALL : MOP_IN ( OP_CALL ) ; GET_ABSADDR_INC ( addr , p ) ; STACK_PUSH_CALL_FRAME ( p ) ; p = reg -> p + addr ; MOP_OUT ; continue ; break ; case OP_RETURN : MOP_IN ( OP_RETURN ) ; STACK_RETURN ( p ) ; STACK_PUSH_RETURN ; MOP_OUT ; continue ; break ; # endif case OP_FINISH : goto finish ; break ; fail : MOP_OUT ; case OP_FAIL : MOP_IN ( OP_FAIL ) ; STACK_POP ; p = stk -> u . state . pcode ; s = stk -> u . state . pstr ; sprev = stk -> u . state . pstr_prev ; # ifdef USE_COMBINATION_EXPLOSION_CHECK if ( stk -> u . state . state_check != 0 ) { stk -> type = STK_STATE_CHECK_MARK ; stk ++ ; } # endif MOP_OUT ; continue ; break ; default : goto bytecode_error ; } sprev = sbegin ; } finish : STACK_SAVE ; return best_len ; # ifdef ONIG_DEBUG stack_error : STACK_SAVE ; return ONIGERR_STACK_BUG ; # endif bytecode_error : STACK_SAVE ; return ONIGERR_UNDEFINED_BYTECODE ; unexpected_bytecode_error : STACK_SAVE ; return ONIGERR_UNEXPECTED_BYTECODE ; }
","<S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_ENSURE ( 1 <S2SV_ModStart> ++ ; s <S2SV_ModEnd> ++ ; MOP_OUT
",kkos@oniguruma/690313a061f7a4fa614ec5cc8368b4f2284e059b,CVE-2017-9224,https://github.com/kkos/oniguruma/commit/690313a061f7a4fa614ec5cc8368b4f2284e059b,2017-05-24T15:29Z,1453,"<S2SV_ModStart> OP_INFINITE_REPEAT ; } if ( num_mem > INT_MAX / sizeof ( mem ) ) { fprintf ( stderr, ""warning: <S2SV_blank> num_mem <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)\\n"", num_mem, ( int ) ( INT_MAX / sizeof ( mem ) ) ) ; num_mem = INT_MAX ; } <S2SV_ModStart> += tlen ; if ( num_mem > INT_MAX / sizeof ( mem ) ) { fprintf ( stderr, ""warning: <S2SV_blank> num_mem <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)\\n"", num_mem, ( int ) ( INT_MAX / sizeof ( mem ) ) ) ; if ( num_mem > INT_MAX / sizeof ( mem ) ) { fprintf ( stderr, ""warning: <S2SV_blank> num_mem <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)\\n"", ( int ) ( INT_MAX / sizeof ( mem ) ) ) { fprintf ( stderr, ""warning: <S2SV_blank> num_mem <S2SV_blank> exceeds <S2SV_blank> the <S2SV_blank> maximum <S2SV_blank> allowed <S2SV_blank> (%d)\\n"", num_mem, ( int )",0
1469,CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
",ImageMagick@ImageMagick/1bc1fd0ff8c555841c78829217ac81fa0598255d,CVE-2016-10071,https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d,2017-03-02T21:59Z,1469,"<S2SV_ModStart> ; if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( filepos > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ;",0
1497,CWE-125,"CWE-125 PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1497,<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result,1
1498,CWE-125,"CWE-125 static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ; <S2SV_StartBug> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <S2SV_EndBug> int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\'' && * raw != \'""\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) { <S2SV_StartBug> char * s = """" ; <S2SV_EndBug> char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf , sizeof ( buf ) , ""(unicode<S2SV_blank>error)<S2SV_blank>%s"" , s ) ; ast_error ( n , buf ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n , ""(unicode<S2SV_blank>error)<S2SV_blank>unknown<S2SV_blank>error"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; } # endif return NULL ; } PyArena_AddPyObject ( c -> c_arena , str ) ; return Str ( str , kind , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case NUMBER : { PyObject * pynum = parsenumber ( c , STR ( ch ) ) ; if ( ! pynum ) return NULL ; PyArena_AddPyObject ( c -> c_arena , pynum ) ; return Num ( pynum , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case LPAR : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RPAR ) return Tuple ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( TYPE ( ch ) == yield_expr ) return ast_for_expr ( c , ch ) ; return ast_for_testlist_comp ( c , ch ) ; case LSQB : ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RSQB ) return List ( NULL , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; REQ ( ch , listmaker ) ; if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts = seq_for_testlist ( c , ch ) ; if ( ! elts ) return NULL ; return List ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else return ast_for_listcomp ( c , ch ) ; case LBRACE : { int i , size ; asdl_seq * keys , * values ; ch = CHILD ( n , 1 ) ; if ( TYPE ( ch ) == RBRACE ) { return Dict ( NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( NCH ( ch ) == 1 || TYPE ( CHILD ( ch , 1 ) ) == COMMA ) { asdl_seq * elts ; size = ( NCH ( ch ) + 1 ) / 2 ; elts = asdl_seq_new ( size , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 2 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( elts , i / 2 , expression ) ; } return Set ( elts , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) { return ast_for_setcomp ( c , ch ) ; } else if ( NCH ( ch ) > 3 && TYPE ( CHILD ( ch , 3 ) ) == comp_for ) { return ast_for_dictcomp ( c , ch ) ; } else { size = ( NCH ( ch ) + 1 ) / 4 ; keys = asdl_seq_new ( size , c -> c_arena ) ; if ( ! keys ) return NULL ; values = asdl_seq_new ( size , c -> c_arena ) ; if ( ! values ) return NULL ; for ( i = 0 ; i < NCH ( ch ) ; i += 4 ) { expr_ty expression ; expression = ast_for_expr ( c , CHILD ( ch , i ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( keys , i / 4 , expression ) ; expression = ast_for_expr ( c , CHILD ( ch , i + 2 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( values , i / 4 , expression ) ; } return Dict ( keys , values , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } case BACKQUOTE : { expr_ty expression ; if ( Py_Py3kWarningFlag && ! ast_warn ( c , n , ""backquote<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>3.x;<S2SV_blank>use<S2SV_blank>repr()"" ) ) return NULL ; expression = ast_for_testlist ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; return Repr ( expression , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } default : PyErr_Format ( PyExc_SystemError , ""unhandled<S2SV_blank>atom<S2SV_blank>%d"" , TYPE ( ch ) ) ; return NULL ; } }
","<S2SV_ModStart> , 0 ) <S2SV_ModEnd> ) ; char <S2SV_ModStart> errstr ) { const
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1498,"<S2SV_ModStart>, * s <S2SV_ModEnd> = STR ( <S2SV_ModStart> 0 ) ) <S2SV_ModEnd> ; int quote <S2SV_ModStart> = """" ; PyOS_snprintf ( buf, sizeof ( buf ), ""(unicode <S2SV_blank> error) <S2SV_blank> %s"", _PyUnicode_AsString ( errstr ) ; Py_DECREF ( type ) ; Py_XDECREF ( tback ) ; str = PyArena_AddPyObject ( c -> c_arena, str ) ; return Str ( str, kind, LINENO ( n ), n -> n_col_offset, c -> c_arena ) ; if (! str ) { Py_DECREF ( type ) ; Py_DECREF ( value ) ; } else { ast_error ( n, ""(unicode <S2SV_blank> error) <S2SV_blank> unknown <S2SV_blank> error"" ) ; } Py_DECREF ( tback ) <S2SV_ModEnd> ; return NULL",0
1507,CWE-125,"CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
","<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
",radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z,1507,<S2SV_ModStart> : case 0x16 : case 0x17 : case 0x18 : case 0x19 : case 0x0a : case 0x0b : case 0x0c : case 0x0f : case <S2SV_ModStart> : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x6a : case 0x6b : case 0x6e : case 0x6f : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x8a : case 0x8b : case 0x8f : case 0x9a : case 0x9f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x17 : case 0x18 : case 0x19 : case 0x18 : case 0x19 : case 0x18 : case 0x19 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x8a : case 0x,0
1519,CWE-125,"CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { <S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Hello<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Dead<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Interface-ID<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>Backup<S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>List:"" ) ) ; ap = hellop -> hello_neighbor ; while ( ( const u_char * ) ap < dataend ) { ND_TCHECK ( * ap ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , ipaddr_string ( ndo , ap ) ) ) ; ++ ap ; } } break ; } case OSPF_TYPE_DD : { register const struct dd6 * ddp = ( const struct dd6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( ddp -> db_options ) ; ND_PRINT ( ( ndo , ""\\n\\tOptions<S2SV_blank>[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & ddp -> db_options ) ) ) ) ; ND_TCHECK ( ddp -> db_flags ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>DD<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( ospf6_dd_flag_values , ""none"" , ddp -> db_flags ) ) ) ; ND_TCHECK ( ddp -> db_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>DD-Sequence<S2SV_blank>0x%08x"" , EXTRACT_16BITS ( & ddp -> db_mtu ) , EXTRACT_32BITS ( & ddp -> db_seq ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { lshp = ddp -> db_lshdr ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; } case OSPF_TYPE_LS_REQ : if ( ndo -> ndo_vflag > 1 ) { lsrp = ( const struct lsr6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lsrp < dataend ) { ND_TCHECK ( * lsrp ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s"" , ipaddr_string ( ndo , & lsrp -> ls_router ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lsrp -> ls_type ) , & lsrp -> ls_stateid ) ; ++ lsrp ; } } break ; case OSPF_TYPE_LS_UPDATE : if ( ndo -> ndo_vflag > 1 ) { register const struct lsu6 * lsup = ( const struct lsu6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( lsup -> lsu_count ) ; i = EXTRACT_32BITS ( & lsup -> lsu_count ) ; lsap = lsup -> lsu_lsa ; while ( ( const u_char * ) lsap < dataend && i -- ) { if ( ospf6_print_lsa ( ndo , lsap , dataend ) ) goto trunc ; lsap = ( const struct lsa6 * ) ( ( const u_char * ) lsap + EXTRACT_16BITS ( & lsap -> ls_hdr . ls_length ) ) ; } } break ; case OSPF_TYPE_LS_ACK : if ( ndo -> ndo_vflag > 1 ) { lshp = ( const struct lsa6_hdr * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; default : break ; } return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
",the-tcpdump-group@tcpdump/88b2dac837e81cf56dce05e6e7b5989332c0092d,CVE-2017-13036,https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d,2017-09-14T06:29Z,1519,<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options,1
1523,CWE-125,"CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; <S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
","<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
",espruino@Espruino/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,CVE-2018-11592,https://github.com/espruino/Espruino/commit/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,2018-05-31T16:29Z,1523,<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;,1
1545,CWE-125,"CWE-125 static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! Module_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_EndBug> 1 ) ; <S2SV_StartBug> if ( ! Interactive_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ; <S2SV_EndBug> if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields , <S2SV_StartBug> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! FunctionDef_type ) return 0 ; <S2SV_EndBug> AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , <S2SV_StartBug> AsyncFunctionDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! AsyncFunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ClassDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ; <S2SV_EndBug> if ( ! Return_type ) return 0 ; <S2SV_StartBug> Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; <S2SV_EndBug> if ( ! Delete_type ) return 0 ; <S2SV_StartBug> Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ; <S2SV_EndBug> if ( ! Assign_type ) return 0 ; <S2SV_StartBug> AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; <S2SV_EndBug> if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ; if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ; if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" , stmt_type , With_fields , 2 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , AsyncWith_fields , 2 ) ; if ( ! AsyncWith_type ) return 0 ; Raise_type = make_type ( ""Raise"" , stmt_type , Raise_fields , 2 ) ; if ( ! Raise_type ) return 0 ; Try_type = make_type ( ""Try"" , stmt_type , Try_fields , 4 ) ; if ( ! Try_type ) return 0 ; Assert_type = make_type ( ""Assert"" , stmt_type , Assert_fields , 2 ) ; if ( ! Assert_type ) return 0 ; Import_type = make_type ( ""Import"" , stmt_type , Import_fields , 1 ) ; if ( ! Import_type ) return 0 ; ImportFrom_type = make_type ( ""ImportFrom"" , stmt_type , ImportFrom_fields , 3 ) ; if ( ! ImportFrom_type ) return 0 ; Global_type = make_type ( ""Global"" , stmt_type , Global_fields , 1 ) ; if ( ! Global_type ) return 0 ; Nonlocal_type = make_type ( ""Nonlocal"" , stmt_type , Nonlocal_fields , 1 ) ; if ( ! Nonlocal_type ) return 0 ; Expr_type = make_type ( ""Expr"" , stmt_type , Expr_fields , 1 ) ; if ( ! Expr_type ) return 0 ; Pass_type = make_type ( ""Pass"" , stmt_type , NULL , 0 ) ; if ( ! Pass_type ) return 0 ; Break_type = make_type ( ""Break"" , stmt_type , NULL , 0 ) ; if ( ! Break_type ) return 0 ; Continue_type = make_type ( ""Continue"" , stmt_type , NULL , 0 ) ; if ( ! Continue_type ) return 0 ; expr_type = make_type ( ""expr"" , & AST_type , NULL , 0 ) ; if ( ! expr_type ) return 0 ; if ( ! add_attributes ( expr_type , expr_attributes , 4 ) ) return 0 ; BoolOp_type = make_type ( ""BoolOp"" , expr_type , BoolOp_fields , 2 ) ; if ( ! BoolOp_type ) return 0 ; NamedExpr_type = make_type ( ""NamedExpr"" , expr_type , NamedExpr_fields , 2 ) ; if ( ! NamedExpr_type ) return 0 ; BinOp_type = make_type ( ""BinOp"" , expr_type , BinOp_fields , 3 ) ; if ( ! BinOp_type ) return 0 ; UnaryOp_type = make_type ( ""UnaryOp"" , expr_type , UnaryOp_fields , 2 ) ; if ( ! UnaryOp_type ) return 0 ; Lambda_type = make_type ( ""Lambda"" , expr_type , Lambda_fields , 2 ) ; if ( ! Lambda_type ) return 0 ; IfExp_type = make_type ( ""IfExp"" , expr_type , IfExp_fields , 3 ) ; if ( ! IfExp_type ) return 0 ; Dict_type = make_type ( ""Dict"" , expr_type , Dict_fields , 2 ) ; if ( ! Dict_type ) return 0 ; Set_type = make_type ( ""Set"" , expr_type , Set_fields , 1 ) ; if ( ! Set_type ) return 0 ; ListComp_type = make_type ( ""ListComp"" , expr_type , ListComp_fields , 2 ) ; if ( ! ListComp_type ) return 0 ; SetComp_type = make_type ( ""SetComp"" , expr_type , SetComp_fields , 2 ) ; if ( ! SetComp_type ) return 0 ; DictComp_type = make_type ( ""DictComp"" , expr_type , DictComp_fields , 3 ) ; if ( ! DictComp_type ) return 0 ; GeneratorExp_type = make_type ( ""GeneratorExp"" , expr_type , GeneratorExp_fields , 2 ) ; if ( ! GeneratorExp_type ) return 0 ; Await_type = make_type ( ""Await"" , expr_type , Await_fields , 1 ) ; if ( ! Await_type ) return 0 ; Yield_type = make_type ( ""Yield"" , expr_type , Yield_fields , 1 ) ; if ( ! Yield_type ) return 0 ; YieldFrom_type = make_type ( ""YieldFrom"" , expr_type , YieldFrom_fields , 1 ) ; if ( ! YieldFrom_type ) return 0 ; Compare_type = make_type ( ""Compare"" , expr_type , Compare_fields , 3 ) ; if ( ! Compare_type ) return 0 ; Call_type = make_type ( ""Call"" , expr_type , Call_fields , 3 ) ; if ( ! Call_type ) return 0 ; FormattedValue_type = make_type ( ""FormattedValue"" , expr_type , FormattedValue_fields , 3 ) ; if ( ! FormattedValue_type ) return 0 ; JoinedStr_type = make_type ( ""JoinedStr"" , expr_type , JoinedStr_fields , 1 ) ; if ( ! JoinedStr_type ) return 0 ; Constant_type = make_type ( ""Constant"" , expr_type , Constant_fields , 1 ) ; if ( ! Constant_type ) return 0 ; Attribute_type = make_type ( ""Attribute"" , expr_type , Attribute_fields , 3 ) ; if ( ! Attribute_type ) return 0 ; Subscript_type = make_type ( ""Subscript"" , expr_type , Subscript_fields , 3 ) ; if ( ! Subscript_type ) return 0 ; Starred_type = make_type ( ""Starred"" , expr_type , Starred_fields , 2 ) ; if ( ! Starred_type ) return 0 ; Name_type = make_type ( ""Name"" , expr_type , Name_fields , 2 ) ; if ( ! Name_type ) return 0 ; List_type = make_type ( ""List"" , expr_type , List_fields , 2 ) ; if ( ! List_type ) return 0 ; Tuple_type = make_type ( ""Tuple"" , expr_type , Tuple_fields , 2 ) ; if ( ! Tuple_type ) return 0 ; expr_context_type = make_type ( ""expr_context"" , & AST_type , NULL , 0 ) ; if ( ! expr_context_type ) return 0 ; if ( ! add_attributes ( expr_context_type , NULL , 0 ) ) return 0 ; Load_type = make_type ( ""Load"" , expr_context_type , NULL , 0 ) ; if ( ! Load_type ) return 0 ; Load_singleton = PyType_GenericNew ( Load_type , NULL , NULL ) ; if ( ! Load_singleton ) return 0 ; Store_type = make_type ( ""Store"" , expr_context_type , NULL , 0 ) ; if ( ! Store_type ) return 0 ; Store_singleton = PyType_GenericNew ( Store_type , NULL , NULL ) ; if ( ! Store_singleton ) return 0 ; Del_type = make_type ( ""Del"" , expr_context_type , NULL , 0 ) ; if ( ! Del_type ) return 0 ; Del_singleton = PyType_GenericNew ( Del_type , NULL , NULL ) ; if ( ! Del_singleton ) return 0 ; AugLoad_type = make_type ( ""AugLoad"" , expr_context_type , NULL , 0 ) ; if ( ! AugLoad_type ) return 0 ; AugLoad_singleton = PyType_GenericNew ( AugLoad_type , NULL , NULL ) ; if ( ! AugLoad_singleton ) return 0 ; AugStore_type = make_type ( ""AugStore"" , expr_context_type , NULL , 0 ) ; if ( ! AugStore_type ) return 0 ; AugStore_singleton = PyType_GenericNew ( AugStore_type , NULL , NULL ) ; if ( ! AugStore_singleton ) return 0 ; Param_type = make_type ( ""Param"" , expr_context_type , NULL , 0 ) ; if ( ! Param_type ) return 0 ; Param_singleton = PyType_GenericNew ( Param_type , NULL , NULL ) ; if ( ! Param_singleton ) return 0 ; NamedStore_type = make_type ( ""NamedStore"" , expr_context_type , NULL , 0 ) ; if ( ! NamedStore_type ) return 0 ; NamedStore_singleton = PyType_GenericNew ( NamedStore_type , NULL , NULL ) ; if ( ! NamedStore_singleton ) return 0 ; slice_type = make_type ( ""slice"" , & AST_type , NULL , 0 ) ; if ( ! slice_type ) return 0 ; if ( ! add_attributes ( slice_type , NULL , 0 ) ) return 0 ; Slice_type = make_type ( ""Slice"" , slice_type , Slice_fields , 3 ) ; if ( ! Slice_type ) return 0 ; ExtSlice_type = make_type ( ""ExtSlice"" , slice_type , ExtSlice_fields , 1 ) ; if ( ! ExtSlice_type ) return 0 ; Index_type = make_type ( ""Index"" , slice_type , Index_fields , 1 ) ; if ( ! Index_type ) return 0 ; boolop_type = make_type ( ""boolop"" , & AST_type , NULL , 0 ) ; if ( ! boolop_type ) return 0 ; if ( ! add_attributes ( boolop_type , NULL , 0 ) ) return 0 ; And_type = make_type ( ""And"" , boolop_type , NULL , 0 ) ; if ( ! And_type ) return 0 ; And_singleton = PyType_GenericNew ( And_type , NULL , NULL ) ; if ( ! And_singleton ) return 0 ; Or_type = make_type ( ""Or"" , boolop_type , NULL , 0 ) ; if ( ! Or_type ) return 0 ; Or_singleton = PyType_GenericNew ( Or_type , NULL , NULL ) ; if ( ! Or_singleton ) return 0 ; operator_type = make_type ( ""operator"" , & AST_type , NULL , 0 ) ; if ( ! operator_type ) return 0 ; if ( ! add_attributes ( operator_type , NULL , 0 ) ) return 0 ; Add_type = make_type ( ""Add"" , operator_type , NULL , 0 ) ; if ( ! Add_type ) return 0 ; Add_singleton = PyType_GenericNew ( Add_type , NULL , NULL ) ; if ( ! Add_singleton ) return 0 ; Sub_type = make_type ( ""Sub"" , operator_type , NULL , 0 ) ; if ( ! Sub_type ) return 0 ; Sub_singleton = PyType_GenericNew ( Sub_type , NULL , NULL ) ; if ( ! Sub_singleton ) return 0 ; Mult_type = make_type ( ""Mult"" , operator_type , NULL , 0 ) ; if ( ! Mult_type ) return 0 ; Mult_singleton = PyType_GenericNew ( Mult_type , NULL , NULL ) ; if ( ! Mult_singleton ) return 0 ; MatMult_type = make_type ( ""MatMult"" , operator_type , NULL , 0 ) ; if ( ! MatMult_type ) return 0 ; MatMult_singleton = PyType_GenericNew ( MatMult_type , NULL , NULL ) ; if ( ! MatMult_singleton ) return 0 ; Div_type = make_type ( ""Div"" , operator_type , NULL , 0 ) ; if ( ! Div_type ) return 0 ; Div_singleton = PyType_GenericNew ( Div_type , NULL , NULL ) ; if ( ! Div_singleton ) return 0 ; Mod_type = make_type ( ""Mod"" , operator_type , NULL , 0 ) ; if ( ! Mod_type ) return 0 ; Mod_singleton = PyType_GenericNew ( Mod_type , NULL , NULL ) ; if ( ! Mod_singleton ) return 0 ; Pow_type = make_type ( ""Pow"" , operator_type , NULL , 0 ) ; if ( ! Pow_type ) return 0 ; Pow_singleton = PyType_GenericNew ( Pow_type , NULL , NULL ) ; if ( ! Pow_singleton ) return 0 ; LShift_type = make_type ( ""LShift"" , operator_type , NULL , 0 ) ; if ( ! LShift_type ) return 0 ; LShift_singleton = PyType_GenericNew ( LShift_type , NULL , NULL ) ; if ( ! LShift_singleton ) return 0 ; RShift_type = make_type ( ""RShift"" , operator_type , NULL , 0 ) ; if ( ! RShift_type ) return 0 ; RShift_singleton = PyType_GenericNew ( RShift_type , NULL , NULL ) ; if ( ! RShift_singleton ) return 0 ; BitOr_type = make_type ( ""BitOr"" , operator_type , NULL , 0 ) ; if ( ! BitOr_type ) return 0 ; BitOr_singleton = PyType_GenericNew ( BitOr_type , NULL , NULL ) ; if ( ! BitOr_singleton ) return 0 ; BitXor_type = make_type ( ""BitXor"" , operator_type , NULL , 0 ) ; if ( ! BitXor_type ) return 0 ; BitXor_singleton = PyType_GenericNew ( BitXor_type , NULL , NULL ) ; if ( ! BitXor_singleton ) return 0 ; BitAnd_type = make_type ( ""BitAnd"" , operator_type , NULL , 0 ) ; if ( ! BitAnd_type ) return 0 ; BitAnd_singleton = PyType_GenericNew ( BitAnd_type , NULL , NULL ) ; if ( ! BitAnd_singleton ) return 0 ; FloorDiv_type = make_type ( ""FloorDiv"" , operator_type , NULL , 0 ) ; if ( ! FloorDiv_type ) return 0 ; FloorDiv_singleton = PyType_GenericNew ( FloorDiv_type , NULL , NULL ) ; if ( ! FloorDiv_singleton ) return 0 ; unaryop_type = make_type ( ""unaryop"" , & AST_type , NULL , 0 ) ; if ( ! unaryop_type ) return 0 ; if ( ! add_attributes ( unaryop_type , NULL , 0 ) ) return 0 ; Invert_type = make_type ( ""Invert"" , unaryop_type , NULL , 0 ) ; if ( ! Invert_type ) return 0 ; Invert_singleton = PyType_GenericNew ( Invert_type , NULL , NULL ) ; if ( ! Invert_singleton ) return 0 ; Not_type = make_type ( ""Not"" , unaryop_type , NULL , 0 ) ; if ( ! Not_type ) return 0 ; Not_singleton = PyType_GenericNew ( Not_type , NULL , NULL ) ; if ( ! Not_singleton ) return 0 ; UAdd_type = make_type ( ""UAdd"" , unaryop_type , NULL , 0 ) ; if ( ! UAdd_type ) return 0 ; UAdd_singleton = PyType_GenericNew ( UAdd_type , NULL , NULL ) ; if ( ! UAdd_singleton ) return 0 ; USub_type = make_type ( ""USub"" , unaryop_type , NULL , 0 ) ; if ( ! USub_type ) return 0 ; USub_singleton = PyType_GenericNew ( USub_type , NULL , NULL ) ; if ( ! USub_singleton ) return 0 ; cmpop_type = make_type ( ""cmpop"" , & AST_type , NULL , 0 ) ; if ( ! cmpop_type ) return 0 ; if ( ! add_attributes ( cmpop_type , NULL , 0 ) ) return 0 ; Eq_type = make_type ( ""Eq"" , cmpop_type , NULL , 0 ) ; if ( ! Eq_type ) return 0 ; Eq_singleton = PyType_GenericNew ( Eq_type , NULL , NULL ) ; if ( ! Eq_singleton ) return 0 ; NotEq_type = make_type ( ""NotEq"" , cmpop_type , NULL , 0 ) ; if ( ! NotEq_type ) return 0 ; NotEq_singleton = PyType_GenericNew ( NotEq_type , NULL , NULL ) ; if ( ! NotEq_singleton ) return 0 ; Lt_type = make_type ( ""Lt"" , cmpop_type , NULL , 0 ) ; if ( ! Lt_type ) return 0 ; Lt_singleton = PyType_GenericNew ( Lt_type , NULL , NULL ) ; if ( ! Lt_singleton ) return 0 ; LtE_type = make_type ( ""LtE"" , cmpop_type , NULL , 0 ) ; if ( ! LtE_type ) return 0 ; LtE_singleton = PyType_GenericNew ( LtE_type , NULL , NULL ) ; if ( ! LtE_singleton ) return 0 ; Gt_type = make_type ( ""Gt"" , cmpop_type , NULL , 0 ) ; if ( ! Gt_type ) return 0 ; Gt_singleton = PyType_GenericNew ( Gt_type , NULL , NULL ) ; if ( ! Gt_singleton ) return 0 ; GtE_type = make_type ( ""GtE"" , cmpop_type , NULL , 0 ) ; if ( ! GtE_type ) return 0 ; GtE_singleton = PyType_GenericNew ( GtE_type , NULL , NULL ) ; if ( ! GtE_singleton ) return 0 ; Is_type = make_type ( ""Is"" , cmpop_type , NULL , 0 ) ; if ( ! Is_type ) return 0 ; Is_singleton = PyType_GenericNew ( Is_type , NULL , NULL ) ; if ( ! Is_singleton ) return 0 ; IsNot_type = make_type ( ""IsNot"" , cmpop_type , NULL , 0 ) ; if ( ! IsNot_type ) return 0 ; IsNot_singleton = PyType_GenericNew ( IsNot_type , NULL , NULL ) ; if ( ! IsNot_singleton ) return 0 ; In_type = make_type ( ""In"" , cmpop_type , NULL , 0 ) ; if ( ! In_type ) return 0 ; In_singleton = PyType_GenericNew ( In_type , NULL , NULL ) ; if ( ! In_singleton ) return 0 ; NotIn_type = make_type ( ""NotIn"" , cmpop_type , NULL , 0 ) ; if ( ! NotIn_type ) return 0 ; NotIn_singleton = PyType_GenericNew ( NotIn_type , NULL , NULL ) ; if ( ! NotIn_singleton ) return 0 ; comprehension_type = make_type ( ""comprehension"" , & AST_type , comprehension_fields , 4 ) ; if ( ! comprehension_type ) return 0 ; if ( ! add_attributes ( comprehension_type , NULL , 0 ) ) return 0 ; excepthandler_type = make_type ( ""excepthandler"" , & AST_type , NULL , 0 ) ; if ( ! excepthandler_type ) return 0 ; if ( ! add_attributes ( excepthandler_type , excepthandler_attributes , 4 ) ) return 0 ; ExceptHandler_type = make_type ( ""ExceptHandler"" , excepthandler_type , ExceptHandler_fields , 3 ) ; if ( ! ExceptHandler_type ) return 0 ; arguments_type = make_type ( ""arguments"" , & AST_type , arguments_fields , 6 ) ; if ( ! arguments_type ) return 0 ; if ( ! add_attributes ( arguments_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ; <S2SV_EndBug> if ( ! arg_type ) return 0 ; if ( ! add_attributes ( arg_type , arg_attributes , 4 ) ) return 0 ; keyword_type = make_type ( ""keyword"" , & AST_type , keyword_fields , 2 ) ; if ( ! keyword_type ) return 0 ; if ( ! add_attributes ( keyword_type , NULL , 0 ) ) return 0 ; alias_type = make_type ( ""alias"" , & AST_type , alias_fields , 2 ) ; if ( ! alias_type ) return 0 ; if ( ! add_attributes ( alias_type , NULL , 0 ) ) return 0 ; withitem_type = make_type ( ""withitem"" , & AST_type , withitem_fields , 2 ) ; if ( ! withitem_type ) return 0 ; if ( ! add_attributes ( withitem_type , NULL , 0 ) ) return 0 ; <S2SV_StartBug> initialized = 1 ; <S2SV_EndBug> return 1 ; }
","<S2SV_ModStart> , Module_fields , 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_ModStart> if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , Expression_fields , <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> if ( ! Expression_type ) return 0 ; FunctionType_type = make_type ( ""FunctionType"" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , FunctionType_fields , 2 ) ; if ( ! FunctionType_type <S2SV_ModEnd> ) return 0 <S2SV_ModStart> , FunctionDef_fields , 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , <S2SV_ModStart> if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( ""Return"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncFor_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncWith_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , arg_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> return 0 ; type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z,1545,"<S2SV_ModStart> return 0 ; Definition_type = make_type ( ""Definition"", mod_type, Definition_fields, 1 ) ; if (! Definition_type ) return 0 ; <S2SV_ModStart> ( ""Module"", mod_type, Definition_fields, 1 ) ; if (! Module_type ) return 0 ; <S2SV_ModStart> ( ""Interactive"", mod_type, Interactive_fields, 1 ) ; if (! Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"", mod_type, Expression_fields, 1 ) ; if (! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"", mod_type, Suite_fields, 1 ) ; if (! Suite_type ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"", stmt_type, FunctionDef_fields, 5 ) ; if (! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"", stmt_type, AsyncFunctionDef_fields, 5 ) ; if (! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"",",0
1555,CWE-125,"CWE-125 int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ; <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_lower ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; dims = _Ta3_asdl_seq_new ( len , arena ) ; if ( dims == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> slice_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ExtSlice<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( dims , i , value ) ; <S2SV_EndBug> } <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } * out = ExtSlice ( dims , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; <S2SV_EndBug> return 1 ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lower , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { slice_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1555,"<S2SV_ModStart> expr_ty step ; lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_lower, & tmp ) { if ( tmp == NULL ) { goto failed ; } <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp, & lower, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { lower = NULL ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_upper, & tmp ) { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp, & upper, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj, <S2SV_ModStart>, & PyId_step, & tmp ) { int res ; res = obj2ast_expr ( tmp, & step, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower, upper, step, arena ) ; if ( * out == NULL ) goto failed ;",0
1598,CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
",ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z,1598,"<S2SV_ModStart> ""UnableToReadImageData"" ) ; bytes_per_line = sun_info. width * sun_info. depth ; <S2SV_ModStart> ""UnableToReadImageData"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" <S2SV_ModStart> ""InsufficientImageDataInFile"" ) ; if ( bytes_per_line > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError, ""InsufficientImageDataInFile"" ) ;",0
1600,CWE-125,"CWE-125 static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }
","<S2SV_ModStart> , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1
",FreeRDP@FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65,CVE-2020-11047,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,2020-05-07T20:15Z,1600,"<S2SV_ModStart>, ""received <S2SV_blank> Bandwidth <S2SV_blank> Measure <S2SV_blank> Results <S2SV_blank> PDU"" ) ; if ( Stream_GetRemainingLength ( s ) < 4 ) return FALSE ;",0
1613,CWE-125,"CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else <S2SV_StartBug> { <S2SV_EndBug> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : { <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }
","<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z,1613,"<S2SV_ModStart> = 0 ; if ( msg_len < sizeof ( struct olsr_msg4 ) ) { goto trunc ; } <S2SV_ModStart> struct olsr_msg6 ) ) { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x], <S2SV_blank> msg6[0x%04x]"", msgptr. v4 -> msg_type, msgptr. v6 -> msg_type, msgptr. v6 -> msg_len ) ) ; } else { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x]"", msgptr. v4 -> msg_type, msgptr. v4 -> msg_len ) ) ; if ( msg_len_valid == 0 ) { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x]"", msgptr. v4 -> msg_type, msgptr. v4 -> msg_len ) ) ; } else { ND_PRINT ( ( ndo, ""OLSRv%i, <S2SV_blank> msg4[0x%04x]"", msgptr. v4 ->",0
1635,CWE-125,"CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
","<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
",radareorg@radare2/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,CVE-2018-20459,https://github.com/radareorg/radare2/commit/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,2018-12-25T19:29Z,1635,<S2SV_ModStart> [ i ] && j < sizeof ( buf ),0
1637,CWE-125,"CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""trailingnull.bson"" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""dollarquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$query\\"""" ) ; VALIDATE_TEST ( ""dotquery.bson"" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\"".\\"":<S2SV_blank>\\""abc.def\\"""" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow3.bson"" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""overflow4.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""empty_key.bson"" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , ""empty<S2SV_blank>key"" ) ; VALIDATE_TEST ( ""test40.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test41.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test42.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test43.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test44.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test45.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test46.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test47.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test48.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test49.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test50.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test51.bson"" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>code-with-scope"" ) ; VALIDATE_TEST ( ""test52.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test53.bson"" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test54.bson"" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; <S2SV_StartBug> b = BCON_NEW ( ""my_dbref"" , <S2SV_EndBug> ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$id\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\""$\\"":<S2SV_blank>\\""$ref\\"""" ) ; bson_destroy ( b ) ; b = BCON_NEW ( ""my_dbref"" , ""{"" , ""$ref"" , BCON_UTF8 ( ""collection"" ) , ""extra"" , BCON_INT32 ( 2 ) , ""$id"" , BCON_INT32 ( 1 ) , ""}"" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , ""invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\""extra\\"""" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }
","<S2SV_ModStart> ""corrupt<S2SV_blank>BSON"" ) ; VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;
",mongodb@mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,CVE-2018-16790,https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,2018-09-10T05:29Z,1637,"<S2SV_ModStart> ""corrupt <S2SV_blank> BSON"" ) ; VALIDATE_TEST ( ""test59.bson"", BSON_VALIDATE_NONE, 9, BSON_VALIDATE_NONE, ""corrupt <S2SV_blank> BSON"" ) ;",1
1646,CWE-125,"CWE-125 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; <S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug> markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }
","<S2SV_ModStart> , g -> allgc <S2SV_ModEnd> , g ->
",lua@lua/127e7a6c8942b362aa3c6627f44d660a4fb75312,CVE-2020-15889,https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312,2020-07-21T22:15Z,1646,"<S2SV_ModStart> ; markold ( g, g -> allgc, g -> reallyold ) ; markold ( g, g -> finobj, g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L, g, & g -> allgc, g -> survival, g -> reallyold ) ; sweepgen ( L, g, psurvival, g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L, g, & g -> allgc, g -> survival, g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L, g, & g -> finobj, g -> finobjsur ) ; sweepgen ( L, g, psurvival, g -> finobjrold ) ; g -> finobjrold = g -> finobjold ;",0
1653,CWE-125,"CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[gaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]"" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>{"" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , ""<S2SV_blank>}"" ) ) ; } else ND_PRINT ( ( ndo , "",<S2SV_blank>%d<S2SV_blank>source(s)"" , nsrcs ) ) ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , mldv2_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,1653,<S2SV_ModStart> return ; } ND_TCHECK_32BITS ( & icp -> icmp6_data8 [ 0 ] ) ; <S2SV_ModStart> ] & 0x80 ) { ND_TCHECK_32BITS ( & icp -> icmp6_data8 [ 1 ] ) ; <S2SV_ModStart> 1 ] & 0x80 ) { ND_TCHECK_32BITS ( & icp -> icmp6_data8 [ 2 ] ) ; <S2SV_ModStart> 1 ] & 0x80 ) { ND_TCHECK_16BITS ( & icp -> icmp6_data8 [ 1 ] ) ; <S2SV_ModStart> 1 ] & 0x80 ) { ND_TCHECK_16BITS ( & icp -> icmp6_data8 [ 1 ] ) ; <S2SV_ModStart> 1 ] & 0x80 ) ; <S2SV_ModStart> 1 ] & 0x80 ) { ND_TCHECK_16BITS ( & icp -> icmp6_data8 [ 3 ] ) ; <S2SV_ModStart> 1 ] & 0x80 ) { ND_TCHECK_16BITS ( & icp -> icmp6_data8 [ 2 ] & 0x80 ) ; <S2SV_ModStart> 1 ] & 0x80 ) { ND_TCHECK_16,0
1666,CWE-125,"CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>"" , tok2str ( icmp6_opt_values , ""unknown"" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , ""%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s"" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? ""badlen"" : """" , bittok2str ( icmp6_opt_pi_flag_values , ""none"" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s"" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u%s"" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? ""bad<S2SV_blank>option<S2SV_blank>length"" : """" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,"" , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>addr:<S2SV_blank>%s"" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):"" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%ums"" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u"" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%u"" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>pref=%s"" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lifetime=%s"" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ; <S2SV_EndBug> return ; # undef ECHECK }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z,1666,"<S2SV_ModStart> ; if ( nd_opt_mtu ( opp )!= opp -> nd_opt_mtu ) { ND_PRINT ( ( ndo, ""\\n\\t <S2SV_blank> <S2SV_blank> %s <S2SV_blank> mtu <S2SV_blank> (%u): <S2SV_blank> "", tok2str ( icmp6_mtu_values, ""unknown"", opp -> nd_opt_mtu ) ) ) ; break ; } <S2SV_ModStart> : if ( nd_opt_mtu ( opp )!= opp -> nd_opt_mtu ) { ND_PRINT ( ( ndo, ""\\n\\t <S2SV_blank> <S2SV_blank> %s <S2SV_blank> mtu <S2SV_blank> (%u): <S2SV_blank> "", tok2str ( icmp6_mtu_values, ""unknown"", opp -> nd_opt_mtu ) ) ) ; break ; } <S2SV_ModStart> : if ( nd_opt_mtu ( opp -> nd_opt_mtu )!= opp -> nd_opt_mtu ) { ND_PRINT ( ( ndo, ""\\n\\t <S2SV_blank> <S2SV_blank> %s <S2SV_blank> mtu <S2SV_blank> (%u): <S2SV_blank> "", opp -> nd_opt_mtu ) ) ; break ; }",0
1674,CWE-125,"CWE-125 static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <S2SV_StartBug> return tok ; <S2SV_EndBug> }
","<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z,1674,<S2SV_ModStart> = 0 ; # ifdef SUPER_SECURE <S2SV_ModStart> = 0 ; # endif <S2SV_ModStart> = 0 ; # ifdef SUPER_SECURE,0
1681,CWE-125,"CWE-125 BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>TPDU<S2SV_blank>length<S2SV_blank>indicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>routing<S2SV_blank>token<S2SV_blank>or<S2SV_blank>cookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrect<S2SV_blank>negotiation<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%"" PRIu8 """" , type ) ; return FALSE ; } <S2SV_StartBug> nego_process_negotiation_request ( nego , s ) ; <S2SV_EndBug> } return tpkt_ensure_stream_consumed ( s , length ) ; }
","<S2SV_ModStart> FALSE ; } if ( ! <S2SV_ModStart> , s ) ) return FALSE
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z,1681,"<S2SV_ModStart> FALSE ; } if (! <S2SV_ModStart>, s ) ) return FALSE",1
